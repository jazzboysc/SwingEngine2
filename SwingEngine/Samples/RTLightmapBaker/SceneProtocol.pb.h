// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SceneProtocol.proto

#ifndef PROTOBUF_SceneProtocol_2eproto__INCLUDED
#define PROTOBUF_SceneProtocol_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3002000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3002000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
class Color;
class ColorDefaultTypeInternal;
extern ColorDefaultTypeInternal _Color_default_instance_;
class Material;
class MaterialDefaultTypeInternal;
extern MaterialDefaultTypeInternal _Material_default_instance_;
class Quaternion;
class QuaternionDefaultTypeInternal;
extern QuaternionDefaultTypeInternal _Quaternion_default_instance_;
class SceneNode;
class SceneNodeDefaultTypeInternal;
extern SceneNodeDefaultTypeInternal _SceneNode_default_instance_;
class Transform;
class TransformDefaultTypeInternal;
extern TransformDefaultTypeInternal _Transform_default_instance_;
class Vector3;
class Vector3DefaultTypeInternal;
extern Vector3DefaultTypeInternal _Vector3_default_instance_;
class Vector4;
class Vector4DefaultTypeInternal;
extern Vector4DefaultTypeInternal _Vector4_default_instance_;

namespace protobuf_SceneProtocol_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_SceneProtocol_2eproto

// ===================================================================

class Vector3 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Vector3) */ {
 public:
  Vector3();
  virtual ~Vector3();

  Vector3(const Vector3& from);

  inline Vector3& operator=(const Vector3& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector3& default_instance();

  static inline const Vector3* internal_default_instance() {
    return reinterpret_cast<const Vector3*>(
               &_Vector3_default_instance_);
  }

  void Swap(Vector3* other);

  // implements Message ----------------------------------------------

  inline Vector3* New() const PROTOBUF_FINAL { return New(NULL); }

  Vector3* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Vector3& from);
  void MergeFrom(const Vector3& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Vector3* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // required float y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // required float z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // @@protoc_insertion_point(class_scope:Vector3)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float x_;
  float y_;
  float z_;
  friend struct  protobuf_SceneProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Vector4 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Vector4) */ {
 public:
  Vector4();
  virtual ~Vector4();

  Vector4(const Vector4& from);

  inline Vector4& operator=(const Vector4& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector4& default_instance();

  static inline const Vector4* internal_default_instance() {
    return reinterpret_cast<const Vector4*>(
               &_Vector4_default_instance_);
  }

  void Swap(Vector4* other);

  // implements Message ----------------------------------------------

  inline Vector4* New() const PROTOBUF_FINAL { return New(NULL); }

  Vector4* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Vector4& from);
  void MergeFrom(const Vector4& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Vector4* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // required float y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // required float z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // required float w = 4;
  bool has_w() const;
  void clear_w();
  static const int kWFieldNumber = 4;
  float w() const;
  void set_w(float value);

  // @@protoc_insertion_point(class_scope:Vector4)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();
  void set_has_w();
  void clear_has_w();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float x_;
  float y_;
  float z_;
  float w_;
  friend struct  protobuf_SceneProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Quaternion : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Quaternion) */ {
 public:
  Quaternion();
  virtual ~Quaternion();

  Quaternion(const Quaternion& from);

  inline Quaternion& operator=(const Quaternion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Quaternion& default_instance();

  static inline const Quaternion* internal_default_instance() {
    return reinterpret_cast<const Quaternion*>(
               &_Quaternion_default_instance_);
  }

  void Swap(Quaternion* other);

  // implements Message ----------------------------------------------

  inline Quaternion* New() const PROTOBUF_FINAL { return New(NULL); }

  Quaternion* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Quaternion& from);
  void MergeFrom(const Quaternion& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Quaternion* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // required float y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // required float z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // required float w = 4;
  bool has_w() const;
  void clear_w();
  static const int kWFieldNumber = 4;
  float w() const;
  void set_w(float value);

  // @@protoc_insertion_point(class_scope:Quaternion)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();
  void set_has_w();
  void clear_has_w();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float x_;
  float y_;
  float z_;
  float w_;
  friend struct  protobuf_SceneProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Transform : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Transform) */ {
 public:
  Transform();
  virtual ~Transform();

  Transform(const Transform& from);

  inline Transform& operator=(const Transform& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Transform& default_instance();

  static inline const Transform* internal_default_instance() {
    return reinterpret_cast<const Transform*>(
               &_Transform_default_instance_);
  }

  void Swap(Transform* other);

  // implements Message ----------------------------------------------

  inline Transform* New() const PROTOBUF_FINAL { return New(NULL); }

  Transform* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Transform& from);
  void MergeFrom(const Transform& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Transform* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Vector3 scale = 1;
  bool has_scale() const;
  void clear_scale();
  static const int kScaleFieldNumber = 1;
  const ::Vector3& scale() const;
  ::Vector3* mutable_scale();
  ::Vector3* release_scale();
  void set_allocated_scale(::Vector3* scale);

  // required .Quaternion orientation = 2;
  bool has_orientation() const;
  void clear_orientation();
  static const int kOrientationFieldNumber = 2;
  const ::Quaternion& orientation() const;
  ::Quaternion* mutable_orientation();
  ::Quaternion* release_orientation();
  void set_allocated_orientation(::Quaternion* orientation);

  // required .Vector3 translation = 3;
  bool has_translation() const;
  void clear_translation();
  static const int kTranslationFieldNumber = 3;
  const ::Vector3& translation() const;
  ::Vector3* mutable_translation();
  ::Vector3* release_translation();
  void set_allocated_translation(::Vector3* translation);

  // @@protoc_insertion_point(class_scope:Transform)
 private:
  void set_has_scale();
  void clear_has_scale();
  void set_has_orientation();
  void clear_has_orientation();
  void set_has_translation();
  void clear_has_translation();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::Vector3* scale_;
  ::Quaternion* orientation_;
  ::Vector3* translation_;
  friend struct  protobuf_SceneProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Color : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Color) */ {
 public:
  Color();
  virtual ~Color();

  Color(const Color& from);

  inline Color& operator=(const Color& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Color& default_instance();

  static inline const Color* internal_default_instance() {
    return reinterpret_cast<const Color*>(
               &_Color_default_instance_);
  }

  void Swap(Color* other);

  // implements Message ----------------------------------------------

  inline Color* New() const PROTOBUF_FINAL { return New(NULL); }

  Color* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Color& from);
  void MergeFrom(const Color& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Color* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float r = 1;
  bool has_r() const;
  void clear_r();
  static const int kRFieldNumber = 1;
  float r() const;
  void set_r(float value);

  // required float g = 2;
  bool has_g() const;
  void clear_g();
  static const int kGFieldNumber = 2;
  float g() const;
  void set_g(float value);

  // required float b = 3;
  bool has_b() const;
  void clear_b();
  static const int kBFieldNumber = 3;
  float b() const;
  void set_b(float value);

  // required float a = 4;
  bool has_a() const;
  void clear_a();
  static const int kAFieldNumber = 4;
  float a() const;
  void set_a(float value);

  // @@protoc_insertion_point(class_scope:Color)
 private:
  void set_has_r();
  void clear_has_r();
  void set_has_g();
  void clear_has_g();
  void set_has_b();
  void clear_has_b();
  void set_has_a();
  void clear_has_a();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float r_;
  float g_;
  float b_;
  float a_;
  friend struct  protobuf_SceneProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Material : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Material) */ {
 public:
  Material();
  virtual ~Material();

  Material(const Material& from);

  inline Material& operator=(const Material& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Material& default_instance();

  static inline const Material* internal_default_instance() {
    return reinterpret_cast<const Material*>(
               &_Material_default_instance_);
  }

  void Swap(Material* other);

  // implements Message ----------------------------------------------

  inline Material* New() const PROTOBUF_FINAL { return New(NULL); }

  Material* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Material& from);
  void MergeFrom(const Material& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Material* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string diffuseMapURL = 2;
  bool has_diffusemapurl() const;
  void clear_diffusemapurl();
  static const int kDiffuseMapURLFieldNumber = 2;
  const ::std::string& diffusemapurl() const;
  void set_diffusemapurl(const ::std::string& value);
  #if LANG_CXX11
  void set_diffusemapurl(::std::string&& value);
  #endif
  void set_diffusemapurl(const char* value);
  void set_diffusemapurl(const char* value, size_t size);
  ::std::string* mutable_diffusemapurl();
  ::std::string* release_diffusemapurl();
  void set_allocated_diffusemapurl(::std::string* diffusemapurl);

  // optional string roughnessMapURL = 4;
  bool has_roughnessmapurl() const;
  void clear_roughnessmapurl();
  static const int kRoughnessMapURLFieldNumber = 4;
  const ::std::string& roughnessmapurl() const;
  void set_roughnessmapurl(const ::std::string& value);
  #if LANG_CXX11
  void set_roughnessmapurl(::std::string&& value);
  #endif
  void set_roughnessmapurl(const char* value);
  void set_roughnessmapurl(const char* value, size_t size);
  ::std::string* mutable_roughnessmapurl();
  ::std::string* release_roughnessmapurl();
  void set_allocated_roughnessmapurl(::std::string* roughnessmapurl);

  // optional string metallicMapURL = 6;
  bool has_metallicmapurl() const;
  void clear_metallicmapurl();
  static const int kMetallicMapURLFieldNumber = 6;
  const ::std::string& metallicmapurl() const;
  void set_metallicmapurl(const ::std::string& value);
  #if LANG_CXX11
  void set_metallicmapurl(::std::string&& value);
  #endif
  void set_metallicmapurl(const char* value);
  void set_metallicmapurl(const char* value, size_t size);
  ::std::string* mutable_metallicmapurl();
  ::std::string* release_metallicmapurl();
  void set_allocated_metallicmapurl(::std::string* metallicmapurl);

  // optional .Color diffuseColor = 1;
  bool has_diffusecolor() const;
  void clear_diffusecolor();
  static const int kDiffuseColorFieldNumber = 1;
  const ::Color& diffusecolor() const;
  ::Color* mutable_diffusecolor();
  ::Color* release_diffusecolor();
  void set_allocated_diffusecolor(::Color* diffusecolor);

  // optional float roughness = 3;
  bool has_roughness() const;
  void clear_roughness();
  static const int kRoughnessFieldNumber = 3;
  float roughness() const;
  void set_roughness(float value);

  // optional float metallic = 5;
  bool has_metallic() const;
  void clear_metallic();
  static const int kMetallicFieldNumber = 5;
  float metallic() const;
  void set_metallic(float value);

  // @@protoc_insertion_point(class_scope:Material)
 private:
  void set_has_diffusecolor();
  void clear_has_diffusecolor();
  void set_has_diffusemapurl();
  void clear_has_diffusemapurl();
  void set_has_roughness();
  void clear_has_roughness();
  void set_has_roughnessmapurl();
  void clear_has_roughnessmapurl();
  void set_has_metallic();
  void clear_has_metallic();
  void set_has_metallicmapurl();
  void clear_has_metallicmapurl();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr diffusemapurl_;
  ::google::protobuf::internal::ArenaStringPtr roughnessmapurl_;
  ::google::protobuf::internal::ArenaStringPtr metallicmapurl_;
  ::Color* diffusecolor_;
  float roughness_;
  float metallic_;
  friend struct  protobuf_SceneProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SceneNode : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SceneNode) */ {
 public:
  SceneNode();
  virtual ~SceneNode();

  SceneNode(const SceneNode& from);

  inline SceneNode& operator=(const SceneNode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SceneNode& default_instance();

  static inline const SceneNode* internal_default_instance() {
    return reinterpret_cast<const SceneNode*>(
               &_SceneNode_default_instance_);
  }

  void Swap(SceneNode* other);

  // implements Message ----------------------------------------------

  inline SceneNode* New() const PROTOBUF_FINAL { return New(NULL); }

  SceneNode* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SceneNode& from);
  void MergeFrom(const SceneNode& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SceneNode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Material materials = 3;
  int materials_size() const;
  void clear_materials();
  static const int kMaterialsFieldNumber = 3;
  const ::Material& materials(int index) const;
  ::Material* mutable_materials(int index);
  ::Material* add_materials();
  ::google::protobuf::RepeatedPtrField< ::Material >*
      mutable_materials();
  const ::google::protobuf::RepeatedPtrField< ::Material >&
      materials() const;

  // required string meshURL = 2;
  bool has_meshurl() const;
  void clear_meshurl();
  static const int kMeshURLFieldNumber = 2;
  const ::std::string& meshurl() const;
  void set_meshurl(const ::std::string& value);
  #if LANG_CXX11
  void set_meshurl(::std::string&& value);
  #endif
  void set_meshurl(const char* value);
  void set_meshurl(const char* value, size_t size);
  ::std::string* mutable_meshurl();
  ::std::string* release_meshurl();
  void set_allocated_meshurl(::std::string* meshurl);

  // required .Transform worldTransform = 1;
  bool has_worldtransform() const;
  void clear_worldtransform();
  static const int kWorldTransformFieldNumber = 1;
  const ::Transform& worldtransform() const;
  ::Transform* mutable_worldtransform();
  ::Transform* release_worldtransform();
  void set_allocated_worldtransform(::Transform* worldtransform);

  // @@protoc_insertion_point(class_scope:SceneNode)
 private:
  void set_has_worldtransform();
  void clear_has_worldtransform();
  void set_has_meshurl();
  void clear_has_meshurl();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Material > materials_;
  ::google::protobuf::internal::ArenaStringPtr meshurl_;
  ::Transform* worldtransform_;
  friend struct  protobuf_SceneProtocol_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Vector3

// required float x = 1;
inline bool Vector3::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vector3::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vector3::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vector3::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Vector3::x() const {
  // @@protoc_insertion_point(field_get:Vector3.x)
  return x_;
}
inline void Vector3::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:Vector3.x)
}

// required float y = 2;
inline bool Vector3::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vector3::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vector3::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vector3::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Vector3::y() const {
  // @@protoc_insertion_point(field_get:Vector3.y)
  return y_;
}
inline void Vector3::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:Vector3.y)
}

// required float z = 3;
inline bool Vector3::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vector3::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vector3::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vector3::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float Vector3::z() const {
  // @@protoc_insertion_point(field_get:Vector3.z)
  return z_;
}
inline void Vector3::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:Vector3.z)
}

// -------------------------------------------------------------------

// Vector4

// required float x = 1;
inline bool Vector4::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vector4::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vector4::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vector4::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Vector4::x() const {
  // @@protoc_insertion_point(field_get:Vector4.x)
  return x_;
}
inline void Vector4::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:Vector4.x)
}

// required float y = 2;
inline bool Vector4::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vector4::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vector4::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vector4::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Vector4::y() const {
  // @@protoc_insertion_point(field_get:Vector4.y)
  return y_;
}
inline void Vector4::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:Vector4.y)
}

// required float z = 3;
inline bool Vector4::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vector4::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vector4::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vector4::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float Vector4::z() const {
  // @@protoc_insertion_point(field_get:Vector4.z)
  return z_;
}
inline void Vector4::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:Vector4.z)
}

// required float w = 4;
inline bool Vector4::has_w() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Vector4::set_has_w() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Vector4::clear_has_w() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Vector4::clear_w() {
  w_ = 0;
  clear_has_w();
}
inline float Vector4::w() const {
  // @@protoc_insertion_point(field_get:Vector4.w)
  return w_;
}
inline void Vector4::set_w(float value) {
  set_has_w();
  w_ = value;
  // @@protoc_insertion_point(field_set:Vector4.w)
}

// -------------------------------------------------------------------

// Quaternion

// required float x = 1;
inline bool Quaternion::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Quaternion::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Quaternion::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Quaternion::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Quaternion::x() const {
  // @@protoc_insertion_point(field_get:Quaternion.x)
  return x_;
}
inline void Quaternion::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:Quaternion.x)
}

// required float y = 2;
inline bool Quaternion::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Quaternion::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Quaternion::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Quaternion::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Quaternion::y() const {
  // @@protoc_insertion_point(field_get:Quaternion.y)
  return y_;
}
inline void Quaternion::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:Quaternion.y)
}

// required float z = 3;
inline bool Quaternion::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Quaternion::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Quaternion::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Quaternion::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float Quaternion::z() const {
  // @@protoc_insertion_point(field_get:Quaternion.z)
  return z_;
}
inline void Quaternion::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:Quaternion.z)
}

// required float w = 4;
inline bool Quaternion::has_w() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Quaternion::set_has_w() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Quaternion::clear_has_w() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Quaternion::clear_w() {
  w_ = 0;
  clear_has_w();
}
inline float Quaternion::w() const {
  // @@protoc_insertion_point(field_get:Quaternion.w)
  return w_;
}
inline void Quaternion::set_w(float value) {
  set_has_w();
  w_ = value;
  // @@protoc_insertion_point(field_set:Quaternion.w)
}

// -------------------------------------------------------------------

// Transform

// required .Vector3 scale = 1;
inline bool Transform::has_scale() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Transform::set_has_scale() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Transform::clear_has_scale() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Transform::clear_scale() {
  if (scale_ != NULL) scale_->::Vector3::Clear();
  clear_has_scale();
}
inline const ::Vector3& Transform::scale() const {
  // @@protoc_insertion_point(field_get:Transform.scale)
  return scale_ != NULL ? *scale_
                         : *::Vector3::internal_default_instance();
}
inline ::Vector3* Transform::mutable_scale() {
  set_has_scale();
  if (scale_ == NULL) {
    scale_ = new ::Vector3;
  }
  // @@protoc_insertion_point(field_mutable:Transform.scale)
  return scale_;
}
inline ::Vector3* Transform::release_scale() {
  // @@protoc_insertion_point(field_release:Transform.scale)
  clear_has_scale();
  ::Vector3* temp = scale_;
  scale_ = NULL;
  return temp;
}
inline void Transform::set_allocated_scale(::Vector3* scale) {
  delete scale_;
  scale_ = scale;
  if (scale) {
    set_has_scale();
  } else {
    clear_has_scale();
  }
  // @@protoc_insertion_point(field_set_allocated:Transform.scale)
}

// required .Quaternion orientation = 2;
inline bool Transform::has_orientation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Transform::set_has_orientation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Transform::clear_has_orientation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Transform::clear_orientation() {
  if (orientation_ != NULL) orientation_->::Quaternion::Clear();
  clear_has_orientation();
}
inline const ::Quaternion& Transform::orientation() const {
  // @@protoc_insertion_point(field_get:Transform.orientation)
  return orientation_ != NULL ? *orientation_
                         : *::Quaternion::internal_default_instance();
}
inline ::Quaternion* Transform::mutable_orientation() {
  set_has_orientation();
  if (orientation_ == NULL) {
    orientation_ = new ::Quaternion;
  }
  // @@protoc_insertion_point(field_mutable:Transform.orientation)
  return orientation_;
}
inline ::Quaternion* Transform::release_orientation() {
  // @@protoc_insertion_point(field_release:Transform.orientation)
  clear_has_orientation();
  ::Quaternion* temp = orientation_;
  orientation_ = NULL;
  return temp;
}
inline void Transform::set_allocated_orientation(::Quaternion* orientation) {
  delete orientation_;
  orientation_ = orientation;
  if (orientation) {
    set_has_orientation();
  } else {
    clear_has_orientation();
  }
  // @@protoc_insertion_point(field_set_allocated:Transform.orientation)
}

// required .Vector3 translation = 3;
inline bool Transform::has_translation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Transform::set_has_translation() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Transform::clear_has_translation() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Transform::clear_translation() {
  if (translation_ != NULL) translation_->::Vector3::Clear();
  clear_has_translation();
}
inline const ::Vector3& Transform::translation() const {
  // @@protoc_insertion_point(field_get:Transform.translation)
  return translation_ != NULL ? *translation_
                         : *::Vector3::internal_default_instance();
}
inline ::Vector3* Transform::mutable_translation() {
  set_has_translation();
  if (translation_ == NULL) {
    translation_ = new ::Vector3;
  }
  // @@protoc_insertion_point(field_mutable:Transform.translation)
  return translation_;
}
inline ::Vector3* Transform::release_translation() {
  // @@protoc_insertion_point(field_release:Transform.translation)
  clear_has_translation();
  ::Vector3* temp = translation_;
  translation_ = NULL;
  return temp;
}
inline void Transform::set_allocated_translation(::Vector3* translation) {
  delete translation_;
  translation_ = translation;
  if (translation) {
    set_has_translation();
  } else {
    clear_has_translation();
  }
  // @@protoc_insertion_point(field_set_allocated:Transform.translation)
}

// -------------------------------------------------------------------

// Color

// required float r = 1;
inline bool Color::has_r() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Color::set_has_r() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Color::clear_has_r() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Color::clear_r() {
  r_ = 0;
  clear_has_r();
}
inline float Color::r() const {
  // @@protoc_insertion_point(field_get:Color.r)
  return r_;
}
inline void Color::set_r(float value) {
  set_has_r();
  r_ = value;
  // @@protoc_insertion_point(field_set:Color.r)
}

// required float g = 2;
inline bool Color::has_g() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Color::set_has_g() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Color::clear_has_g() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Color::clear_g() {
  g_ = 0;
  clear_has_g();
}
inline float Color::g() const {
  // @@protoc_insertion_point(field_get:Color.g)
  return g_;
}
inline void Color::set_g(float value) {
  set_has_g();
  g_ = value;
  // @@protoc_insertion_point(field_set:Color.g)
}

// required float b = 3;
inline bool Color::has_b() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Color::set_has_b() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Color::clear_has_b() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Color::clear_b() {
  b_ = 0;
  clear_has_b();
}
inline float Color::b() const {
  // @@protoc_insertion_point(field_get:Color.b)
  return b_;
}
inline void Color::set_b(float value) {
  set_has_b();
  b_ = value;
  // @@protoc_insertion_point(field_set:Color.b)
}

// required float a = 4;
inline bool Color::has_a() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Color::set_has_a() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Color::clear_has_a() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Color::clear_a() {
  a_ = 0;
  clear_has_a();
}
inline float Color::a() const {
  // @@protoc_insertion_point(field_get:Color.a)
  return a_;
}
inline void Color::set_a(float value) {
  set_has_a();
  a_ = value;
  // @@protoc_insertion_point(field_set:Color.a)
}

// -------------------------------------------------------------------

// Material

// optional .Color diffuseColor = 1;
inline bool Material::has_diffusecolor() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Material::set_has_diffusecolor() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Material::clear_has_diffusecolor() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Material::clear_diffusecolor() {
  if (diffusecolor_ != NULL) diffusecolor_->::Color::Clear();
  clear_has_diffusecolor();
}
inline const ::Color& Material::diffusecolor() const {
  // @@protoc_insertion_point(field_get:Material.diffuseColor)
  return diffusecolor_ != NULL ? *diffusecolor_
                         : *::Color::internal_default_instance();
}
inline ::Color* Material::mutable_diffusecolor() {
  set_has_diffusecolor();
  if (diffusecolor_ == NULL) {
    diffusecolor_ = new ::Color;
  }
  // @@protoc_insertion_point(field_mutable:Material.diffuseColor)
  return diffusecolor_;
}
inline ::Color* Material::release_diffusecolor() {
  // @@protoc_insertion_point(field_release:Material.diffuseColor)
  clear_has_diffusecolor();
  ::Color* temp = diffusecolor_;
  diffusecolor_ = NULL;
  return temp;
}
inline void Material::set_allocated_diffusecolor(::Color* diffusecolor) {
  delete diffusecolor_;
  diffusecolor_ = diffusecolor;
  if (diffusecolor) {
    set_has_diffusecolor();
  } else {
    clear_has_diffusecolor();
  }
  // @@protoc_insertion_point(field_set_allocated:Material.diffuseColor)
}

// optional string diffuseMapURL = 2;
inline bool Material::has_diffusemapurl() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Material::set_has_diffusemapurl() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Material::clear_has_diffusemapurl() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Material::clear_diffusemapurl() {
  diffusemapurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_diffusemapurl();
}
inline const ::std::string& Material::diffusemapurl() const {
  // @@protoc_insertion_point(field_get:Material.diffuseMapURL)
  return diffusemapurl_.GetNoArena();
}
inline void Material::set_diffusemapurl(const ::std::string& value) {
  set_has_diffusemapurl();
  diffusemapurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Material.diffuseMapURL)
}
#if LANG_CXX11
inline void Material::set_diffusemapurl(::std::string&& value) {
  set_has_diffusemapurl();
  diffusemapurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Material.diffuseMapURL)
}
#endif
inline void Material::set_diffusemapurl(const char* value) {
  set_has_diffusemapurl();
  diffusemapurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Material.diffuseMapURL)
}
inline void Material::set_diffusemapurl(const char* value, size_t size) {
  set_has_diffusemapurl();
  diffusemapurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Material.diffuseMapURL)
}
inline ::std::string* Material::mutable_diffusemapurl() {
  set_has_diffusemapurl();
  // @@protoc_insertion_point(field_mutable:Material.diffuseMapURL)
  return diffusemapurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Material::release_diffusemapurl() {
  // @@protoc_insertion_point(field_release:Material.diffuseMapURL)
  clear_has_diffusemapurl();
  return diffusemapurl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Material::set_allocated_diffusemapurl(::std::string* diffusemapurl) {
  if (diffusemapurl != NULL) {
    set_has_diffusemapurl();
  } else {
    clear_has_diffusemapurl();
  }
  diffusemapurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), diffusemapurl);
  // @@protoc_insertion_point(field_set_allocated:Material.diffuseMapURL)
}

// optional float roughness = 3;
inline bool Material::has_roughness() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Material::set_has_roughness() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Material::clear_has_roughness() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Material::clear_roughness() {
  roughness_ = 0;
  clear_has_roughness();
}
inline float Material::roughness() const {
  // @@protoc_insertion_point(field_get:Material.roughness)
  return roughness_;
}
inline void Material::set_roughness(float value) {
  set_has_roughness();
  roughness_ = value;
  // @@protoc_insertion_point(field_set:Material.roughness)
}

// optional string roughnessMapURL = 4;
inline bool Material::has_roughnessmapurl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Material::set_has_roughnessmapurl() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Material::clear_has_roughnessmapurl() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Material::clear_roughnessmapurl() {
  roughnessmapurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_roughnessmapurl();
}
inline const ::std::string& Material::roughnessmapurl() const {
  // @@protoc_insertion_point(field_get:Material.roughnessMapURL)
  return roughnessmapurl_.GetNoArena();
}
inline void Material::set_roughnessmapurl(const ::std::string& value) {
  set_has_roughnessmapurl();
  roughnessmapurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Material.roughnessMapURL)
}
#if LANG_CXX11
inline void Material::set_roughnessmapurl(::std::string&& value) {
  set_has_roughnessmapurl();
  roughnessmapurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Material.roughnessMapURL)
}
#endif
inline void Material::set_roughnessmapurl(const char* value) {
  set_has_roughnessmapurl();
  roughnessmapurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Material.roughnessMapURL)
}
inline void Material::set_roughnessmapurl(const char* value, size_t size) {
  set_has_roughnessmapurl();
  roughnessmapurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Material.roughnessMapURL)
}
inline ::std::string* Material::mutable_roughnessmapurl() {
  set_has_roughnessmapurl();
  // @@protoc_insertion_point(field_mutable:Material.roughnessMapURL)
  return roughnessmapurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Material::release_roughnessmapurl() {
  // @@protoc_insertion_point(field_release:Material.roughnessMapURL)
  clear_has_roughnessmapurl();
  return roughnessmapurl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Material::set_allocated_roughnessmapurl(::std::string* roughnessmapurl) {
  if (roughnessmapurl != NULL) {
    set_has_roughnessmapurl();
  } else {
    clear_has_roughnessmapurl();
  }
  roughnessmapurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), roughnessmapurl);
  // @@protoc_insertion_point(field_set_allocated:Material.roughnessMapURL)
}

// optional float metallic = 5;
inline bool Material::has_metallic() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Material::set_has_metallic() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Material::clear_has_metallic() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Material::clear_metallic() {
  metallic_ = 0;
  clear_has_metallic();
}
inline float Material::metallic() const {
  // @@protoc_insertion_point(field_get:Material.metallic)
  return metallic_;
}
inline void Material::set_metallic(float value) {
  set_has_metallic();
  metallic_ = value;
  // @@protoc_insertion_point(field_set:Material.metallic)
}

// optional string metallicMapURL = 6;
inline bool Material::has_metallicmapurl() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Material::set_has_metallicmapurl() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Material::clear_has_metallicmapurl() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Material::clear_metallicmapurl() {
  metallicmapurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_metallicmapurl();
}
inline const ::std::string& Material::metallicmapurl() const {
  // @@protoc_insertion_point(field_get:Material.metallicMapURL)
  return metallicmapurl_.GetNoArena();
}
inline void Material::set_metallicmapurl(const ::std::string& value) {
  set_has_metallicmapurl();
  metallicmapurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Material.metallicMapURL)
}
#if LANG_CXX11
inline void Material::set_metallicmapurl(::std::string&& value) {
  set_has_metallicmapurl();
  metallicmapurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Material.metallicMapURL)
}
#endif
inline void Material::set_metallicmapurl(const char* value) {
  set_has_metallicmapurl();
  metallicmapurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Material.metallicMapURL)
}
inline void Material::set_metallicmapurl(const char* value, size_t size) {
  set_has_metallicmapurl();
  metallicmapurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Material.metallicMapURL)
}
inline ::std::string* Material::mutable_metallicmapurl() {
  set_has_metallicmapurl();
  // @@protoc_insertion_point(field_mutable:Material.metallicMapURL)
  return metallicmapurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Material::release_metallicmapurl() {
  // @@protoc_insertion_point(field_release:Material.metallicMapURL)
  clear_has_metallicmapurl();
  return metallicmapurl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Material::set_allocated_metallicmapurl(::std::string* metallicmapurl) {
  if (metallicmapurl != NULL) {
    set_has_metallicmapurl();
  } else {
    clear_has_metallicmapurl();
  }
  metallicmapurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), metallicmapurl);
  // @@protoc_insertion_point(field_set_allocated:Material.metallicMapURL)
}

// -------------------------------------------------------------------

// SceneNode

// required .Transform worldTransform = 1;
inline bool SceneNode::has_worldtransform() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SceneNode::set_has_worldtransform() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SceneNode::clear_has_worldtransform() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SceneNode::clear_worldtransform() {
  if (worldtransform_ != NULL) worldtransform_->::Transform::Clear();
  clear_has_worldtransform();
}
inline const ::Transform& SceneNode::worldtransform() const {
  // @@protoc_insertion_point(field_get:SceneNode.worldTransform)
  return worldtransform_ != NULL ? *worldtransform_
                         : *::Transform::internal_default_instance();
}
inline ::Transform* SceneNode::mutable_worldtransform() {
  set_has_worldtransform();
  if (worldtransform_ == NULL) {
    worldtransform_ = new ::Transform;
  }
  // @@protoc_insertion_point(field_mutable:SceneNode.worldTransform)
  return worldtransform_;
}
inline ::Transform* SceneNode::release_worldtransform() {
  // @@protoc_insertion_point(field_release:SceneNode.worldTransform)
  clear_has_worldtransform();
  ::Transform* temp = worldtransform_;
  worldtransform_ = NULL;
  return temp;
}
inline void SceneNode::set_allocated_worldtransform(::Transform* worldtransform) {
  delete worldtransform_;
  worldtransform_ = worldtransform;
  if (worldtransform) {
    set_has_worldtransform();
  } else {
    clear_has_worldtransform();
  }
  // @@protoc_insertion_point(field_set_allocated:SceneNode.worldTransform)
}

// required string meshURL = 2;
inline bool SceneNode::has_meshurl() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SceneNode::set_has_meshurl() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SceneNode::clear_has_meshurl() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SceneNode::clear_meshurl() {
  meshurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_meshurl();
}
inline const ::std::string& SceneNode::meshurl() const {
  // @@protoc_insertion_point(field_get:SceneNode.meshURL)
  return meshurl_.GetNoArena();
}
inline void SceneNode::set_meshurl(const ::std::string& value) {
  set_has_meshurl();
  meshurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SceneNode.meshURL)
}
#if LANG_CXX11
inline void SceneNode::set_meshurl(::std::string&& value) {
  set_has_meshurl();
  meshurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SceneNode.meshURL)
}
#endif
inline void SceneNode::set_meshurl(const char* value) {
  set_has_meshurl();
  meshurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SceneNode.meshURL)
}
inline void SceneNode::set_meshurl(const char* value, size_t size) {
  set_has_meshurl();
  meshurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SceneNode.meshURL)
}
inline ::std::string* SceneNode::mutable_meshurl() {
  set_has_meshurl();
  // @@protoc_insertion_point(field_mutable:SceneNode.meshURL)
  return meshurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SceneNode::release_meshurl() {
  // @@protoc_insertion_point(field_release:SceneNode.meshURL)
  clear_has_meshurl();
  return meshurl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SceneNode::set_allocated_meshurl(::std::string* meshurl) {
  if (meshurl != NULL) {
    set_has_meshurl();
  } else {
    clear_has_meshurl();
  }
  meshurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), meshurl);
  // @@protoc_insertion_point(field_set_allocated:SceneNode.meshURL)
}

// repeated .Material materials = 3;
inline int SceneNode::materials_size() const {
  return materials_.size();
}
inline void SceneNode::clear_materials() {
  materials_.Clear();
}
inline const ::Material& SceneNode::materials(int index) const {
  // @@protoc_insertion_point(field_get:SceneNode.materials)
  return materials_.Get(index);
}
inline ::Material* SceneNode::mutable_materials(int index) {
  // @@protoc_insertion_point(field_mutable:SceneNode.materials)
  return materials_.Mutable(index);
}
inline ::Material* SceneNode::add_materials() {
  // @@protoc_insertion_point(field_add:SceneNode.materials)
  return materials_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Material >*
SceneNode::mutable_materials() {
  // @@protoc_insertion_point(field_mutable_list:SceneNode.materials)
  return &materials_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Material >&
SceneNode::materials() const {
  // @@protoc_insertion_point(field_list:SceneNode.materials)
  return materials_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_SceneProtocol_2eproto__INCLUDED
