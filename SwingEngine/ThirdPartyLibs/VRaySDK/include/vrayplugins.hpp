#ifndef _VRAY_PLUGINS_HPP_
#define _VRAY_PLUGINS_HPP_
#ifndef _VRAY_SDK_HPP_
#include "vraysdk.hpp"
#endif
namespace VRay {
namespace Plugins {

class ASGVISNode : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "ASGVISNode"; }

	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	bool set_transform(const Transform& transform) { return setValue("transform", transform); }
	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	Transform get_transform() const { return getTransform("transform"); }

	//! (description missing)
	bool set_geometry(const Plugin& plugin) { return setValue("geometry", plugin); }
	//! (description missing)
	Plugin get_geometry() const { return getPlugin("geometry"); }

	//! (description missing)
	bool set_material(const Plugin& plugin) { return setValue("material", plugin); }
	//! (description missing)
	Plugin get_material() const { return getPlugin("material"); }

	//! (description missing)
	bool set_volume(const Plugin& plugin) { return setValue("volume", plugin); }
	//! (description missing)
	Plugin get_volume() const { return getPlugin("volume"); }

	//! Number of transform samples
 	//! [Default value] 0
	bool set_nsamples(int val) { return setValue("nsamples", val); }
	//! Number of transform samples
 	//! [Default value] 0
	int get_nsamples() const { return getInt("nsamples"); }

	//! (description missing)
	bool set_lights(const ValueList& pluginList) { return setValue("lights", pluginList); }
	//! (description missing)
	ValueList get_lights() const { return getValueList("lights"); }

	//! true if the object is renderable (visible) and false otherwise; it only makes sense to use this parameter if it is animated, or if another object depends on this node but it must not be rendered
 	//! [Default value] true
	bool set_visible(bool val) { return setValue("visible", val); }
	//! true if the object is renderable (visible) and false otherwise; it only makes sense to use this parameter if it is animated, or if another object depends on this node but it must not be rendered
 	//! [Default value] true
	bool get_visible() const { return getBool("visible"); }

	//! This can be used to give instances of nodes an identifier - if -1 is provided then a unique runtime render id will be calculated
 	//! [Default value] -1
	bool set_objectID(int val) { return setValue("objectID", val); }
	//! This can be used to give instances of nodes an identifier - if -1 is provided then a unique runtime render id will be calculated
 	//! [Default value] -1
	int get_objectID() const { return getInt("objectID"); }
};

class BRDFAlHair : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "BRDFAlHair"; }

	//! [UI Guides] minValue=0, maxValue=1
 	bool set_opacity(const Plugin& texturefloat) { return setValue("opacity", texturefloat); }
	//! [UI Guides] minValue=0, maxValue=1
 	bool set_opacity(float texturefloat) { return setValue("opacity", texturefloat); }
	//! [UI Guides] minValue=0, maxValue=1
 	Value get_opacity() const { return getValue("opacity"); }

	//! The melanin content of the hair fibre. Use this to generate natural colors for mammalian hair. 0 will give white hair, 0.2-04 blonde, 0.4-0.6 red, 0.6-0.8 brown and 0.8-1.0 black hair. If you want to set the color of the hair with a texture map, set this to 0 and use the Dye color parameter.
 	//! [UI Guides] minValue=0, maxValue=1
 	bool set_melanin(const Plugin& texturefloat) { return setValue("melanin", texturefloat); }
	//! The melanin content of the hair fibre. Use this to generate natural colors for mammalian hair. 0 will give white hair, 0.2-04 blonde, 0.4-0.6 red, 0.6-0.8 brown and 0.8-1.0 black hair. If you want to set the color of the hair with a texture map, set this to 0 and use the Dye color parameter.
 	//! [UI Guides] minValue=0, maxValue=1
 	bool set_melanin(float texturefloat) { return setValue("melanin", texturefloat); }
	//! The melanin content of the hair fibre. Use this to generate natural colors for mammalian hair. 0 will give white hair, 0.2-04 blonde, 0.4-0.6 red, 0.6-0.8 brown and 0.8-1.0 black hair. If you want to set the color of the hair with a texture map, set this to 0 and use the Dye color parameter.
 	//! [UI Guides] minValue=0, maxValue=1
 	Value get_melanin() const { return getValue("melanin"); }

	//! Color tint to apply to the hair.
 	bool set_dye_color(const Plugin& texture) { return setValue("dye_color", texture); }
	//! Color tint to apply to the hair.
 	bool set_dye_color(const AColor& texture) { return setValue("dye_color", texture); }
	//! Color tint to apply to the hair.
 	Value get_dye_color() const { return getValue("dye_color"); }

	//! The width of the hair highlights, essentially how shiny the hair appears. Values in the range 1-7 are sensible for human hair.
 	//! [Default value] 3
	bool set_specular_width(float val) { return setValue("specular_width", val); }
	//! The width of the hair highlights, essentially how shiny the hair appears. Values in the range 1-7 are sensible for human hair.
 	//! [Default value] 3
	float get_specular_width() const { return getFloat("specular_width"); }

	//! How much the highlights are shifted along the hair by the cuticles on the hair fibre. Generally this wants to be 1 to 1.5 times the value of the Width parameter.
 	//! [Default value] 4
	bool set_specular_shift(float val) { return setValue("specular_shift", val); }
	//! How much the highlights are shifted along the hair by the cuticles on the hair fibre. Generally this wants to be 1 to 1.5 times the value of the Width parameter.
 	//! [Default value] 4
	float get_specular_shift() const { return getFloat("specular_shift"); }

	//! Tint on the diffuse illumination.
 	bool set_diffuse_color(const Plugin& texture) { return setValue("diffuse_color", texture); }
	//! Tint on the diffuse illumination.
 	bool set_diffuse_color(const AColor& texture) { return setValue("diffuse_color", texture); }
	//! Tint on the diffuse illumination.
 	Value get_diffuse_color() const { return getValue("diffuse_color"); }

	//! Multiplier on the strength of the diffuse illumination.
 	//! [UI Guides] minValue=0, maxValue=1
 	bool set_diffuse_strength(const Plugin& texturefloat) { return setValue("diffuse_strength", texturefloat); }
	//! Multiplier on the strength of the diffuse illumination.
 	//! [UI Guides] minValue=0, maxValue=1
 	bool set_diffuse_strength(float texturefloat) { return setValue("diffuse_strength", texturefloat); }
	//! Multiplier on the strength of the diffuse illumination.
 	//! [UI Guides] minValue=0, maxValue=1
 	Value get_diffuse_strength() const { return getValue("diffuse_strength"); }

	//! Controls the amount of light bleeding through the hair in dual-scattering mode.
 	//! [UI Guides] minValue=0, maxValue=1
 	bool set_forward_scattering(const Plugin& texturefloat) { return setValue("forward_scattering", texturefloat); }
	//! Controls the amount of light bleeding through the hair in dual-scattering mode.
 	//! [UI Guides] minValue=0, maxValue=1
 	bool set_forward_scattering(float texturefloat) { return setValue("forward_scattering", texturefloat); }
	//! Controls the amount of light bleeding through the hair in dual-scattering mode.
 	//! [UI Guides] minValue=0, maxValue=1
 	Value get_forward_scattering() const { return getValue("forward_scattering"); }

	//! Controls the amount of light kicked back from the hair in dual-scattering mode.
 	//! [UI Guides] minValue=0, maxValue=1
 	bool set_back_scattering(const Plugin& texturefloat) { return setValue("back_scattering", texturefloat); }
	//! Controls the amount of light kicked back from the hair in dual-scattering mode.
 	//! [UI Guides] minValue=0, maxValue=1
 	bool set_back_scattering(float texturefloat) { return setValue("back_scattering", texturefloat); }
	//! Controls the amount of light kicked back from the hair in dual-scattering mode.
 	//! [UI Guides] minValue=0, maxValue=1
 	Value get_back_scattering() const { return getValue("back_scattering"); }

	//! (description missing)
	bool set_specular1_color(const Plugin& texture) { return setValue("specular1_color", texture); }
	//! (description missing)
	bool set_specular1_color(const AColor& texture) { return setValue("specular1_color", texture); }
	//! (description missing)
	Value get_specular1_color() const { return getValue("specular1_color"); }

	//! [UI Guides] minValue=0, maxValue=1
 	bool set_specular1_strength(const Plugin& texturefloat) { return setValue("specular1_strength", texturefloat); }
	//! [UI Guides] minValue=0, maxValue=1
 	bool set_specular1_strength(float texturefloat) { return setValue("specular1_strength", texturefloat); }
	//! [UI Guides] minValue=0, maxValue=1
 	Value get_specular1_strength() const { return getValue("specular1_strength"); }

	//! Offset on the shift of this lobe's highlight.
 	bool set_specular1_shift(const Plugin& texturefloat) { return setValue("specular1_shift", texturefloat); }
	//! Offset on the shift of this lobe's highlight.
 	bool set_specular1_shift(float texturefloat) { return setValue("specular1_shift", texturefloat); }
	//! Offset on the shift of this lobe's highlight.
 	Value get_specular1_shift() const { return getValue("specular1_shift"); }

	//! Multiplier on the width of this lobe's highlight.
 	bool set_specular1_width_scale(const Plugin& texturefloat) { return setValue("specular1_width_scale", texturefloat); }
	//! Multiplier on the width of this lobe's highlight.
 	bool set_specular1_width_scale(float texturefloat) { return setValue("specular1_width_scale", texturefloat); }
	//! Multiplier on the width of this lobe's highlight.
 	Value get_specular1_width_scale() const { return getValue("specular1_width_scale"); }

	//! (description missing)
	bool set_specular2_color(const Plugin& texture) { return setValue("specular2_color", texture); }
	//! (description missing)
	bool set_specular2_color(const AColor& texture) { return setValue("specular2_color", texture); }
	//! (description missing)
	Value get_specular2_color() const { return getValue("specular2_color"); }

	//! [UI Guides] minValue=0, maxValue=1
 	bool set_specular2_strength(const Plugin& texturefloat) { return setValue("specular2_strength", texturefloat); }
	//! [UI Guides] minValue=0, maxValue=1
 	bool set_specular2_strength(float texturefloat) { return setValue("specular2_strength", texturefloat); }
	//! [UI Guides] minValue=0, maxValue=1
 	Value get_specular2_strength() const { return getValue("specular2_strength"); }

	//! Offset on the shift of this lobe's highlight.
 	bool set_specular2_shift(const Plugin& texturefloat) { return setValue("specular2_shift", texturefloat); }
	//! Offset on the shift of this lobe's highlight.
 	bool set_specular2_shift(float texturefloat) { return setValue("specular2_shift", texturefloat); }
	//! Offset on the shift of this lobe's highlight.
 	Value get_specular2_shift() const { return getValue("specular2_shift"); }

	//! Multiplier on the width of this lobe's highlight.
 	bool set_specular2_width_scale(const Plugin& texturefloat) { return setValue("specular2_width_scale", texturefloat); }
	//! Multiplier on the width of this lobe's highlight.
 	bool set_specular2_width_scale(float texturefloat) { return setValue("specular2_width_scale", texturefloat); }
	//! Multiplier on the width of this lobe's highlight.
 	Value get_specular2_width_scale() const { return getValue("specular2_width_scale"); }

	//! Strength of the caustic glints. Sensible values are in the range 1-5.
 	//! [Default value] 2.5
	bool set_glint_strength(float val) { return setValue("glint_strength", val); }
	//! Strength of the caustic glints. Sensible values are in the range 1-5.
 	//! [Default value] 2.5
	float get_glint_strength() const { return getFloat("glint_strength"); }

	//! (description missing)
	bool set_transmission_color(const Plugin& texture) { return setValue("transmission_color", texture); }
	//! (description missing)
	bool set_transmission_color(const AColor& texture) { return setValue("transmission_color", texture); }
	//! (description missing)
	Value get_transmission_color() const { return getValue("transmission_color"); }

	//! [UI Guides] minValue=0, maxValue=1
 	bool set_transmission_strength(const Plugin& texturefloat) { return setValue("transmission_strength", texturefloat); }
	//! [UI Guides] minValue=0, maxValue=1
 	bool set_transmission_strength(float texturefloat) { return setValue("transmission_strength", texturefloat); }
	//! [UI Guides] minValue=0, maxValue=1
 	Value get_transmission_strength() const { return getValue("transmission_strength"); }

	//! Offset on the shift of this lobe's highlight.
 	bool set_transmission_shift(const Plugin& texturefloat) { return setValue("transmission_shift", texturefloat); }
	//! Offset on the shift of this lobe's highlight.
 	bool set_transmission_shift(float texturefloat) { return setValue("transmission_shift", texturefloat); }
	//! Offset on the shift of this lobe's highlight.
 	Value get_transmission_shift() const { return getValue("transmission_shift"); }

	//! Multiplier on the width of this lobe's highlight.
 	bool set_transmission_width_scale(const Plugin& texturefloat) { return setValue("transmission_width_scale", texturefloat); }
	//! Multiplier on the width of this lobe's highlight.
 	bool set_transmission_width_scale(float texturefloat) { return setValue("transmission_width_scale", texturefloat); }
	//! Multiplier on the width of this lobe's highlight.
 	Value get_transmission_width_scale() const { return getValue("transmission_width_scale"); }

	//! Controls the rolloff of the caustic glints in the hair. Lower values make the glints more pingy, higher values make them softer and less apparent.
 	//! [Default value] 5
	bool set_glint_rolloff(float val) { return setValue("glint_rolloff", val); }
	//! Controls the rolloff of the caustic glints in the hair. Lower values make the glints more pingy, higher values make them softer and less apparent.
 	//! [Default value] 5
	float get_glint_rolloff() const { return getFloat("glint_rolloff"); }

	//! Controls the rolloff of the transmission highlight. Essentially, if you want the transmission highlight to only appear when the light is directly behind the hair, set this value to 10 or lower. If you want to increase the amount the highlight spreads as the light comes around from behind, set this value higher than 10.
 	//! [Default value] 10
	bool set_transmission_rolloff(float val) { return setValue("transmission_rolloff", val); }
	//! Controls the rolloff of the transmission highlight. Essentially, if you want the transmission highlight to only appear when the light is directly behind the hair, set this value to 10 or lower. If you want to increase the amount the highlight spreads as the light comes around from behind, set this value higher than 10.
 	//! [Default value] 10
	float get_transmission_rolloff() const { return getFloat("transmission_rolloff"); }

	//! Adds a random offset to the melanin content of the hair. Values from 0.05 to 0.2 give a very natural color variation.
 	bool set_random_melanin(const Plugin& texturefloat) { return setValue("random_melanin", texturefloat); }
	//! Adds a random offset to the melanin content of the hair. Values from 0.05 to 0.2 give a very natural color variation.
 	bool set_random_melanin(float texturefloat) { return setValue("random_melanin", texturefloat); }
	//! Adds a random offset to the melanin content of the hair. Values from 0.05 to 0.2 give a very natural color variation.
 	Value get_random_melanin() const { return getValue("random_melanin"); }

	//! Adds a random offest to the hue of the dye color.
 	bool set_random_hue(const Plugin& texturefloat) { return setValue("random_hue", texturefloat); }
	//! Adds a random offest to the hue of the dye color.
 	bool set_random_hue(float texturefloat) { return setValue("random_hue", texturefloat); }
	//! Adds a random offest to the hue of the dye color.
 	Value get_random_hue() const { return getValue("random_hue"); }

	//! Adds a random offest to the saturation of the Dye color.
 	bool set_random_saturation(const Plugin& texturefloat) { return setValue("random_saturation", texturefloat); }
	//! Adds a random offest to the saturation of the Dye color.
 	bool set_random_saturation(float texturefloat) { return setValue("random_saturation", texturefloat); }
	//! Adds a random offest to the saturation of the Dye color.
 	Value get_random_saturation() const { return getValue("random_saturation"); }

	//! Adds a random offset to the hair tangent which can be useful for breaking up uniform-looking grooms. Note that this value is dependent on your scene scale.
 	bool set_random_tangent(const Plugin& texturefloat) { return setValue("random_tangent", texturefloat); }
	//! Adds a random offset to the hair tangent which can be useful for breaking up uniform-looking grooms. Note that this value is dependent on your scene scale.
 	bool set_random_tangent(float texturefloat) { return setValue("random_tangent", texturefloat); }
	//! Adds a random offset to the hair tangent which can be useful for breaking up uniform-looking grooms. Note that this value is dependent on your scene scale.
 	Value get_random_tangent() const { return getValue("random_tangent"); }

	//! [UI Guides] minValue=0, maxValue=1
 	//! [Default value] 0
	bool set_diffuse_indirect_strength(float val) { return setValue("diffuse_indirect_strength", val); }
	//! [UI Guides] minValue=0, maxValue=1
 	//! [Default value] 0
	float get_diffuse_indirect_strength() const { return getFloat("diffuse_indirect_strength"); }

	//! [UI Guides] minValue=0, maxValue=1
 	//! [Default value] 0
	bool set_glossy_indirect_strength(float val) { return setValue("glossy_indirect_strength", val); }
	//! [UI Guides] minValue=0, maxValue=1
 	//! [Default value] 0
	float get_glossy_indirect_strength() const { return getFloat("glossy_indirect_strength"); }
};

class BRDFAlSurface : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "BRDFAlSurface"; }

	//! Overall bump map (applied to all components)
 	//! [UI Guides] attributes=textureSlot, startTab=V-Ray alSurface, startRollout=Bump
 	bool set_bump_map(const Plugin& texture) { return setValue("bump_map", texture); }
	//! Overall bump map (applied to all components)
 	//! [UI Guides] attributes=textureSlot, startTab=V-Ray alSurface, startRollout=Bump
 	bool set_bump_map(const AColor& texture) { return setValue("bump_map", texture); }
	//! Overall bump map (applied to all components)
 	//! [UI Guides] attributes=textureSlot, startTab=V-Ray alSurface, startRollout=Bump
 	Value get_bump_map() const { return getValue("bump_map"); }

	//! Bump amount
 	//! [UI Guides] quantityType=distance
 	bool set_bump_amount(const Plugin& texturefloat) { return setValue("bump_amount", texturefloat); }
	//! Bump amount
 	//! [UI Guides] quantityType=distance
 	bool set_bump_amount(float texturefloat) { return setValue("bump_amount", texturefloat); }
	//! Bump amount
 	//! [UI Guides] quantityType=distance
 	Value get_bump_amount() const { return getValue("bump_amount"); }

	//! The type of the map (0 - from regular texture output, 1 - normal map in tangent space, 2 - normal map in object space, 3 - normal map in camera space, 4 - normal map in world space, 5 - from texture bump output, 6 - explicit normal)
 	//! [UI Guides] enum=0:Bump Map;1:Normal map in tangent space;2:Normal map in object space;3:Normal map in screen space;4:Normal map in world space;5:From texture bump output;6:Explicit normal
 	//! [Default value] 0
	bool set_bump_type(int val) { return setValue("bump_type", val); }
	//! The type of the map (0 - from regular texture output, 1 - normal map in tangent space, 2 - normal map in object space, 3 - normal map in camera space, 4 - normal map in world space, 5 - from texture bump output, 6 - explicit normal)
 	//! [UI Guides] enum=0:Bump Map;1:Normal map in tangent space;2:Normal map in object space;3:Normal map in screen space;4:Normal map in world space;5:From texture bump output;6:Explicit normal
 	//! [Default value] 0
	int get_bump_type() const { return getInt("bump_type"); }

	//! Opacity map
 	//! [UI Guides] minValue=0, maxValue=1, startRollout=Diffuse and Opacity
 	bool set_opacity(const Plugin& texturefloat) { return setValue("opacity", texturefloat); }
	//! Opacity map
 	//! [UI Guides] minValue=0, maxValue=1, startRollout=Diffuse and Opacity
 	bool set_opacity(float texturefloat) { return setValue("opacity", texturefloat); }
	//! Opacity map
 	//! [UI Guides] minValue=0, maxValue=1, startRollout=Diffuse and Opacity
 	Value get_opacity() const { return getValue("opacity"); }

	//! The diffuse surface color
 	//! [UI Guides] displayName=Diffuse Color, enableIf: ?diffuse_strength>0
 	bool set_diffuse(const Plugin& texture) { return setValue("diffuse", texture); }
	//! The diffuse surface color
 	//! [UI Guides] displayName=Diffuse Color, enableIf: ?diffuse_strength>0
 	bool set_diffuse(const AColor& texture) { return setValue("diffuse", texture); }
	//! The diffuse surface color
 	//! [UI Guides] displayName=Diffuse Color, enableIf: ?diffuse_strength>0
 	Value get_diffuse() const { return getValue("diffuse"); }

	//! The strength of the diffuse component
 	//! [UI Guides] minValue=0, maxValue=1
 	bool set_diffuse_strength(const Plugin& texturefloat) { return setValue("diffuse_strength", texturefloat); }
	//! The strength of the diffuse component
 	//! [UI Guides] minValue=0, maxValue=1
 	bool set_diffuse_strength(float texturefloat) { return setValue("diffuse_strength", texturefloat); }
	//! The strength of the diffuse component
 	//! [UI Guides] minValue=0, maxValue=1
 	Value get_diffuse_strength() const { return getValue("diffuse_strength"); }

	//! Additoinal diffuse bump map
 	//! [UI Guides] enableIf: ?diffuse_strength>0, attributes=textureSlot
 	bool set_diffuse_bump_map(const Plugin& texture) { return setValue("diffuse_bump_map", texture); }
	//! Additoinal diffuse bump map
 	//! [UI Guides] enableIf: ?diffuse_strength>0, attributes=textureSlot
 	bool set_diffuse_bump_map(const AColor& texture) { return setValue("diffuse_bump_map", texture); }
	//! Additoinal diffuse bump map
 	//! [UI Guides] enableIf: ?diffuse_strength>0, attributes=textureSlot
 	Value get_diffuse_bump_map() const { return getValue("diffuse_bump_map"); }

	//! Diffuse bump amount
 	//! [UI Guides] quantityType=distance, enableIf: ?diffuse_strength>0
 	bool set_diffuse_bump_amount(const Plugin& texturefloat) { return setValue("diffuse_bump_amount", texturefloat); }
	//! Diffuse bump amount
 	//! [UI Guides] quantityType=distance, enableIf: ?diffuse_strength>0
 	bool set_diffuse_bump_amount(float texturefloat) { return setValue("diffuse_bump_amount", texturefloat); }
	//! Diffuse bump amount
 	//! [UI Guides] quantityType=distance, enableIf: ?diffuse_strength>0
 	Value get_diffuse_bump_amount() const { return getValue("diffuse_bump_amount"); }

	//! The type of the map (0 - from regular texture output, 1 - normal map in tangent space, 2 - normal map in object space, 3 - normal map in camera space, 4 - normal map in world space, 5 - from texture bump output, 6 - explicit normal)
 	//! [UI Guides] enum=0:Bump Map;1:Normal map in tangent space;2:Normal map in object space;3:Normal map in screen space;4:Normal map in world space;5:From texture bump output;6:Explicit normal, enableIf: ?diffuse_strength>0
 	//! [Default value] 0
	bool set_diffuse_bump_type(int val) { return setValue("diffuse_bump_type", val); }
	//! The type of the map (0 - from regular texture output, 1 - normal map in tangent space, 2 - normal map in object space, 3 - normal map in camera space, 4 - normal map in world space, 5 - from texture bump output, 6 - explicit normal)
 	//! [UI Guides] enum=0:Bump Map;1:Normal map in tangent space;2:Normal map in object space;3:Normal map in screen space;4:Normal map in world space;5:From texture bump output;6:Explicit normal, enableIf: ?diffuse_strength>0
 	//! [Default value] 0
	int get_diffuse_bump_type() const { return getInt("diffuse_bump_type"); }

	//! The first specular color
 	//! [UI Guides] displayName=Reflect 1 Color, enableIf: ?reflect1_strength>0, startRollout=Reflection 1
 	bool set_reflect1(const Plugin& texture) { return setValue("reflect1", texture); }
	//! The first specular color
 	//! [UI Guides] displayName=Reflect 1 Color, enableIf: ?reflect1_strength>0, startRollout=Reflection 1
 	bool set_reflect1(const AColor& texture) { return setValue("reflect1", texture); }
	//! The first specular color
 	//! [UI Guides] displayName=Reflect 1 Color, enableIf: ?reflect1_strength>0, startRollout=Reflection 1
 	Value get_reflect1() const { return getValue("reflect1"); }

	//! The strength of the first specular component
 	//! [UI Guides] displayName=Reflect 1 Strength, minValue=0, maxValue=1
 	bool set_reflect1_strength(const Plugin& texturefloat) { return setValue("reflect1_strength", texturefloat); }
	//! The strength of the first specular component
 	//! [UI Guides] displayName=Reflect 1 Strength, minValue=0, maxValue=1
 	bool set_reflect1_strength(float texturefloat) { return setValue("reflect1_strength", texturefloat); }
	//! The strength of the first specular component
 	//! [UI Guides] displayName=Reflect 1 Strength, minValue=0, maxValue=1
 	Value get_reflect1_strength() const { return getValue("reflect1_strength"); }

	//! The roughness of the first specular component
 	//! [UI Guides] displayName=Reflect 1 Roughness, minValue=0, maxValue=1, enableIf: ?reflect1_strength>0
 	bool set_reflect1_roughness(const Plugin& texturefloat) { return setValue("reflect1_roughness", texturefloat); }
	//! The roughness of the first specular component
 	//! [UI Guides] displayName=Reflect 1 Roughness, minValue=0, maxValue=1, enableIf: ?reflect1_strength>0
 	bool set_reflect1_roughness(float texturefloat) { return setValue("reflect1_roughness", texturefloat); }
	//! The roughness of the first specular component
 	//! [UI Guides] displayName=Reflect 1 Roughness, minValue=0, maxValue=1, enableIf: ?reflect1_strength>0
 	Value get_reflect1_roughness() const { return getValue("reflect1_roughness"); }

	//! The IOR for the first specular component
 	//! [UI Guides] displayName=Reflect 1 IOR, enableIf: ?reflect1_strength>0
 	bool set_reflect1_ior(const Plugin& texturefloat) { return setValue("reflect1_ior", texturefloat); }
	//! The IOR for the first specular component
 	//! [UI Guides] displayName=Reflect 1 IOR, enableIf: ?reflect1_strength>0
 	bool set_reflect1_ior(float texturefloat) { return setValue("reflect1_ior", texturefloat); }
	//! The IOR for the first specular component
 	//! [UI Guides] displayName=Reflect 1 IOR, enableIf: ?reflect1_strength>0
 	Value get_reflect1_ior() const { return getValue("reflect1_ior"); }

	//! The BRDF distribution type for the first specular component (0 - Beckmann, 1 - GGX)
 	//! [UI Guides] displayName=Reflect 1 Distribution, enum=0:Beckmann;1:GGX, enableIf: ?reflect1_strength>0
 	//! [Default value] 0
	bool set_reflect1_distribution(int val) { return setValue("reflect1_distribution", val); }
	//! The BRDF distribution type for the first specular component (0 - Beckmann, 1 - GGX)
 	//! [UI Guides] displayName=Reflect 1 Distribution, enum=0:Beckmann;1:GGX, enableIf: ?reflect1_strength>0
 	//! [Default value] 0
	int get_reflect1_distribution() const { return getInt("reflect1_distribution"); }

	//! Additional bump map for the first specular component
 	//! [UI Guides] displayName=Reflect 1 Bump Map, attributes=textureSlot, enableIf: ?reflect1_strength>0
 	bool set_reflect1_bump_map(const Plugin& texture) { return setValue("reflect1_bump_map", texture); }
	//! Additional bump map for the first specular component
 	//! [UI Guides] displayName=Reflect 1 Bump Map, attributes=textureSlot, enableIf: ?reflect1_strength>0
 	bool set_reflect1_bump_map(const AColor& texture) { return setValue("reflect1_bump_map", texture); }
	//! Additional bump map for the first specular component
 	//! [UI Guides] displayName=Reflect 1 Bump Map, attributes=textureSlot, enableIf: ?reflect1_strength>0
 	Value get_reflect1_bump_map() const { return getValue("reflect1_bump_map"); }

	//! Additional bump amount for the first speculer component
 	//! [UI Guides] displayName=Reflect 1 Bump Amount, quantityType=distance, enableIf: ?reflect1_strength>0
 	bool set_reflect1_bump_amount(const Plugin& texturefloat) { return setValue("reflect1_bump_amount", texturefloat); }
	//! Additional bump amount for the first speculer component
 	//! [UI Guides] displayName=Reflect 1 Bump Amount, quantityType=distance, enableIf: ?reflect1_strength>0
 	bool set_reflect1_bump_amount(float texturefloat) { return setValue("reflect1_bump_amount", texturefloat); }
	//! Additional bump amount for the first speculer component
 	//! [UI Guides] displayName=Reflect 1 Bump Amount, quantityType=distance, enableIf: ?reflect1_strength>0
 	Value get_reflect1_bump_amount() const { return getValue("reflect1_bump_amount"); }

	//! The type of the map (0 - from regular texture output, 1 - normal map in tangent space, 2 - normal map in object space, 3 - normal map in camera space, 4 - normal map in world space, 5 - from texture bump output, 6 - explicit normal)
 	//! [UI Guides] enum=0:Bump Map;1:Normal map in tangent space;2:Normal map in object space;3:Normal map in screen space;4:Normal map in world space;5:From texture bump output;6:Explicit normal, displayName=Reflect 1 Bump Type, enableIf: ?reflect1_strength>0
 	//! [Default value] 0
	bool set_reflect1_bump_type(int val) { return setValue("reflect1_bump_type", val); }
	//! The type of the map (0 - from regular texture output, 1 - normal map in tangent space, 2 - normal map in object space, 3 - normal map in camera space, 4 - normal map in world space, 5 - from texture bump output, 6 - explicit normal)
 	//! [UI Guides] enum=0:Bump Map;1:Normal map in tangent space;2:Normal map in object space;3:Normal map in screen space;4:Normal map in world space;5:From texture bump output;6:Explicit normal, displayName=Reflect 1 Bump Type, enableIf: ?reflect1_strength>0
 	//! [Default value] 0
	int get_reflect1_bump_type() const { return getInt("reflect1_bump_type"); }

	//! The second specular color
 	//! [UI Guides] displayName=Reflect 2 Color, enableIf: ?reflect2_strength>0, startRollout=Reflection 2
 	bool set_reflect2(const Plugin& texture) { return setValue("reflect2", texture); }
	//! The second specular color
 	//! [UI Guides] displayName=Reflect 2 Color, enableIf: ?reflect2_strength>0, startRollout=Reflection 2
 	bool set_reflect2(const AColor& texture) { return setValue("reflect2", texture); }
	//! The second specular color
 	//! [UI Guides] displayName=Reflect 2 Color, enableIf: ?reflect2_strength>0, startRollout=Reflection 2
 	Value get_reflect2() const { return getValue("reflect2"); }

	//! The strength of the second specular component
 	//! [UI Guides] displayName=Reflect 2 Strength, minValue=0, maxValue=1
 	bool set_reflect2_strength(const Plugin& texturefloat) { return setValue("reflect2_strength", texturefloat); }
	//! The strength of the second specular component
 	//! [UI Guides] displayName=Reflect 2 Strength, minValue=0, maxValue=1
 	bool set_reflect2_strength(float texturefloat) { return setValue("reflect2_strength", texturefloat); }
	//! The strength of the second specular component
 	//! [UI Guides] displayName=Reflect 2 Strength, minValue=0, maxValue=1
 	Value get_reflect2_strength() const { return getValue("reflect2_strength"); }

	//! The roughness of the second specular component
 	//! [UI Guides] displayName=Reflect 2 Roughness, minValue=0, maxValue=1, enableIf: ?reflect2_strength>0
 	bool set_reflect2_roughness(const Plugin& texturefloat) { return setValue("reflect2_roughness", texturefloat); }
	//! The roughness of the second specular component
 	//! [UI Guides] displayName=Reflect 2 Roughness, minValue=0, maxValue=1, enableIf: ?reflect2_strength>0
 	bool set_reflect2_roughness(float texturefloat) { return setValue("reflect2_roughness", texturefloat); }
	//! The roughness of the second specular component
 	//! [UI Guides] displayName=Reflect 2 Roughness, minValue=0, maxValue=1, enableIf: ?reflect2_strength>0
 	Value get_reflect2_roughness() const { return getValue("reflect2_roughness"); }

	//! The IOR for the second specular component
 	//! [UI Guides] displayName=Reflect 2 IOR, enableIf: ?reflect2_strength>0
 	bool set_reflect2_ior(const Plugin& texturefloat) { return setValue("reflect2_ior", texturefloat); }
	//! The IOR for the second specular component
 	//! [UI Guides] displayName=Reflect 2 IOR, enableIf: ?reflect2_strength>0
 	bool set_reflect2_ior(float texturefloat) { return setValue("reflect2_ior", texturefloat); }
	//! The IOR for the second specular component
 	//! [UI Guides] displayName=Reflect 2 IOR, enableIf: ?reflect2_strength>0
 	Value get_reflect2_ior() const { return getValue("reflect2_ior"); }

	//! The BRDF distribution type for the second specular component (0 - Beckmann, 1 - GGX)
 	//! [UI Guides] displayName=Reflect 2 Distribution, enum=0:Beckmann;1:GGX, enableIf: ?reflect2_strength>0
 	//! [Default value] 0
	bool set_reflect2_distribution(int val) { return setValue("reflect2_distribution", val); }
	//! The BRDF distribution type for the second specular component (0 - Beckmann, 1 - GGX)
 	//! [UI Guides] displayName=Reflect 2 Distribution, enum=0:Beckmann;1:GGX, enableIf: ?reflect2_strength>0
 	//! [Default value] 0
	int get_reflect2_distribution() const { return getInt("reflect2_distribution"); }

	//! Additional bump map for the second specular component
 	//! [UI Guides] displayName=Reflect 2 Bump Map, attributes=textureSlot, enableIf: ?reflect2_strength>0
 	bool set_reflect2_bump_map(const Plugin& texture) { return setValue("reflect2_bump_map", texture); }
	//! Additional bump map for the second specular component
 	//! [UI Guides] displayName=Reflect 2 Bump Map, attributes=textureSlot, enableIf: ?reflect2_strength>0
 	bool set_reflect2_bump_map(const AColor& texture) { return setValue("reflect2_bump_map", texture); }
	//! Additional bump map for the second specular component
 	//! [UI Guides] displayName=Reflect 2 Bump Map, attributes=textureSlot, enableIf: ?reflect2_strength>0
 	Value get_reflect2_bump_map() const { return getValue("reflect2_bump_map"); }

	//! Additional bump amount for the second speculer component
 	//! [UI Guides] displayName=Reflect 2 Bump Amount, quantityType=distance, enableIf: ?reflect2_strength>0
 	bool set_reflect2_bump_amount(const Plugin& texturefloat) { return setValue("reflect2_bump_amount", texturefloat); }
	//! Additional bump amount for the second speculer component
 	//! [UI Guides] displayName=Reflect 2 Bump Amount, quantityType=distance, enableIf: ?reflect2_strength>0
 	bool set_reflect2_bump_amount(float texturefloat) { return setValue("reflect2_bump_amount", texturefloat); }
	//! Additional bump amount for the second speculer component
 	//! [UI Guides] displayName=Reflect 2 Bump Amount, quantityType=distance, enableIf: ?reflect2_strength>0
 	Value get_reflect2_bump_amount() const { return getValue("reflect2_bump_amount"); }

	//! The type of the map (0 - from regular texture output, 1 - normal map in tangent space, 2 - normal map in object space, 3 - normal map in camera space, 4 - normal map in world space, 5 - from texture bump output, 6 - explicit normal)
 	//! [UI Guides] enum=0:Bump Map;1:Normal map in tangent space;2:Normal map in object space;3:Normal map in screen space;4:Normal map in world space;5:From texture bump output;6:Explicit normal, displayName=Reflect 2 Bump Type, enableIf: ?reflect2_strength>0
 	//! [Default value] 0
	bool set_reflect2_bump_type(int val) { return setValue("reflect2_bump_type", val); }
	//! The type of the map (0 - from regular texture output, 1 - normal map in tangent space, 2 - normal map in object space, 3 - normal map in camera space, 4 - normal map in world space, 5 - from texture bump output, 6 - explicit normal)
 	//! [UI Guides] enum=0:Bump Map;1:Normal map in tangent space;2:Normal map in object space;3:Normal map in screen space;4:Normal map in world space;5:From texture bump output;6:Explicit normal, displayName=Reflect 2 Bump Type, enableIf: ?reflect2_strength>0
 	//! [Default value] 0
	int get_reflect2_bump_type() const { return getInt("reflect2_bump_type"); }

	//! Mix between the diffuse component and the SSS component
 	//! [UI Guides] displayName=SSS Mix, minValue=0, maxValue=1, startRollout=SSS
 	bool set_sss_mix(const Plugin& texturefloat) { return setValue("sss_mix", texturefloat); }
	//! Mix between the diffuse component and the SSS component
 	//! [UI Guides] displayName=SSS Mix, minValue=0, maxValue=1, startRollout=SSS
 	bool set_sss_mix(float texturefloat) { return setValue("sss_mix", texturefloat); }
	//! Mix between the diffuse component and the SSS component
 	//! [UI Guides] displayName=SSS Mix, minValue=0, maxValue=1, startRollout=SSS
 	Value get_sss_mix() const { return getValue("sss_mix"); }

	//! Sub-surface scattering mode (0 - diffusion; 1 - directional)
 	//! [UI Guides] displayName=SSS Mode, enum=0:Diffusion;1:Directional, enableIf: ?sss_mix>0
 	//! [Default value] 0
	bool set_sss_mode(int val) { return setValue("sss_mode", val); }
	//! Sub-surface scattering mode (0 - diffusion; 1 - directional)
 	//! [UI Guides] displayName=SSS Mode, enum=0:Diffusion;1:Directional, enableIf: ?sss_mix>0
 	//! [Default value] 0
	int get_sss_mode() const { return getInt("sss_mode"); }

	//! Scale for the SSS effect; smaller values make light go deeper into the object
 	//! [UI Guides] displayName=SSS Density Scale, enableIf: ?sss_mix>0
 	//! [Default value] 1
	bool set_sss_density_scale(float val) { return setValue("sss_density_scale", val); }
	//! Scale for the SSS effect; smaller values make light go deeper into the object
 	//! [UI Guides] displayName=SSS Density Scale, enableIf: ?sss_mix>0
 	//! [Default value] 1
	float get_sss_density_scale() const { return getFloat("sss_density_scale"); }

	//! Weight of the first SSS component
 	//! [UI Guides] displayName=SSS 1 Weight, minValue=0, maxValue=10, softMinValue=0, softMaxValue=1, enableIf: ?sss_mix>0, startRollout=
 	bool set_sss1_weight(const Plugin& texturefloat) { return setValue("sss1_weight", texturefloat); }
	//! Weight of the first SSS component
 	//! [UI Guides] displayName=SSS 1 Weight, minValue=0, maxValue=10, softMinValue=0, softMaxValue=1, enableIf: ?sss_mix>0, startRollout=
 	bool set_sss1_weight(float texturefloat) { return setValue("sss1_weight", texturefloat); }
	//! Weight of the first SSS component
 	//! [UI Guides] displayName=SSS 1 Weight, minValue=0, maxValue=10, softMinValue=0, softMaxValue=1, enableIf: ?sss_mix>0, startRollout=
 	Value get_sss1_weight() const { return getValue("sss1_weight"); }

	//! Color of the first SSS component
 	//! [UI Guides] displayName=SSS 1 Color, enableIf: ?sss_mix>0, ?sss1_weight>0
 	bool set_sss1_color(const Plugin& texture) { return setValue("sss1_color", texture); }
	//! Color of the first SSS component
 	//! [UI Guides] displayName=SSS 1 Color, enableIf: ?sss_mix>0, ?sss1_weight>0
 	bool set_sss1_color(const AColor& texture) { return setValue("sss1_color", texture); }
	//! Color of the first SSS component
 	//! [UI Guides] displayName=SSS 1 Color, enableIf: ?sss_mix>0, ?sss1_weight>0
 	Value get_sss1_color() const { return getValue("sss1_color"); }

	//! Radius for the first SSS component. Larger values cause light to go deeper into the surface
 	//! [UI Guides] displayName=SSS 1 Radius, quantityType=distance, enableIf: ?sss_mix>0, ?sss1_weight>0
 	bool set_sss1_radius(const Plugin& texturefloat) { return setValue("sss1_radius", texturefloat); }
	//! Radius for the first SSS component. Larger values cause light to go deeper into the surface
 	//! [UI Guides] displayName=SSS 1 Radius, quantityType=distance, enableIf: ?sss_mix>0, ?sss1_weight>0
 	bool set_sss1_radius(float texturefloat) { return setValue("sss1_radius", texturefloat); }
	//! Radius for the first SSS component. Larger values cause light to go deeper into the surface
 	//! [UI Guides] displayName=SSS 1 Radius, quantityType=distance, enableIf: ?sss_mix>0, ?sss1_weight>0
 	Value get_sss1_radius() const { return getValue("sss1_radius"); }

	//! Weight of the second SSS component
 	//! [UI Guides] displayName=SSS 2 Weight, minValue=0, maxValue=10, softMinValue=0, softMaxValue=1, enableIf: ?sss_mix>0, startRollout=
 	bool set_sss2_weight(const Plugin& texturefloat) { return setValue("sss2_weight", texturefloat); }
	//! Weight of the second SSS component
 	//! [UI Guides] displayName=SSS 2 Weight, minValue=0, maxValue=10, softMinValue=0, softMaxValue=1, enableIf: ?sss_mix>0, startRollout=
 	bool set_sss2_weight(float texturefloat) { return setValue("sss2_weight", texturefloat); }
	//! Weight of the second SSS component
 	//! [UI Guides] displayName=SSS 2 Weight, minValue=0, maxValue=10, softMinValue=0, softMaxValue=1, enableIf: ?sss_mix>0, startRollout=
 	Value get_sss2_weight() const { return getValue("sss2_weight"); }

	//! Color of the second SSS component
 	//! [UI Guides] displayName=SSS 2 Color, enableIf: ?sss_mix>0, ?sss2_weight>0
 	bool set_sss2_color(const Plugin& texture) { return setValue("sss2_color", texture); }
	//! Color of the second SSS component
 	//! [UI Guides] displayName=SSS 2 Color, enableIf: ?sss_mix>0, ?sss2_weight>0
 	bool set_sss2_color(const AColor& texture) { return setValue("sss2_color", texture); }
	//! Color of the second SSS component
 	//! [UI Guides] displayName=SSS 2 Color, enableIf: ?sss_mix>0, ?sss2_weight>0
 	Value get_sss2_color() const { return getValue("sss2_color"); }

	//! Radius for the second SSS component. Larger values cause light to go deeper into the surface
 	//! [UI Guides] displayName=SSS 2 Radius, quantityType=distance, enableIf: ?sss_mix>0, ?sss2_weight>0
 	bool set_sss2_radius(const Plugin& texturefloat) { return setValue("sss2_radius", texturefloat); }
	//! Radius for the second SSS component. Larger values cause light to go deeper into the surface
 	//! [UI Guides] displayName=SSS 2 Radius, quantityType=distance, enableIf: ?sss_mix>0, ?sss2_weight>0
 	bool set_sss2_radius(float texturefloat) { return setValue("sss2_radius", texturefloat); }
	//! Radius for the second SSS component. Larger values cause light to go deeper into the surface
 	//! [UI Guides] displayName=SSS 2 Radius, quantityType=distance, enableIf: ?sss_mix>0, ?sss2_weight>0
 	Value get_sss2_radius() const { return getValue("sss2_radius"); }

	//! Weight of the third SSS component
 	//! [UI Guides] displayName=SSS 3 Weight, minValue=0, maxValue=10, softMinValue=0, softMaxValue=1, enableIf: ?sss_mix>0, startRollout=
 	bool set_sss3_weight(const Plugin& texturefloat) { return setValue("sss3_weight", texturefloat); }
	//! Weight of the third SSS component
 	//! [UI Guides] displayName=SSS 3 Weight, minValue=0, maxValue=10, softMinValue=0, softMaxValue=1, enableIf: ?sss_mix>0, startRollout=
 	bool set_sss3_weight(float texturefloat) { return setValue("sss3_weight", texturefloat); }
	//! Weight of the third SSS component
 	//! [UI Guides] displayName=SSS 3 Weight, minValue=0, maxValue=10, softMinValue=0, softMaxValue=1, enableIf: ?sss_mix>0, startRollout=
 	Value get_sss3_weight() const { return getValue("sss3_weight"); }

	//! Color of the third SSS component
 	//! [UI Guides] displayName=SSS 3 Color, enableIf: ?sss_mix>0, ?sss3_weight>0
 	bool set_sss3_color(const Plugin& texture) { return setValue("sss3_color", texture); }
	//! Color of the third SSS component
 	//! [UI Guides] displayName=SSS 3 Color, enableIf: ?sss_mix>0, ?sss3_weight>0
 	bool set_sss3_color(const AColor& texture) { return setValue("sss3_color", texture); }
	//! Color of the third SSS component
 	//! [UI Guides] displayName=SSS 3 Color, enableIf: ?sss_mix>0, ?sss3_weight>0
 	Value get_sss3_color() const { return getValue("sss3_color"); }

	//! Radius for the third SSS component. Larger values cause light to go deeper into the surface
 	//! [UI Guides] displayName=SSS 3 Radius, quantityType=distance, enableIf: ?sss_mix>0, ?sss3_weight>0
 	bool set_sss3_radius(const Plugin& texturefloat) { return setValue("sss3_radius", texturefloat); }
	//! Radius for the third SSS component. Larger values cause light to go deeper into the surface
 	//! [UI Guides] displayName=SSS 3 Radius, quantityType=distance, enableIf: ?sss_mix>0, ?sss3_weight>0
 	bool set_sss3_radius(float texturefloat) { return setValue("sss3_radius", texturefloat); }
	//! Radius for the third SSS component. Larger values cause light to go deeper into the surface
 	//! [UI Guides] displayName=SSS 3 Radius, quantityType=distance, enableIf: ?sss_mix>0, ?sss3_weight>0
 	Value get_sss3_radius() const { return getValue("sss3_radius"); }

	//! Maximum depth for reflections; set to -1 to use the global depth
 	//! [UI Guides] startRollout=Options, minValue=-1
 	//! [Default value] 5
	bool set_reflect_max_depth(int val) { return setValue("reflect_max_depth", val); }
	//! Maximum depth for reflections; set to -1 to use the global depth
 	//! [UI Guides] startRollout=Options, minValue=-1
 	//! [Default value] 5
	int get_reflect_max_depth() const { return getInt("reflect_max_depth"); }

	//! Subdivs for sampling reflections when local subdivs are enabled
 	//! [UI Guides] quantityType=localSubdivs, minValue=1
 	//! [Default value] 8
	bool set_reflect_subdivs(int val) { return setValue("reflect_subdivs", val); }
	//! Subdivs for sampling reflections when local subdivs are enabled
 	//! [UI Guides] quantityType=localSubdivs, minValue=1
 	//! [Default value] 8
	int get_reflect_subdivs() const { return getInt("reflect_subdivs"); }

	//! Subdivs for sampling SSS when local subdivs are enabled
 	//! [UI Guides] displayName=SSS Subdivs, quantityType=localSubdivs, minValue=1
 	//! [Default value] 8
	bool set_sss_subdivs(int val) { return setValue("sss_subdivs", val); }
	//! Subdivs for sampling SSS when local subdivs are enabled
 	//! [UI Guides] displayName=SSS Subdivs, quantityType=localSubdivs, minValue=1
 	//! [Default value] 8
	int get_sss_subdivs() const { return getInt("sss_subdivs"); }
};

class BRDFBlinn : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "BRDFBlinn"; }

	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	bool set_color(const Color& color) { return setValue("color", color); }
	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	Color get_color() const { return getColor("color"); }

	//! (description missing)
	bool set_color_tex(const Plugin& texture) { return setValue("color_tex", texture); }
	//! (description missing)
	bool set_color_tex(const AColor& texture) { return setValue("color_tex", texture); }
	//! (description missing)
	Value get_color_tex() const { return getValue("color_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_color_tex_mult(float val) { return setValue("color_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_color_tex_mult() const { return getFloat("color_tex_mult"); }

	//! (description missing)
	//! [Default value] Color(0, 0, 0)
	bool set_transparency(const Color& color) { return setValue("transparency", color); }
	//! (description missing)
	//! [Default value] Color(0, 0, 0)
	Color get_transparency() const { return getColor("transparency"); }

	//! (description missing)
	bool set_transparency_tex(const Plugin& texture) { return setValue("transparency_tex", texture); }
	//! (description missing)
	bool set_transparency_tex(const AColor& texture) { return setValue("transparency_tex", texture); }
	//! (description missing)
	Value get_transparency_tex() const { return getValue("transparency_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_transparency_tex_mult(float val) { return setValue("transparency_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_transparency_tex_mult() const { return getFloat("transparency_tex_mult"); }

	//! (description missing)
	//! [Default value] 0.01
	bool set_cutoff(float val) { return setValue("cutoff", val); }
	//! (description missing)
	//! [Default value] 0.01
	float get_cutoff() const { return getFloat("cutoff"); }

	//! (description missing)
	//! [Default value] false
	bool set_back_side(bool val) { return setValue("back_side", val); }
	//! (description missing)
	//! [Default value] false
	bool get_back_side() const { return getBool("back_side"); }

	//! (description missing)
	//! [Default value] true
	bool set_trace_reflections(bool val) { return setValue("trace_reflections", val); }
	//! (description missing)
	//! [Default value] true
	bool get_trace_reflections() const { return getBool("trace_reflections"); }

	//! The maximum reflection depth (-1 is controlled by the global options)
 	//! [Default value] -1
	bool set_trace_depth(int val) { return setValue("trace_depth", val); }
	//! The maximum reflection depth (-1 is controlled by the global options)
 	//! [Default value] -1
	int get_trace_depth() const { return getInt("trace_depth"); }

	//! Specifies how render channels are propagated through the BRDF (0 - only the color channel; 1 - color and alpha; 2 - all channels
 	//! [Default value] 0
	bool set_affect_alpha(int val) { return setValue("affect_alpha", val); }
	//! Specifies how render channels are propagated through the BRDF (0 - only the color channel; 1 - color and alpha; 2 - all channels
 	//! [Default value] 0
	int get_affect_alpha() const { return getInt("affect_alpha"); }

	//! The color to use when the maximum depth is reached
 	bool set_reflect_exit_color(const Plugin& texture) { return setValue("reflect_exit_color", texture); }
	//! The color to use when the maximum depth is reached
 	bool set_reflect_exit_color(const AColor& texture) { return setValue("reflect_exit_color", texture); }
	//! The color to use when the maximum depth is reached
 	Value get_reflect_exit_color() const { return getValue("reflect_exit_color"); }

	//! True to enable dim distance
 	//! [Default value] false
	bool set_reflect_dim_distance_on(bool val) { return setValue("reflect_dim_distance_on", val); }
	//! True to enable dim distance
 	//! [Default value] false
	bool get_reflect_dim_distance_on() const { return getBool("reflect_dim_distance_on"); }

	//! How much to dim reflection as length of rays increases
 	//! [UI Guides] quantityType=distance
 	//! [Default value] 1e+018
	bool set_reflect_dim_distance(float val) { return setValue("reflect_dim_distance", val); }
	//! How much to dim reflection as length of rays increases
 	//! [UI Guides] quantityType=distance
 	//! [Default value] 1e+018
	float get_reflect_dim_distance() const { return getFloat("reflect_dim_distance"); }

	//! Fall off for the dim distance
 	//! [Default value] 0
	bool set_reflect_dim_distance_falloff(float val) { return setValue("reflect_dim_distance_falloff", val); }
	//! Fall off for the dim distance
 	//! [Default value] 0
	float get_reflect_dim_distance_falloff() const { return getFloat("reflect_dim_distance_falloff"); }

	//! (description missing)
	//! [Default value] 0.8
	bool set_hilightGlossiness(float val) { return setValue("hilightGlossiness", val); }
	//! (description missing)
	//! [Default value] 0.8
	float get_hilightGlossiness() const { return getFloat("hilightGlossiness"); }

	//! (description missing)
	bool set_hilightGlossiness_tex(const Plugin& texturefloat) { return setValue("hilightGlossiness_tex", texturefloat); }
	//! (description missing)
	bool set_hilightGlossiness_tex(float texturefloat) { return setValue("hilightGlossiness_tex", texturefloat); }
	//! (description missing)
	Value get_hilightGlossiness_tex() const { return getValue("hilightGlossiness_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_hilightGlossiness_tex_mult(float val) { return setValue("hilightGlossiness_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_hilightGlossiness_tex_mult() const { return getFloat("hilightGlossiness_tex_mult"); }

	//! (description missing)
	//! [Default value] 0.8
	bool set_reflectionGlossiness(float val) { return setValue("reflectionGlossiness", val); }
	//! (description missing)
	//! [Default value] 0.8
	float get_reflectionGlossiness() const { return getFloat("reflectionGlossiness"); }

	//! (description missing)
	bool set_reflectionGlossiness_tex(const Plugin& texturefloat) { return setValue("reflectionGlossiness_tex", texturefloat); }
	//! (description missing)
	bool set_reflectionGlossiness_tex(float texturefloat) { return setValue("reflectionGlossiness_tex", texturefloat); }
	//! (description missing)
	Value get_reflectionGlossiness_tex() const { return getValue("reflectionGlossiness_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_reflectionGlossiness_tex_mult(float val) { return setValue("reflectionGlossiness_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_reflectionGlossiness_tex_mult() const { return getFloat("reflectionGlossiness_tex_mult"); }

	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	bool set_subdivs(int val) { return setValue("subdivs", val); }
	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	int get_subdivs() const { return getInt("subdivs"); }

	//! Determines if the glossy rays are treated by V-Ray as GI rays: 0 - never; 1 - only for rays that are already marked as GI rays; 2 - always
 	//! [Default value] 1
	bool set_glossyAsGI(int val) { return setValue("glossyAsGI", val); }
	//! Determines if the glossy rays are treated by V-Ray as GI rays: 0 - never; 1 - only for rays that are already marked as GI rays; 2 - always
 	//! [Default value] 1
	int get_glossyAsGI() const { return getInt("glossyAsGI"); }

	//! Soften edge of the BRDF at light/shadow transition
 	//! [Default value] 0
	bool set_soften_edge(float val) { return setValue("soften_edge", val); }
	//! Soften edge of the BRDF at light/shadow transition
 	//! [Default value] 0
	float get_soften_edge() const { return getFloat("soften_edge"); }

	//! (description missing)
	//! [Default value] 0
	bool set_interpolation_on(int val) { return setValue("interpolation_on", val); }
	//! (description missing)
	//! [Default value] 0
	int get_interpolation_on() const { return getInt("interpolation_on"); }

	//! (description missing)
	//! [Default value] -1
	bool set_imap_min_rate(int val) { return setValue("imap_min_rate", val); }
	//! (description missing)
	//! [Default value] -1
	int get_imap_min_rate() const { return getInt("imap_min_rate"); }

	//! (description missing)
	//! [Default value] 1
	bool set_imap_max_rate(int val) { return setValue("imap_max_rate", val); }
	//! (description missing)
	//! [Default value] 1
	int get_imap_max_rate() const { return getInt("imap_max_rate"); }

	//! (description missing)
	//! [Default value] 0.25
	bool set_imap_color_thresh(float val) { return setValue("imap_color_thresh", val); }
	//! (description missing)
	//! [Default value] 0.25
	float get_imap_color_thresh() const { return getFloat("imap_color_thresh"); }

	//! (description missing)
	//! [Default value] 0.4
	bool set_imap_norm_thresh(float val) { return setValue("imap_norm_thresh", val); }
	//! (description missing)
	//! [Default value] 0.4
	float get_imap_norm_thresh() const { return getFloat("imap_norm_thresh"); }

	//! (description missing)
	//! [Default value] 20
	bool set_imap_samples(int val) { return setValue("imap_samples", val); }
	//! (description missing)
	//! [Default value] 20
	int get_imap_samples() const { return getInt("imap_samples"); }

	//! Reflection anisotropy in the range (-1, 1)
 	bool set_anisotropy(const Plugin& texturefloat) { return setValue("anisotropy", texturefloat); }
	//! Reflection anisotropy in the range (-1, 1)
 	bool set_anisotropy(float texturefloat) { return setValue("anisotropy", texturefloat); }
	//! Reflection anisotropy in the range (-1, 1)
 	Value get_anisotropy() const { return getValue("anisotropy"); }

	//! (description missing)
	bool set_anisotropy_uvwgen(const Plugin& plugin) { return setValue("anisotropy_uvwgen", plugin); }
	//! (description missing)
	Plugin get_anisotropy_uvwgen() const { return getPlugin("anisotropy_uvwgen"); }

	//! Anisotropy rotation in the range [0, 1]
 	bool set_anisotropy_rotation(const Plugin& texturefloat) { return setValue("anisotropy_rotation", texturefloat); }
	//! Anisotropy rotation in the range [0, 1]
 	bool set_anisotropy_rotation(float texturefloat) { return setValue("anisotropy_rotation", texturefloat); }
	//! Anisotropy rotation in the range [0, 1]
 	Value get_anisotropy_rotation() const { return getValue("anisotropy_rotation"); }

	//! true to fix dark edges with glossy reflections; only set this to false for compatibility with older versions
 	//! [Default value] true
	bool set_fix_dark_edges(bool val) { return setValue("fix_dark_edges", val); }
	//! true to fix dark edges with glossy reflections; only set this to false for compatibility with older versions
 	//! [Default value] true
	bool get_fix_dark_edges() const { return getBool("fix_dark_edges"); }
};

class BRDFBump : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "BRDFBump"; }

	//! Base BRDF
 	bool set_base_brdf(const Plugin& plugin) { return setValue("base_brdf", plugin); }
	//! Base BRDF
 	Plugin get_base_brdf() const { return getPlugin("base_brdf"); }

	//! Bump texture
 	bool set_bump_tex_color(const Plugin& texture) { return setValue("bump_tex_color", texture); }
	//! Bump texture
 	bool set_bump_tex_color(const AColor& texture) { return setValue("bump_tex_color", texture); }
	//! Bump texture
 	Value get_bump_tex_color() const { return getValue("bump_tex_color"); }

	//! Bump texture
 	bool set_bump_tex_float(const Plugin& texturefloat) { return setValue("bump_tex_float", texturefloat); }
	//! Bump texture
 	bool set_bump_tex_float(float texturefloat) { return setValue("bump_tex_float", texturefloat); }
	//! Bump texture
 	Value get_bump_tex_float() const { return getValue("bump_tex_float"); }

	//! Bump amount
 	//! [Default value] 1
	bool set_bump_tex_mult(float val) { return setValue("bump_tex_mult", val); }
	//! Bump amount
 	//! [Default value] 1
	float get_bump_tex_mult() const { return getFloat("bump_tex_mult"); }

	//! Bump amount texture
 	bool set_bump_tex_mult_tex(const Plugin& texturefloat) { return setValue("bump_tex_mult_tex", texturefloat); }
	//! Bump amount texture
 	bool set_bump_tex_mult_tex(float texturefloat) { return setValue("bump_tex_mult_tex", texturefloat); }
	//! Bump amount texture
 	Value get_bump_tex_mult_tex() const { return getValue("bump_tex_mult_tex"); }

	//! Bump texture; this is deprecated, use bump_tex_color or bump_tex_float
 	bool set_bump_tex(const Plugin& plugin) { return setValue("bump_tex", plugin); }
	//! Bump texture; this is deprecated, use bump_tex_color or bump_tex_float
 	Plugin get_bump_tex() const { return getPlugin("bump_tex"); }

	//! true to offset the surface shading point, in addition to the normal
 	//! [Default value] false
	bool set_bump_shadows(bool val) { return setValue("bump_shadows", val); }
	//! true to offset the surface shading point, in addition to the normal
 	//! [Default value] false
	bool get_bump_shadows() const { return getBool("bump_shadows"); }

	//! The type of the map (0 - from regular texture output, 1 - normal map in tangent space, 2 - normal map in object space, 3 - normal map in camera space, 4 - normal map in world space, 5 - from texture bump output, 6 - explicit normal)
 	//! [UI Guides] enum=0:Bump Map;1:Normal map in tangent space;2:Normal map in object space;3:Normal map in screen space;4:Normal map in world space;5:From texture bump output;6:Explicit normal
 	//! [Default value] 0
	bool set_map_type(int val) { return setValue("map_type", val); }
	//! The type of the map (0 - from regular texture output, 1 - normal map in tangent space, 2 - normal map in object space, 3 - normal map in camera space, 4 - normal map in world space, 5 - from texture bump output, 6 - explicit normal)
 	//! [UI Guides] enum=0:Bump Map;1:Normal map in tangent space;2:Normal map in object space;3:Normal map in screen space;4:Normal map in world space;5:From texture bump output;6:Explicit normal
 	//! [Default value] 0
	int get_map_type() const { return getInt("map_type"); }

	//! The uvw generator for the normal map texture when map_type is 1.
 	bool set_normal_uvwgen(const Plugin& plugin) { return setValue("normal_uvwgen", plugin); }
	//! The uvw generator for the normal map texture when map_type is 1.
 	Plugin get_normal_uvwgen() const { return getPlugin("normal_uvwgen"); }

	//! When this is true the BRDFBump will try to match the Maya bump/normal mapping
 	//! [Default value] false
	bool set_maya_compatible(bool val) { return setValue("maya_compatible", val); }
	//! When this is true the BRDFBump will try to match the Maya bump/normal mapping
 	//! [Default value] false
	bool get_maya_compatible() const { return getBool("maya_compatible"); }

	//! true to compute bump mapping for shadow rays in case the material is transparent; false to skip the bump map for shadow rays (faster rendering)
 	//! [Default value] true
	bool set_compute_bump_for_shadows(bool val) { return setValue("compute_bump_for_shadows", val); }
	//! true to compute bump mapping for shadow rays in case the material is transparent; false to skip the bump map for shadow rays (faster rendering)
 	//! [Default value] true
	bool get_compute_bump_for_shadows() const { return getBool("compute_bump_for_shadows"); }

	//! Scale for sampling the bitmap when map_type is 0. Normally this is tied to the ray differentials, but can be changed if necessary.
 	//! [Default value] 1
	bool set_bump_delta_scale(float val) { return setValue("bump_delta_scale", val); }
	//! Scale for sampling the bitmap when map_type is 0. Normally this is tied to the ray differentials, but can be changed if necessary.
 	//! [Default value] 1
	float get_bump_delta_scale() const { return getFloat("bump_delta_scale"); }

	//! Multiplier applied to the normal map
 	//! [Default value] 1
	bool set_normal_map_mult(float val) { return setValue("normal_map_mult", val); }
	//! Multiplier applied to the normal map
 	//! [Default value] 1
	float get_normal_map_mult() const { return getFloat("normal_map_mult"); }

	//! Texture for additional bump effect
 	bool set_additional_bump(const Plugin& texture) { return setValue("additional_bump", texture); }
	//! Texture for additional bump effect
 	bool set_additional_bump(const AColor& texture) { return setValue("additional_bump", texture); }
	//! Texture for additional bump effect
 	Value get_additional_bump() const { return getValue("additional_bump"); }

	//! Multiplier applied to the bump map
 	//! [Default value] 1
	bool set_bump_map_mult(float val) { return setValue("bump_map_mult", val); }
	//! Multiplier applied to the bump map
 	//! [Default value] 1
	float get_bump_map_mult() const { return getFloat("bump_map_mult"); }
};

class BRDFCSV : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "BRDFCSV"; }

	//! (description missing)
	//! [Default value] Color(0, 0, 0)
	bool set_transparency(const Color& color) { return setValue("transparency", color); }
	//! (description missing)
	//! [Default value] Color(0, 0, 0)
	Color get_transparency() const { return getColor("transparency"); }

	//! (description missing)
	bool set_transparency_tex(const Plugin& texture) { return setValue("transparency_tex", texture); }
	//! (description missing)
	bool set_transparency_tex(const AColor& texture) { return setValue("transparency_tex", texture); }
	//! (description missing)
	Value get_transparency_tex() const { return getValue("transparency_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_transparency_tex_mult(float val) { return setValue("transparency_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_transparency_tex_mult() const { return getFloat("transparency_tex_mult"); }

	//! (description missing)
	//! [Default value] 0.01
	bool set_cutoff(float val) { return setValue("cutoff", val); }
	//! (description missing)
	//! [Default value] 0.01
	float get_cutoff() const { return getFloat("cutoff"); }

	//! (description missing)
	//! [Default value] false
	bool set_back_side(bool val) { return setValue("back_side", val); }
	//! (description missing)
	//! [Default value] false
	bool get_back_side() const { return getBool("back_side"); }

	//! (description missing)
	//! [Default value] true
	bool set_trace_reflections(bool val) { return setValue("trace_reflections", val); }
	//! (description missing)
	//! [Default value] true
	bool get_trace_reflections() const { return getBool("trace_reflections"); }

	//! The maximum reflection depth (-1 is controlled by the global options)
 	//! [Default value] -1
	bool set_trace_depth(int val) { return setValue("trace_depth", val); }
	//! The maximum reflection depth (-1 is controlled by the global options)
 	//! [Default value] -1
	int get_trace_depth() const { return getInt("trace_depth"); }

	//! Specifies how render channels are propagated through the BRDF (0 - only the color channel; 1 - color and alpha; 2 - all channels
 	//! [Default value] 0
	bool set_affect_alpha(int val) { return setValue("affect_alpha", val); }
	//! Specifies how render channels are propagated through the BRDF (0 - only the color channel; 1 - color and alpha; 2 - all channels
 	//! [Default value] 0
	int get_affect_alpha() const { return getInt("affect_alpha"); }

	//! The color to use when the maximum depth is reached
 	bool set_reflect_exit_color(const Plugin& texture) { return setValue("reflect_exit_color", texture); }
	//! The color to use when the maximum depth is reached
 	bool set_reflect_exit_color(const AColor& texture) { return setValue("reflect_exit_color", texture); }
	//! The color to use when the maximum depth is reached
 	Value get_reflect_exit_color() const { return getValue("reflect_exit_color"); }

	//! How much to dim reflection as length of rays increases
 	//! [Default value] 1e+018
	bool set_reflect_dim_distance(float val) { return setValue("reflect_dim_distance", val); }
	//! How much to dim reflection as length of rays increases
 	//! [Default value] 1e+018
	float get_reflect_dim_distance() const { return getFloat("reflect_dim_distance"); }

	//! True to enable dim distance
 	//! [Default value] false
	bool set_reflect_dim_distance_on(bool val) { return setValue("reflect_dim_distance_on", val); }
	//! True to enable dim distance
 	//! [Default value] false
	bool get_reflect_dim_distance_on() const { return getBool("reflect_dim_distance_on"); }

	//! Fall off for the dim distance
 	//! [Default value] 0
	bool set_reflect_dim_distance_falloff(float val) { return setValue("reflect_dim_distance_falloff", val); }
	//! Fall off for the dim distance
 	//! [Default value] 0
	float get_reflect_dim_distance_falloff() const { return getFloat("reflect_dim_distance_falloff"); }

	//! Determines if the glossy rays are treated by V-Ray as GI rays: 0 - never; 1 - only for rays that are already marked as GI rays; 2 - always
 	//! [Default value] 1
	bool set_glossyAsGI(int val) { return setValue("glossyAsGI", val); }
	//! Determines if the glossy rays are treated by V-Ray as GI rays: 0 - never; 1 - only for rays that are already marked as GI rays; 2 - always
 	//! [Default value] 1
	int get_glossyAsGI() const { return getInt("glossyAsGI"); }

	//! (description missing)
	//! [Default value] 8
	bool set_subdivs(int val) { return setValue("subdivs", val); }
	//! (description missing)
	//! [Default value] 8
	int get_subdivs() const { return getInt("subdivs"); }

	//! [UI Guides] fileAsset=csv
 	bool set_csv_path(const char* str) { return setValue("csv_path", str); }
	//! [UI Guides] fileAsset=csv
 	bool set_csv_path(const std::string& str) { return setValue("csv_path", str); }
	//! [UI Guides] fileAsset=csv
 	std::string get_csv_path() const { return getString("csv_path"); }

	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	bool set_csv_color_filter(const Color& color) { return setValue("csv_color_filter", color); }
	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	Color get_csv_color_filter() const { return getColor("csv_color_filter"); }
};

class BRDFCarPaint : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "BRDFCarPaint"; }

	//! [UI Guides] startTab=V-Ray Car Paint, startRollout=Base layer parameters
 	bool set_base_color(const Plugin& texture) { return setValue("base_color", texture); }
	//! [UI Guides] startTab=V-Ray Car Paint, startRollout=Base layer parameters
 	bool set_base_color(const AColor& texture) { return setValue("base_color", texture); }
	//! [UI Guides] startTab=V-Ray Car Paint, startRollout=Base layer parameters
 	Value get_base_color() const { return getValue("base_color"); }

	//! [UI Guides] minValue=0, maxValue=1
 	bool set_base_reflection(const Plugin& texturefloat) { return setValue("base_reflection", texturefloat); }
	//! [UI Guides] minValue=0, maxValue=1
 	bool set_base_reflection(float texturefloat) { return setValue("base_reflection", texturefloat); }
	//! [UI Guides] minValue=0, maxValue=1
 	Value get_base_reflection() const { return getValue("base_reflection"); }

	//! [UI Guides] minValue=0, maxValue=1
 	bool set_base_glossiness(const Plugin& texturefloat) { return setValue("base_glossiness", texturefloat); }
	//! [UI Guides] minValue=0, maxValue=1
 	bool set_base_glossiness(float texturefloat) { return setValue("base_glossiness", texturefloat); }
	//! [UI Guides] minValue=0, maxValue=1
 	Value get_base_glossiness() const { return getValue("base_glossiness"); }

	//! Toggle reflections for base layer
 	//! [UI Guides] displayName=Base trace reflections
 	//! [Default value] true
	bool set_base_traceReflections(bool val) { return setValue("base_traceReflections", val); }
	//! Toggle reflections for base layer
 	//! [UI Guides] displayName=Base trace reflections
 	//! [Default value] true
	bool get_base_traceReflections() const { return getBool("base_traceReflections"); }

	//! Bump texture for the base layer
 	//! [UI Guides] startRollout=
 	bool set_base_bump_float(const Plugin& texturefloat) { return setValue("base_bump_float", texturefloat); }
	//! Bump texture for the base layer
 	//! [UI Guides] startRollout=
 	bool set_base_bump_float(float texturefloat) { return setValue("base_bump_float", texturefloat); }
	//! Bump texture for the base layer
 	//! [UI Guides] startRollout=
 	Value get_base_bump_float() const { return getValue("base_bump_float"); }

	//! Bump texture for the base layer (color version)
 	bool set_base_bump_color(const Plugin& texture) { return setValue("base_bump_color", texture); }
	//! Bump texture for the base layer (color version)
 	bool set_base_bump_color(const AColor& texture) { return setValue("base_bump_color", texture); }
	//! Bump texture for the base layer (color version)
 	Value get_base_bump_color() const { return getValue("base_bump_color"); }

	//! Bump amount for the base layer
 	bool set_base_bump_amount(const Plugin& texturefloat) { return setValue("base_bump_amount", texturefloat); }
	//! Bump amount for the base layer
 	bool set_base_bump_amount(float texturefloat) { return setValue("base_bump_amount", texturefloat); }
	//! Bump amount for the base layer
 	Value get_base_bump_amount() const { return getValue("base_bump_amount"); }

	//! The type of the map (0 - from regular texture output, 1 - normal map in tangent space, 2 - normal map in object space, 3 - normal map in camera space, 4 - normal map in world space, 5 - from texture bump output, 6 - explicit normal)
 	//! [UI Guides] enum=0:Bump Map;1:Normal map in tangent space;2:Normal map in object space;3:Normal map in screen space;4:Normal map in world space;5:From texture bump output;6:Explicit normal
 	//! [Default value] 0
	bool set_base_bump_type(int val) { return setValue("base_bump_type", val); }
	//! The type of the map (0 - from regular texture output, 1 - normal map in tangent space, 2 - normal map in object space, 3 - normal map in camera space, 4 - normal map in world space, 5 - from texture bump output, 6 - explicit normal)
 	//! [UI Guides] enum=0:Bump Map;1:Normal map in tangent space;2:Normal map in object space;3:Normal map in screen space;4:Normal map in world space;5:From texture bump output;6:Explicit normal
 	//! [Default value] 0
	int get_base_bump_type() const { return getInt("base_bump_type"); }

	//! [UI Guides] startRollout=Flake layer parameters
 	bool set_flake_color(const Plugin& texture) { return setValue("flake_color", texture); }
	//! [UI Guides] startRollout=Flake layer parameters
 	bool set_flake_color(const AColor& texture) { return setValue("flake_color", texture); }
	//! [UI Guides] startRollout=Flake layer parameters
 	Value get_flake_color() const { return getValue("flake_color"); }

	//! [UI Guides] minValue=0, maxValue=1
 	bool set_flake_glossiness(const Plugin& texturefloat) { return setValue("flake_glossiness", texturefloat); }
	//! [UI Guides] minValue=0, maxValue=1
 	bool set_flake_glossiness(float texturefloat) { return setValue("flake_glossiness", texturefloat); }
	//! [UI Guides] minValue=0, maxValue=1
 	Value get_flake_glossiness() const { return getValue("flake_glossiness"); }

	//! [UI Guides] minValue=0, maxValue=1
 	bool set_flake_orientation(const Plugin& texturefloat) { return setValue("flake_orientation", texturefloat); }
	//! [UI Guides] minValue=0, maxValue=1
 	bool set_flake_orientation(float texturefloat) { return setValue("flake_orientation", texturefloat); }
	//! [UI Guides] minValue=0, maxValue=1
 	Value get_flake_orientation() const { return getValue("flake_orientation"); }

	//! [UI Guides] minValue=0, maxValue=20
 	//! [Default value] 0.5
	bool set_flake_density(float val) { return setValue("flake_density", val); }
	//! [UI Guides] minValue=0, maxValue=20
 	//! [Default value] 0.5
	float get_flake_density() const { return getFloat("flake_density"); }

	//! [UI Guides] minValue=0, maxValue=1
 	//! [Default value] 0.01
	bool set_flake_scale(float val) { return setValue("flake_scale", val); }
	//! [UI Guides] minValue=0, maxValue=1
 	//! [Default value] 0.01
	float get_flake_scale() const { return getFloat("flake_scale"); }

	//! [UI Guides] minValue=0
 	//! [Default value] 0.5
	bool set_flake_size(float val) { return setValue("flake_size", val); }
	//! [UI Guides] minValue=0
 	//! [Default value] 0.5
	float get_flake_size() const { return getFloat("flake_size"); }

	//! The size of the internal flakes map
 	//! [UI Guides] minValue=32, maxValue=8192
 	//! [Default value] 1024
	bool set_flake_map_size(int val) { return setValue("flake_map_size", val); }
	//! The size of the internal flakes map
 	//! [UI Guides] minValue=32, maxValue=8192
 	//! [Default value] 1024
	int get_flake_map_size() const { return getInt("flake_map_size"); }

	//! Flake filtering mode (0 - simple; 1 - directional)
 	//! [UI Guides] enum=0:Simple;1:Directional
 	//! [Default value] 1
	bool set_flake_filtering_mode(int val) { return setValue("flake_filtering_mode", val); }
	//! Flake filtering mode (0 - simple; 1 - directional)
 	//! [UI Guides] enum=0:Simple;1:Directional
 	//! [Default value] 1
	int get_flake_filtering_mode() const { return getInt("flake_filtering_mode"); }

	//! The random seed for the flakes
 	//! [UI Guides] minValue=1, maxValue=65536
 	//! [Default value] 1
	bool set_flake_seed(int val) { return setValue("flake_seed", val); }
	//! The random seed for the flakes
 	//! [UI Guides] minValue=1, maxValue=65536
 	//! [Default value] 1
	int get_flake_seed() const { return getInt("flake_seed"); }

	//! (description missing)
	bool set_flake_uvwgen(const Plugin& plugin) { return setValue("flake_uvwgen", plugin); }
	//! (description missing)
	Plugin get_flake_uvwgen() const { return getPlugin("flake_uvwgen"); }

	//! The mapping method for the flakes (0 - explicit mapping channel, 1 - triplanar projection in object space)
 	//! [UI Guides] enum=0:Mapping channel;1:Triplanar
 	//! [Default value] 0
	bool set_mapping_type(int val) { return setValue("mapping_type", val); }
	//! The mapping method for the flakes (0 - explicit mapping channel, 1 - triplanar projection in object space)
 	//! [UI Guides] enum=0:Mapping channel;1:Triplanar
 	//! [Default value] 0
	int get_mapping_type() const { return getInt("mapping_type"); }

	//! The mapping channel when the mapping_type is 0
 	//! [Default value] 0
	bool set_mapping_channel(int val) { return setValue("mapping_channel", val); }
	//! The mapping channel when the mapping_type is 0
 	//! [Default value] 0
	int get_mapping_channel() const { return getInt("mapping_channel"); }

	//! Toggle reflections for flake layer
 	//! [UI Guides] displayName=Flake trace reflections
 	//! [Default value] true
	bool set_flake_traceReflections(bool val) { return setValue("flake_traceReflections", val); }
	//! Toggle reflections for flake layer
 	//! [UI Guides] displayName=Flake trace reflections
 	//! [Default value] true
	bool get_flake_traceReflections() const { return getBool("flake_traceReflections"); }

	//! [UI Guides] startRollout=Coat layer parameters
 	bool set_coat_color(const Plugin& texture) { return setValue("coat_color", texture); }
	//! [UI Guides] startRollout=Coat layer parameters
 	bool set_coat_color(const AColor& texture) { return setValue("coat_color", texture); }
	//! [UI Guides] startRollout=Coat layer parameters
 	Value get_coat_color() const { return getValue("coat_color"); }

	//! [UI Guides] minValue=0, maxValue=1
 	bool set_coat_strength(const Plugin& texturefloat) { return setValue("coat_strength", texturefloat); }
	//! [UI Guides] minValue=0, maxValue=1
 	bool set_coat_strength(float texturefloat) { return setValue("coat_strength", texturefloat); }
	//! [UI Guides] minValue=0, maxValue=1
 	Value get_coat_strength() const { return getValue("coat_strength"); }

	//! The glossiness of the coat layer
 	//! [UI Guides] minValue=0, maxValue=1
 	bool set_coat_glossiness(const Plugin& texturefloat) { return setValue("coat_glossiness", texturefloat); }
	//! The glossiness of the coat layer
 	//! [UI Guides] minValue=0, maxValue=1
 	bool set_coat_glossiness(float texturefloat) { return setValue("coat_glossiness", texturefloat); }
	//! The glossiness of the coat layer
 	//! [UI Guides] minValue=0, maxValue=1
 	Value get_coat_glossiness() const { return getValue("coat_glossiness"); }

	//! Toggle reflections for coat layer
 	//! [UI Guides] displayName=Coat trace reflections
 	//! [Default value] true
	bool set_coat_traceReflections(bool val) { return setValue("coat_traceReflections", val); }
	//! Toggle reflections for coat layer
 	//! [UI Guides] displayName=Coat trace reflections
 	//! [Default value] true
	bool get_coat_traceReflections() const { return getBool("coat_traceReflections"); }

	//! Bump texture for the coat layer
 	//! [UI Guides] startRollout=
 	bool set_coat_bump_float(const Plugin& texturefloat) { return setValue("coat_bump_float", texturefloat); }
	//! Bump texture for the coat layer
 	//! [UI Guides] startRollout=
 	bool set_coat_bump_float(float texturefloat) { return setValue("coat_bump_float", texturefloat); }
	//! Bump texture for the coat layer
 	//! [UI Guides] startRollout=
 	Value get_coat_bump_float() const { return getValue("coat_bump_float"); }

	//! Bump texture for the coat layer (color version)
 	bool set_coat_bump_color(const Plugin& texture) { return setValue("coat_bump_color", texture); }
	//! Bump texture for the coat layer (color version)
 	bool set_coat_bump_color(const AColor& texture) { return setValue("coat_bump_color", texture); }
	//! Bump texture for the coat layer (color version)
 	Value get_coat_bump_color() const { return getValue("coat_bump_color"); }

	//! Bump amount for the coat layer
 	bool set_coat_bump_amount(const Plugin& texturefloat) { return setValue("coat_bump_amount", texturefloat); }
	//! Bump amount for the coat layer
 	bool set_coat_bump_amount(float texturefloat) { return setValue("coat_bump_amount", texturefloat); }
	//! Bump amount for the coat layer
 	Value get_coat_bump_amount() const { return getValue("coat_bump_amount"); }

	//! The type of the map (0 - from regular texture output, 1 - normal map in tangent space, 2 - normal map in object space, 3 - normal map in camera space, 4 - normal map in world space, 5 - from texture bump output, 6 - explicit normal)
 	//! [UI Guides] enum=0:Bump Map;1:Normal map in tangent space;2:Normal map in object space;3:Normal map in screen space;4:Normal map in world space;5:From texture bump output;6:Explicit normal
 	//! [Default value] 0
	bool set_coat_bump_type(int val) { return setValue("coat_bump_type", val); }
	//! The type of the map (0 - from regular texture output, 1 - normal map in tangent space, 2 - normal map in object space, 3 - normal map in camera space, 4 - normal map in world space, 5 - from texture bump output, 6 - explicit normal)
 	//! [UI Guides] enum=0:Bump Map;1:Normal map in tangent space;2:Normal map in object space;3:Normal map in screen space;4:Normal map in world space;5:From texture bump output;6:Explicit normal
 	//! [Default value] 0
	int get_coat_bump_type() const { return getInt("coat_bump_type"); }

	//! [UI Guides] startRollout=Options, displayName=Trace reflections
 	//! [Default value] true
	bool set_traceReflections(bool val) { return setValue("traceReflections", val); }
	//! [UI Guides] startRollout=Options, displayName=Trace reflections
 	//! [Default value] true
	bool get_traceReflections() const { return getBool("traceReflections"); }

	//! The maximum reflection depth (-1 is controlled by the global options)
 	//! [UI Guides] minValue=1, maxValue=1000
 	//! [Default value] -1
	bool set_trace_depth(int val) { return setValue("trace_depth", val); }
	//! The maximum reflection depth (-1 is controlled by the global options)
 	//! [UI Guides] minValue=1, maxValue=1000
 	//! [Default value] -1
	int get_trace_depth() const { return getInt("trace_depth"); }

	//! [UI Guides] displayName=Double sided
 	//! [Default value] true
	bool set_doubleSided(bool val) { return setValue("doubleSided", val); }
	//! [UI Guides] displayName=Double sided
 	//! [Default value] true
	bool get_doubleSided() const { return getBool("doubleSided"); }

	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	bool set_subdivs(int val) { return setValue("subdivs", val); }
	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	int get_subdivs() const { return getInt("subdivs"); }

	//! [UI Guides] minValue=0, maxValue=1
 	//! [Default value] 0.001
	bool set_cutoff_threshold(float val) { return setValue("cutoff_threshold", val); }
	//! [UI Guides] minValue=0, maxValue=1
 	//! [Default value] 0.001
	float get_cutoff_threshold() const { return getFloat("cutoff_threshold"); }

	//! True to use the 'environment override' texture.
 	//! [UI Guides] startRollout=Environment override
 	//! [Default value] false
	bool set_use_environment_override(bool val) { return setValue("use_environment_override", val); }
	//! True to use the 'environment override' texture.
 	//! [UI Guides] startRollout=Environment override
 	//! [Default value] false
	bool get_use_environment_override() const { return getBool("use_environment_override"); }

	//! Environment override texture
 	//! [UI Guides] enableIf: ?use_environment_override=1
 	bool set_environment_override(const Plugin& texture) { return setValue("environment_override", texture); }
	//! Environment override texture
 	//! [UI Guides] enableIf: ?use_environment_override=1
 	bool set_environment_override(const AColor& texture) { return setValue("environment_override", texture); }
	//! Environment override texture
 	//! [UI Guides] enableIf: ?use_environment_override=1
 	Value get_environment_override() const { return getValue("environment_override"); }

	//! Environment override priority (used when several materials override it along a ray path)
 	//! [UI Guides] enableIf: ?use_environment_override=1, minValue=-1000, maxValue=1000
 	//! [Default value] 0
	bool set_environment_priority(int val) { return setValue("environment_priority", val); }
	//! Environment override priority (used when several materials override it along a ray path)
 	//! [UI Guides] enableIf: ?use_environment_override=1, minValue=-1000, maxValue=1000
 	//! [Default value] 0
	int get_environment_priority() const { return getInt("environment_priority"); }
};

class BRDFCookTorrance : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "BRDFCookTorrance"; }

	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	bool set_color(const Color& color) { return setValue("color", color); }
	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	Color get_color() const { return getColor("color"); }

	//! (description missing)
	bool set_color_tex(const Plugin& texture) { return setValue("color_tex", texture); }
	//! (description missing)
	bool set_color_tex(const AColor& texture) { return setValue("color_tex", texture); }
	//! (description missing)
	Value get_color_tex() const { return getValue("color_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_color_tex_mult(float val) { return setValue("color_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_color_tex_mult() const { return getFloat("color_tex_mult"); }

	//! (description missing)
	//! [Default value] Color(0, 0, 0)
	bool set_transparency(const Color& color) { return setValue("transparency", color); }
	//! (description missing)
	//! [Default value] Color(0, 0, 0)
	Color get_transparency() const { return getColor("transparency"); }

	//! (description missing)
	bool set_transparency_tex(const Plugin& texture) { return setValue("transparency_tex", texture); }
	//! (description missing)
	bool set_transparency_tex(const AColor& texture) { return setValue("transparency_tex", texture); }
	//! (description missing)
	Value get_transparency_tex() const { return getValue("transparency_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_transparency_tex_mult(float val) { return setValue("transparency_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_transparency_tex_mult() const { return getFloat("transparency_tex_mult"); }

	//! (description missing)
	//! [Default value] 0.01
	bool set_cutoff(float val) { return setValue("cutoff", val); }
	//! (description missing)
	//! [Default value] 0.01
	float get_cutoff() const { return getFloat("cutoff"); }

	//! (description missing)
	//! [Default value] false
	bool set_back_side(bool val) { return setValue("back_side", val); }
	//! (description missing)
	//! [Default value] false
	bool get_back_side() const { return getBool("back_side"); }

	//! (description missing)
	//! [Default value] true
	bool set_trace_reflections(bool val) { return setValue("trace_reflections", val); }
	//! (description missing)
	//! [Default value] true
	bool get_trace_reflections() const { return getBool("trace_reflections"); }

	//! The maximum reflection depth (-1 is controlled by the global options)
 	//! [Default value] -1
	bool set_trace_depth(int val) { return setValue("trace_depth", val); }
	//! The maximum reflection depth (-1 is controlled by the global options)
 	//! [Default value] -1
	int get_trace_depth() const { return getInt("trace_depth"); }

	//! Specifies how render channels are propagated through the BRDF (0 - only the color channel; 1 - color and alpha; 2 - all channels
 	//! [Default value] 0
	bool set_affect_alpha(int val) { return setValue("affect_alpha", val); }
	//! Specifies how render channels are propagated through the BRDF (0 - only the color channel; 1 - color and alpha; 2 - all channels
 	//! [Default value] 0
	int get_affect_alpha() const { return getInt("affect_alpha"); }

	//! The color to use when the maximum depth is reached
 	bool set_reflect_exit_color(const Plugin& texture) { return setValue("reflect_exit_color", texture); }
	//! The color to use when the maximum depth is reached
 	bool set_reflect_exit_color(const AColor& texture) { return setValue("reflect_exit_color", texture); }
	//! The color to use when the maximum depth is reached
 	Value get_reflect_exit_color() const { return getValue("reflect_exit_color"); }

	//! True to enable dim distance
 	//! [Default value] false
	bool set_reflect_dim_distance_on(bool val) { return setValue("reflect_dim_distance_on", val); }
	//! True to enable dim distance
 	//! [Default value] false
	bool get_reflect_dim_distance_on() const { return getBool("reflect_dim_distance_on"); }

	//! How much to dim reflection as length of rays increases
 	//! [UI Guides] quantityType=distance
 	//! [Default value] 1e+018
	bool set_reflect_dim_distance(float val) { return setValue("reflect_dim_distance", val); }
	//! How much to dim reflection as length of rays increases
 	//! [UI Guides] quantityType=distance
 	//! [Default value] 1e+018
	float get_reflect_dim_distance() const { return getFloat("reflect_dim_distance"); }

	//! Fall off for the dim distance
 	//! [Default value] 0
	bool set_reflect_dim_distance_falloff(float val) { return setValue("reflect_dim_distance_falloff", val); }
	//! Fall off for the dim distance
 	//! [Default value] 0
	float get_reflect_dim_distance_falloff() const { return getFloat("reflect_dim_distance_falloff"); }

	//! (description missing)
	//! [Default value] 0.8
	bool set_hilightGlossiness(float val) { return setValue("hilightGlossiness", val); }
	//! (description missing)
	//! [Default value] 0.8
	float get_hilightGlossiness() const { return getFloat("hilightGlossiness"); }

	//! (description missing)
	bool set_hilightGlossiness_tex(const Plugin& texturefloat) { return setValue("hilightGlossiness_tex", texturefloat); }
	//! (description missing)
	bool set_hilightGlossiness_tex(float texturefloat) { return setValue("hilightGlossiness_tex", texturefloat); }
	//! (description missing)
	Value get_hilightGlossiness_tex() const { return getValue("hilightGlossiness_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_hilightGlossiness_tex_mult(float val) { return setValue("hilightGlossiness_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_hilightGlossiness_tex_mult() const { return getFloat("hilightGlossiness_tex_mult"); }

	//! (description missing)
	//! [Default value] 0.8
	bool set_reflectionGlossiness(float val) { return setValue("reflectionGlossiness", val); }
	//! (description missing)
	//! [Default value] 0.8
	float get_reflectionGlossiness() const { return getFloat("reflectionGlossiness"); }

	//! (description missing)
	bool set_reflectionGlossiness_tex(const Plugin& texturefloat) { return setValue("reflectionGlossiness_tex", texturefloat); }
	//! (description missing)
	bool set_reflectionGlossiness_tex(float texturefloat) { return setValue("reflectionGlossiness_tex", texturefloat); }
	//! (description missing)
	Value get_reflectionGlossiness_tex() const { return getValue("reflectionGlossiness_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_reflectionGlossiness_tex_mult(float val) { return setValue("reflectionGlossiness_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_reflectionGlossiness_tex_mult() const { return getFloat("reflectionGlossiness_tex_mult"); }

	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	bool set_subdivs(int val) { return setValue("subdivs", val); }
	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	int get_subdivs() const { return getInt("subdivs"); }

	//! Determines if the glossy rays are treated by V-Ray as GI rays: 0 - never; 1 - only for rays that are already marked as GI rays; 2 - always
 	//! [Default value] 1
	bool set_glossyAsGI(int val) { return setValue("glossyAsGI", val); }
	//! Determines if the glossy rays are treated by V-Ray as GI rays: 0 - never; 1 - only for rays that are already marked as GI rays; 2 - always
 	//! [Default value] 1
	int get_glossyAsGI() const { return getInt("glossyAsGI"); }

	//! Soften edge of the BRDF at light/shadow transition
 	//! [Default value] 0
	bool set_soften_edge(float val) { return setValue("soften_edge", val); }
	//! Soften edge of the BRDF at light/shadow transition
 	//! [Default value] 0
	float get_soften_edge() const { return getFloat("soften_edge"); }

	//! (description missing)
	//! [Default value] 0
	bool set_interpolation_on(int val) { return setValue("interpolation_on", val); }
	//! (description missing)
	//! [Default value] 0
	int get_interpolation_on() const { return getInt("interpolation_on"); }

	//! (description missing)
	//! [Default value] -1
	bool set_imap_min_rate(int val) { return setValue("imap_min_rate", val); }
	//! (description missing)
	//! [Default value] -1
	int get_imap_min_rate() const { return getInt("imap_min_rate"); }

	//! (description missing)
	//! [Default value] 1
	bool set_imap_max_rate(int val) { return setValue("imap_max_rate", val); }
	//! (description missing)
	//! [Default value] 1
	int get_imap_max_rate() const { return getInt("imap_max_rate"); }

	//! (description missing)
	//! [Default value] 0.25
	bool set_imap_color_thresh(float val) { return setValue("imap_color_thresh", val); }
	//! (description missing)
	//! [Default value] 0.25
	float get_imap_color_thresh() const { return getFloat("imap_color_thresh"); }

	//! (description missing)
	//! [Default value] 0.4
	bool set_imap_norm_thresh(float val) { return setValue("imap_norm_thresh", val); }
	//! (description missing)
	//! [Default value] 0.4
	float get_imap_norm_thresh() const { return getFloat("imap_norm_thresh"); }

	//! (description missing)
	//! [Default value] 20
	bool set_imap_samples(int val) { return setValue("imap_samples", val); }
	//! (description missing)
	//! [Default value] 20
	int get_imap_samples() const { return getInt("imap_samples"); }

	//! Reflection anisotropy in the range (-1, 1)
 	bool set_anisotropy(const Plugin& texturefloat) { return setValue("anisotropy", texturefloat); }
	//! Reflection anisotropy in the range (-1, 1)
 	bool set_anisotropy(float texturefloat) { return setValue("anisotropy", texturefloat); }
	//! Reflection anisotropy in the range (-1, 1)
 	Value get_anisotropy() const { return getValue("anisotropy"); }

	//! (description missing)
	bool set_anisotropy_uvwgen(const Plugin& plugin) { return setValue("anisotropy_uvwgen", plugin); }
	//! (description missing)
	Plugin get_anisotropy_uvwgen() const { return getPlugin("anisotropy_uvwgen"); }

	//! Anisotropy rotation in the range [0, 1]
 	bool set_anisotropy_rotation(const Plugin& texturefloat) { return setValue("anisotropy_rotation", texturefloat); }
	//! Anisotropy rotation in the range [0, 1]
 	bool set_anisotropy_rotation(float texturefloat) { return setValue("anisotropy_rotation", texturefloat); }
	//! Anisotropy rotation in the range [0, 1]
 	Value get_anisotropy_rotation() const { return getValue("anisotropy_rotation"); }

	//! true to fix dark edges with glossy reflections; only set this to false for compatibility with older versions
 	//! [Default value] true
	bool set_fix_dark_edges(bool val) { return setValue("fix_dark_edges", val); }
	//! true to fix dark edges with glossy reflections; only set this to false for compatibility with older versions
 	//! [Default value] true
	bool get_fix_dark_edges() const { return getBool("fix_dark_edges"); }
};

class BRDFDiffuse : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "BRDFDiffuse"; }

	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	bool set_color(const Color& color) { return setValue("color", color); }
	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	Color get_color() const { return getColor("color"); }

	//! (description missing)
	bool set_color_tex(const Plugin& texture) { return setValue("color_tex", texture); }
	//! (description missing)
	bool set_color_tex(const AColor& texture) { return setValue("color_tex", texture); }
	//! (description missing)
	Value get_color_tex() const { return getValue("color_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_color_tex_mult(float val) { return setValue("color_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_color_tex_mult() const { return getFloat("color_tex_mult"); }

	//! (description missing)
	//! [Default value] Color(0, 0, 0)
	bool set_transparency(const Color& color) { return setValue("transparency", color); }
	//! (description missing)
	//! [Default value] Color(0, 0, 0)
	Color get_transparency() const { return getColor("transparency"); }

	//! (description missing)
	bool set_transparency_tex(const Plugin& texture) { return setValue("transparency_tex", texture); }
	//! (description missing)
	bool set_transparency_tex(const AColor& texture) { return setValue("transparency_tex", texture); }
	//! (description missing)
	Value get_transparency_tex() const { return getValue("transparency_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_transparency_tex_mult(float val) { return setValue("transparency_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_transparency_tex_mult() const { return getFloat("transparency_tex_mult"); }

	//! (description missing)
	bool set_roughness(const Plugin& texturefloat) { return setValue("roughness", texturefloat); }
	//! (description missing)
	bool set_roughness(float texturefloat) { return setValue("roughness", texturefloat); }
	//! (description missing)
	Value get_roughness() const { return getValue("roughness"); }

	//! (description missing)
	//! [Default value] true
	bool set_use_irradiance_map(bool val) { return setValue("use_irradiance_map", val); }
	//! (description missing)
	//! [Default value] true
	bool get_use_irradiance_map() const { return getBool("use_irradiance_map"); }

	//! (description missing)
	//! [Default value] false
	bool set_color_tex_alpha_as_transparency(bool val) { return setValue("color_tex_alpha_as_transparency", val); }
	//! (description missing)
	//! [Default value] false
	bool get_color_tex_alpha_as_transparency() const { return getBool("color_tex_alpha_as_transparency"); }
};

class BRDFDiffuseASGVIS : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "BRDFDiffuseASGVIS"; }

	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	bool set_color(const Color& color) { return setValue("color", color); }
	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	Color get_color() const { return getColor("color"); }

	//! (description missing)
	bool set_color_tex(const Plugin& texture) { return setValue("color_tex", texture); }
	//! (description missing)
	bool set_color_tex(const AColor& texture) { return setValue("color_tex", texture); }
	//! (description missing)
	Value get_color_tex() const { return getValue("color_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_color_tex_mult(float val) { return setValue("color_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_color_tex_mult() const { return getFloat("color_tex_mult"); }

	//! (description missing)
	//! [Default value] Color(0, 0, 0)
	bool set_transparency(const Color& color) { return setValue("transparency", color); }
	//! (description missing)
	//! [Default value] Color(0, 0, 0)
	Color get_transparency() const { return getColor("transparency"); }

	//! (description missing)
	bool set_transparency_tex(const Plugin& texture) { return setValue("transparency_tex", texture); }
	//! (description missing)
	bool set_transparency_tex(const AColor& texture) { return setValue("transparency_tex", texture); }
	//! (description missing)
	Value get_transparency_tex() const { return getValue("transparency_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_transparency_tex_mult(float val) { return setValue("transparency_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_transparency_tex_mult() const { return getFloat("transparency_tex_mult"); }

	//! (description missing)
	bool set_roughness(const Plugin& texturefloat) { return setValue("roughness", texturefloat); }
	//! (description missing)
	bool set_roughness(float texturefloat) { return setValue("roughness", texturefloat); }
	//! (description missing)
	Value get_roughness() const { return getValue("roughness"); }

	//! (description missing)
	//! [Default value] true
	bool set_use_irradiance_map(bool val) { return setValue("use_irradiance_map", val); }
	//! (description missing)
	//! [Default value] true
	bool get_use_irradiance_map() const { return getBool("use_irradiance_map"); }

	//! (description missing)
	//! [Default value] false
	bool set_use_color_tex_alpha_as_transparency(bool val) { return setValue("use_color_tex_alpha_as_transparency", val); }
	//! (description missing)
	//! [Default value] false
	bool get_use_color_tex_alpha_as_transparency() const { return getBool("use_color_tex_alpha_as_transparency"); }
};

class BRDFDiffuse_forSSS : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "BRDFDiffuse_forSSS"; }

	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	bool set_color(const Color& color) { return setValue("color", color); }
	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	Color get_color() const { return getColor("color"); }

	//! (description missing)
	bool set_color_tex(const Plugin& texture) { return setValue("color_tex", texture); }
	//! (description missing)
	bool set_color_tex(const AColor& texture) { return setValue("color_tex", texture); }
	//! (description missing)
	Value get_color_tex() const { return getValue("color_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_color_tex_mult(float val) { return setValue("color_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_color_tex_mult() const { return getFloat("color_tex_mult"); }

	//! (description missing)
	//! [Default value] Color(0, 0, 0)
	bool set_transparency(const Color& color) { return setValue("transparency", color); }
	//! (description missing)
	//! [Default value] Color(0, 0, 0)
	Color get_transparency() const { return getColor("transparency"); }

	//! (description missing)
	bool set_transparency_tex(const Plugin& texture) { return setValue("transparency_tex", texture); }
	//! (description missing)
	bool set_transparency_tex(const AColor& texture) { return setValue("transparency_tex", texture); }
	//! (description missing)
	Value get_transparency_tex() const { return getValue("transparency_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_transparency_tex_mult(float val) { return setValue("transparency_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_transparency_tex_mult() const { return getFloat("transparency_tex_mult"); }

	//! Color on the back sides of the material
 	bool set_back_color(const Plugin& texture) { return setValue("back_color", texture); }
	//! Color on the back sides of the material
 	bool set_back_color(const AColor& texture) { return setValue("back_color", texture); }
	//! Color on the back sides of the material
 	Value get_back_color() const { return getValue("back_color"); }

	//! (description missing)
	bool set_roughness(const Plugin& texturefloat) { return setValue("roughness", texturefloat); }
	//! (description missing)
	bool set_roughness(float texturefloat) { return setValue("roughness", texturefloat); }
	//! (description missing)
	Value get_roughness() const { return getValue("roughness"); }

	//! (description missing)
	//! [Default value] true
	bool set_use_irradiance_map(bool val) { return setValue("use_irradiance_map", val); }
	//! (description missing)
	//! [Default value] true
	bool get_use_irradiance_map() const { return getBool("use_irradiance_map"); }
};

class BRDFDiffuse_forSSSASGVIS : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "BRDFDiffuse_forSSSASGVIS"; }

	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	bool set_color(const Color& color) { return setValue("color", color); }
	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	Color get_color() const { return getColor("color"); }

	//! (description missing)
	bool set_color_tex(const Plugin& texture) { return setValue("color_tex", texture); }
	//! (description missing)
	bool set_color_tex(const AColor& texture) { return setValue("color_tex", texture); }
	//! (description missing)
	Value get_color_tex() const { return getValue("color_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_color_tex_mult(float val) { return setValue("color_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_color_tex_mult() const { return getFloat("color_tex_mult"); }

	//! (description missing)
	//! [Default value] Color(0, 0, 0)
	bool set_transparency(const Color& color) { return setValue("transparency", color); }
	//! (description missing)
	//! [Default value] Color(0, 0, 0)
	Color get_transparency() const { return getColor("transparency"); }

	//! (description missing)
	bool set_transparency_tex(const Plugin& texture) { return setValue("transparency_tex", texture); }
	//! (description missing)
	bool set_transparency_tex(const AColor& texture) { return setValue("transparency_tex", texture); }
	//! (description missing)
	Value get_transparency_tex() const { return getValue("transparency_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_transparency_tex_mult(float val) { return setValue("transparency_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_transparency_tex_mult() const { return getFloat("transparency_tex_mult"); }

	//! Color on the back sides of the material
 	bool set_back_color(const Plugin& texture) { return setValue("back_color", texture); }
	//! Color on the back sides of the material
 	bool set_back_color(const AColor& texture) { return setValue("back_color", texture); }
	//! Color on the back sides of the material
 	Value get_back_color() const { return getValue("back_color"); }

	//! (description missing)
	bool set_roughness(const Plugin& texturefloat) { return setValue("roughness", texturefloat); }
	//! (description missing)
	bool set_roughness(float texturefloat) { return setValue("roughness", texturefloat); }
	//! (description missing)
	Value get_roughness() const { return getValue("roughness"); }

	//! (description missing)
	//! [Default value] true
	bool set_use_irradiance_map(bool val) { return setValue("use_irradiance_map", val); }
	//! (description missing)
	//! [Default value] true
	bool get_use_irradiance_map() const { return getBool("use_irradiance_map"); }
};

class BRDFFlakes : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "BRDFFlakes"; }

	//! [UI Guides] startTab=V-Ray Flakes, startRollout=Flakes parameters
 	bool set_flake_color(const Plugin& texture) { return setValue("flake_color", texture); }
	//! [UI Guides] startTab=V-Ray Flakes, startRollout=Flakes parameters
 	bool set_flake_color(const AColor& texture) { return setValue("flake_color", texture); }
	//! [UI Guides] startTab=V-Ray Flakes, startRollout=Flakes parameters
 	Value get_flake_color() const { return getValue("flake_color"); }

	//! [UI Guides] minValue=0, maxValue=1
 	bool set_flake_glossiness(const Plugin& texturefloat) { return setValue("flake_glossiness", texturefloat); }
	//! [UI Guides] minValue=0, maxValue=1
 	bool set_flake_glossiness(float texturefloat) { return setValue("flake_glossiness", texturefloat); }
	//! [UI Guides] minValue=0, maxValue=1
 	Value get_flake_glossiness() const { return getValue("flake_glossiness"); }

	//! [UI Guides] minValue=0, maxValue=1
 	bool set_flake_orientation(const Plugin& texturefloat) { return setValue("flake_orientation", texturefloat); }
	//! [UI Guides] minValue=0, maxValue=1
 	bool set_flake_orientation(float texturefloat) { return setValue("flake_orientation", texturefloat); }
	//! [UI Guides] minValue=0, maxValue=1
 	Value get_flake_orientation() const { return getValue("flake_orientation"); }

	//! [UI Guides] minValue=0, maxValue=20
 	//! [Default value] 0.5
	bool set_flake_density(float val) { return setValue("flake_density", val); }
	//! [UI Guides] minValue=0, maxValue=20
 	//! [Default value] 0.5
	float get_flake_density() const { return getFloat("flake_density"); }

	//! [UI Guides] minValue=0, maxValue=1
 	//! [Default value] 0.01
	bool set_flake_scale(float val) { return setValue("flake_scale", val); }
	//! [UI Guides] minValue=0, maxValue=1
 	//! [Default value] 0.01
	float get_flake_scale() const { return getFloat("flake_scale"); }

	//! [UI Guides] minValue=0
 	//! [Default value] 0.5
	bool set_flake_size(float val) { return setValue("flake_size", val); }
	//! [UI Guides] minValue=0
 	//! [Default value] 0.5
	float get_flake_size() const { return getFloat("flake_size"); }

	//! The size of the internal flakes map
 	//! [UI Guides] minValue=32, maxValue=8192
 	//! [Default value] 1024
	bool set_flake_map_size(int val) { return setValue("flake_map_size", val); }
	//! The size of the internal flakes map
 	//! [UI Guides] minValue=32, maxValue=8192
 	//! [Default value] 1024
	int get_flake_map_size() const { return getInt("flake_map_size"); }

	//! Flake filtering mode (0 - simple; 1 - directional)
 	//! [UI Guides] enum=0:Simple;1:Directional
 	//! [Default value] 1
	bool set_flake_filtering_mode(int val) { return setValue("flake_filtering_mode", val); }
	//! Flake filtering mode (0 - simple; 1 - directional)
 	//! [UI Guides] enum=0:Simple;1:Directional
 	//! [Default value] 1
	int get_flake_filtering_mode() const { return getInt("flake_filtering_mode"); }

	//! The random seed for the flakes
 	//! [UI Guides] minValue=1, maxValue=65536
 	//! [Default value] 1
	bool set_flake_seed(int val) { return setValue("flake_seed", val); }
	//! The random seed for the flakes
 	//! [UI Guides] minValue=1, maxValue=65536
 	//! [Default value] 1
	int get_flake_seed() const { return getInt("flake_seed"); }

	//! (description missing)
	bool set_flake_uvwgen(const Plugin& plugin) { return setValue("flake_uvwgen", plugin); }
	//! (description missing)
	Plugin get_flake_uvwgen() const { return getPlugin("flake_uvwgen"); }

	//! The mapping method for the flakes (0 - explicit mapping channel, 1 - triplanar projection in object space)
 	//! [UI Guides] enum=0:Mapping channel;1:Triplanar
 	//! [Default value] 0
	bool set_mapping_type(int val) { return setValue("mapping_type", val); }
	//! The mapping method for the flakes (0 - explicit mapping channel, 1 - triplanar projection in object space)
 	//! [UI Guides] enum=0:Mapping channel;1:Triplanar
 	//! [Default value] 0
	int get_mapping_type() const { return getInt("mapping_type"); }

	//! The mapping channel when the mapping_type is 0
 	//! [Default value] 0
	bool set_mapping_channel(int val) { return setValue("mapping_channel", val); }
	//! The mapping channel when the mapping_type is 0
 	//! [Default value] 0
	int get_mapping_channel() const { return getInt("mapping_channel"); }

	//! [UI Guides] startRollout=Options, displayName=Trace reflections
 	//! [Default value] true
	bool set_traceReflections(bool val) { return setValue("traceReflections", val); }
	//! [UI Guides] startRollout=Options, displayName=Trace reflections
 	//! [Default value] true
	bool get_traceReflections() const { return getBool("traceReflections"); }

	//! The maximum reflection depth (-1 is controlled by the global options)
 	//! [UI Guides] minValue=1, maxValue=1000
 	//! [Default value] -1
	bool set_trace_depth(int val) { return setValue("trace_depth", val); }
	//! The maximum reflection depth (-1 is controlled by the global options)
 	//! [UI Guides] minValue=1, maxValue=1000
 	//! [Default value] -1
	int get_trace_depth() const { return getInt("trace_depth"); }

	//! [UI Guides] displayName=Double sided
 	//! [Default value] 1
	bool set_doubleSided(int val) { return setValue("doubleSided", val); }
	//! [UI Guides] displayName=Double sided
 	//! [Default value] 1
	int get_doubleSided() const { return getInt("doubleSided"); }

	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	bool set_subdivs(int val) { return setValue("subdivs", val); }
	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	int get_subdivs() const { return getInt("subdivs"); }

	//! [UI Guides] minValue=0, maxValue=1
 	//! [Default value] 0.001
	bool set_cutoff_threshold(float val) { return setValue("cutoff_threshold", val); }
	//! [UI Guides] minValue=0, maxValue=1
 	//! [Default value] 0.001
	float get_cutoff_threshold() const { return getFloat("cutoff_threshold"); }

	//! True to use the 'environment override' texture.
 	//! [UI Guides] startRollout=Environment override
 	//! [Default value] false
	bool set_use_environment_override(bool val) { return setValue("use_environment_override", val); }
	//! True to use the 'environment override' texture.
 	//! [UI Guides] startRollout=Environment override
 	//! [Default value] false
	bool get_use_environment_override() const { return getBool("use_environment_override"); }

	//! Environment override texture
 	//! [UI Guides] enableIf: ?use_environment_override=1
 	bool set_environment_override(const Plugin& texture) { return setValue("environment_override", texture); }
	//! Environment override texture
 	//! [UI Guides] enableIf: ?use_environment_override=1
 	bool set_environment_override(const AColor& texture) { return setValue("environment_override", texture); }
	//! Environment override texture
 	//! [UI Guides] enableIf: ?use_environment_override=1
 	Value get_environment_override() const { return getValue("environment_override"); }

	//! Environment override priority (used when several materials override it along a ray path)
 	//! [UI Guides] enableIf: ?use_environment_override=1, minValue=-1000, maxValue=1000
 	//! [Default value] 0
	bool set_environment_priority(int val) { return setValue("environment_priority", val); }
	//! Environment override priority (used when several materials override it along a ray path)
 	//! [UI Guides] enableIf: ?use_environment_override=1, minValue=-1000, maxValue=1000
 	//! [Default value] 0
	int get_environment_priority() const { return getInt("environment_priority"); }
};

class BRDFGGX : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "BRDFGGX"; }

	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	bool set_color(const Color& color) { return setValue("color", color); }
	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	Color get_color() const { return getColor("color"); }

	//! (description missing)
	bool set_color_tex(const Plugin& texture) { return setValue("color_tex", texture); }
	//! (description missing)
	bool set_color_tex(const AColor& texture) { return setValue("color_tex", texture); }
	//! (description missing)
	Value get_color_tex() const { return getValue("color_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_color_tex_mult(float val) { return setValue("color_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_color_tex_mult() const { return getFloat("color_tex_mult"); }

	//! (description missing)
	//! [Default value] Color(0, 0, 0)
	bool set_transparency(const Color& color) { return setValue("transparency", color); }
	//! (description missing)
	//! [Default value] Color(0, 0, 0)
	Color get_transparency() const { return getColor("transparency"); }

	//! (description missing)
	bool set_transparency_tex(const Plugin& texture) { return setValue("transparency_tex", texture); }
	//! (description missing)
	bool set_transparency_tex(const AColor& texture) { return setValue("transparency_tex", texture); }
	//! (description missing)
	Value get_transparency_tex() const { return getValue("transparency_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_transparency_tex_mult(float val) { return setValue("transparency_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_transparency_tex_mult() const { return getFloat("transparency_tex_mult"); }

	//! (description missing)
	//! [Default value] 0.01
	bool set_cutoff(float val) { return setValue("cutoff", val); }
	//! (description missing)
	//! [Default value] 0.01
	float get_cutoff() const { return getFloat("cutoff"); }

	//! (description missing)
	//! [Default value] false
	bool set_back_side(bool val) { return setValue("back_side", val); }
	//! (description missing)
	//! [Default value] false
	bool get_back_side() const { return getBool("back_side"); }

	//! (description missing)
	//! [Default value] true
	bool set_trace_reflections(bool val) { return setValue("trace_reflections", val); }
	//! (description missing)
	//! [Default value] true
	bool get_trace_reflections() const { return getBool("trace_reflections"); }

	//! The maximum reflection depth (-1 is controlled by the global options)
 	//! [Default value] -1
	bool set_trace_depth(int val) { return setValue("trace_depth", val); }
	//! The maximum reflection depth (-1 is controlled by the global options)
 	//! [Default value] -1
	int get_trace_depth() const { return getInt("trace_depth"); }

	//! Specifies how render channels are propagated through the BRDF (0 - only the color channel; 1 - color and alpha; 2 - all channels
 	//! [Default value] 0
	bool set_affect_alpha(int val) { return setValue("affect_alpha", val); }
	//! Specifies how render channels are propagated through the BRDF (0 - only the color channel; 1 - color and alpha; 2 - all channels
 	//! [Default value] 0
	int get_affect_alpha() const { return getInt("affect_alpha"); }

	//! The color to use when the maximum depth is reached
 	bool set_reflect_exit_color(const Plugin& texture) { return setValue("reflect_exit_color", texture); }
	//! The color to use when the maximum depth is reached
 	bool set_reflect_exit_color(const AColor& texture) { return setValue("reflect_exit_color", texture); }
	//! The color to use when the maximum depth is reached
 	Value get_reflect_exit_color() const { return getValue("reflect_exit_color"); }

	//! True to enable dim distance
 	//! [Default value] false
	bool set_reflect_dim_distance_on(bool val) { return setValue("reflect_dim_distance_on", val); }
	//! True to enable dim distance
 	//! [Default value] false
	bool get_reflect_dim_distance_on() const { return getBool("reflect_dim_distance_on"); }

	//! How much to dim reflection as length of rays increases
 	//! [UI Guides] quantityType=distance
 	//! [Default value] 1e+018
	bool set_reflect_dim_distance(float val) { return setValue("reflect_dim_distance", val); }
	//! How much to dim reflection as length of rays increases
 	//! [UI Guides] quantityType=distance
 	//! [Default value] 1e+018
	float get_reflect_dim_distance() const { return getFloat("reflect_dim_distance"); }

	//! Fall off for the dim distance
 	//! [Default value] 0
	bool set_reflect_dim_distance_falloff(float val) { return setValue("reflect_dim_distance_falloff", val); }
	//! Fall off for the dim distance
 	//! [Default value] 0
	float get_reflect_dim_distance_falloff() const { return getFloat("reflect_dim_distance_falloff"); }

	//! (description missing)
	//! [Default value] 0.8
	bool set_hilightGlossiness(float val) { return setValue("hilightGlossiness", val); }
	//! (description missing)
	//! [Default value] 0.8
	float get_hilightGlossiness() const { return getFloat("hilightGlossiness"); }

	//! (description missing)
	bool set_hilightGlossiness_tex(const Plugin& texturefloat) { return setValue("hilightGlossiness_tex", texturefloat); }
	//! (description missing)
	bool set_hilightGlossiness_tex(float texturefloat) { return setValue("hilightGlossiness_tex", texturefloat); }
	//! (description missing)
	Value get_hilightGlossiness_tex() const { return getValue("hilightGlossiness_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_hilightGlossiness_tex_mult(float val) { return setValue("hilightGlossiness_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_hilightGlossiness_tex_mult() const { return getFloat("hilightGlossiness_tex_mult"); }

	//! (description missing)
	//! [Default value] 0.8
	bool set_reflectionGlossiness(float val) { return setValue("reflectionGlossiness", val); }
	//! (description missing)
	//! [Default value] 0.8
	float get_reflectionGlossiness() const { return getFloat("reflectionGlossiness"); }

	//! (description missing)
	bool set_reflectionGlossiness_tex(const Plugin& texturefloat) { return setValue("reflectionGlossiness_tex", texturefloat); }
	//! (description missing)
	bool set_reflectionGlossiness_tex(float texturefloat) { return setValue("reflectionGlossiness_tex", texturefloat); }
	//! (description missing)
	Value get_reflectionGlossiness_tex() const { return getValue("reflectionGlossiness_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_reflectionGlossiness_tex_mult(float val) { return setValue("reflectionGlossiness_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_reflectionGlossiness_tex_mult() const { return getFloat("reflectionGlossiness_tex_mult"); }

	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	bool set_subdivs(int val) { return setValue("subdivs", val); }
	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	int get_subdivs() const { return getInt("subdivs"); }

	//! Determines if the glossy rays are treated by V-Ray as GI rays: 0 - never; 1 - only for rays that are already marked as GI rays; 2 - always
 	//! [Default value] 1
	bool set_glossyAsGI(int val) { return setValue("glossyAsGI", val); }
	//! Determines if the glossy rays are treated by V-Ray as GI rays: 0 - never; 1 - only for rays that are already marked as GI rays; 2 - always
 	//! [Default value] 1
	int get_glossyAsGI() const { return getInt("glossyAsGI"); }

	//! Soften edge of the BRDF at light/shadow transition
 	//! [Default value] 0
	bool set_soften_edge(float val) { return setValue("soften_edge", val); }
	//! Soften edge of the BRDF at light/shadow transition
 	//! [Default value] 0
	float get_soften_edge() const { return getFloat("soften_edge"); }

	//! (description missing)
	//! [Default value] 0
	bool set_interpolation_on(int val) { return setValue("interpolation_on", val); }
	//! (description missing)
	//! [Default value] 0
	int get_interpolation_on() const { return getInt("interpolation_on"); }

	//! (description missing)
	//! [Default value] -1
	bool set_imap_min_rate(int val) { return setValue("imap_min_rate", val); }
	//! (description missing)
	//! [Default value] -1
	int get_imap_min_rate() const { return getInt("imap_min_rate"); }

	//! (description missing)
	//! [Default value] 1
	bool set_imap_max_rate(int val) { return setValue("imap_max_rate", val); }
	//! (description missing)
	//! [Default value] 1
	int get_imap_max_rate() const { return getInt("imap_max_rate"); }

	//! (description missing)
	//! [Default value] 0.25
	bool set_imap_color_thresh(float val) { return setValue("imap_color_thresh", val); }
	//! (description missing)
	//! [Default value] 0.25
	float get_imap_color_thresh() const { return getFloat("imap_color_thresh"); }

	//! (description missing)
	//! [Default value] 0.4
	bool set_imap_norm_thresh(float val) { return setValue("imap_norm_thresh", val); }
	//! (description missing)
	//! [Default value] 0.4
	float get_imap_norm_thresh() const { return getFloat("imap_norm_thresh"); }

	//! (description missing)
	//! [Default value] 20
	bool set_imap_samples(int val) { return setValue("imap_samples", val); }
	//! (description missing)
	//! [Default value] 20
	int get_imap_samples() const { return getInt("imap_samples"); }

	//! Reflection anisotropy in the range (-1, 1)
 	bool set_anisotropy(const Plugin& texturefloat) { return setValue("anisotropy", texturefloat); }
	//! Reflection anisotropy in the range (-1, 1)
 	bool set_anisotropy(float texturefloat) { return setValue("anisotropy", texturefloat); }
	//! Reflection anisotropy in the range (-1, 1)
 	Value get_anisotropy() const { return getValue("anisotropy"); }

	//! (description missing)
	bool set_anisotropy_uvwgen(const Plugin& plugin) { return setValue("anisotropy_uvwgen", plugin); }
	//! (description missing)
	Plugin get_anisotropy_uvwgen() const { return getPlugin("anisotropy_uvwgen"); }

	//! Anisotropy rotation in the range [0, 1]
 	bool set_anisotropy_rotation(const Plugin& texturefloat) { return setValue("anisotropy_rotation", texturefloat); }
	//! Anisotropy rotation in the range [0, 1]
 	bool set_anisotropy_rotation(float texturefloat) { return setValue("anisotropy_rotation", texturefloat); }
	//! Anisotropy rotation in the range [0, 1]
 	Value get_anisotropy_rotation() const { return getValue("anisotropy_rotation"); }

	//! true to fix dark edges with glossy reflections; only set this to false for compatibility with older versions
 	//! [Default value] true
	bool set_fix_dark_edges(bool val) { return setValue("fix_dark_edges", val); }
	//! true to fix dark edges with glossy reflections; only set this to false for compatibility with older versions
 	//! [Default value] true
	bool get_fix_dark_edges() const { return getBool("fix_dark_edges"); }

	//! How much to increase/decrease the tail of the glossy highlight when using GGX reflection model
 	//! [UI Guides] displayName=GTR gamma, minValue=0.001, maxValue=1000.0
 	bool set_gtr_gamma(const Plugin& texturefloat) { return setValue("gtr_gamma", texturefloat); }
	//! How much to increase/decrease the tail of the glossy highlight when using GGX reflection model
 	//! [UI Guides] displayName=GTR gamma, minValue=0.001, maxValue=1000.0
 	bool set_gtr_gamma(float texturefloat) { return setValue("gtr_gamma", texturefloat); }
	//! How much to increase/decrease the tail of the glossy highlight when using GGX reflection model
 	//! [UI Guides] displayName=GTR gamma, minValue=0.001, maxValue=1000.0
 	Value get_gtr_gamma() const { return getValue("gtr_gamma"); }

	//! true to use the old (and incorrect) method for computing shadow masking when GTR gamma is different from 2.0
 	//! [Default value] false
	bool set_gtr_oldGamma(bool val) { return setValue("gtr_oldGamma", val); }
	//! true to use the old (and incorrect) method for computing shadow masking when GTR gamma is different from 2.0
 	//! [Default value] false
	bool get_gtr_oldGamma() const { return getBool("gtr_oldGamma"); }
};

class BRDFGlass : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "BRDFGlass"; }

	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	bool set_color(const Color& color) { return setValue("color", color); }
	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	Color get_color() const { return getColor("color"); }

	//! (description missing)
	bool set_color_tex(const Plugin& texture) { return setValue("color_tex", texture); }
	//! (description missing)
	bool set_color_tex(const AColor& texture) { return setValue("color_tex", texture); }
	//! (description missing)
	Value get_color_tex() const { return getValue("color_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_color_tex_mult(float val) { return setValue("color_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_color_tex_mult() const { return getFloat("color_tex_mult"); }

	//! (description missing)
	//! [Default value] Color(0, 0, 0)
	bool set_transparency(const Color& color) { return setValue("transparency", color); }
	//! (description missing)
	//! [Default value] Color(0, 0, 0)
	Color get_transparency() const { return getColor("transparency"); }

	//! (description missing)
	bool set_transparency_tex(const Plugin& texture) { return setValue("transparency_tex", texture); }
	//! (description missing)
	bool set_transparency_tex(const AColor& texture) { return setValue("transparency_tex", texture); }
	//! (description missing)
	Value get_transparency_tex() const { return getValue("transparency_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_transparency_tex_mult(float val) { return setValue("transparency_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_transparency_tex_mult() const { return getFloat("transparency_tex_mult"); }

	//! IOR for the glass; this is ignored if the surface has a volume shader (the volume IOR is used).
 	//! [Default value] 1.55
	bool set_ior(float val) { return setValue("ior", val); }
	//! IOR for the glass; this is ignored if the surface has a volume shader (the volume IOR is used).
 	//! [Default value] 1.55
	float get_ior() const { return getFloat("ior"); }

	//! (description missing)
	//! [Default value] 0.01
	bool set_cutoff(float val) { return setValue("cutoff", val); }
	//! (description missing)
	//! [Default value] 0.01
	float get_cutoff() const { return getFloat("cutoff"); }

	//! (description missing)
	//! [Default value] false
	bool set_affect_shadows(bool val) { return setValue("affect_shadows", val); }
	//! (description missing)
	//! [Default value] false
	bool get_affect_shadows() const { return getBool("affect_shadows"); }

	//! Specifies how render channels are propagated through the glass (0 - only the color channel; 1 - color and alpha; 2 - all channels
 	//! [UI Guides] enum=0:Color only;1:Color and alpha;2:All channels
 	//! [Default value] 0
	bool set_affect_alpha(int val) { return setValue("affect_alpha", val); }
	//! Specifies how render channels are propagated through the glass (0 - only the color channel; 1 - color and alpha; 2 - all channels
 	//! [UI Guides] enum=0:Color only;1:Color and alpha;2:All channels
 	//! [Default value] 0
	int get_affect_alpha() const { return getInt("affect_alpha"); }

	//! (description missing)
	//! [Default value] true
	bool set_trace_refractions(bool val) { return setValue("trace_refractions", val); }
	//! (description missing)
	//! [Default value] true
	bool get_trace_refractions() const { return getBool("trace_refractions"); }

	//! The maximum refraction bounces (-1 is controlled by the global options)
 	//! [Default value] -1
	bool set_trace_depth(int val) { return setValue("trace_depth", val); }
	//! The maximum refraction bounces (-1 is controlled by the global options)
 	//! [Default value] -1
	int get_trace_depth() const { return getInt("trace_depth"); }

	//! (description missing)
	//! [Default value] false
	bool set_exit_color_on(bool val) { return setValue("exit_color_on", val); }
	//! (description missing)
	//! [Default value] false
	bool get_exit_color_on() const { return getBool("exit_color_on"); }

	//! The color to use when the maximum depth is reached
 	bool set_reflect_exit_color(const Plugin& texture) { return setValue("reflect_exit_color", texture); }
	//! The color to use when the maximum depth is reached
 	bool set_reflect_exit_color(const AColor& texture) { return setValue("reflect_exit_color", texture); }
	//! The color to use when the maximum depth is reached
 	Value get_reflect_exit_color() const { return getValue("reflect_exit_color"); }

	//! The color to use when maximum depth is reached when exit_color_on is true
 	bool set_refract_exit_color(const Plugin& texture) { return setValue("refract_exit_color", texture); }
	//! The color to use when maximum depth is reached when exit_color_on is true
 	bool set_refract_exit_color(const AColor& texture) { return setValue("refract_exit_color", texture); }
	//! The color to use when maximum depth is reached when exit_color_on is true
 	Value get_refract_exit_color() const { return getValue("refract_exit_color"); }

	//! (description missing)
	bool set_volume(const Plugin& plugin) { return setValue("volume", plugin); }
	//! (description missing)
	Plugin get_volume() const { return getPlugin("volume"); }

	//! (description missing)
	bool set_ior_tex(const Plugin& texturefloat) { return setValue("ior_tex", texturefloat); }
	//! (description missing)
	bool set_ior_tex(float texturefloat) { return setValue("ior_tex", texturefloat); }
	//! (description missing)
	Value get_ior_tex() const { return getValue("ior_tex"); }
};

class BRDFGlassGlossy : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "BRDFGlassGlossy"; }

	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	bool set_color(const Color& color) { return setValue("color", color); }
	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	Color get_color() const { return getColor("color"); }

	//! (description missing)
	bool set_color_tex(const Plugin& texture) { return setValue("color_tex", texture); }
	//! (description missing)
	bool set_color_tex(const AColor& texture) { return setValue("color_tex", texture); }
	//! (description missing)
	Value get_color_tex() const { return getValue("color_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_color_tex_mult(float val) { return setValue("color_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_color_tex_mult() const { return getFloat("color_tex_mult"); }

	//! (description missing)
	//! [Default value] Color(0, 0, 0)
	bool set_transparency(const Color& color) { return setValue("transparency", color); }
	//! (description missing)
	//! [Default value] Color(0, 0, 0)
	Color get_transparency() const { return getColor("transparency"); }

	//! (description missing)
	bool set_transparency_tex(const Plugin& texture) { return setValue("transparency_tex", texture); }
	//! (description missing)
	bool set_transparency_tex(const AColor& texture) { return setValue("transparency_tex", texture); }
	//! (description missing)
	Value get_transparency_tex() const { return getValue("transparency_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_transparency_tex_mult(float val) { return setValue("transparency_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_transparency_tex_mult() const { return getFloat("transparency_tex_mult"); }

	//! IOR for the glass; this is ignored if the surface has a volume shader (the volume IOR is used).
 	//! [Default value] 1.55
	bool set_ior(float val) { return setValue("ior", val); }
	//! IOR for the glass; this is ignored if the surface has a volume shader (the volume IOR is used).
 	//! [Default value] 1.55
	float get_ior() const { return getFloat("ior"); }

	//! (description missing)
	//! [Default value] 0.01
	bool set_cutoff(float val) { return setValue("cutoff", val); }
	//! (description missing)
	//! [Default value] 0.01
	float get_cutoff() const { return getFloat("cutoff"); }

	//! (description missing)
	//! [Default value] false
	bool set_affect_shadows(bool val) { return setValue("affect_shadows", val); }
	//! (description missing)
	//! [Default value] false
	bool get_affect_shadows() const { return getBool("affect_shadows"); }

	//! Specifies how render channels are propagated through the glass (0 - only the color channel; 1 - color and alpha; 2 - all channels
 	//! [UI Guides] enum=0:Color only;1:Color and alpha;2:All channels
 	//! [Default value] 0
	bool set_affect_alpha(int val) { return setValue("affect_alpha", val); }
	//! Specifies how render channels are propagated through the glass (0 - only the color channel; 1 - color and alpha; 2 - all channels
 	//! [UI Guides] enum=0:Color only;1:Color and alpha;2:All channels
 	//! [Default value] 0
	int get_affect_alpha() const { return getInt("affect_alpha"); }

	//! (description missing)
	//! [Default value] true
	bool set_trace_refractions(bool val) { return setValue("trace_refractions", val); }
	//! (description missing)
	//! [Default value] true
	bool get_trace_refractions() const { return getBool("trace_refractions"); }

	//! The maximum refraction bounces (-1 is controlled by the global options)
 	//! [Default value] -1
	bool set_trace_depth(int val) { return setValue("trace_depth", val); }
	//! The maximum refraction bounces (-1 is controlled by the global options)
 	//! [Default value] -1
	int get_trace_depth() const { return getInt("trace_depth"); }

	//! (description missing)
	//! [Default value] false
	bool set_exit_color_on(bool val) { return setValue("exit_color_on", val); }
	//! (description missing)
	//! [Default value] false
	bool get_exit_color_on() const { return getBool("exit_color_on"); }

	//! The color to use when the maximum depth is reached
 	bool set_reflect_exit_color(const Plugin& texture) { return setValue("reflect_exit_color", texture); }
	//! The color to use when the maximum depth is reached
 	bool set_reflect_exit_color(const AColor& texture) { return setValue("reflect_exit_color", texture); }
	//! The color to use when the maximum depth is reached
 	Value get_reflect_exit_color() const { return getValue("reflect_exit_color"); }

	//! The color to use when maximum depth is reached when exit_color_on is true
 	bool set_refract_exit_color(const Plugin& texture) { return setValue("refract_exit_color", texture); }
	//! The color to use when maximum depth is reached when exit_color_on is true
 	bool set_refract_exit_color(const AColor& texture) { return setValue("refract_exit_color", texture); }
	//! The color to use when maximum depth is reached when exit_color_on is true
 	Value get_refract_exit_color() const { return getValue("refract_exit_color"); }

	//! (description missing)
	bool set_volume(const Plugin& plugin) { return setValue("volume", plugin); }
	//! (description missing)
	Plugin get_volume() const { return getPlugin("volume"); }

	//! (description missing)
	bool set_ior_tex(const Plugin& texturefloat) { return setValue("ior_tex", texturefloat); }
	//! (description missing)
	bool set_ior_tex(float texturefloat) { return setValue("ior_tex", texturefloat); }
	//! (description missing)
	Value get_ior_tex() const { return getValue("ior_tex"); }

	//! (description missing)
	//! [Default value] 0.8
	bool set_glossiness(float val) { return setValue("glossiness", val); }
	//! (description missing)
	//! [Default value] 0.8
	float get_glossiness() const { return getFloat("glossiness"); }

	//! (description missing)
	bool set_glossiness_tex(const Plugin& texturefloat) { return setValue("glossiness_tex", texturefloat); }
	//! (description missing)
	bool set_glossiness_tex(float texturefloat) { return setValue("glossiness_tex", texturefloat); }
	//! (description missing)
	Value get_glossiness_tex() const { return getValue("glossiness_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_glossiness_tex_mult(float val) { return setValue("glossiness_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_glossiness_tex_mult() const { return getFloat("glossiness_tex_mult"); }

	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	bool set_subdivs(int val) { return setValue("subdivs", val); }
	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	int get_subdivs() const { return getInt("subdivs"); }

	//! (description missing)
	//! [Default value] 0
	bool set_dispersion_on(int val) { return setValue("dispersion_on", val); }
	//! (description missing)
	//! [Default value] 0
	int get_dispersion_on() const { return getInt("dispersion_on"); }

	//! (description missing)
	//! [Default value] 1
	bool set_dispersion(float val) { return setValue("dispersion", val); }
	//! (description missing)
	//! [Default value] 1
	float get_dispersion() const { return getFloat("dispersion"); }

	//! (description missing)
	//! [Default value] 0
	bool set_interpolation_on(int val) { return setValue("interpolation_on", val); }
	//! (description missing)
	//! [Default value] 0
	int get_interpolation_on() const { return getInt("interpolation_on"); }

	//! (description missing)
	//! [Default value] -1
	bool set_imap_min_rate(int val) { return setValue("imap_min_rate", val); }
	//! (description missing)
	//! [Default value] -1
	int get_imap_min_rate() const { return getInt("imap_min_rate"); }

	//! (description missing)
	//! [Default value] 1
	bool set_imap_max_rate(int val) { return setValue("imap_max_rate", val); }
	//! (description missing)
	//! [Default value] 1
	int get_imap_max_rate() const { return getInt("imap_max_rate"); }

	//! (description missing)
	//! [Default value] 0.25
	bool set_imap_color_thresh(float val) { return setValue("imap_color_thresh", val); }
	//! (description missing)
	//! [Default value] 0.25
	float get_imap_color_thresh() const { return getFloat("imap_color_thresh"); }

	//! (description missing)
	//! [Default value] 0.4
	bool set_imap_norm_thresh(float val) { return setValue("imap_norm_thresh", val); }
	//! (description missing)
	//! [Default value] 0.4
	float get_imap_norm_thresh() const { return getFloat("imap_norm_thresh"); }

	//! (description missing)
	//! [Default value] 20
	bool set_imap_samples(int val) { return setValue("imap_samples", val); }
	//! (description missing)
	//! [Default value] 20
	int get_imap_samples() const { return getInt("imap_samples"); }
};

class BRDFHOPS : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "BRDFHOPS"; }

	//! (description missing)
	//! [Default value] Color(0, 0, 0)
	bool set_transparency(const Color& color) { return setValue("transparency", color); }
	//! (description missing)
	//! [Default value] Color(0, 0, 0)
	Color get_transparency() const { return getColor("transparency"); }

	//! (description missing)
	bool set_transparency_tex(const Plugin& texture) { return setValue("transparency_tex", texture); }
	//! (description missing)
	bool set_transparency_tex(const AColor& texture) { return setValue("transparency_tex", texture); }
	//! (description missing)
	Value get_transparency_tex() const { return getValue("transparency_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_transparency_tex_mult(float val) { return setValue("transparency_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_transparency_tex_mult() const { return getFloat("transparency_tex_mult"); }

	//! (description missing)
	//! [Default value] 0.01
	bool set_cutoff(float val) { return setValue("cutoff", val); }
	//! (description missing)
	//! [Default value] 0.01
	float get_cutoff() const { return getFloat("cutoff"); }

	//! (description missing)
	//! [Default value] false
	bool set_back_side(bool val) { return setValue("back_side", val); }
	//! (description missing)
	//! [Default value] false
	bool get_back_side() const { return getBool("back_side"); }

	//! (description missing)
	//! [Default value] true
	bool set_trace_reflections(bool val) { return setValue("trace_reflections", val); }
	//! (description missing)
	//! [Default value] true
	bool get_trace_reflections() const { return getBool("trace_reflections"); }

	//! The maximum reflection depth (-1 is controlled by the global options)
 	//! [Default value] -1
	bool set_trace_depth(int val) { return setValue("trace_depth", val); }
	//! The maximum reflection depth (-1 is controlled by the global options)
 	//! [Default value] -1
	int get_trace_depth() const { return getInt("trace_depth"); }

	//! Specifies how render channels are propagated through the BRDF (0 - only the color channel; 1 - color and alpha; 2 - all channels
 	//! [Default value] 0
	bool set_affect_alpha(int val) { return setValue("affect_alpha", val); }
	//! Specifies how render channels are propagated through the BRDF (0 - only the color channel; 1 - color and alpha; 2 - all channels
 	//! [Default value] 0
	int get_affect_alpha() const { return getInt("affect_alpha"); }

	//! The color to use when the maximum depth is reached
 	bool set_reflect_exit_color(const Plugin& texture) { return setValue("reflect_exit_color", texture); }
	//! The color to use when the maximum depth is reached
 	bool set_reflect_exit_color(const AColor& texture) { return setValue("reflect_exit_color", texture); }
	//! The color to use when the maximum depth is reached
 	Value get_reflect_exit_color() const { return getValue("reflect_exit_color"); }

	//! How much to dim reflection as length of rays increases
 	//! [Default value] 1e+018
	bool set_reflect_dim_distance(float val) { return setValue("reflect_dim_distance", val); }
	//! How much to dim reflection as length of rays increases
 	//! [Default value] 1e+018
	float get_reflect_dim_distance() const { return getFloat("reflect_dim_distance"); }

	//! True to enable dim distance
 	//! [Default value] false
	bool set_reflect_dim_distance_on(bool val) { return setValue("reflect_dim_distance_on", val); }
	//! True to enable dim distance
 	//! [Default value] false
	bool get_reflect_dim_distance_on() const { return getBool("reflect_dim_distance_on"); }

	//! Fall off for the dim distance
 	//! [Default value] 0
	bool set_reflect_dim_distance_falloff(float val) { return setValue("reflect_dim_distance_falloff", val); }
	//! Fall off for the dim distance
 	//! [Default value] 0
	float get_reflect_dim_distance_falloff() const { return getFloat("reflect_dim_distance_falloff"); }

	//! Determines if the glossy rays are treated by V-Ray as GI rays: 0 - never; 1 - only for rays that are already marked as GI rays; 2 - always
 	//! [Default value] 1
	bool set_glossyAsGI(int val) { return setValue("glossyAsGI", val); }
	//! Determines if the glossy rays are treated by V-Ray as GI rays: 0 - never; 1 - only for rays that are already marked as GI rays; 2 - always
 	//! [Default value] 1
	int get_glossyAsGI() const { return getInt("glossyAsGI"); }

	//! (description missing)
	//! [Default value] 8
	bool set_subdivs(int val) { return setValue("subdivs", val); }
	//! (description missing)
	//! [Default value] 8
	int get_subdivs() const { return getInt("subdivs"); }

	//! [UI Guides] fileAsset=csv
 	bool set_csv_path(const char* str) { return setValue("csv_path", str); }
	//! [UI Guides] fileAsset=csv
 	bool set_csv_path(const std::string& str) { return setValue("csv_path", str); }
	//! [UI Guides] fileAsset=csv
 	std::string get_csv_path() const { return getString("csv_path"); }

	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	bool set_csv_color_filter(const Color& color) { return setValue("csv_color_filter", color); }
	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	Color get_csv_color_filter() const { return getColor("csv_color_filter"); }

	//! [UI Guides] fileAsset=flakecsv
 	bool set_flakes_csv_path(const char* str) { return setValue("flakes_csv_path", str); }
	//! [UI Guides] fileAsset=flakecsv
 	bool set_flakes_csv_path(const std::string& str) { return setValue("flakes_csv_path", str); }
	//! [UI Guides] fileAsset=flakecsv
 	std::string get_flakes_csv_path() const { return getString("flakes_csv_path"); }

	//! (description missing)
	bool set_coat_color(const Plugin& texture) { return setValue("coat_color", texture); }
	//! (description missing)
	bool set_coat_color(const AColor& texture) { return setValue("coat_color", texture); }
	//! (description missing)
	Value get_coat_color() const { return getValue("coat_color"); }

	//! (description missing)
	bool set_coat_strength(const Plugin& texturefloat) { return setValue("coat_strength", texturefloat); }
	//! (description missing)
	bool set_coat_strength(float texturefloat) { return setValue("coat_strength", texturefloat); }
	//! (description missing)
	Value get_coat_strength() const { return getValue("coat_strength"); }

	//! The glossiness of the coat layer
 	bool set_coat_glossiness(const Plugin& texturefloat) { return setValue("coat_glossiness", texturefloat); }
	//! The glossiness of the coat layer
 	bool set_coat_glossiness(float texturefloat) { return setValue("coat_glossiness", texturefloat); }
	//! The glossiness of the coat layer
 	Value get_coat_glossiness() const { return getValue("coat_glossiness"); }

	//! Bump texture for the coat layer
 	bool set_coat_bump_float(const Plugin& texturefloat) { return setValue("coat_bump_float", texturefloat); }
	//! Bump texture for the coat layer
 	bool set_coat_bump_float(float texturefloat) { return setValue("coat_bump_float", texturefloat); }
	//! Bump texture for the coat layer
 	Value get_coat_bump_float() const { return getValue("coat_bump_float"); }

	//! Bump texture for the coat layer (color version)
 	bool set_coat_bump_color(const Plugin& texture) { return setValue("coat_bump_color", texture); }
	//! Bump texture for the coat layer (color version)
 	bool set_coat_bump_color(const AColor& texture) { return setValue("coat_bump_color", texture); }
	//! Bump texture for the coat layer (color version)
 	Value get_coat_bump_color() const { return getValue("coat_bump_color"); }

	//! Bump amount for the coat layer
 	bool set_coat_bump_amount(const Plugin& texturefloat) { return setValue("coat_bump_amount", texturefloat); }
	//! Bump amount for the coat layer
 	bool set_coat_bump_amount(float texturefloat) { return setValue("coat_bump_amount", texturefloat); }
	//! Bump amount for the coat layer
 	Value get_coat_bump_amount() const { return getValue("coat_bump_amount"); }

	//! The type of bump mapping (see BRDFBump for more details)
 	//! [Default value] 0
	bool set_coat_bump_type(int val) { return setValue("coat_bump_type", val); }
	//! The type of bump mapping (see BRDFBump for more details)
 	//! [Default value] 0
	int get_coat_bump_type() const { return getInt("coat_bump_type"); }

	//! Toggle reflections for coat layer
 	//! [Default value] 1
	bool set_coat_traceReflections(int val) { return setValue("coat_traceReflections", val); }
	//! Toggle reflections for coat layer
 	//! [Default value] 1
	int get_coat_traceReflections() const { return getInt("coat_traceReflections"); }

	//! (description missing)
	//! [Default value] 8
	bool set_coat_subdivs(int val) { return setValue("coat_subdivs", val); }
	//! (description missing)
	//! [Default value] 8
	int get_coat_subdivs() const { return getInt("coat_subdivs"); }

	//! Enabled layers ORmask (1 - base, 2 - flakes, 4 - coat)
 	//! [UI Guides] enum=0:Base;1:Flakes;4:Coat
 	//! [Default value] 7
	bool set_enabled_layers(int val) { return setValue("enabled_layers", val); }
	//! Enabled layers ORmask (1 - base, 2 - flakes, 4 - coat)
 	//! [UI Guides] enum=0:Base;1:Flakes;4:Coat
 	//! [Default value] 7
	int get_enabled_layers() const { return getInt("enabled_layers"); }

	//! Flake scale - aparent flakes size in the real world
 	//! [Default value] 0.005
	bool set_flake_scale(float val) { return setValue("flake_scale", val); }
	//! Flake scale - aparent flakes size in the real world
 	//! [Default value] 0.005
	float get_flake_scale() const { return getFloat("flake_scale"); }

	//! Flake size multiplier (larger values = more flake overlap)
 	//! [Default value] 0.125
	bool set_flake_size(float val) { return setValue("flake_size", val); }
	//! Flake size multiplier (larger values = more flake overlap)
 	//! [Default value] 0.125
	float get_flake_size() const { return getFloat("flake_size"); }

	//! Toggle reflections for flake layer
 	//! [Default value] 0
	bool set_flake_traceReflections(int val) { return setValue("flake_traceReflections", val); }
	//! Toggle reflections for flake layer
 	//! [Default value] 0
	int get_flake_traceReflections() const { return getInt("flake_traceReflections"); }

	//! (description missing)
	//! [Default value] 1
	bool set_doubleSided(int val) { return setValue("doubleSided", val); }
	//! (description missing)
	//! [Default value] 1
	int get_doubleSided() const { return getInt("doubleSided"); }

	//! Flake glossiness (only if reflections are enabled)
 	bool set_flake_glossiness(const Plugin& texturefloat) { return setValue("flake_glossiness", texturefloat); }
	//! Flake glossiness (only if reflections are enabled)
 	bool set_flake_glossiness(float texturefloat) { return setValue("flake_glossiness", texturefloat); }
	//! Flake glossiness (only if reflections are enabled)
 	Value get_flake_glossiness() const { return getValue("flake_glossiness"); }

	//! Environment override texture
 	bool set_environment_override(const Plugin& texture) { return setValue("environment_override", texture); }
	//! Environment override texture
 	bool set_environment_override(const AColor& texture) { return setValue("environment_override", texture); }
	//! Environment override texture
 	Value get_environment_override() const { return getValue("environment_override"); }

	//! (description missing)
	//! [Default value] 0
	bool set_environment_priority(int val) { return setValue("environment_priority", val); }
	//! (description missing)
	//! [Default value] 0
	int get_environment_priority() const { return getInt("environment_priority"); }
};

class BRDFHair : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "BRDFHair"; }

	//! [UI Guides] startTab=V-Ray Simple Hair, startRollout=V-Ray Simple Hair, displayName=Specular color
 	bool set_specular_color_tex(const Plugin& texture) { return setValue("specular_color_tex", texture); }
	//! [UI Guides] startTab=V-Ray Simple Hair, startRollout=V-Ray Simple Hair, displayName=Specular color
 	bool set_specular_color_tex(const AColor& texture) { return setValue("specular_color_tex", texture); }
	//! [UI Guides] startTab=V-Ray Simple Hair, startRollout=V-Ray Simple Hair, displayName=Specular color
 	Value get_specular_color_tex() const { return getValue("specular_color_tex"); }

	//! [UI Guides] displayName=Specular power, minValue=0
 	//! [Default value] 1
	bool set_specular_power(float val) { return setValue("specular_power", val); }
	//! [UI Guides] displayName=Specular power, minValue=0
 	//! [Default value] 1
	float get_specular_power() const { return getFloat("specular_power"); }

	//! [UI Guides] displayName=Diffuse color
 	bool set_diffuse_color_tex(const Plugin& texture) { return setValue("diffuse_color_tex", texture); }
	//! [UI Guides] displayName=Diffuse color
 	bool set_diffuse_color_tex(const AColor& texture) { return setValue("diffuse_color_tex", texture); }
	//! [UI Guides] displayName=Diffuse color
 	Value get_diffuse_color_tex() const { return getValue("diffuse_color_tex"); }
};

class BRDFHair2 : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "BRDFHair2"; }

	//! [UI Guides] displayName=Diffuse color, startTab=V-Ray Hair 2, startRollout=V-Ray Hair 2
 	bool set_diffuse_color_tex(const Plugin& texture) { return setValue("diffuse_color_tex", texture); }
	//! [UI Guides] displayName=Diffuse color, startTab=V-Ray Hair 2, startRollout=V-Ray Hair 2
 	bool set_diffuse_color_tex(const AColor& texture) { return setValue("diffuse_color_tex", texture); }
	//! [UI Guides] displayName=Diffuse color, startTab=V-Ray Hair 2, startRollout=V-Ray Hair 2
 	Value get_diffuse_color_tex() const { return getValue("diffuse_color_tex"); }

	//! Absorption coeficient, controls the color of the hair
 	bool set_absorption(const Plugin& texture) { return setValue("absorption", texture); }
	//! Absorption coeficient, controls the color of the hair
 	bool set_absorption(const AColor& texture) { return setValue("absorption", texture); }
	//! Absorption coeficient, controls the color of the hair
 	Value get_absorption() const { return getValue("absorption"); }

	//! Index of refraction for the hair
 	//! [UI Guides] minValue=0, maxValue=100
 	//! [Default value] 1.55
	bool set_refraction_index(float val) { return setValue("refraction_index", val); }
	//! Index of refraction for the hair
 	//! [UI Guides] minValue=0, maxValue=100
 	//! [Default value] 1.55
	float get_refraction_index() const { return getFloat("refraction_index"); }

	//! Multiplier for the Diffuse component
 	//! [UI Guides] minValue=0
 	//! [Default value] 1
	bool set_diffuse_mult(float val) { return setValue("diffuse_mult", val); }
	//! Multiplier for the Diffuse component
 	//! [UI Guides] minValue=0
 	//! [Default value] 1
	float get_diffuse_mult() const { return getFloat("diffuse_mult"); }

	//! Multiplier for the R lobe
 	//! [UI Guides] displayName=R lobe multiplier, startRollout=
 	//! [Default value] 1
	bool set_r_mult(float val) { return setValue("r_mult", val); }
	//! Multiplier for the R lobe
 	//! [UI Guides] displayName=R lobe multiplier, startRollout=
 	//! [Default value] 1
	float get_r_mult() const { return getFloat("r_mult"); }

	//! Longitudinal shift for the R lobe
 	//! [UI Guides] displayName=Long. shift: R lobe
 	//! [Default value] -10
	bool set_r_long_shift(float val) { return setValue("r_long_shift", val); }
	//! Longitudinal shift for the R lobe
 	//! [UI Guides] displayName=Long. shift: R lobe
 	//! [Default value] -10
	float get_r_long_shift() const { return getFloat("r_long_shift"); }

	//! Longitudinal width (stddev.) for the R lobe
 	//! [UI Guides] displayName=Long. width: R lobe
 	//! [Default value] 5
	bool set_r_long_width(float val) { return setValue("r_long_width", val); }
	//! Longitudinal width (stddev.) for the R lobe
 	//! [UI Guides] displayName=Long. width: R lobe
 	//! [Default value] 5
	float get_r_long_width() const { return getFloat("r_long_width"); }

	//! Multiplier for the TT lobe
 	//! [UI Guides] displayName=TT lobe multiplier, startRollout=
 	//! [Default value] 1
	bool set_tt_mult(float val) { return setValue("tt_mult", val); }
	//! Multiplier for the TT lobe
 	//! [UI Guides] displayName=TT lobe multiplier, startRollout=
 	//! [Default value] 1
	float get_tt_mult() const { return getFloat("tt_mult"); }

	//! Longitudinal shift for the TT lobe
 	//! [UI Guides] displayName=Long. shift: TT lobe
 	//! [Default value] 5
	bool set_tt_long_shift(float val) { return setValue("tt_long_shift", val); }
	//! Longitudinal shift for the TT lobe
 	//! [UI Guides] displayName=Long. shift: TT lobe
 	//! [Default value] 5
	float get_tt_long_shift() const { return getFloat("tt_long_shift"); }

	//! Longitudinal width (stddev.) for the TT lobe
 	//! [UI Guides] displayName=Long. width: TT lobe
 	//! [Default value] 2.5
	bool set_tt_long_width(float val) { return setValue("tt_long_width", val); }
	//! Longitudinal width (stddev.) for the TT lobe
 	//! [UI Guides] displayName=Long. width: TT lobe
 	//! [Default value] 2.5
	float get_tt_long_width() const { return getFloat("tt_long_width"); }

	//! Multiplier for the TRT lobe
 	//! [UI Guides] displayName=TRT lobe multiplier, startRollout=
 	//! [Default value] 1
	bool set_trt_mult(float val) { return setValue("trt_mult", val); }
	//! Multiplier for the TRT lobe
 	//! [UI Guides] displayName=TRT lobe multiplier, startRollout=
 	//! [Default value] 1
	float get_trt_mult() const { return getFloat("trt_mult"); }

	//! Longitudinal shift for the TRT lobe
 	//! [UI Guides] displayName=Long. shift: TRT lobe
 	//! [Default value] 15
	bool set_trt_long_shift(float val) { return setValue("trt_long_shift", val); }
	//! Longitudinal shift for the TRT lobe
 	//! [UI Guides] displayName=Long. shift: TRT lobe
 	//! [Default value] 15
	float get_trt_long_shift() const { return getFloat("trt_long_shift"); }

	//! Longitudinal width (stddev.) for the TRT lobe
 	//! [UI Guides] displayName=Long. width: TRT lobe
 	//! [Default value] 10
	bool set_trt_long_width(float val) { return setValue("trt_long_width", val); }
	//! Longitudinal width (stddev.) for the TRT lobe
 	//! [UI Guides] displayName=Long. width: TRT lobe
 	//! [Default value] 10
	float get_trt_long_width() const { return getFloat("trt_long_width"); }

	//! Glint scale factor 0.5 to 5.0
 	//! [UI Guides] startRollout=
 	//! [Default value] 0.5
	bool set_glint_scale(float val) { return setValue("glint_scale", val); }
	//! Glint scale factor 0.5 to 5.0
 	//! [UI Guides] startRollout=
 	//! [Default value] 0.5
	float get_glint_scale() const { return getFloat("glint_scale"); }

	//! Azimuthal width of the caustic from 10 to 25 degrees
 	//! [Default value] 10
	bool set_azimuthal_width(float val) { return setValue("azimuthal_width", val); }
	//! Azimuthal width of the caustic from 10 to 25 degrees
 	//! [Default value] 10
	float get_azimuthal_width() const { return getFloat("azimuthal_width"); }

	//! Fade range for caustic merge (0.2 to 0.4)
 	//! [Default value] 0.2
	bool set_fade_range(float val) { return setValue("fade_range", val); }
	//! Fade range for caustic merge (0.2 to 0.4)
 	//! [Default value] 0.2
	float get_fade_range() const { return getFloat("fade_range"); }

	//! Caustic intensity limit
 	//! [Default value] 0.5
	bool set_caustic_limit(float val) { return setValue("caustic_limit", val); }
	//! Caustic intensity limit
 	//! [Default value] 0.5
	float get_caustic_limit() const { return getFloat("caustic_limit"); }
};

class BRDFHair3 : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "BRDFHair3"; }

	//! Overall color multiplier
 	//! [UI Guides] startTab=V-Ray Hair 3, startRollout=General parameters
 	bool set_overall_color(const Plugin& texture) { return setValue("overall_color", texture); }
	//! Overall color multiplier
 	//! [UI Guides] startTab=V-Ray Hair 3, startRollout=General parameters
 	bool set_overall_color(const AColor& texture) { return setValue("overall_color", texture); }
	//! Overall color multiplier
 	//! [UI Guides] startTab=V-Ray Hair 3, startRollout=General parameters
 	Value get_overall_color() const { return getValue("overall_color"); }

	//! Transparency
 	bool set_transparency(const Plugin& texture) { return setValue("transparency", texture); }
	//! Transparency
 	bool set_transparency(const AColor& texture) { return setValue("transparency", texture); }
	//! Transparency
 	Value get_transparency() const { return getValue("transparency"); }

	//! Diffuse hair color
 	//! [UI Guides] startRollout=Diffuse
 	bool set_diffuse_color(const Plugin& texture) { return setValue("diffuse_color", texture); }
	//! Diffuse hair color
 	//! [UI Guides] startRollout=Diffuse
 	bool set_diffuse_color(const AColor& texture) { return setValue("diffuse_color", texture); }
	//! Diffuse hair color
 	//! [UI Guides] startRollout=Diffuse
 	Value get_diffuse_color() const { return getValue("diffuse_color"); }

	//! Multiplier for the diffuse color
 	//! [UI Guides] minValue=0, maxValue=1000
 	bool set_diffuse_amount(const Plugin& texturefloat) { return setValue("diffuse_amount", texturefloat); }
	//! Multiplier for the diffuse color
 	//! [UI Guides] minValue=0, maxValue=1000
 	bool set_diffuse_amount(float texturefloat) { return setValue("diffuse_amount", texturefloat); }
	//! Multiplier for the diffuse color
 	//! [UI Guides] minValue=0, maxValue=1000
 	Value get_diffuse_amount() const { return getValue("diffuse_amount"); }

	//! Primary specular color
 	//! [UI Guides] displayName=Prim. specular, startRollout=Primary specular
 	bool set_primary_specular(const Plugin& texture) { return setValue("primary_specular", texture); }
	//! Primary specular color
 	//! [UI Guides] displayName=Prim. specular, startRollout=Primary specular
 	bool set_primary_specular(const AColor& texture) { return setValue("primary_specular", texture); }
	//! Primary specular color
 	//! [UI Guides] displayName=Prim. specular, startRollout=Primary specular
 	Value get_primary_specular() const { return getValue("primary_specular"); }

	//! Multiplier for the primary specular color
 	//! [UI Guides] displayName=Prim. specular amount, minValue=0, maxValue=1000
 	bool set_primary_specular_amount(const Plugin& texturefloat) { return setValue("primary_specular_amount", texturefloat); }
	//! Multiplier for the primary specular color
 	//! [UI Guides] displayName=Prim. specular amount, minValue=0, maxValue=1000
 	bool set_primary_specular_amount(float texturefloat) { return setValue("primary_specular_amount", texturefloat); }
	//! Multiplier for the primary specular color
 	//! [UI Guides] displayName=Prim. specular amount, minValue=0, maxValue=1000
 	Value get_primary_specular_amount() const { return getValue("primary_specular_amount"); }

	//! Primary glossiness
 	//! [UI Guides] displayName=Prim. glossiness, minValue=0, maxValue=1
 	bool set_primary_glossiness(const Plugin& texturefloat) { return setValue("primary_glossiness", texturefloat); }
	//! Primary glossiness
 	//! [UI Guides] displayName=Prim. glossiness, minValue=0, maxValue=1
 	bool set_primary_glossiness(float texturefloat) { return setValue("primary_glossiness", texturefloat); }
	//! Primary glossiness
 	//! [UI Guides] displayName=Prim. glossiness, minValue=0, maxValue=1
 	Value get_primary_glossiness() const { return getValue("primary_glossiness"); }

	//! true to derive the secondary specular color from the transmission color
 	//! [UI Guides] displayName=Sec. lock to transmission, startRollout=Secondary specular
 	//! [Default value] true
	bool set_secondary_lock_to_transmission(bool val) { return setValue("secondary_lock_to_transmission", val); }
	//! true to derive the secondary specular color from the transmission color
 	//! [UI Guides] displayName=Sec. lock to transmission, startRollout=Secondary specular
 	//! [Default value] true
	bool get_secondary_lock_to_transmission() const { return getBool("secondary_lock_to_transmission"); }

	//! Secondary specular color
 	//! [UI Guides] displayName=Sec. specular, enableIf: ?secondary_lock_to_transmission=0
 	bool set_secondary_specular(const Plugin& texture) { return setValue("secondary_specular", texture); }
	//! Secondary specular color
 	//! [UI Guides] displayName=Sec. specular, enableIf: ?secondary_lock_to_transmission=0
 	bool set_secondary_specular(const AColor& texture) { return setValue("secondary_specular", texture); }
	//! Secondary specular color
 	//! [UI Guides] displayName=Sec. specular, enableIf: ?secondary_lock_to_transmission=0
 	Value get_secondary_specular() const { return getValue("secondary_specular"); }

	//! Multiplier for the secondary specular color
 	//! [UI Guides] displayName=Sec. specular amount, enableIf: ?secondary_lock_to_transmission=0, minValue=0, maxValue=1000
 	bool set_secondary_specular_amount(const Plugin& texturefloat) { return setValue("secondary_specular_amount", texturefloat); }
	//! Multiplier for the secondary specular color
 	//! [UI Guides] displayName=Sec. specular amount, enableIf: ?secondary_lock_to_transmission=0, minValue=0, maxValue=1000
 	bool set_secondary_specular_amount(float texturefloat) { return setValue("secondary_specular_amount", texturefloat); }
	//! Multiplier for the secondary specular color
 	//! [UI Guides] displayName=Sec. specular amount, enableIf: ?secondary_lock_to_transmission=0, minValue=0, maxValue=1000
 	Value get_secondary_specular_amount() const { return getValue("secondary_specular_amount"); }

	//! Secondary glossiness
 	//! [UI Guides] displayName=Sec. glossiness, minValue=0, maxValue=1
 	bool set_secondary_glossiness(const Plugin& texturefloat) { return setValue("secondary_glossiness", texturefloat); }
	//! Secondary glossiness
 	//! [UI Guides] displayName=Sec. glossiness, minValue=0, maxValue=1
 	bool set_secondary_glossiness(float texturefloat) { return setValue("secondary_glossiness", texturefloat); }
	//! Secondary glossiness
 	//! [UI Guides] displayName=Sec. glossiness, minValue=0, maxValue=1
 	Value get_secondary_glossiness() const { return getValue("secondary_glossiness"); }

	//! Transmission color
 	//! [UI Guides] startRollout=Transmission
 	bool set_transmission(const Plugin& texture) { return setValue("transmission", texture); }
	//! Transmission color
 	//! [UI Guides] startRollout=Transmission
 	bool set_transmission(const AColor& texture) { return setValue("transmission", texture); }
	//! Transmission color
 	//! [UI Guides] startRollout=Transmission
 	Value get_transmission() const { return getValue("transmission"); }

	//! Multiplier for the transmission color
 	//! [UI Guides] minValue=0, maxValue=1000
 	bool set_transmission_amount(const Plugin& texturefloat) { return setValue("transmission_amount", texturefloat); }
	//! Multiplier for the transmission color
 	//! [UI Guides] minValue=0, maxValue=1000
 	bool set_transmission_amount(float texturefloat) { return setValue("transmission_amount", texturefloat); }
	//! Multiplier for the transmission color
 	//! [UI Guides] minValue=0, maxValue=1000
 	Value get_transmission_amount() const { return getValue("transmission_amount"); }

	//! Transmission glossiness along strand length
 	//! [UI Guides] displayName=Trans. gloss. length, minValue=0, maxValue=1
 	bool set_transmission_glossiness_length(const Plugin& texturefloat) { return setValue("transmission_glossiness_length", texturefloat); }
	//! Transmission glossiness along strand length
 	//! [UI Guides] displayName=Trans. gloss. length, minValue=0, maxValue=1
 	bool set_transmission_glossiness_length(float texturefloat) { return setValue("transmission_glossiness_length", texturefloat); }
	//! Transmission glossiness along strand length
 	//! [UI Guides] displayName=Trans. gloss. length, minValue=0, maxValue=1
 	Value get_transmission_glossiness_length() const { return getValue("transmission_glossiness_length"); }

	//! Transmission glossiness across strand width
 	//! [UI Guides] displayName=Trans. gloss. width, minValue=0, maxValue=1
 	bool set_transmission_glossiness_width(const Plugin& texturefloat) { return setValue("transmission_glossiness_width", texturefloat); }
	//! Transmission glossiness across strand width
 	//! [UI Guides] displayName=Trans. gloss. width, minValue=0, maxValue=1
 	bool set_transmission_glossiness_width(float texturefloat) { return setValue("transmission_glossiness_width", texturefloat); }
	//! Transmission glossiness across strand width
 	//! [UI Guides] displayName=Trans. gloss. width, minValue=0, maxValue=1
 	Value get_transmission_glossiness_width() const { return getValue("transmission_glossiness_width"); }

	//! true to always compute the material as opaque for shadow rays
 	//! [UI Guides] startRollout=Options
 	//! [Default value] false
	bool set_opaque_for_shadows(bool val) { return setValue("opaque_for_shadows", val); }
	//! true to always compute the material as opaque for shadow rays
 	//! [UI Guides] startRollout=Options
 	//! [Default value] false
	bool get_opaque_for_shadows() const { return getBool("opaque_for_shadows"); }

	//! true to always compute the material as opaque for GI rays
 	//! [UI Guides] displayName=Opaque for GI
 	//! [Default value] false
	bool set_opaque_for_gi(bool val) { return setValue("opaque_for_gi", val); }
	//! true to always compute the material as opaque for GI rays
 	//! [UI Guides] displayName=Opaque for GI
 	//! [Default value] false
	bool get_opaque_for_gi() const { return getBool("opaque_for_gi"); }

	//! true to use a simpler and less precise representation of the BRDF for GI rays
 	//! [UI Guides] displayName=Simplify for GI
 	//! [Default value] true
	bool set_simplify_for_gi(bool val) { return setValue("simplify_for_gi", val); }
	//! true to use a simpler and less precise representation of the BRDF for GI rays
 	//! [UI Guides] displayName=Simplify for GI
 	//! [Default value] true
	bool get_simplify_for_gi() const { return getBool("simplify_for_gi"); }

	//! true to use the light cache/irradiance map; false to always use brute force GI for the hair
 	//! [UI Guides] displayName=Use cached GI
 	//! [Default value] true
	bool set_use_cached_gi(bool val) { return setValue("use_cached_gi", val); }
	//! true to use the light cache/irradiance map; false to always use brute force GI for the hair
 	//! [UI Guides] displayName=Use cached GI
 	//! [Default value] true
	bool get_use_cached_gi() const { return getBool("use_cached_gi"); }

	//! A multiplier for the direct lighting of the hair; could be useful to brighten up the result when not using GI
 	//! [UI Guides] startRollout=Advanced
 	//! [Default value] 1
	bool set_light_multiplier(float val) { return setValue("light_multiplier", val); }
	//! A multiplier for the direct lighting of the hair; could be useful to brighten up the result when not using GI
 	//! [UI Guides] startRollout=Advanced
 	//! [Default value] 1
	float get_light_multiplier() const { return getFloat("light_multiplier"); }
};

class BRDFLayered : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "BRDFLayered"; }

	//! (description missing)
	bool set_brdfs(const ValueList& pluginList) { return setValue("brdfs", pluginList); }
	//! (description missing)
	ValueList get_brdfs() const { return getValueList("brdfs"); }

	//! (description missing)
	bool set_weights(const ValueList& pluginList) { return setValue("weights", pluginList); }
	//! (description missing)
	ValueList get_weights() const { return getValueList("weights"); }

	//! (description missing)
	//! [Default value] Color(0, 0, 0)
	bool set_transparency(const Color& color) { return setValue("transparency", color); }
	//! (description missing)
	//! [Default value] Color(0, 0, 0)
	Color get_transparency() const { return getColor("transparency"); }

	//! (description missing)
	bool set_transparency_tex(const Plugin& texture) { return setValue("transparency_tex", texture); }
	//! (description missing)
	bool set_transparency_tex(const AColor& texture) { return setValue("transparency_tex", texture); }
	//! (description missing)
	Value get_transparency_tex() const { return getValue("transparency_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_transparency_tex_mult(float val) { return setValue("transparency_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_transparency_tex_mult() const { return getFloat("transparency_tex_mult"); }

	//! Weight for the material layers. 0 = Default, 1 = Additive. 2 and 3 used by RT GPU only (2 = MDL normalize, 3 = MDL clamp max)
 	//! [Default value] 0
	bool set_additive_mode(int val) { return setValue("additive_mode", val); }
	//! Weight for the material layers. 0 = Default, 1 = Additive. 2 and 3 used by RT GPU only (2 = MDL normalize, 3 = MDL clamp max)
 	//! [Default value] 0
	int get_additive_mode() const { return getInt("additive_mode"); }

	//! Render channels the result of this BRDF will be written to
 	bool set_channels(const ValueList& pluginList) { return setValue("channels", pluginList); }
	//! Render channels the result of this BRDF will be written to
 	ValueList get_channels() const { return getValueList("channels"); }
};

class BRDFLight : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "BRDFLight"; }

	//! The self-illumination color
 	//! [UI Guides] startTab=V-Ray Light Mtl, startRollout=V-Ray Light Mtl, displayName=Light color
 	bool set_color(const Plugin& texture) { return setValue("color", texture); }
	//! The self-illumination color
 	//! [UI Guides] startTab=V-Ray Light Mtl, startRollout=V-Ray Light Mtl, displayName=Light color
 	bool set_color(const AColor& texture) { return setValue("color", texture); }
	//! The self-illumination color
 	//! [UI Guides] startTab=V-Ray Light Mtl, startRollout=V-Ray Light Mtl, displayName=Light color
 	Value get_color() const { return getValue("color"); }

	//! Color Multiplier
 	//! [UI Guides] displayName=Color multiplier
 	bool set_colorMultiplier(const Plugin& texturefloat) { return setValue("colorMultiplier", texturefloat); }
	//! Color Multiplier
 	//! [UI Guides] displayName=Color multiplier
 	bool set_colorMultiplier(float texturefloat) { return setValue("colorMultiplier", texturefloat); }
	//! Color Multiplier
 	//! [UI Guides] displayName=Color multiplier
 	Value get_colorMultiplier() const { return getValue("colorMultiplier"); }

	//! Transparency of the BRDF
 	bool set_transparency(const Plugin& texture) { return setValue("transparency", texture); }
	//! Transparency of the BRDF
 	bool set_transparency(const AColor& texture) { return setValue("transparency", texture); }
	//! Transparency of the BRDF
 	Value get_transparency() const { return getValue("transparency"); }

	//! If false, the light color is black for back-facing surfaces
 	//! [UI Guides] displayName=Double sided
 	//! [Default value] false
	bool set_doubleSided(bool val) { return setValue("doubleSided", val); }
	//! If false, the light color is black for back-facing surfaces
 	//! [UI Guides] displayName=Double sided
 	//! [Default value] false
	bool get_doubleSided() const { return getBool("doubleSided"); }

	//! Emit on back side
 	//! [UI Guides] displayName=Emit on back side
 	//! [Default value] true
	bool set_emitOnBackSide(bool val) { return setValue("emitOnBackSide", val); }
	//! Emit on back side
 	//! [UI Guides] displayName=Emit on back side
 	//! [Default value] true
	bool get_emitOnBackSide() const { return getBool("emitOnBackSide"); }

	//! Render channels the result of this BRDF will be written to
 	bool set_channels(const ValueList& pluginList) { return setValue("channels", pluginList); }
	//! Render channels the result of this BRDF will be written to
 	ValueList get_channels() const { return getValueList("channels"); }

	//! Compensate camera exposure
 	//! [UI Guides] displayName=Compensate exposure
 	//! [Default value] false
	bool set_compensateExposure(bool val) { return setValue("compensateExposure", val); }
	//! Compensate camera exposure
 	//! [UI Guides] displayName=Compensate exposure
 	//! [Default value] false
	bool get_compensateExposure() const { return getBool("compensateExposure"); }

	//! When enabled the color of the light brdf is multiplied by the brdf's opacity ( inverse of the brdf's transparency )
 	//! [UI Guides] displayName=Multiply by opacity
 	//! [Default value] false
	bool set_multiplyByOpacity(bool val) { return setValue("multiplyByOpacity", val); }
	//! When enabled the color of the light brdf is multiplied by the brdf's opacity ( inverse of the brdf's transparency )
 	//! [UI Guides] displayName=Multiply by opacity
 	//! [Default value] false
	bool get_multiplyByOpacity() const { return getBool("multiplyByOpacity"); }

	//! When enabled, the light emission affects GI rays and illuminates the scene
 	//! [Default value] true
	bool set_affect_gi(bool val) { return setValue("affect_gi", val); }
	//! When enabled, the light emission affects GI rays and illuminates the scene
 	//! [Default value] true
	bool get_affect_gi() const { return getBool("affect_gi"); }
};

class BRDFMirror : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "BRDFMirror"; }

	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	bool set_color(const Color& color) { return setValue("color", color); }
	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	Color get_color() const { return getColor("color"); }

	//! (description missing)
	bool set_color_tex(const Plugin& texture) { return setValue("color_tex", texture); }
	//! (description missing)
	bool set_color_tex(const AColor& texture) { return setValue("color_tex", texture); }
	//! (description missing)
	Value get_color_tex() const { return getValue("color_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_color_tex_mult(float val) { return setValue("color_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_color_tex_mult() const { return getFloat("color_tex_mult"); }

	//! (description missing)
	//! [Default value] Color(0, 0, 0)
	bool set_transparency(const Color& color) { return setValue("transparency", color); }
	//! (description missing)
	//! [Default value] Color(0, 0, 0)
	Color get_transparency() const { return getColor("transparency"); }

	//! (description missing)
	bool set_transparency_tex(const Plugin& texture) { return setValue("transparency_tex", texture); }
	//! (description missing)
	bool set_transparency_tex(const AColor& texture) { return setValue("transparency_tex", texture); }
	//! (description missing)
	Value get_transparency_tex() const { return getValue("transparency_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_transparency_tex_mult(float val) { return setValue("transparency_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_transparency_tex_mult() const { return getFloat("transparency_tex_mult"); }

	//! (description missing)
	//! [Default value] 0.01
	bool set_cutoff(float val) { return setValue("cutoff", val); }
	//! (description missing)
	//! [Default value] 0.01
	float get_cutoff() const { return getFloat("cutoff"); }

	//! (description missing)
	//! [Default value] false
	bool set_back_side(bool val) { return setValue("back_side", val); }
	//! (description missing)
	//! [Default value] false
	bool get_back_side() const { return getBool("back_side"); }

	//! (description missing)
	//! [Default value] true
	bool set_trace_reflections(bool val) { return setValue("trace_reflections", val); }
	//! (description missing)
	//! [Default value] true
	bool get_trace_reflections() const { return getBool("trace_reflections"); }

	//! The maximum reflection depth (-1 is controlled by the global options)
 	//! [Default value] -1
	bool set_trace_depth(int val) { return setValue("trace_depth", val); }
	//! The maximum reflection depth (-1 is controlled by the global options)
 	//! [Default value] -1
	int get_trace_depth() const { return getInt("trace_depth"); }

	//! Specifies how render channels are propagated through the BRDF (0 - only the color channel; 1 - color and alpha; 2 - all channels
 	//! [Default value] 0
	bool set_affect_alpha(int val) { return setValue("affect_alpha", val); }
	//! Specifies how render channels are propagated through the BRDF (0 - only the color channel; 1 - color and alpha; 2 - all channels
 	//! [Default value] 0
	int get_affect_alpha() const { return getInt("affect_alpha"); }

	//! The color to use when the maximum depth is reached
 	bool set_reflect_exit_color(const Plugin& texture) { return setValue("reflect_exit_color", texture); }
	//! The color to use when the maximum depth is reached
 	bool set_reflect_exit_color(const AColor& texture) { return setValue("reflect_exit_color", texture); }
	//! The color to use when the maximum depth is reached
 	Value get_reflect_exit_color() const { return getValue("reflect_exit_color"); }

	//! True to enable dim distance
 	//! [Default value] false
	bool set_reflect_dim_distance_on(bool val) { return setValue("reflect_dim_distance_on", val); }
	//! True to enable dim distance
 	//! [Default value] false
	bool get_reflect_dim_distance_on() const { return getBool("reflect_dim_distance_on"); }

	//! How much to dim reflection as length of rays increases
 	//! [UI Guides] quantityType=distance
 	//! [Default value] 1e+018
	bool set_reflect_dim_distance(float val) { return setValue("reflect_dim_distance", val); }
	//! How much to dim reflection as length of rays increases
 	//! [UI Guides] quantityType=distance
 	//! [Default value] 1e+018
	float get_reflect_dim_distance() const { return getFloat("reflect_dim_distance"); }

	//! Fall off for the dim distance
 	//! [Default value] 0
	bool set_reflect_dim_distance_falloff(float val) { return setValue("reflect_dim_distance_falloff", val); }
	//! Fall off for the dim distance
 	//! [Default value] 0
	float get_reflect_dim_distance_falloff() const { return getFloat("reflect_dim_distance_falloff"); }
};

class BRDFModoUnity : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "BRDFModoUnity"; }

	//! Multiplier for the 'albedo' texture.
 	//! [Default value] Color(1, 1, 1)
	bool set_albedo_mult(const Color& color) { return setValue("albedo_mult", color); }
	//! Multiplier for the 'albedo' texture.
 	//! [Default value] Color(1, 1, 1)
	Color get_albedo_mult() const { return getColor("albedo_mult"); }

	//! The base color is used as the main reflection color for both the dielectric and metallic sub-materials.
 	//! [UI Guides] displayName=Base Albedo, attributes=textureSlot
 	bool set_albedo(const Plugin& texture) { return setValue("albedo", texture); }
	//! The base color is used as the main reflection color for both the dielectric and metallic sub-materials.
 	//! [UI Guides] displayName=Base Albedo, attributes=textureSlot
 	bool set_albedo(const AColor& texture) { return setValue("albedo", texture); }
	//! The base color is used as the main reflection color for both the dielectric and metallic sub-materials.
 	//! [UI Guides] displayName=Base Albedo, attributes=textureSlot
 	Value get_albedo() const { return getValue("albedo"); }

	//! The metallic amount defines the mix between the dielectric and metallic sub-materials. 0.0 - only dieletric (diffuse + white specular with fresnel).1.0 - only metallic (tinted specular with NO fresnel).
 	//! [UI Guides] minValue=0.0, maxValue=1.0
 	bool set_metallic(const Plugin& texturefloat) { return setValue("metallic", texturefloat); }
	//! The metallic amount defines the mix between the dielectric and metallic sub-materials. 0.0 - only dieletric (diffuse + white specular with fresnel).1.0 - only metallic (tinted specular with NO fresnel).
 	//! [UI Guides] minValue=0.0, maxValue=1.0
 	bool set_metallic(float texturefloat) { return setValue("metallic", texturefloat); }
	//! The metallic amount defines the mix between the dielectric and metallic sub-materials. 0.0 - only dieletric (diffuse + white specular with fresnel).1.0 - only metallic (tinted specular with NO fresnel).
 	//! [UI Guides] minValue=0.0, maxValue=1.0
 	Value get_metallic() const { return getValue("metallic"); }

	//! Smoothness for both the dielectric and metallic sub-materials. Same as V-Ray glossiness.
 	//! [UI Guides] minValue=0.0, maxValue=1.0
 	bool set_smoothness(const Plugin& texturefloat) { return setValue("smoothness", texturefloat); }
	//! Smoothness for both the dielectric and metallic sub-materials. Same as V-Ray glossiness.
 	//! [UI Guides] minValue=0.0, maxValue=1.0
 	bool set_smoothness(float texturefloat) { return setValue("smoothness", texturefloat); }
	//! Smoothness for both the dielectric and metallic sub-materials. Same as V-Ray glossiness.
 	//! [UI Guides] minValue=0.0, maxValue=1.0
 	Value get_smoothness() const { return getValue("smoothness"); }

	//! Multiplier for the 'emissive' texture.
 	//! [Default value] Color(1, 1, 1)
	bool set_emissive_mult(const Color& color) { return setValue("emissive_mult", color); }
	//! Multiplier for the 'emissive' texture.
 	//! [Default value] Color(1, 1, 1)
	Color get_emissive_mult() const { return getColor("emissive_mult"); }

	//! Emission color.
 	//! [UI Guides] displayName=Emissive Color, attributes=textureSlot
 	bool set_emissive(const Plugin& texture) { return setValue("emissive", texture); }
	//! Emission color.
 	//! [UI Guides] displayName=Emissive Color, attributes=textureSlot
 	bool set_emissive(const AColor& texture) { return setValue("emissive", texture); }
	//! Emission color.
 	//! [UI Guides] displayName=Emissive Color, attributes=textureSlot
 	Value get_emissive() const { return getValue("emissive"); }

	//! Multiplier for the emissive color.
 	//! [UI Guides] displayName=Emissive Level, minValue=0.0
 	//! [Default value] 1
	bool set_emissivelevel(float val) { return setValue("emissivelevel", val); }
	//! Multiplier for the emissive color.
 	//! [UI Guides] displayName=Emissive Level, minValue=0.0
 	//! [Default value] 1
	float get_emissivelevel() const { return getFloat("emissivelevel"); }

	//! Incident fresnel reflection amount for the dielectric sub-material.
 	//! [UI Guides] displayName=Fresnel Reflectance 0, minValue=0.0, maxValue=1.0
 	//! [Default value] 0.04
	bool set_fresrel0(float val) { return setValue("fresrel0", val); }
	//! Incident fresnel reflection amount for the dielectric sub-material.
 	//! [UI Guides] displayName=Fresnel Reflectance 0, minValue=0.0, maxValue=1.0
 	//! [Default value] 0.04
	float get_fresrel0() const { return getFloat("fresrel0"); }

	//! Number of reflection rays. This is the square of the V-Ray subdivs parameter.
 	//! [UI Guides] displayName=Reflection rays, minValue=1
 	//! [Default value] 64
	bool set_reflRays(int val) { return setValue("reflRays", val); }
	//! Number of reflection rays. This is the square of the V-Ray subdivs parameter.
 	//! [UI Guides] displayName=Reflection rays, minValue=1
 	//! [Default value] 64
	int get_reflRays() const { return getInt("reflRays"); }

	//! This map is NOT used when rendering with V-Ray. The purpose of this parameter is to facilitate export/import to/from a .vrscene of the ambient occlusion map.
 	//! [UI Guides] attributes=textureSlot
 	bool set_ambient_occlusion_map(const Plugin& texture) { return setValue("ambient_occlusion_map", texture); }
	//! This map is NOT used when rendering with V-Ray. The purpose of this parameter is to facilitate export/import to/from a .vrscene of the ambient occlusion map.
 	//! [UI Guides] attributes=textureSlot
 	bool set_ambient_occlusion_map(const AColor& texture) { return setValue("ambient_occlusion_map", texture); }
	//! This map is NOT used when rendering with V-Ray. The purpose of this parameter is to facilitate export/import to/from a .vrscene of the ambient occlusion map.
 	//! [UI Guides] attributes=textureSlot
 	Value get_ambient_occlusion_map() const { return getValue("ambient_occlusion_map"); }
};

class BRDFModoUnreal : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "BRDFModoUnreal"; }

	//! The base color is used as the main reflection color for both the dielectric and metallic sub-materials.
 	//! [UI Guides] displayName=Base Color
 	bool set_base(const Plugin& texture) { return setValue("base", texture); }
	//! The base color is used as the main reflection color for both the dielectric and metallic sub-materials.
 	//! [UI Guides] displayName=Base Color
 	bool set_base(const AColor& texture) { return setValue("base", texture); }
	//! The base color is used as the main reflection color for both the dielectric and metallic sub-materials.
 	//! [UI Guides] displayName=Base Color
 	Value get_base() const { return getValue("base"); }

	//! The metallic amount defines the mix between the dielectric and metallic sub-materials. 0.0 - only dieletric (diffuse + white specular with fresnel).1.0 - only metallic (tinted specular with NO fresnel).
 	//! [UI Guides] minValue=0.0, maxValue=1.0
 	bool set_metallic(const Plugin& texturefloat) { return setValue("metallic", texturefloat); }
	//! The metallic amount defines the mix between the dielectric and metallic sub-materials. 0.0 - only dieletric (diffuse + white specular with fresnel).1.0 - only metallic (tinted specular with NO fresnel).
 	//! [UI Guides] minValue=0.0, maxValue=1.0
 	bool set_metallic(float texturefloat) { return setValue("metallic", texturefloat); }
	//! The metallic amount defines the mix between the dielectric and metallic sub-materials. 0.0 - only dieletric (diffuse + white specular with fresnel).1.0 - only metallic (tinted specular with NO fresnel).
 	//! [UI Guides] minValue=0.0, maxValue=1.0
 	Value get_metallic() const { return getValue("metallic"); }

	//! Incident specular amount for the dielectric sub-material.
 	//! [UI Guides] minValue=0.0, maxValue=12.5
 	bool set_specular(const Plugin& texturefloat) { return setValue("specular", texturefloat); }
	//! Incident specular amount for the dielectric sub-material.
 	//! [UI Guides] minValue=0.0, maxValue=12.5
 	bool set_specular(float texturefloat) { return setValue("specular", texturefloat); }
	//! Incident specular amount for the dielectric sub-material.
 	//! [UI Guides] minValue=0.0, maxValue=12.5
 	Value get_specular() const { return getValue("specular"); }

	//! Roughness for both the dielectric and metallic sub-materials.
 	//! [UI Guides] minValue=0.0, maxValue=1.0
 	bool set_roughness(const Plugin& texturefloat) { return setValue("roughness", texturefloat); }
	//! Roughness for both the dielectric and metallic sub-materials.
 	//! [UI Guides] minValue=0.0, maxValue=1.0
 	bool set_roughness(float texturefloat) { return setValue("roughness", texturefloat); }
	//! Roughness for both the dielectric and metallic sub-materials.
 	//! [UI Guides] minValue=0.0, maxValue=1.0
 	Value get_roughness() const { return getValue("roughness"); }

	//! Emission color.
 	//! [UI Guides] displayName=Emissive Color
 	bool set_emissive(const Plugin& texture) { return setValue("emissive", texture); }
	//! Emission color.
 	//! [UI Guides] displayName=Emissive Color
 	bool set_emissive(const AColor& texture) { return setValue("emissive", texture); }
	//! Emission color.
 	//! [UI Guides] displayName=Emissive Color
 	Value get_emissive() const { return getValue("emissive"); }

	//! Opacity of the whole material.
 	//! [UI Guides] displayName=Opacity, minValue=0.0, maxValue=1.0
 	bool set_opacityUE(const Plugin& texturefloat) { return setValue("opacityUE", texturefloat); }
	//! Opacity of the whole material.
 	//! [UI Guides] displayName=Opacity, minValue=0.0, maxValue=1.0
 	bool set_opacityUE(float texturefloat) { return setValue("opacityUE", texturefloat); }
	//! Opacity of the whole material.
 	//! [UI Guides] displayName=Opacity, minValue=0.0, maxValue=1.0
 	Value get_opacityUE() const { return getValue("opacityUE"); }

	//! Number of reflection rays. This is the square of the V-Ray subdivs parameter.
 	//! [UI Guides] displayName=Reflection rays, minValue=1
 	//! [Default value] 64
	bool set_reflRays(int val) { return setValue("reflRays", val); }
	//! Number of reflection rays. This is the square of the V-Ray subdivs parameter.
 	//! [UI Guides] displayName=Reflection rays, minValue=1
 	//! [Default value] 64
	int get_reflRays() const { return getInt("reflRays"); }

	//! This map is NOT used when rendering with V-Ray. The purpose of this parameter is to facilitate export/import to/from a .vrscene of the ambient occlusion map.
 	//! [UI Guides] attributes=textureSlot
 	bool set_ambient_occlusion_map(const Plugin& texture) { return setValue("ambient_occlusion_map", texture); }
	//! This map is NOT used when rendering with V-Ray. The purpose of this parameter is to facilitate export/import to/from a .vrscene of the ambient occlusion map.
 	//! [UI Guides] attributes=textureSlot
 	bool set_ambient_occlusion_map(const AColor& texture) { return setValue("ambient_occlusion_map", texture); }
	//! This map is NOT used when rendering with V-Ray. The purpose of this parameter is to facilitate export/import to/from a .vrscene of the ambient occlusion map.
 	//! [UI Guides] attributes=textureSlot
 	Value get_ambient_occlusion_map() const { return getValue("ambient_occlusion_map"); }
};

class BRDFMultiBump : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "BRDFMultiBump"; }

	//! Base BRDF
 	bool set_base_brdf(const Plugin& plugin) { return setValue("base_brdf", plugin); }
	//! Base BRDF
 	Plugin get_base_brdf() const { return getPlugin("base_brdf"); }

	//! Bump texture
 	bool set_bump_tex_0(const Plugin& texture) { return setValue("bump_tex_0", texture); }
	//! Bump texture
 	bool set_bump_tex_0(const AColor& texture) { return setValue("bump_tex_0", texture); }
	//! Bump texture
 	Value get_bump_tex_0() const { return getValue("bump_tex_0"); }

	//! Bump multipler 0
 	bool set_bump_mult_0(const Plugin& texturefloat) { return setValue("bump_mult_0", texturefloat); }
	//! Bump multipler 0
 	bool set_bump_mult_0(float texturefloat) { return setValue("bump_mult_0", texturefloat); }
	//! Bump multipler 0
 	Value get_bump_mult_0() const { return getValue("bump_mult_0"); }

	//! A list with the type of the maps (0 - from regular texture output, 1 - normal map in tangent space, 2 - normal map in object space, 3 - normal map in camera space, 4 - normal map in world space, 5 - from texture bump output, 6 - explicit normal)
 	//! [UI Guides] enum=0:Bump Map;1:Normal map in tangent space;2:Normal map in object space;3:Normal map in screen space;4:Normal map in world space;5:From texture bump output;6:Explicit normal
 	//! [Default value] 0
	bool set_map_type_0(int val) { return setValue("map_type_0", val); }
	//! A list with the type of the maps (0 - from regular texture output, 1 - normal map in tangent space, 2 - normal map in object space, 3 - normal map in camera space, 4 - normal map in world space, 5 - from texture bump output, 6 - explicit normal)
 	//! [UI Guides] enum=0:Bump Map;1:Normal map in tangent space;2:Normal map in object space;3:Normal map in screen space;4:Normal map in world space;5:From texture bump output;6:Explicit normal
 	//! [Default value] 0
	int get_map_type_0() const { return getInt("map_type_0"); }

	//! Bump texture
 	bool set_bump_tex_1(const Plugin& texture) { return setValue("bump_tex_1", texture); }
	//! Bump texture
 	bool set_bump_tex_1(const AColor& texture) { return setValue("bump_tex_1", texture); }
	//! Bump texture
 	Value get_bump_tex_1() const { return getValue("bump_tex_1"); }

	//! Bump multipler 0
 	bool set_bump_mult_1(const Plugin& texturefloat) { return setValue("bump_mult_1", texturefloat); }
	//! Bump multipler 0
 	bool set_bump_mult_1(float texturefloat) { return setValue("bump_mult_1", texturefloat); }
	//! Bump multipler 0
 	Value get_bump_mult_1() const { return getValue("bump_mult_1"); }

	//! A list with the type of the maps (0 - from regular texture output, 1 - normal map in tangent space, 2 - normal map in object space, 3 - normal map in camera space, 4 - normal map in world space, 5 - from texture bump output, 6 - explicit normal)
 	//! [UI Guides] enum=0:Bump Map;1:Normal map in tangent space;2:Normal map in object space;3:Normal map in screen space;4:Normal map in world space;5:From texture bump output;6:Explicit normal
 	//! [Default value] 0
	bool set_map_type_1(int val) { return setValue("map_type_1", val); }
	//! A list with the type of the maps (0 - from regular texture output, 1 - normal map in tangent space, 2 - normal map in object space, 3 - normal map in camera space, 4 - normal map in world space, 5 - from texture bump output, 6 - explicit normal)
 	//! [UI Guides] enum=0:Bump Map;1:Normal map in tangent space;2:Normal map in object space;3:Normal map in screen space;4:Normal map in world space;5:From texture bump output;6:Explicit normal
 	//! [Default value] 0
	int get_map_type_1() const { return getInt("map_type_1"); }

	//! Bump texture
 	bool set_bump_tex_2(const Plugin& texture) { return setValue("bump_tex_2", texture); }
	//! Bump texture
 	bool set_bump_tex_2(const AColor& texture) { return setValue("bump_tex_2", texture); }
	//! Bump texture
 	Value get_bump_tex_2() const { return getValue("bump_tex_2"); }

	//! Bump multipler 0
 	bool set_bump_mult_2(const Plugin& texturefloat) { return setValue("bump_mult_2", texturefloat); }
	//! Bump multipler 0
 	bool set_bump_mult_2(float texturefloat) { return setValue("bump_mult_2", texturefloat); }
	//! Bump multipler 0
 	Value get_bump_mult_2() const { return getValue("bump_mult_2"); }

	//! A list with the type of the maps (0 - from regular texture output, 1 - normal map in tangent space, 2 - normal map in object space, 3 - normal map in camera space, 4 - normal map in world space, 5 - from texture bump output, 6 - explicit normal)
 	//! [UI Guides] enum=0:Bump Map;1:Normal map in tangent space;2:Normal map in object space;3:Normal map in screen space;4:Normal map in world space;5:From texture bump output;6:Explicit normal
 	//! [Default value] 0
	bool set_map_type_2(int val) { return setValue("map_type_2", val); }
	//! A list with the type of the maps (0 - from regular texture output, 1 - normal map in tangent space, 2 - normal map in object space, 3 - normal map in camera space, 4 - normal map in world space, 5 - from texture bump output, 6 - explicit normal)
 	//! [UI Guides] enum=0:Bump Map;1:Normal map in tangent space;2:Normal map in object space;3:Normal map in screen space;4:Normal map in world space;5:From texture bump output;6:Explicit normal
 	//! [Default value] 0
	int get_map_type_2() const { return getInt("map_type_2"); }

	//! Bump texture
 	bool set_bump_tex_3(const Plugin& texture) { return setValue("bump_tex_3", texture); }
	//! Bump texture
 	bool set_bump_tex_3(const AColor& texture) { return setValue("bump_tex_3", texture); }
	//! Bump texture
 	Value get_bump_tex_3() const { return getValue("bump_tex_3"); }

	//! Bump multipler 0
 	bool set_bump_mult_3(const Plugin& texturefloat) { return setValue("bump_mult_3", texturefloat); }
	//! Bump multipler 0
 	bool set_bump_mult_3(float texturefloat) { return setValue("bump_mult_3", texturefloat); }
	//! Bump multipler 0
 	Value get_bump_mult_3() const { return getValue("bump_mult_3"); }

	//! A list with the type of the maps (0 - from regular texture output, 1 - normal map in tangent space, 2 - normal map in object space, 3 - normal map in camera space, 4 - normal map in world space, 5 - from texture bump output, 6 - explicit normal)
 	//! [UI Guides] enum=0:Bump Map;1:Normal map in tangent space;2:Normal map in object space;3:Normal map in screen space;4:Normal map in world space;5:From texture bump output;6:Explicit normal
 	//! [Default value] 0
	bool set_map_type_3(int val) { return setValue("map_type_3", val); }
	//! A list with the type of the maps (0 - from regular texture output, 1 - normal map in tangent space, 2 - normal map in object space, 3 - normal map in camera space, 4 - normal map in world space, 5 - from texture bump output, 6 - explicit normal)
 	//! [UI Guides] enum=0:Bump Map;1:Normal map in tangent space;2:Normal map in object space;3:Normal map in screen space;4:Normal map in world space;5:From texture bump output;6:Explicit normal
 	//! [Default value] 0
	int get_map_type_3() const { return getInt("map_type_3"); }

	//! The uvw generator for the normal map texture when map_type is 1.
 	bool set_normal_uvwgen(const Plugin& plugin) { return setValue("normal_uvwgen", plugin); }
	//! The uvw generator for the normal map texture when map_type is 1.
 	Plugin get_normal_uvwgen() const { return getPlugin("normal_uvwgen"); }
};

class BRDFPhong : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "BRDFPhong"; }

	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	bool set_color(const Color& color) { return setValue("color", color); }
	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	Color get_color() const { return getColor("color"); }

	//! (description missing)
	bool set_color_tex(const Plugin& texture) { return setValue("color_tex", texture); }
	//! (description missing)
	bool set_color_tex(const AColor& texture) { return setValue("color_tex", texture); }
	//! (description missing)
	Value get_color_tex() const { return getValue("color_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_color_tex_mult(float val) { return setValue("color_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_color_tex_mult() const { return getFloat("color_tex_mult"); }

	//! (description missing)
	//! [Default value] Color(0, 0, 0)
	bool set_transparency(const Color& color) { return setValue("transparency", color); }
	//! (description missing)
	//! [Default value] Color(0, 0, 0)
	Color get_transparency() const { return getColor("transparency"); }

	//! (description missing)
	bool set_transparency_tex(const Plugin& texture) { return setValue("transparency_tex", texture); }
	//! (description missing)
	bool set_transparency_tex(const AColor& texture) { return setValue("transparency_tex", texture); }
	//! (description missing)
	Value get_transparency_tex() const { return getValue("transparency_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_transparency_tex_mult(float val) { return setValue("transparency_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_transparency_tex_mult() const { return getFloat("transparency_tex_mult"); }

	//! (description missing)
	//! [Default value] 0.01
	bool set_cutoff(float val) { return setValue("cutoff", val); }
	//! (description missing)
	//! [Default value] 0.01
	float get_cutoff() const { return getFloat("cutoff"); }

	//! (description missing)
	//! [Default value] false
	bool set_back_side(bool val) { return setValue("back_side", val); }
	//! (description missing)
	//! [Default value] false
	bool get_back_side() const { return getBool("back_side"); }

	//! (description missing)
	//! [Default value] true
	bool set_trace_reflections(bool val) { return setValue("trace_reflections", val); }
	//! (description missing)
	//! [Default value] true
	bool get_trace_reflections() const { return getBool("trace_reflections"); }

	//! The maximum reflection depth (-1 is controlled by the global options)
 	//! [Default value] -1
	bool set_trace_depth(int val) { return setValue("trace_depth", val); }
	//! The maximum reflection depth (-1 is controlled by the global options)
 	//! [Default value] -1
	int get_trace_depth() const { return getInt("trace_depth"); }

	//! Specifies how render channels are propagated through the BRDF (0 - only the color channel; 1 - color and alpha; 2 - all channels
 	//! [Default value] 0
	bool set_affect_alpha(int val) { return setValue("affect_alpha", val); }
	//! Specifies how render channels are propagated through the BRDF (0 - only the color channel; 1 - color and alpha; 2 - all channels
 	//! [Default value] 0
	int get_affect_alpha() const { return getInt("affect_alpha"); }

	//! The color to use when the maximum depth is reached
 	bool set_reflect_exit_color(const Plugin& texture) { return setValue("reflect_exit_color", texture); }
	//! The color to use when the maximum depth is reached
 	bool set_reflect_exit_color(const AColor& texture) { return setValue("reflect_exit_color", texture); }
	//! The color to use when the maximum depth is reached
 	Value get_reflect_exit_color() const { return getValue("reflect_exit_color"); }

	//! True to enable dim distance
 	//! [Default value] false
	bool set_reflect_dim_distance_on(bool val) { return setValue("reflect_dim_distance_on", val); }
	//! True to enable dim distance
 	//! [Default value] false
	bool get_reflect_dim_distance_on() const { return getBool("reflect_dim_distance_on"); }

	//! How much to dim reflection as length of rays increases
 	//! [UI Guides] quantityType=distance
 	//! [Default value] 1e+018
	bool set_reflect_dim_distance(float val) { return setValue("reflect_dim_distance", val); }
	//! How much to dim reflection as length of rays increases
 	//! [UI Guides] quantityType=distance
 	//! [Default value] 1e+018
	float get_reflect_dim_distance() const { return getFloat("reflect_dim_distance"); }

	//! Fall off for the dim distance
 	//! [Default value] 0
	bool set_reflect_dim_distance_falloff(float val) { return setValue("reflect_dim_distance_falloff", val); }
	//! Fall off for the dim distance
 	//! [Default value] 0
	float get_reflect_dim_distance_falloff() const { return getFloat("reflect_dim_distance_falloff"); }

	//! (description missing)
	//! [Default value] 0.8
	bool set_hilightGlossiness(float val) { return setValue("hilightGlossiness", val); }
	//! (description missing)
	//! [Default value] 0.8
	float get_hilightGlossiness() const { return getFloat("hilightGlossiness"); }

	//! (description missing)
	bool set_hilightGlossiness_tex(const Plugin& texturefloat) { return setValue("hilightGlossiness_tex", texturefloat); }
	//! (description missing)
	bool set_hilightGlossiness_tex(float texturefloat) { return setValue("hilightGlossiness_tex", texturefloat); }
	//! (description missing)
	Value get_hilightGlossiness_tex() const { return getValue("hilightGlossiness_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_hilightGlossiness_tex_mult(float val) { return setValue("hilightGlossiness_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_hilightGlossiness_tex_mult() const { return getFloat("hilightGlossiness_tex_mult"); }

	//! (description missing)
	//! [Default value] 0.8
	bool set_reflectionGlossiness(float val) { return setValue("reflectionGlossiness", val); }
	//! (description missing)
	//! [Default value] 0.8
	float get_reflectionGlossiness() const { return getFloat("reflectionGlossiness"); }

	//! (description missing)
	bool set_reflectionGlossiness_tex(const Plugin& texturefloat) { return setValue("reflectionGlossiness_tex", texturefloat); }
	//! (description missing)
	bool set_reflectionGlossiness_tex(float texturefloat) { return setValue("reflectionGlossiness_tex", texturefloat); }
	//! (description missing)
	Value get_reflectionGlossiness_tex() const { return getValue("reflectionGlossiness_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_reflectionGlossiness_tex_mult(float val) { return setValue("reflectionGlossiness_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_reflectionGlossiness_tex_mult() const { return getFloat("reflectionGlossiness_tex_mult"); }

	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	bool set_subdivs(int val) { return setValue("subdivs", val); }
	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	int get_subdivs() const { return getInt("subdivs"); }

	//! Determines if the glossy rays are treated by V-Ray as GI rays: 0 - never; 1 - only for rays that are already marked as GI rays; 2 - always
 	//! [Default value] 1
	bool set_glossyAsGI(int val) { return setValue("glossyAsGI", val); }
	//! Determines if the glossy rays are treated by V-Ray as GI rays: 0 - never; 1 - only for rays that are already marked as GI rays; 2 - always
 	//! [Default value] 1
	int get_glossyAsGI() const { return getInt("glossyAsGI"); }

	//! Soften edge of the BRDF at light/shadow transition
 	//! [Default value] 0
	bool set_soften_edge(float val) { return setValue("soften_edge", val); }
	//! Soften edge of the BRDF at light/shadow transition
 	//! [Default value] 0
	float get_soften_edge() const { return getFloat("soften_edge"); }

	//! (description missing)
	//! [Default value] 0
	bool set_interpolation_on(int val) { return setValue("interpolation_on", val); }
	//! (description missing)
	//! [Default value] 0
	int get_interpolation_on() const { return getInt("interpolation_on"); }

	//! (description missing)
	//! [Default value] -1
	bool set_imap_min_rate(int val) { return setValue("imap_min_rate", val); }
	//! (description missing)
	//! [Default value] -1
	int get_imap_min_rate() const { return getInt("imap_min_rate"); }

	//! (description missing)
	//! [Default value] 1
	bool set_imap_max_rate(int val) { return setValue("imap_max_rate", val); }
	//! (description missing)
	//! [Default value] 1
	int get_imap_max_rate() const { return getInt("imap_max_rate"); }

	//! (description missing)
	//! [Default value] 0.25
	bool set_imap_color_thresh(float val) { return setValue("imap_color_thresh", val); }
	//! (description missing)
	//! [Default value] 0.25
	float get_imap_color_thresh() const { return getFloat("imap_color_thresh"); }

	//! (description missing)
	//! [Default value] 0.4
	bool set_imap_norm_thresh(float val) { return setValue("imap_norm_thresh", val); }
	//! (description missing)
	//! [Default value] 0.4
	float get_imap_norm_thresh() const { return getFloat("imap_norm_thresh"); }

	//! (description missing)
	//! [Default value] 20
	bool set_imap_samples(int val) { return setValue("imap_samples", val); }
	//! (description missing)
	//! [Default value] 20
	int get_imap_samples() const { return getInt("imap_samples"); }
};

class BRDFReflection : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "BRDFReflection"; }

	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	bool set_color(const Color& color) { return setValue("color", color); }
	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	Color get_color() const { return getColor("color"); }

	//! (description missing)
	bool set_color_tex(const Plugin& texture) { return setValue("color_tex", texture); }
	//! (description missing)
	bool set_color_tex(const AColor& texture) { return setValue("color_tex", texture); }
	//! (description missing)
	Value get_color_tex() const { return getValue("color_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_color_tex_mult(float val) { return setValue("color_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_color_tex_mult() const { return getFloat("color_tex_mult"); }

	//! (description missing)
	//! [Default value] Color(0, 0, 0)
	bool set_transparency(const Color& color) { return setValue("transparency", color); }
	//! (description missing)
	//! [Default value] Color(0, 0, 0)
	Color get_transparency() const { return getColor("transparency"); }

	//! (description missing)
	bool set_transparency_tex(const Plugin& texture) { return setValue("transparency_tex", texture); }
	//! (description missing)
	bool set_transparency_tex(const AColor& texture) { return setValue("transparency_tex", texture); }
	//! (description missing)
	Value get_transparency_tex() const { return getValue("transparency_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_transparency_tex_mult(float val) { return setValue("transparency_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_transparency_tex_mult() const { return getFloat("transparency_tex_mult"); }

	//! (description missing)
	//! [Default value] 0.01
	bool set_cutoff(float val) { return setValue("cutoff", val); }
	//! (description missing)
	//! [Default value] 0.01
	float get_cutoff() const { return getFloat("cutoff"); }

	//! (description missing)
	//! [Default value] false
	bool set_back_side(bool val) { return setValue("back_side", val); }
	//! (description missing)
	//! [Default value] false
	bool get_back_side() const { return getBool("back_side"); }

	//! (description missing)
	//! [Default value] true
	bool set_trace_reflections(bool val) { return setValue("trace_reflections", val); }
	//! (description missing)
	//! [Default value] true
	bool get_trace_reflections() const { return getBool("trace_reflections"); }

	//! The maximum reflection depth (-1 is controlled by the global options)
 	//! [Default value] -1
	bool set_trace_depth(int val) { return setValue("trace_depth", val); }
	//! The maximum reflection depth (-1 is controlled by the global options)
 	//! [Default value] -1
	int get_trace_depth() const { return getInt("trace_depth"); }

	//! Specifies how render channels are propagated through the BRDF (0 - only the color channel; 1 - color and alpha; 2 - all channels
 	//! [Default value] 0
	bool set_affect_alpha(int val) { return setValue("affect_alpha", val); }
	//! Specifies how render channels are propagated through the BRDF (0 - only the color channel; 1 - color and alpha; 2 - all channels
 	//! [Default value] 0
	int get_affect_alpha() const { return getInt("affect_alpha"); }

	//! The color to use when the maximum depth is reached
 	bool set_reflect_exit_color(const Plugin& texture) { return setValue("reflect_exit_color", texture); }
	//! The color to use when the maximum depth is reached
 	bool set_reflect_exit_color(const AColor& texture) { return setValue("reflect_exit_color", texture); }
	//! The color to use when the maximum depth is reached
 	Value get_reflect_exit_color() const { return getValue("reflect_exit_color"); }

	//! True to enable dim distance
 	//! [Default value] false
	bool set_reflect_dim_distance_on(bool val) { return setValue("reflect_dim_distance_on", val); }
	//! True to enable dim distance
 	//! [Default value] false
	bool get_reflect_dim_distance_on() const { return getBool("reflect_dim_distance_on"); }

	//! How much to dim reflection as length of rays increases
 	//! [UI Guides] quantityType=distance
 	//! [Default value] 1e+018
	bool set_reflect_dim_distance(float val) { return setValue("reflect_dim_distance", val); }
	//! How much to dim reflection as length of rays increases
 	//! [UI Guides] quantityType=distance
 	//! [Default value] 1e+018
	float get_reflect_dim_distance() const { return getFloat("reflect_dim_distance"); }

	//! Fall off for the dim distance
 	//! [Default value] 0
	bool set_reflect_dim_distance_falloff(float val) { return setValue("reflect_dim_distance_falloff", val); }
	//! Fall off for the dim distance
 	//! [Default value] 0
	float get_reflect_dim_distance_falloff() const { return getFloat("reflect_dim_distance_falloff"); }

	//! (description missing)
	//! [Default value] 0.8
	bool set_hilightGlossiness(float val) { return setValue("hilightGlossiness", val); }
	//! (description missing)
	//! [Default value] 0.8
	float get_hilightGlossiness() const { return getFloat("hilightGlossiness"); }

	//! (description missing)
	bool set_hilightGlossiness_tex(const Plugin& texturefloat) { return setValue("hilightGlossiness_tex", texturefloat); }
	//! (description missing)
	bool set_hilightGlossiness_tex(float texturefloat) { return setValue("hilightGlossiness_tex", texturefloat); }
	//! (description missing)
	Value get_hilightGlossiness_tex() const { return getValue("hilightGlossiness_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_hilightGlossiness_tex_mult(float val) { return setValue("hilightGlossiness_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_hilightGlossiness_tex_mult() const { return getFloat("hilightGlossiness_tex_mult"); }

	//! (description missing)
	//! [Default value] 0.8
	bool set_reflectionGlossiness(float val) { return setValue("reflectionGlossiness", val); }
	//! (description missing)
	//! [Default value] 0.8
	float get_reflectionGlossiness() const { return getFloat("reflectionGlossiness"); }

	//! (description missing)
	bool set_reflectionGlossiness_tex(const Plugin& texturefloat) { return setValue("reflectionGlossiness_tex", texturefloat); }
	//! (description missing)
	bool set_reflectionGlossiness_tex(float texturefloat) { return setValue("reflectionGlossiness_tex", texturefloat); }
	//! (description missing)
	Value get_reflectionGlossiness_tex() const { return getValue("reflectionGlossiness_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_reflectionGlossiness_tex_mult(float val) { return setValue("reflectionGlossiness_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_reflectionGlossiness_tex_mult() const { return getFloat("reflectionGlossiness_tex_mult"); }

	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	bool set_subdivs(int val) { return setValue("subdivs", val); }
	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	int get_subdivs() const { return getInt("subdivs"); }

	//! Determines if the glossy rays are treated by V-Ray as GI rays: 0 - never; 1 - only for rays that are already marked as GI rays; 2 - always
 	//! [Default value] 1
	bool set_glossyAsGI(int val) { return setValue("glossyAsGI", val); }
	//! Determines if the glossy rays are treated by V-Ray as GI rays: 0 - never; 1 - only for rays that are already marked as GI rays; 2 - always
 	//! [Default value] 1
	int get_glossyAsGI() const { return getInt("glossyAsGI"); }

	//! Soften edge of the BRDF at light/shadow transition
 	//! [Default value] 0
	bool set_soften_edge(float val) { return setValue("soften_edge", val); }
	//! Soften edge of the BRDF at light/shadow transition
 	//! [Default value] 0
	float get_soften_edge() const { return getFloat("soften_edge"); }

	//! (description missing)
	//! [Default value] 0
	bool set_interpolation_on(int val) { return setValue("interpolation_on", val); }
	//! (description missing)
	//! [Default value] 0
	int get_interpolation_on() const { return getInt("interpolation_on"); }

	//! (description missing)
	//! [Default value] -1
	bool set_imap_min_rate(int val) { return setValue("imap_min_rate", val); }
	//! (description missing)
	//! [Default value] -1
	int get_imap_min_rate() const { return getInt("imap_min_rate"); }

	//! (description missing)
	//! [Default value] 1
	bool set_imap_max_rate(int val) { return setValue("imap_max_rate", val); }
	//! (description missing)
	//! [Default value] 1
	int get_imap_max_rate() const { return getInt("imap_max_rate"); }

	//! (description missing)
	//! [Default value] 0.25
	bool set_imap_color_thresh(float val) { return setValue("imap_color_thresh", val); }
	//! (description missing)
	//! [Default value] 0.25
	float get_imap_color_thresh() const { return getFloat("imap_color_thresh"); }

	//! (description missing)
	//! [Default value] 0.4
	bool set_imap_norm_thresh(float val) { return setValue("imap_norm_thresh", val); }
	//! (description missing)
	//! [Default value] 0.4
	float get_imap_norm_thresh() const { return getFloat("imap_norm_thresh"); }

	//! (description missing)
	//! [Default value] 20
	bool set_imap_samples(int val) { return setValue("imap_samples", val); }
	//! (description missing)
	//! [Default value] 20
	int get_imap_samples() const { return getInt("imap_samples"); }

	//! 0-Blinn, 1-Phong, 2-Ward
 	//! [Default value] 0
	bool set_shaderType(int val) { return setValue("shaderType", val); }
	//! 0-Blinn, 1-Phong, 2-Ward
 	//! [Default value] 0
	int get_shaderType() const { return getInt("shaderType"); }

	//! reflection anisotropy in the range (-1, 1)
 	//! [Default value] 0
	bool set_anisotropy(float val) { return setValue("anisotropy", val); }
	//! reflection anisotropy in the range (-1, 1)
 	//! [Default value] 0
	float get_anisotropy() const { return getFloat("anisotropy"); }

	//! Texture for reflection anisotropy in the range (-1, 1)
 	bool set_anisotropy_tex(const Plugin& texturefloat) { return setValue("anisotropy_tex", texturefloat); }
	//! Texture for reflection anisotropy in the range (-1, 1)
 	bool set_anisotropy_tex(float texturefloat) { return setValue("anisotropy_tex", texturefloat); }
	//! Texture for reflection anisotropy in the range (-1, 1)
 	Value get_anisotropy_tex() const { return getValue("anisotropy_tex"); }

	//! Multiplier for anisotropy texture
 	//! [Default value] 1
	bool set_anisotropy_tex_mult(float val) { return setValue("anisotropy_tex_mult", val); }
	//! Multiplier for anisotropy texture
 	//! [Default value] 1
	float get_anisotropy_tex_mult() const { return getFloat("anisotropy_tex_mult"); }

	//! anisotropy rotation in the range [0, 1]
 	//! [Default value] 0
	bool set_anisotropy_rotation(float val) { return setValue("anisotropy_rotation", val); }
	//! anisotropy rotation in the range [0, 1]
 	//! [Default value] 0
	float get_anisotropy_rotation() const { return getFloat("anisotropy_rotation"); }

	//! Texture for anisotropy rotation in the range [0, 1]
 	bool set_anisotropy_rotation_tex(const Plugin& texturefloat) { return setValue("anisotropy_rotation_tex", texturefloat); }
	//! Texture for anisotropy rotation in the range [0, 1]
 	bool set_anisotropy_rotation_tex(float texturefloat) { return setValue("anisotropy_rotation_tex", texturefloat); }
	//! Texture for anisotropy rotation in the range [0, 1]
 	Value get_anisotropy_rotation_tex() const { return getValue("anisotropy_rotation_tex"); }

	//! Multiplier for anisotropy rotation texture
 	//! [Default value] 1
	bool set_anisotropy_rotation_tex_mult(float val) { return setValue("anisotropy_rotation_tex_mult", val); }
	//! Multiplier for anisotropy rotation texture
 	//! [Default value] 1
	float get_anisotropy_rotation_tex_mult() const { return getFloat("anisotropy_rotation_tex_mult"); }

	//! Which axis to use for anistropy 0=x 1=y 2=z
 	//! [Default value] 2
	bool set_anisotropy_local_axis(int val) { return setValue("anisotropy_local_axis", val); }
	//! Which axis to use for anistropy 0=x 1=y 2=z
 	//! [Default value] 2
	int get_anisotropy_local_axis() const { return getInt("anisotropy_local_axis"); }

	//! What uvw map channel to use for anistropy
 	//! [Default value] 1
	bool set_anisotropy_map_channel(int val) { return setValue("anisotropy_map_channel", val); }
	//! What uvw map channel to use for anistropy
 	//! [Default value] 1
	int get_anisotropy_map_channel() const { return getInt("anisotropy_map_channel"); }

	//! Whether to use a map channel instead of a local axis
 	//! [Default value] true
	bool set_anisotropy_use_map_channel(bool val) { return setValue("anisotropy_use_map_channel", val); }
	//! Whether to use a map channel instead of a local axis
 	//! [Default value] true
	bool get_anisotropy_use_map_channel() const { return getBool("anisotropy_use_map_channel"); }

	//! If this is provided we will use it, otherwise we will make our own based on the local-axis/ map channel settings
 	bool set_anisotropy_uvwgen(const Plugin& plugin) { return setValue("anisotropy_uvwgen", plugin); }
	//! If this is provided we will use it, otherwise we will make our own based on the local-axis/ map channel settings
 	Plugin get_anisotropy_uvwgen() const { return getPlugin("anisotropy_uvwgen"); }

	//! true to fix dark edges with glossy reflections; only set this to false for compatibility with older versions
 	//! [Default value] true
	bool set_fix_dark_edges(bool val) { return setValue("fix_dark_edges", val); }
	//! true to fix dark edges with glossy reflections; only set this to false for compatibility with older versions
 	//! [Default value] true
	bool get_fix_dark_edges() const { return getBool("fix_dark_edges"); }
};

class BRDFRefraction : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "BRDFRefraction"; }

	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	bool set_color(const Color& color) { return setValue("color", color); }
	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	Color get_color() const { return getColor("color"); }

	//! (description missing)
	bool set_color_tex(const Plugin& texture) { return setValue("color_tex", texture); }
	//! (description missing)
	bool set_color_tex(const AColor& texture) { return setValue("color_tex", texture); }
	//! (description missing)
	Value get_color_tex() const { return getValue("color_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_color_tex_mult(float val) { return setValue("color_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_color_tex_mult() const { return getFloat("color_tex_mult"); }

	//! (description missing)
	//! [Default value] Color(0, 0, 0)
	bool set_transparency(const Color& color) { return setValue("transparency", color); }
	//! (description missing)
	//! [Default value] Color(0, 0, 0)
	Color get_transparency() const { return getColor("transparency"); }

	//! (description missing)
	bool set_transparency_tex(const Plugin& texture) { return setValue("transparency_tex", texture); }
	//! (description missing)
	bool set_transparency_tex(const AColor& texture) { return setValue("transparency_tex", texture); }
	//! (description missing)
	Value get_transparency_tex() const { return getValue("transparency_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_transparency_tex_mult(float val) { return setValue("transparency_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_transparency_tex_mult() const { return getFloat("transparency_tex_mult"); }

	//! IOR for the glass; this is ignored if the surface has a volume shader (the volume IOR is used).
 	//! [Default value] 1.55
	bool set_ior(float val) { return setValue("ior", val); }
	//! IOR for the glass; this is ignored if the surface has a volume shader (the volume IOR is used).
 	//! [Default value] 1.55
	float get_ior() const { return getFloat("ior"); }

	//! (description missing)
	bool set_ior_tex(const Plugin& texturefloat) { return setValue("ior_tex", texturefloat); }
	//! (description missing)
	bool set_ior_tex(float texturefloat) { return setValue("ior_tex", texturefloat); }
	//! (description missing)
	Value get_ior_tex() const { return getValue("ior_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_ior_tex_mult(float val) { return setValue("ior_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_ior_tex_mult() const { return getFloat("ior_tex_mult"); }

	//! (description missing)
	//! [Default value] 0.01
	bool set_cutoff(float val) { return setValue("cutoff", val); }
	//! (description missing)
	//! [Default value] 0.01
	float get_cutoff() const { return getFloat("cutoff"); }

	//! (description missing)
	//! [Default value] false
	bool set_affect_shadows(bool val) { return setValue("affect_shadows", val); }
	//! (description missing)
	//! [Default value] false
	bool get_affect_shadows() const { return getBool("affect_shadows"); }

	//! (description missing)
	//! [Default value] false
	bool set_affect_alpha(bool val) { return setValue("affect_alpha", val); }
	//! (description missing)
	//! [Default value] false
	bool get_affect_alpha() const { return getBool("affect_alpha"); }

	//! (description missing)
	//! [Default value] true
	bool set_trace_refractions(bool val) { return setValue("trace_refractions", val); }
	//! (description missing)
	//! [Default value] true
	bool get_trace_refractions() const { return getBool("trace_refractions"); }

	//! The maximum refraction bounces (-1 is controlled by the global options)
 	//! [Default value] -1
	bool set_trace_depth(int val) { return setValue("trace_depth", val); }
	//! The maximum refraction bounces (-1 is controlled by the global options)
 	//! [Default value] -1
	int get_trace_depth() const { return getInt("trace_depth"); }

	//! (description missing)
	//! [Default value] false
	bool set_exit_color_on(bool val) { return setValue("exit_color_on", val); }
	//! (description missing)
	//! [Default value] false
	bool get_exit_color_on() const { return getBool("exit_color_on"); }

	//! The color to use when the maximum depth is reached
 	//! [Default value] Color(0, 0, 0)
	bool set_reflect_exit_color(const Color& color) { return setValue("reflect_exit_color", color); }
	//! The color to use when the maximum depth is reached
 	//! [Default value] Color(0, 0, 0)
	Color get_reflect_exit_color() const { return getColor("reflect_exit_color"); }

	//! The color to use when maximum depth is reached when exit_color_on is true
 	//! [Default value] Color(0, 0, 0)
	bool set_refract_exit_color(const Color& color) { return setValue("refract_exit_color", color); }
	//! The color to use when maximum depth is reached when exit_color_on is true
 	//! [Default value] Color(0, 0, 0)
	Color get_refract_exit_color() const { return getColor("refract_exit_color"); }

	//! A fog color
 	//! [Default value] Color(1, 1, 1)
	bool set_fog_color(const Color& color) { return setValue("fog_color", color); }
	//! A fog color
 	//! [Default value] Color(1, 1, 1)
	Color get_fog_color() const { return getColor("fog_color"); }

	//! A multiplier for the fog plugin
 	//! [Default value] 1
	bool set_fog_color_mult(float val) { return setValue("fog_color_mult", val); }
	//! A multiplier for the fog plugin
 	//! [Default value] 1
	float get_fog_color_mult() const { return getFloat("fog_color_mult"); }

	//! Fog emission color
 	//! [Default value] Color(0, 0, 0)
	bool set_fog_emission(const Color& color) { return setValue("fog_emission", color); }
	//! Fog emission color
 	//! [Default value] Color(0, 0, 0)
	Color get_fog_emission() const { return getColor("fog_emission"); }

	//! Bias for the fogging distance
 	//! [Default value] 0
	bool set_fog_bias(float val) { return setValue("fog_bias", val); }
	//! Bias for the fogging distance
 	//! [Default value] 0
	float get_fog_bias() const { return getFloat("fog_bias"); }

	//! (description missing)
	//! [Default value] 0.8
	bool set_glossiness(float val) { return setValue("glossiness", val); }
	//! (description missing)
	//! [Default value] 0.8
	float get_glossiness() const { return getFloat("glossiness"); }

	//! (description missing)
	bool set_glossiness_tex(const Plugin& texturefloat) { return setValue("glossiness_tex", texturefloat); }
	//! (description missing)
	bool set_glossiness_tex(float texturefloat) { return setValue("glossiness_tex", texturefloat); }
	//! (description missing)
	Value get_glossiness_tex() const { return getValue("glossiness_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_glossiness_tex_mult(float val) { return setValue("glossiness_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_glossiness_tex_mult() const { return getFloat("glossiness_tex_mult"); }

	//! (description missing)
	//! [Default value] 8
	bool set_subdivs(int val) { return setValue("subdivs", val); }
	//! (description missing)
	//! [Default value] 8
	int get_subdivs() const { return getInt("subdivs"); }

	//! Whether to enable dispersion
 	//! [Default value] false
	bool set_dispersion_on(bool val) { return setValue("dispersion_on", val); }
	//! Whether to enable dispersion
 	//! [Default value] false
	bool get_dispersion_on() const { return getBool("dispersion_on"); }

	//! The dispersion amount
 	//! [Default value] -1
	bool set_dispersion(float val) { return setValue("dispersion", val); }
	//! The dispersion amount
 	//! [Default value] -1
	float get_dispersion() const { return getFloat("dispersion"); }

	//! (description missing)
	//! [Default value] 0
	bool set_interpolation_on(int val) { return setValue("interpolation_on", val); }
	//! (description missing)
	//! [Default value] 0
	int get_interpolation_on() const { return getInt("interpolation_on"); }

	//! (description missing)
	//! [Default value] -1
	bool set_imap_min_rate(int val) { return setValue("imap_min_rate", val); }
	//! (description missing)
	//! [Default value] -1
	int get_imap_min_rate() const { return getInt("imap_min_rate"); }

	//! (description missing)
	//! [Default value] 1
	bool set_imap_max_rate(int val) { return setValue("imap_max_rate", val); }
	//! (description missing)
	//! [Default value] 1
	int get_imap_max_rate() const { return getInt("imap_max_rate"); }

	//! (description missing)
	//! [Default value] 0.25
	bool set_imap_color_thresh(float val) { return setValue("imap_color_thresh", val); }
	//! (description missing)
	//! [Default value] 0.25
	float get_imap_color_thresh() const { return getFloat("imap_color_thresh"); }

	//! (description missing)
	//! [Default value] 0.4
	bool set_imap_norm_thresh(float val) { return setValue("imap_norm_thresh", val); }
	//! (description missing)
	//! [Default value] 0.4
	float get_imap_norm_thresh() const { return getFloat("imap_norm_thresh"); }

	//! (description missing)
	//! [Default value] 20
	bool set_imap_samples(int val) { return setValue("imap_samples", val); }
	//! (description missing)
	//! [Default value] 20
	int get_imap_samples() const { return getInt("imap_samples"); }

	//! Whether or not transluceny should be turned on
 	//! [Default value] false
	bool set_translucency_on(bool val) { return setValue("translucency_on", val); }
	//! Whether or not transluceny should be turned on
 	//! [Default value] false
	bool get_translucency_on() const { return getBool("translucency_on"); }

	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	bool set_translucency(const Color& color) { return setValue("translucency", color); }
	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	Color get_translucency() const { return getColor("translucency"); }

	//! (description missing)
	bool set_translucency_tex(const Plugin& texture) { return setValue("translucency_tex", texture); }
	//! (description missing)
	bool set_translucency_tex(const AColor& texture) { return setValue("translucency_tex", texture); }
	//! (description missing)
	Value get_translucency_tex() const { return getValue("translucency_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_translucency_tex_mult(float val) { return setValue("translucency_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_translucency_tex_mult() const { return getFloat("translucency_tex_mult"); }

	//! (description missing)
	//! [Default value] 1e+018
	bool set_thickness(float val) { return setValue("thickness", val); }
	//! (description missing)
	//! [Default value] 1e+018
	float get_thickness() const { return getFloat("thickness"); }

	//! (description missing)
	//! [Default value] 0
	bool set_scatter_coeff(float val) { return setValue("scatter_coeff", val); }
	//! (description missing)
	//! [Default value] 0
	float get_scatter_coeff() const { return getFloat("scatter_coeff"); }

	//! (description missing)
	//! [Default value] 1
	bool set_scatter_direction(float val) { return setValue("scatter_direction", val); }
	//! (description missing)
	//! [Default value] 1
	float get_scatter_direction() const { return getFloat("scatter_direction"); }
};

class BRDFSSS : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "BRDFSSS"; }

	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	bool set_color(const Color& color) { return setValue("color", color); }
	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	Color get_color() const { return getColor("color"); }

	//! (description missing)
	bool set_color_tex(const Plugin& texture) { return setValue("color_tex", texture); }
	//! (description missing)
	bool set_color_tex(const AColor& texture) { return setValue("color_tex", texture); }
	//! (description missing)
	Value get_color_tex() const { return getValue("color_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_color_tex_mult(float val) { return setValue("color_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_color_tex_mult() const { return getFloat("color_tex_mult"); }

	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	bool set_translucency(const Color& color) { return setValue("translucency", color); }
	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	Color get_translucency() const { return getColor("translucency"); }

	//! (description missing)
	bool set_translucency_tex(const Plugin& texture) { return setValue("translucency_tex", texture); }
	//! (description missing)
	bool set_translucency_tex(const AColor& texture) { return setValue("translucency_tex", texture); }
	//! (description missing)
	Value get_translucency_tex() const { return getValue("translucency_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_translucency_tex_mult(float val) { return setValue("translucency_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_translucency_tex_mult() const { return getFloat("translucency_tex_mult"); }

	//! (description missing)
	//! [Default value] 0
	bool set_glossiness(float val) { return setValue("glossiness", val); }
	//! (description missing)
	//! [Default value] 0
	float get_glossiness() const { return getFloat("glossiness"); }

	//! (description missing)
	bool set_glossiness_tex(const Plugin& texturefloat) { return setValue("glossiness_tex", texturefloat); }
	//! (description missing)
	bool set_glossiness_tex(float texturefloat) { return setValue("glossiness_tex", texturefloat); }
	//! (description missing)
	Value get_glossiness_tex() const { return getValue("glossiness_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_glossiness_tex_mult(float val) { return setValue("glossiness_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_glossiness_tex_mult() const { return getFloat("glossiness_tex_mult"); }

	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	bool set_subdivs(int val) { return setValue("subdivs", val); }
	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	int get_subdivs() const { return getInt("subdivs"); }

	//! (description missing)
	//! [Default value] 1e+018
	bool set_thickness(float val) { return setValue("thickness", val); }
	//! (description missing)
	//! [Default value] 1e+018
	float get_thickness() const { return getFloat("thickness"); }

	//! (description missing)
	//! [Default value] 0
	bool set_scatter_coeff(float val) { return setValue("scatter_coeff", val); }
	//! (description missing)
	//! [Default value] 0
	float get_scatter_coeff() const { return getFloat("scatter_coeff"); }

	//! (description missing)
	//! [Default value] 1
	bool set_scatter_direction(float val) { return setValue("scatter_direction", val); }
	//! (description missing)
	//! [Default value] 1
	float get_scatter_direction() const { return getFloat("scatter_direction"); }
};

class BRDFSSS2 : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "BRDFSSS2"; }

	//! Sampling density for the illumination map
 	//! [Default value] -1
	bool set_prepass_rate(int val) { return setValue("prepass_rate", val); }
	//! Sampling density for the illumination map
 	//! [Default value] -1
	int get_prepass_rate() const { return getInt("prepass_rate"); }

	//! Interpolation accuracy for the illumination map; normally 1.0 is fine.
 	//! [Default value] 1
	bool set_interpolation_accuracy(float val) { return setValue("interpolation_accuracy", val); }
	//! Interpolation accuracy for the illumination map; normally 1.0 is fine.
 	//! [Default value] 1
	float get_interpolation_accuracy() const { return getFloat("interpolation_accuracy"); }

	//! Values below 1.0 will make the object look as if it is bigger. Values above 1.0 will make it look as if it is smaller
 	//! [Default value] 1
	bool set_scale(float val) { return setValue("scale", val); }
	//! Values below 1.0 will make the object look as if it is bigger. Values above 1.0 will make it look as if it is smaller
 	//! [Default value] 1
	float get_scale() const { return getFloat("scale"); }

	//! (description missing)
	//! [Default value] 1.5
	bool set_ior(float val) { return setValue("ior", val); }
	//! (description missing)
	//! [Default value] 1.5
	float get_ior() const { return getFloat("ior"); }

	//! (description missing)
	bool set_diffuse_reflectance(const Plugin& texture) { return setValue("diffuse_reflectance", texture); }
	//! (description missing)
	bool set_diffuse_reflectance(const AColor& texture) { return setValue("diffuse_reflectance", texture); }
	//! (description missing)
	Value get_diffuse_reflectance() const { return getValue("diffuse_reflectance"); }

	//! This is measured in centimeters
 	bool set_scatter_radius(const Plugin& texture) { return setValue("scatter_radius", texture); }
	//! This is measured in centimeters
 	bool set_scatter_radius(const AColor& texture) { return setValue("scatter_radius", texture); }
	//! This is measured in centimeters
 	Value get_scatter_radius() const { return getValue("scatter_radius"); }

	//! The scatter radius will be multiplied by this number
 	bool set_scatter_radius_mult(const Plugin& texturefloat) { return setValue("scatter_radius_mult", texturefloat); }
	//! The scatter radius will be multiplied by this number
 	bool set_scatter_radius_mult(float texturefloat) { return setValue("scatter_radius_mult", texturefloat); }
	//! The scatter radius will be multiplied by this number
 	Value get_scatter_radius_mult() const { return getValue("scatter_radius_mult"); }

	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	bool set_subdivs(int val) { return setValue("subdivs", val); }
	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	int get_subdivs() const { return getInt("subdivs"); }

	//! (description missing)
	//! [Default value] 0
	bool set_phase_function(float val) { return setValue("phase_function", val); }
	//! (description missing)
	//! [Default value] 0
	float get_phase_function() const { return getFloat("phase_function"); }

	//! How to compute single scattering (0 - off; 1 - approximation; 2 - raytraced (solid); 3 - raytraced (volumetric); 4 - only provide a volume, BRDF itself is transparent
 	//! [Default value] 1
	bool set_single_scatter(int val) { return setValue("single_scatter", val); }
	//! How to compute single scattering (0 - off; 1 - approximation; 2 - raytraced (solid); 3 - raytraced (volumetric); 4 - only provide a volume, BRDF itself is transparent
 	//! [Default value] 1
	int get_single_scatter() const { return getInt("single_scatter"); }

	//! (description missing)
	//! [Default value] true
	bool set_front_scatter(bool val) { return setValue("front_scatter", val); }
	//! (description missing)
	//! [Default value] true
	bool get_front_scatter() const { return getBool("front_scatter"); }

	//! (description missing)
	//! [Default value] true
	bool set_back_scatter(bool val) { return setValue("back_scatter", val); }
	//! (description missing)
	//! [Default value] true
	bool get_back_scatter() const { return getBool("back_scatter"); }

	//! (description missing)
	//! [Default value] false
	bool set_scatter_gi(bool val) { return setValue("scatter_gi", val); }
	//! (description missing)
	//! [Default value] false
	bool get_scatter_gi() const { return getBool("scatter_gi"); }

	//! (description missing)
	//! [Default value] 4
	bool set_prepass_lod_threshold(float val) { return setValue("prepass_lod_threshold", val); }
	//! (description missing)
	//! [Default value] 4
	float get_prepass_lod_threshold() const { return getFloat("prepass_lod_threshold"); }

	//! (description missing)
	//! [Default value] 1.2
	bool set_prepass_blur(float val) { return setValue("prepass_blur", val); }
	//! (description missing)
	//! [Default value] 1.2
	float get_prepass_blur() const { return getFloat("prepass_blur"); }

	//! 0 to calculate a separate illuminataion map for this shader; otherwise all shaders with the same prepass ID will share the same illumination map
 	//! [Default value] 0
	bool set_prepass_id(int val) { return setValue("prepass_id", val); }
	//! 0 to calculate a separate illuminataion map for this shader; otherwise all shaders with the same prepass ID will share the same illumination map
 	//! [Default value] 0
	int get_prepass_id() const { return getInt("prepass_id"); }

	//! Set to true to apply the inverse of gamma correction
 	//! [Default value] false
	bool set_linear_workflow(bool val) { return setValue("linear_workflow", val); }
	//! Set to true to apply the inverse of gamma correction
 	//! [Default value] false
	bool get_linear_workflow() const { return getBool("linear_workflow"); }

	//! Determines the meaning of the two colors: 0 - diffuse surface reflectance and scatter radius; 1 - scatter coefficient and fog color
 	//! [Default value] 0
	bool set_color_mode(int val) { return setValue("color_mode", val); }
	//! Determines the meaning of the two colors: 0 - diffuse surface reflectance and scatter radius; 1 - scatter coefficient and fog color
 	//! [Default value] 0
	int get_color_mode() const { return getInt("color_mode"); }

	//! (description missing)
	//! [Default value] 0
	bool set_geometry_based_sampling(int val) { return setValue("geometry_based_sampling", val); }
	//! (description missing)
	//! [Default value] 0
	int get_geometry_based_sampling() const { return getInt("geometry_based_sampling"); }

	//! (description missing)
	//! [Default value] 16
	bool set_samples_per_unit_area(float val) { return setValue("samples_per_unit_area", val); }
	//! (description missing)
	//! [Default value] 16
	float get_samples_per_unit_area() const { return getFloat("samples_per_unit_area"); }

	//! An offset along the geometric surface normal at which to perform shading in order to avoid surface acne.
 	//! [Default value] 0.001
	bool set_surface_offset(float val) { return setValue("surface_offset", val); }
	//! An offset along the geometric surface normal at which to perform shading in order to avoid surface acne.
 	//! [Default value] 0.001
	float get_surface_offset() const { return getFloat("surface_offset"); }

	//! (description missing)
	//! [Default value] 0
	bool set_preview_samples(int val) { return setValue("preview_samples", val); }
	//! (description missing)
	//! [Default value] 0
	int get_preview_samples() const { return getInt("preview_samples"); }

	//! [UI Guides] quantityType=distance
 	//! [Default value] 0.1
	bool set_max_distance(float val) { return setValue("max_distance", val); }
	//! [UI Guides] quantityType=distance
 	//! [Default value] 0.1
	float get_max_distance() const { return getFloat("max_distance"); }

	//! (description missing)
	//! [Default value] Color(0, 0, 0)
	bool set_background_color(const Color& color) { return setValue("background_color", color); }
	//! (description missing)
	//! [Default value] Color(0, 0, 0)
	Color get_background_color() const { return getColor("background_color"); }

	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	bool set_samples_color(const Color& color) { return setValue("samples_color", color); }
	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	Color get_samples_color() const { return getColor("samples_color"); }
};

class BRDFSSS2Complex : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "BRDFSSS2Complex"; }

	//! Values below 1.0 will make the object look as if it is bigger. Values above 1.0 will make it look as if it is smaller
 	//! [UI Guides] startTab=V-Ray Fast SSS2, startRollout=General parameters, minValue=0, maxValue=10000
 	//! [Default value] 1
	bool set_scale(float val) { return setValue("scale", val); }
	//! Values below 1.0 will make the object look as if it is bigger. Values above 1.0 will make it look as if it is smaller
 	//! [UI Guides] startTab=V-Ray Fast SSS2, startRollout=General parameters, minValue=0, maxValue=10000
 	//! [Default value] 1
	float get_scale() const { return getFloat("scale"); }

	//! [UI Guides] displayName=Index of refraction, minValue=0, maxValue=100
 	//! [Default value] 1.5
	bool set_ior(float val) { return setValue("ior", val); }
	//! [UI Guides] displayName=Index of refraction, minValue=0, maxValue=100
 	//! [Default value] 1.5
	float get_ior() const { return getFloat("ior"); }

	//! Opacity texture
 	//! [UI Guides] minValue=0, maxValue=1
 	bool set_opacity(const Plugin& texturefloat) { return setValue("opacity", texturefloat); }
	//! Opacity texture
 	//! [UI Guides] minValue=0, maxValue=1
 	bool set_opacity(float texturefloat) { return setValue("opacity", texturefloat); }
	//! Opacity texture
 	//! [UI Guides] minValue=0, maxValue=1
 	Value get_opacity() const { return getValue("opacity"); }

	//! [UI Guides] startRollout=Diffuse and sub-surface scattering layers
 	bool set_overall_color(const Plugin& texture) { return setValue("overall_color", texture); }
	//! [UI Guides] startRollout=Diffuse and sub-surface scattering layers
 	bool set_overall_color(const AColor& texture) { return setValue("overall_color", texture); }
	//! [UI Guides] startRollout=Diffuse and sub-surface scattering layers
 	Value get_overall_color() const { return getValue("overall_color"); }

	//! (description missing)
	bool set_diffuse_color(const Plugin& texture) { return setValue("diffuse_color", texture); }
	//! (description missing)
	bool set_diffuse_color(const AColor& texture) { return setValue("diffuse_color", texture); }
	//! (description missing)
	Value get_diffuse_color() const { return getValue("diffuse_color"); }

	//! [UI Guides] minValue=0, maxValue=1
 	bool set_diffuse_amount(const Plugin& texturefloat) { return setValue("diffuse_amount", texturefloat); }
	//! [UI Guides] minValue=0, maxValue=1
 	bool set_diffuse_amount(float texturefloat) { return setValue("diffuse_amount", texturefloat); }
	//! [UI Guides] minValue=0, maxValue=1
 	Value get_diffuse_amount() const { return getValue("diffuse_amount"); }

	//! (description missing)
	bool set_sub_surface_color(const Plugin& texture) { return setValue("sub_surface_color", texture); }
	//! (description missing)
	bool set_sub_surface_color(const AColor& texture) { return setValue("sub_surface_color", texture); }
	//! (description missing)
	Value get_sub_surface_color() const { return getValue("sub_surface_color"); }

	//! This is measured in centimeters
 	//! [UI Guides] displayName=Scatter Color
 	bool set_scatter_radius(const Plugin& texture) { return setValue("scatter_radius", texture); }
	//! This is measured in centimeters
 	//! [UI Guides] displayName=Scatter Color
 	bool set_scatter_radius(const AColor& texture) { return setValue("scatter_radius", texture); }
	//! This is measured in centimeters
 	//! [UI Guides] displayName=Scatter Color
 	Value get_scatter_radius() const { return getValue("scatter_radius"); }

	//! The scatter color will be multiplied by this number
 	//! [UI Guides] displayName=Scatter Radius in cm, minValue=0
 	bool set_scatter_radius_mult(const Plugin& texturefloat) { return setValue("scatter_radius_mult", texturefloat); }
	//! The scatter color will be multiplied by this number
 	//! [UI Guides] displayName=Scatter Radius in cm, minValue=0
 	bool set_scatter_radius_mult(float texturefloat) { return setValue("scatter_radius_mult", texturefloat); }
	//! The scatter color will be multiplied by this number
 	//! [UI Guides] displayName=Scatter Radius in cm, minValue=0
 	Value get_scatter_radius_mult() const { return getValue("scatter_radius_mult"); }

	//! [UI Guides] minValue=-1, maxValue=1
 	//! [Default value] 0
	bool set_phase_function(float val) { return setValue("phase_function", val); }
	//! [UI Guides] minValue=-1, maxValue=1
 	//! [Default value] 0
	float get_phase_function() const { return getFloat("phase_function"); }

	//! Determines the meaning of the two colors: 0 - diffuse surface reflectance and scatter radius; 1 - scatter coefficient and fog color
 	//! [UI Guides] enum=0:Diffuse surface reflectance and scatter radius;1:Scatter coefficient and fog color
 	//! [Default value] 0
	bool set_color_mode(int val) { return setValue("color_mode", val); }
	//! Determines the meaning of the two colors: 0 - diffuse surface reflectance and scatter radius; 1 - scatter coefficient and fog color
 	//! [UI Guides] enum=0:Diffuse surface reflectance and scatter radius;1:Scatter coefficient and fog color
 	//! [Default value] 0
	int get_color_mode() const { return getInt("color_mode"); }

	//! [UI Guides] startRollout=Specular layer
 	bool set_specular_color(const Plugin& texture) { return setValue("specular_color", texture); }
	//! [UI Guides] startRollout=Specular layer
 	bool set_specular_color(const AColor& texture) { return setValue("specular_color", texture); }
	//! [UI Guides] startRollout=Specular layer
 	Value get_specular_color() const { return getValue("specular_color"); }

	//! [UI Guides] minValue=0, maxValue=1
 	bool set_specular_amount(const Plugin& texturefloat) { return setValue("specular_amount", texturefloat); }
	//! [UI Guides] minValue=0, maxValue=1
 	bool set_specular_amount(float texturefloat) { return setValue("specular_amount", texturefloat); }
	//! [UI Guides] minValue=0, maxValue=1
 	Value get_specular_amount() const { return getValue("specular_amount"); }

	//! [UI Guides] minValue=0, maxValue=1
 	bool set_specular_glossiness(const Plugin& texturefloat) { return setValue("specular_glossiness", texturefloat); }
	//! [UI Guides] minValue=0, maxValue=1
 	bool set_specular_glossiness(float texturefloat) { return setValue("specular_glossiness", texturefloat); }
	//! [UI Guides] minValue=0, maxValue=1
 	Value get_specular_glossiness() const { return getValue("specular_glossiness"); }

	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	bool set_specular_subdivs(int val) { return setValue("specular_subdivs", val); }
	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	int get_specular_subdivs() const { return getInt("specular_subdivs"); }

	//! [UI Guides] minValue=0
 	//! [Default value] 0.01
	bool set_cutoff_threshold(float val) { return setValue("cutoff_threshold", val); }
	//! [UI Guides] minValue=0
 	//! [Default value] 0.01
	float get_cutoff_threshold() const { return getFloat("cutoff_threshold"); }

	//! (description missing)
	//! [Default value] false
	bool set_trace_reflections(bool val) { return setValue("trace_reflections", val); }
	//! (description missing)
	//! [Default value] false
	bool get_trace_reflections() const { return getBool("trace_reflections"); }

	//! [UI Guides] minValue=1, maxValue=100
 	//! [Default value] 5
	bool set_reflection_depth(int val) { return setValue("reflection_depth", val); }
	//! [UI Guides] minValue=1, maxValue=100
 	//! [Default value] 5
	int get_reflection_depth() const { return getInt("reflection_depth"); }

	//! 0 - Prepass-based illumination map; 1 - Object-based illumination map; 2 - Raytraced; 3 - None (diffuse approx.);
 	//! [UI Guides] startRollout=Multiple scattering, displayName=Multiple scattering, enum=0:Prepass-based illumination map;1:Object-based illumination map;2:Raytraced;3:None
 	//! [Default value] 0
	bool set_geometry_based_sampling(int val) { return setValue("geometry_based_sampling", val); }
	//! 0 - Prepass-based illumination map; 1 - Object-based illumination map; 2 - Raytraced; 3 - None (diffuse approx.);
 	//! [UI Guides] startRollout=Multiple scattering, displayName=Multiple scattering, enum=0:Prepass-based illumination map;1:Object-based illumination map;2:Raytraced;3:None
 	//! [Default value] 0
	int get_geometry_based_sampling() const { return getInt("geometry_based_sampling"); }

	//! Sampling density for the illumination map
 	//! [UI Guides] enableIf: ?geometry_based_sampling=0, minValue=-100, maxValue=100
 	//! [Default value] -1
	bool set_prepass_rate(int val) { return setValue("prepass_rate", val); }
	//! Sampling density for the illumination map
 	//! [UI Guides] enableIf: ?geometry_based_sampling=0, minValue=-100, maxValue=100
 	//! [Default value] -1
	int get_prepass_rate() const { return getInt("prepass_rate"); }

	//! 0 to calculate a separate illuminataion map for this shader; otherwise all shaders with the same prepass ID will share the same illumination map
 	//! [UI Guides] enableIf: ?geometry_based_sampling=0
 	//! [Default value] 0
	bool set_prepass_id(int val) { return setValue("prepass_id", val); }
	//! 0 to calculate a separate illuminataion map for this shader; otherwise all shaders with the same prepass ID will share the same illumination map
 	//! [UI Guides] enableIf: ?geometry_based_sampling=0
 	//! [Default value] 0
	int get_prepass_id() const { return getInt("prepass_id"); }

	//! Prepass mode: 0 - calculate new irradiance map for each frame (meaningless in RT); 1 - calculate and save map for each frame (meaningless in RT); 2 - load saved irradiance map for each frame; 3 - calculate and save map only for the first rendered frame; 4 - load saved irradiance map on the first rendered frame only
 	//! [UI Guides] enum=0:New for each frame;1:Save map for each frame;2:Load saved map for each frame;3:Save map only for first frame;4:Load saved map for first frame, enableIf: ?geometry_based_sampling=0
 	//! [Default value] 0
	bool set_prepass_mode(int val) { return setValue("prepass_mode", val); }
	//! Prepass mode: 0 - calculate new irradiance map for each frame (meaningless in RT); 1 - calculate and save map for each frame (meaningless in RT); 2 - load saved irradiance map for each frame; 3 - calculate and save map only for the first rendered frame; 4 - load saved irradiance map on the first rendered frame only
 	//! [UI Guides] enum=0:New for each frame;1:Save map for each frame;2:Load saved map for each frame;3:Save map only for first frame;4:Load saved map for first frame, enableIf: ?geometry_based_sampling=0
 	//! [Default value] 0
	int get_prepass_mode() const { return getInt("prepass_mode"); }

	//! File path template for saved irradiance map files, frame number is appended for modes 1 and 2.
 	//! [UI Guides] displayName=Prepass File, fileAsset=vrsssmap, fileAssetNames=VRayFastSSS2 illumination map, fileAssetOp=bothLoadAndSave, enableIf: ?geometry_based_sampling=0, ?prepass_mode>0
 	bool set_prepass_fileName(const char* str) { return setValue("prepass_fileName", str); }
	//! File path template for saved irradiance map files, frame number is appended for modes 1 and 2.
 	//! [UI Guides] displayName=Prepass File, fileAsset=vrsssmap, fileAssetNames=VRayFastSSS2 illumination map, fileAssetOp=bothLoadAndSave, enableIf: ?geometry_based_sampling=0, ?prepass_mode>0
 	bool set_prepass_fileName(const std::string& str) { return setValue("prepass_fileName", str); }
	//! File path template for saved irradiance map files, frame number is appended for modes 1 and 2.
 	//! [UI Guides] displayName=Prepass File, fileAsset=vrsssmap, fileAssetNames=VRayFastSSS2 illumination map, fileAssetOp=bothLoadAndSave, enableIf: ?geometry_based_sampling=0, ?prepass_mode>0
 	std::string get_prepass_fileName() const { return getString("prepass_fileName"); }

	//! If this parameter is true then 'Samples per unit area' will be computed automatically.
 	//! [UI Guides] enableIf: ?geometry_based_sampling=1
 	//! [Default value] false
	bool set_auto_density(bool val) { return setValue("auto_density", val); }
	//! If this parameter is true then 'Samples per unit area' will be computed automatically.
 	//! [UI Guides] enableIf: ?geometry_based_sampling=1
 	//! [Default value] false
	bool get_auto_density() const { return getBool("auto_density"); }

	//! [UI Guides] enableIf: ?auto_density=0, ?geometry_based_sampling=1, minValue=0
 	//! [Default value] 16
	bool set_samples_per_unit_area(float val) { return setValue("samples_per_unit_area", val); }
	//! [UI Guides] enableIf: ?auto_density=0, ?geometry_based_sampling=1, minValue=0
 	//! [Default value] 16
	float get_samples_per_unit_area() const { return getFloat("samples_per_unit_area"); }

	//! An offset along the geometric surface normal at which to perform shading in order to avoid surface acne.
 	//! [UI Guides] enableIf: ?geometry_based_sampling=1, minValue=0
 	//! [Default value] 0.001
	bool set_surface_offset(float val) { return setValue("surface_offset", val); }
	//! An offset along the geometric surface normal at which to perform shading in order to avoid surface acne.
 	//! [UI Guides] enableIf: ?geometry_based_sampling=1, minValue=0
 	//! [Default value] 0.001
	float get_surface_offset() const { return getFloat("surface_offset"); }

	//! [UI Guides] enableIf: ?geometry_based_sampling=1
 	//! [Default value] false
	bool set_preview_samples(bool val) { return setValue("preview_samples", val); }
	//! [UI Guides] enableIf: ?geometry_based_sampling=1
 	//! [Default value] false
	bool get_preview_samples() const { return getBool("preview_samples"); }

	//! [UI Guides] enableIf: ?geometry_based_sampling=1, ?preview_samples=1, quantityType=distance, minValue=0, maxValue=10000
 	//! [Default value] 0.1
	bool set_max_distance(float val) { return setValue("max_distance", val); }
	//! [UI Guides] enableIf: ?geometry_based_sampling=1, ?preview_samples=1, quantityType=distance, minValue=0, maxValue=10000
 	//! [Default value] 0.1
	float get_max_distance() const { return getFloat("max_distance"); }

	//! [UI Guides] enableIf: ?geometry_based_sampling=1, ?preview_samples=1
 	//! [Default value] Color(0, 0, 0)
	bool set_background_color(const Color& color) { return setValue("background_color", color); }
	//! [UI Guides] enableIf: ?geometry_based_sampling=1, ?preview_samples=1
 	//! [Default value] Color(0, 0, 0)
	Color get_background_color() const { return getColor("background_color"); }

	//! [UI Guides] enableIf: ?geometry_based_sampling=1, ?preview_samples=1
 	//! [Default value] Color(1, 1, 1)
	bool set_samples_color(const Color& color) { return setValue("samples_color", color); }
	//! [UI Guides] enableIf: ?geometry_based_sampling=1, ?preview_samples=1
 	//! [Default value] Color(1, 1, 1)
	Color get_samples_color() const { return getColor("samples_color"); }

	//! 0 - None; 1 - Simple; 2 - Raytraced(solid); 3 - Raytraced(refractive)
 	//! [UI Guides] startRollout=Options, enum=0:None;1:Simple;2:Raytracedsolid;3:Raytracedrefractive
 	//! [Default value] 1
	bool set_single_scatter(int val) { return setValue("single_scatter", val); }
	//! 0 - None; 1 - Simple; 2 - Raytraced(solid); 3 - Raytraced(refractive)
 	//! [UI Guides] startRollout=Options, enum=0:None;1:Simple;2:Raytracedsolid;3:Raytracedrefractive
 	//! [Default value] 1
	int get_single_scatter() const { return getInt("single_scatter"); }

	//! Single scatter subdivisions
 	//! [UI Guides] displayName=Single scatter subdivs, minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	bool set_subdivs(int val) { return setValue("subdivs", val); }
	//! Single scatter subdivisions
 	//! [UI Guides] displayName=Single scatter subdivs, minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	int get_subdivs() const { return getInt("subdivs"); }

	//! [UI Guides] minValue=1, maxValue=1000
 	//! [Default value] 5
	bool set_refraction_depth(int val) { return setValue("refraction_depth", val); }
	//! [UI Guides] minValue=1, maxValue=1000
 	//! [Default value] 5
	int get_refraction_depth() const { return getInt("refraction_depth"); }

	//! [UI Guides] enableIf: ?geometry_based_sampling=0, displayName=Front lighting
 	//! [Default value] true
	bool set_front_scatter(bool val) { return setValue("front_scatter", val); }
	//! [UI Guides] enableIf: ?geometry_based_sampling=0, displayName=Front lighting
 	//! [Default value] true
	bool get_front_scatter() const { return getBool("front_scatter"); }

	//! [UI Guides] enableIf: ?geometry_based_sampling=0, displayName=Back lighting
 	//! [Default value] true
	bool set_back_scatter(bool val) { return setValue("back_scatter", val); }
	//! [UI Guides] enableIf: ?geometry_based_sampling=0, displayName=Back lighting
 	//! [Default value] true
	bool get_back_scatter() const { return getBool("back_scatter"); }

	//! [UI Guides] displayName=Scatter GI
 	//! [Default value] false
	bool set_scatter_gi(bool val) { return setValue("scatter_gi", val); }
	//! [UI Guides] displayName=Scatter GI
 	//! [Default value] false
	bool get_scatter_gi() const { return getBool("scatter_gi"); }

	//! Interpolation accuracy for the illumination map; normally 1.0 is fine.
 	//! [UI Guides] enableIf: ?geometry_based_sampling<2, minValue=0.1, maxValue=100.0
 	//! [Default value] 1
	bool set_interpolation_accuracy(float val) { return setValue("interpolation_accuracy", val); }
	//! Interpolation accuracy for the illumination map; normally 1.0 is fine.
 	//! [UI Guides] enableIf: ?geometry_based_sampling<2, minValue=0.1, maxValue=100.0
 	//! [Default value] 1
	float get_interpolation_accuracy() const { return getFloat("interpolation_accuracy"); }

	//! [UI Guides] enableIf: ?geometry_based_sampling<2, minValue=0, maxValue=100
 	//! [Default value] 1.2
	bool set_prepass_blur(float val) { return setValue("prepass_blur", val); }
	//! [UI Guides] enableIf: ?geometry_based_sampling<2, minValue=0, maxValue=100
 	//! [Default value] 1.2
	float get_prepass_blur() const { return getFloat("prepass_blur"); }

	//! Render channels the result of this BRDF will be written to
 	bool set_channels(const ValueList& pluginList) { return setValue("channels", pluginList); }
	//! Render channels the result of this BRDF will be written to
 	ValueList get_channels() const { return getValueList("channels"); }

	//! Set to true to apply the inverse of gamma correction
 	//! [Default value] false
	bool set_linear_workflow(bool val) { return setValue("linear_workflow", val); }
	//! Set to true to apply the inverse of gamma correction
 	//! [Default value] false
	bool get_linear_workflow() const { return getBool("linear_workflow"); }
};

class BRDFSampled : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "BRDFSampled"; }

	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	bool set_color(const Color& color) { return setValue("color", color); }
	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	Color get_color() const { return getColor("color"); }

	//! (description missing)
	bool set_color_tex(const Plugin& texture) { return setValue("color_tex", texture); }
	//! (description missing)
	bool set_color_tex(const AColor& texture) { return setValue("color_tex", texture); }
	//! (description missing)
	Value get_color_tex() const { return getValue("color_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_color_tex_mult(float val) { return setValue("color_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_color_tex_mult() const { return getFloat("color_tex_mult"); }

	//! (description missing)
	//! [Default value] Color(0.5, 0.5, 0.5)
	bool set_transparency(const Color& color) { return setValue("transparency", color); }
	//! (description missing)
	//! [Default value] Color(0.5, 0.5, 0.5)
	Color get_transparency() const { return getColor("transparency"); }

	//! (description missing)
	bool set_transparency_tex(const Plugin& texture) { return setValue("transparency_tex", texture); }
	//! (description missing)
	bool set_transparency_tex(const AColor& texture) { return setValue("transparency_tex", texture); }
	//! (description missing)
	Value get_transparency_tex() const { return getValue("transparency_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_transparency_tex_mult(float val) { return setValue("transparency_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_transparency_tex_mult() const { return getFloat("transparency_tex_mult"); }

	//! (description missing)
	//! [Default value] 0.01
	bool set_cutoff(float val) { return setValue("cutoff", val); }
	//! (description missing)
	//! [Default value] 0.01
	float get_cutoff() const { return getFloat("cutoff"); }

	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	bool set_subdivs(int val) { return setValue("subdivs", val); }
	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	int get_subdivs() const { return getInt("subdivs"); }

	//! (description missing)
	//! [Default value] false
	bool set_back_side(bool val) { return setValue("back_side", val); }
	//! (description missing)
	//! [Default value] false
	bool get_back_side() const { return getBool("back_side"); }

	//! (description missing)
	bool set_brdf_bitmap(const Plugin& plugin) { return setValue("brdf_bitmap", plugin); }
	//! (description missing)
	Plugin get_brdf_bitmap() const { return getPlugin("brdf_bitmap"); }

	//! Number of d_theta samples
 	//! [Default value] 0
	bool set_brdf_nsamples_d_theta(int val) { return setValue("brdf_nsamples_d_theta", val); }
	//! Number of d_theta samples
 	//! [Default value] 0
	int get_brdf_nsamples_d_theta() const { return getInt("brdf_nsamples_d_theta"); }

	//! Number of d_phi samples (1 means isotropic BRDF)
 	//! [Default value] 1
	bool set_brdf_nsamples_d_phi(int val) { return setValue("brdf_nsamples_d_phi", val); }
	//! Number of d_phi samples (1 means isotropic BRDF)
 	//! [Default value] 1
	int get_brdf_nsamples_d_phi() const { return getInt("brdf_nsamples_d_phi"); }

	//! true to use importance sampling for the reflections
 	//! [Default value] true
	bool set_brdf_importance_sampling_on(bool val) { return setValue("brdf_importance_sampling_on", val); }
	//! true to use importance sampling for the reflections
 	//! [Default value] true
	bool get_brdf_importance_sampling_on() const { return getBool("brdf_importance_sampling_on"); }

	//! Resolution for the resampling of the BRDF used for importance sampling of reflections
 	//! [Default value] 32
	bool set_brdf_importance_sampling_resolution(int val) { return setValue("brdf_importance_sampling_resolution", val); }
	//! Resolution for the resampling of the BRDF used for importance sampling of reflections
 	//! [Default value] 32
	int get_brdf_importance_sampling_resolution() const { return getInt("brdf_importance_sampling_resolution"); }

	//! Number of terms to decompose the view-dependent portion of the resampling matrix
 	//! [Default value] 4
	bool set_brdf_importance_sampling_view_terms(int val) { return setValue("brdf_importance_sampling_view_terms", val); }
	//! Number of terms to decompose the view-dependent portion of the resampling matrix
 	//! [Default value] 4
	int get_brdf_importance_sampling_view_terms() const { return getInt("brdf_importance_sampling_view_terms"); }

	//! Number of terms to decompose the half-angle portion of the resampling matrix
 	//! [Default value] 2
	bool set_brdf_importance_sampling_half_terms(int val) { return setValue("brdf_importance_sampling_half_terms", val); }
	//! Number of terms to decompose the half-angle portion of the resampling matrix
 	//! [Default value] 2
	int get_brdf_importance_sampling_half_terms() const { return getInt("brdf_importance_sampling_half_terms"); }
};

class BRDFScanned : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "BRDFScanned"; }

	//! [UI Guides] fileAsset=vrscan
 	bool set_file(const char* str) { return setValue("file", str); }
	//! [UI Guides] fileAsset=vrscan
 	bool set_file(const std::string& str) { return setValue("file", str); }
	//! [UI Guides] fileAsset=vrscan
 	std::string get_file() const { return getString("file"); }

	//! Paint replacement color
 	bool set_paintcolor(const Plugin& texture) { return setValue("paintcolor", texture); }
	//! Paint replacement color
 	bool set_paintcolor(const AColor& texture) { return setValue("paintcolor", texture); }
	//! Paint replacement color
 	Value get_paintcolor() const { return getValue("paintcolor"); }

	//! Filter color
 	bool set_filtercolor(const Plugin& texture) { return setValue("filtercolor", texture); }
	//! Filter color
 	bool set_filtercolor(const AColor& texture) { return setValue("filtercolor", texture); }
	//! Filter color
 	Value get_filtercolor() const { return getValue("filtercolor"); }

	//! Clear Coat Multiplier
 	bool set_ccmult(const Plugin& texture) { return setValue("ccmult", texture); }
	//! Clear Coat Multiplier
 	bool set_ccmult(const AColor& texture) { return setValue("ccmult", texture); }
	//! Clear Coat Multiplier
 	Value get_ccmult() const { return getValue("ccmult"); }

	//! (description missing)
	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! (description missing)
	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! (description missing)
	//! [Default value] 1
	bool set_tiling_factor(float val) { return setValue("tiling_factor", val); }
	//! (description missing)
	//! [Default value] 1
	float get_tiling_factor() const { return getFloat("tiling_factor"); }

	//! All parameters serialized to a binary param block
 	//! [Default value] 0
	bool set_param_block(const IntList& intList) { return setValue("param_block", intList); }
	//! All parameters serialized to a binary param block
 	//! [Default value] 0
	bool set_param_block(const int* ints, size_t count) { return setArray("param_block", ints, count); }
	//! All parameters serialized to a binary param block
 	//! [Default value] 0
	template<size_t count> bool set_param_block(const int (&ints)[count]) { return setArray("param_block", ints, count); }
	//! All parameters serialized to a binary param block
 	//! [Default value] 0
	IntList get_param_block() const { return getIntList("param_block"); }
};

class BRDFSimbiont : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "BRDFSimbiont"; }

	//! DarkTree shaded (.dsts) file
 	//! [UI Guides] displayName=File;fileAsset=dsts
 	bool set_file(const char* str) { return setValue("file", str); }
	//! DarkTree shaded (.dsts) file
 	//! [UI Guides] displayName=File;fileAsset=dsts
 	bool set_file(const std::string& str) { return setValue("file", str); }
	//! DarkTree shaded (.dsts) file
 	//! [UI Guides] displayName=File;fileAsset=dsts
 	std::string get_file() const { return getString("file"); }

	//! The uvw space that will be used for DarkTree evaluation
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw space that will be used for DarkTree evaluation
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! Bump Scale
 	//! [UI Guides] displayName=Bump Scale
 	//! [Default value] 1
	bool set_bump_scale(float val) { return setValue("bump_scale", val); }
	//! Bump Scale
 	//! [UI Guides] displayName=Bump Scale
 	//! [Default value] 1
	float get_bump_scale() const { return getFloat("bump_scale"); }

	//! Near Camera Distance
 	//! [UI Guides] displayName=Near
 	//! [Default value] 0
	bool set_near_camera_dist(float val) { return setValue("near_camera_dist", val); }
	//! Near Camera Distance
 	//! [UI Guides] displayName=Near
 	//! [Default value] 0
	float get_near_camera_dist() const { return getFloat("near_camera_dist"); }

	//! Far Camera Distance
 	//! [UI Guides] displayName=Far
 	//! [Default value] 5
	bool set_far_camera_dist(float val) { return setValue("far_camera_dist", val); }
	//! Far Camera Distance
 	//! [UI Guides] displayName=Far
 	//! [Default value] 5
	float get_far_camera_dist() const { return getFloat("far_camera_dist"); }

	//! Enable tweak 0
 	//! [Default value] false
	bool set_tweak_enable_0(bool val) { return setValue("tweak_enable_0", val); }
	//! Enable tweak 0
 	//! [Default value] false
	bool get_tweak_enable_0() const { return getBool("tweak_enable_0"); }

	//! Tweak 0 name
 	bool set_tweak_name_0(const char* str) { return setValue("tweak_name_0", str); }
	//! Tweak 0 name
 	bool set_tweak_name_0(const std::string& str) { return setValue("tweak_name_0", str); }
	//! Tweak 0 name
 	std::string get_tweak_name_0() const { return getString("tweak_name_0"); }

	//! Tweak 0 int/bool value
 	bool set_tweak_int_0(const Plugin& textureint) { return setValue("tweak_int_0", textureint); }
	//! Tweak 0 int/bool value
 	bool set_tweak_int_0(int textureint) { return setValue("tweak_int_0", textureint); }
	//! Tweak 0 int/bool value
 	Value get_tweak_int_0() const { return getValue("tweak_int_0"); }

	//! Tweak 0 float value
 	bool set_tweak_float_0(const Plugin& texturefloat) { return setValue("tweak_float_0", texturefloat); }
	//! Tweak 0 float value
 	bool set_tweak_float_0(float texturefloat) { return setValue("tweak_float_0", texturefloat); }
	//! Tweak 0 float value
 	Value get_tweak_float_0() const { return getValue("tweak_float_0"); }

	//! Tweak 0 color value
 	bool set_tweak_color_0(const Plugin& texture) { return setValue("tweak_color_0", texture); }
	//! Tweak 0 color value
 	bool set_tweak_color_0(const AColor& texture) { return setValue("tweak_color_0", texture); }
	//! Tweak 0 color value
 	Value get_tweak_color_0() const { return getValue("tweak_color_0"); }

	//! Enable tweak 1
 	//! [Default value] false
	bool set_tweak_enable_1(bool val) { return setValue("tweak_enable_1", val); }
	//! Enable tweak 1
 	//! [Default value] false
	bool get_tweak_enable_1() const { return getBool("tweak_enable_1"); }

	//! Tweak 1 name
 	bool set_tweak_name_1(const char* str) { return setValue("tweak_name_1", str); }
	//! Tweak 1 name
 	bool set_tweak_name_1(const std::string& str) { return setValue("tweak_name_1", str); }
	//! Tweak 1 name
 	std::string get_tweak_name_1() const { return getString("tweak_name_1"); }

	//! Tweak 1 int/bool value
 	bool set_tweak_int_1(const Plugin& textureint) { return setValue("tweak_int_1", textureint); }
	//! Tweak 1 int/bool value
 	bool set_tweak_int_1(int textureint) { return setValue("tweak_int_1", textureint); }
	//! Tweak 1 int/bool value
 	Value get_tweak_int_1() const { return getValue("tweak_int_1"); }

	//! Tweak 1 float value
 	bool set_tweak_float_1(const Plugin& texturefloat) { return setValue("tweak_float_1", texturefloat); }
	//! Tweak 1 float value
 	bool set_tweak_float_1(float texturefloat) { return setValue("tweak_float_1", texturefloat); }
	//! Tweak 1 float value
 	Value get_tweak_float_1() const { return getValue("tweak_float_1"); }

	//! Tweak 1 color value
 	bool set_tweak_color_1(const Plugin& texture) { return setValue("tweak_color_1", texture); }
	//! Tweak 1 color value
 	bool set_tweak_color_1(const AColor& texture) { return setValue("tweak_color_1", texture); }
	//! Tweak 1 color value
 	Value get_tweak_color_1() const { return getValue("tweak_color_1"); }

	//! Enable tweak 2
 	//! [Default value] false
	bool set_tweak_enable_2(bool val) { return setValue("tweak_enable_2", val); }
	//! Enable tweak 2
 	//! [Default value] false
	bool get_tweak_enable_2() const { return getBool("tweak_enable_2"); }

	//! Tweak 2 name
 	bool set_tweak_name_2(const char* str) { return setValue("tweak_name_2", str); }
	//! Tweak 2 name
 	bool set_tweak_name_2(const std::string& str) { return setValue("tweak_name_2", str); }
	//! Tweak 2 name
 	std::string get_tweak_name_2() const { return getString("tweak_name_2"); }

	//! Tweak 2 int/bool value
 	bool set_tweak_int_2(const Plugin& textureint) { return setValue("tweak_int_2", textureint); }
	//! Tweak 2 int/bool value
 	bool set_tweak_int_2(int textureint) { return setValue("tweak_int_2", textureint); }
	//! Tweak 2 int/bool value
 	Value get_tweak_int_2() const { return getValue("tweak_int_2"); }

	//! Tweak 2 float value
 	bool set_tweak_float_2(const Plugin& texturefloat) { return setValue("tweak_float_2", texturefloat); }
	//! Tweak 2 float value
 	bool set_tweak_float_2(float texturefloat) { return setValue("tweak_float_2", texturefloat); }
	//! Tweak 2 float value
 	Value get_tweak_float_2() const { return getValue("tweak_float_2"); }

	//! Tweak 2 color value
 	bool set_tweak_color_2(const Plugin& texture) { return setValue("tweak_color_2", texture); }
	//! Tweak 2 color value
 	bool set_tweak_color_2(const AColor& texture) { return setValue("tweak_color_2", texture); }
	//! Tweak 2 color value
 	Value get_tweak_color_2() const { return getValue("tweak_color_2"); }

	//! Enable tweak 3
 	//! [Default value] false
	bool set_tweak_enable_3(bool val) { return setValue("tweak_enable_3", val); }
	//! Enable tweak 3
 	//! [Default value] false
	bool get_tweak_enable_3() const { return getBool("tweak_enable_3"); }

	//! Tweak 3 name
 	bool set_tweak_name_3(const char* str) { return setValue("tweak_name_3", str); }
	//! Tweak 3 name
 	bool set_tweak_name_3(const std::string& str) { return setValue("tweak_name_3", str); }
	//! Tweak 3 name
 	std::string get_tweak_name_3() const { return getString("tweak_name_3"); }

	//! Tweak 3 int/bool value
 	bool set_tweak_int_3(const Plugin& textureint) { return setValue("tweak_int_3", textureint); }
	//! Tweak 3 int/bool value
 	bool set_tweak_int_3(int textureint) { return setValue("tweak_int_3", textureint); }
	//! Tweak 3 int/bool value
 	Value get_tweak_int_3() const { return getValue("tweak_int_3"); }

	//! Tweak 3 float value
 	bool set_tweak_float_3(const Plugin& texturefloat) { return setValue("tweak_float_3", texturefloat); }
	//! Tweak 3 float value
 	bool set_tweak_float_3(float texturefloat) { return setValue("tweak_float_3", texturefloat); }
	//! Tweak 3 float value
 	Value get_tweak_float_3() const { return getValue("tweak_float_3"); }

	//! Tweak 3 color value
 	bool set_tweak_color_3(const Plugin& texture) { return setValue("tweak_color_3", texture); }
	//! Tweak 3 color value
 	bool set_tweak_color_3(const AColor& texture) { return setValue("tweak_color_3", texture); }
	//! Tweak 3 color value
 	Value get_tweak_color_3() const { return getValue("tweak_color_3"); }

	//! Enable tweak 4
 	//! [Default value] false
	bool set_tweak_enable_4(bool val) { return setValue("tweak_enable_4", val); }
	//! Enable tweak 4
 	//! [Default value] false
	bool get_tweak_enable_4() const { return getBool("tweak_enable_4"); }

	//! Tweak 4 name
 	bool set_tweak_name_4(const char* str) { return setValue("tweak_name_4", str); }
	//! Tweak 4 name
 	bool set_tweak_name_4(const std::string& str) { return setValue("tweak_name_4", str); }
	//! Tweak 4 name
 	std::string get_tweak_name_4() const { return getString("tweak_name_4"); }

	//! Tweak 4 int/bool value
 	bool set_tweak_int_4(const Plugin& textureint) { return setValue("tweak_int_4", textureint); }
	//! Tweak 4 int/bool value
 	bool set_tweak_int_4(int textureint) { return setValue("tweak_int_4", textureint); }
	//! Tweak 4 int/bool value
 	Value get_tweak_int_4() const { return getValue("tweak_int_4"); }

	//! Tweak 4 float value
 	bool set_tweak_float_4(const Plugin& texturefloat) { return setValue("tweak_float_4", texturefloat); }
	//! Tweak 4 float value
 	bool set_tweak_float_4(float texturefloat) { return setValue("tweak_float_4", texturefloat); }
	//! Tweak 4 float value
 	Value get_tweak_float_4() const { return getValue("tweak_float_4"); }

	//! Tweak 4 color value
 	bool set_tweak_color_4(const Plugin& texture) { return setValue("tweak_color_4", texture); }
	//! Tweak 4 color value
 	bool set_tweak_color_4(const AColor& texture) { return setValue("tweak_color_4", texture); }
	//! Tweak 4 color value
 	Value get_tweak_color_4() const { return getValue("tweak_color_4"); }

	//! Enable tweak 5
 	//! [Default value] false
	bool set_tweak_enable_5(bool val) { return setValue("tweak_enable_5", val); }
	//! Enable tweak 5
 	//! [Default value] false
	bool get_tweak_enable_5() const { return getBool("tweak_enable_5"); }

	//! Tweak 5 name
 	bool set_tweak_name_5(const char* str) { return setValue("tweak_name_5", str); }
	//! Tweak 5 name
 	bool set_tweak_name_5(const std::string& str) { return setValue("tweak_name_5", str); }
	//! Tweak 5 name
 	std::string get_tweak_name_5() const { return getString("tweak_name_5"); }

	//! Tweak 5 int/bool value
 	bool set_tweak_int_5(const Plugin& textureint) { return setValue("tweak_int_5", textureint); }
	//! Tweak 5 int/bool value
 	bool set_tweak_int_5(int textureint) { return setValue("tweak_int_5", textureint); }
	//! Tweak 5 int/bool value
 	Value get_tweak_int_5() const { return getValue("tweak_int_5"); }

	//! Tweak 5 float value
 	bool set_tweak_float_5(const Plugin& texturefloat) { return setValue("tweak_float_5", texturefloat); }
	//! Tweak 5 float value
 	bool set_tweak_float_5(float texturefloat) { return setValue("tweak_float_5", texturefloat); }
	//! Tweak 5 float value
 	Value get_tweak_float_5() const { return getValue("tweak_float_5"); }

	//! Tweak 5 color value
 	bool set_tweak_color_5(const Plugin& texture) { return setValue("tweak_color_5", texture); }
	//! Tweak 5 color value
 	bool set_tweak_color_5(const AColor& texture) { return setValue("tweak_color_5", texture); }
	//! Tweak 5 color value
 	Value get_tweak_color_5() const { return getValue("tweak_color_5"); }

	//! Enable tweak 6
 	//! [Default value] false
	bool set_tweak_enable_6(bool val) { return setValue("tweak_enable_6", val); }
	//! Enable tweak 6
 	//! [Default value] false
	bool get_tweak_enable_6() const { return getBool("tweak_enable_6"); }

	//! Tweak 6 name
 	bool set_tweak_name_6(const char* str) { return setValue("tweak_name_6", str); }
	//! Tweak 6 name
 	bool set_tweak_name_6(const std::string& str) { return setValue("tweak_name_6", str); }
	//! Tweak 6 name
 	std::string get_tweak_name_6() const { return getString("tweak_name_6"); }

	//! Tweak 6 int/bool value
 	bool set_tweak_int_6(const Plugin& textureint) { return setValue("tweak_int_6", textureint); }
	//! Tweak 6 int/bool value
 	bool set_tweak_int_6(int textureint) { return setValue("tweak_int_6", textureint); }
	//! Tweak 6 int/bool value
 	Value get_tweak_int_6() const { return getValue("tweak_int_6"); }

	//! Tweak 6 float value
 	bool set_tweak_float_6(const Plugin& texturefloat) { return setValue("tweak_float_6", texturefloat); }
	//! Tweak 6 float value
 	bool set_tweak_float_6(float texturefloat) { return setValue("tweak_float_6", texturefloat); }
	//! Tweak 6 float value
 	Value get_tweak_float_6() const { return getValue("tweak_float_6"); }

	//! Tweak 6 color value
 	bool set_tweak_color_6(const Plugin& texture) { return setValue("tweak_color_6", texture); }
	//! Tweak 6 color value
 	bool set_tweak_color_6(const AColor& texture) { return setValue("tweak_color_6", texture); }
	//! Tweak 6 color value
 	Value get_tweak_color_6() const { return getValue("tweak_color_6"); }

	//! Enable tweak 7
 	//! [Default value] false
	bool set_tweak_enable_7(bool val) { return setValue("tweak_enable_7", val); }
	//! Enable tweak 7
 	//! [Default value] false
	bool get_tweak_enable_7() const { return getBool("tweak_enable_7"); }

	//! Tweak 7 name
 	bool set_tweak_name_7(const char* str) { return setValue("tweak_name_7", str); }
	//! Tweak 7 name
 	bool set_tweak_name_7(const std::string& str) { return setValue("tweak_name_7", str); }
	//! Tweak 7 name
 	std::string get_tweak_name_7() const { return getString("tweak_name_7"); }

	//! Tweak 7 int/bool value
 	bool set_tweak_int_7(const Plugin& textureint) { return setValue("tweak_int_7", textureint); }
	//! Tweak 7 int/bool value
 	bool set_tweak_int_7(int textureint) { return setValue("tweak_int_7", textureint); }
	//! Tweak 7 int/bool value
 	Value get_tweak_int_7() const { return getValue("tweak_int_7"); }

	//! Tweak 7 float value
 	bool set_tweak_float_7(const Plugin& texturefloat) { return setValue("tweak_float_7", texturefloat); }
	//! Tweak 7 float value
 	bool set_tweak_float_7(float texturefloat) { return setValue("tweak_float_7", texturefloat); }
	//! Tweak 7 float value
 	Value get_tweak_float_7() const { return getValue("tweak_float_7"); }

	//! Tweak 7 color value
 	bool set_tweak_color_7(const Plugin& texture) { return setValue("tweak_color_7", texture); }
	//! Tweak 7 color value
 	bool set_tweak_color_7(const AColor& texture) { return setValue("tweak_color_7", texture); }
	//! Tweak 7 color value
 	Value get_tweak_color_7() const { return getValue("tweak_color_7"); }

	//! Enable tweak 8
 	//! [Default value] false
	bool set_tweak_enable_8(bool val) { return setValue("tweak_enable_8", val); }
	//! Enable tweak 8
 	//! [Default value] false
	bool get_tweak_enable_8() const { return getBool("tweak_enable_8"); }

	//! Tweak 8 name
 	bool set_tweak_name_8(const char* str) { return setValue("tweak_name_8", str); }
	//! Tweak 8 name
 	bool set_tweak_name_8(const std::string& str) { return setValue("tweak_name_8", str); }
	//! Tweak 8 name
 	std::string get_tweak_name_8() const { return getString("tweak_name_8"); }

	//! Tweak 8 int/bool value
 	bool set_tweak_int_8(const Plugin& textureint) { return setValue("tweak_int_8", textureint); }
	//! Tweak 8 int/bool value
 	bool set_tweak_int_8(int textureint) { return setValue("tweak_int_8", textureint); }
	//! Tweak 8 int/bool value
 	Value get_tweak_int_8() const { return getValue("tweak_int_8"); }

	//! Tweak 8 float value
 	bool set_tweak_float_8(const Plugin& texturefloat) { return setValue("tweak_float_8", texturefloat); }
	//! Tweak 8 float value
 	bool set_tweak_float_8(float texturefloat) { return setValue("tweak_float_8", texturefloat); }
	//! Tweak 8 float value
 	Value get_tweak_float_8() const { return getValue("tweak_float_8"); }

	//! Tweak 8 color value
 	bool set_tweak_color_8(const Plugin& texture) { return setValue("tweak_color_8", texture); }
	//! Tweak 8 color value
 	bool set_tweak_color_8(const AColor& texture) { return setValue("tweak_color_8", texture); }
	//! Tweak 8 color value
 	Value get_tweak_color_8() const { return getValue("tweak_color_8"); }

	//! Enable tweak 9
 	//! [Default value] false
	bool set_tweak_enable_9(bool val) { return setValue("tweak_enable_9", val); }
	//! Enable tweak 9
 	//! [Default value] false
	bool get_tweak_enable_9() const { return getBool("tweak_enable_9"); }

	//! Tweak 9 name
 	bool set_tweak_name_9(const char* str) { return setValue("tweak_name_9", str); }
	//! Tweak 9 name
 	bool set_tweak_name_9(const std::string& str) { return setValue("tweak_name_9", str); }
	//! Tweak 9 name
 	std::string get_tweak_name_9() const { return getString("tweak_name_9"); }

	//! Tweak 9 int/bool value
 	bool set_tweak_int_9(const Plugin& textureint) { return setValue("tweak_int_9", textureint); }
	//! Tweak 9 int/bool value
 	bool set_tweak_int_9(int textureint) { return setValue("tweak_int_9", textureint); }
	//! Tweak 9 int/bool value
 	Value get_tweak_int_9() const { return getValue("tweak_int_9"); }

	//! Tweak 9 float value
 	bool set_tweak_float_9(const Plugin& texturefloat) { return setValue("tweak_float_9", texturefloat); }
	//! Tweak 9 float value
 	bool set_tweak_float_9(float texturefloat) { return setValue("tweak_float_9", texturefloat); }
	//! Tweak 9 float value
 	Value get_tweak_float_9() const { return getValue("tweak_float_9"); }

	//! Tweak 9 color value
 	bool set_tweak_color_9(const Plugin& texture) { return setValue("tweak_color_9", texture); }
	//! Tweak 9 color value
 	bool set_tweak_color_9(const AColor& texture) { return setValue("tweak_color_9", texture); }
	//! Tweak 9 color value
 	Value get_tweak_color_9() const { return getValue("tweak_color_9"); }

	//! Enable tweak 10
 	//! [Default value] false
	bool set_tweak_enable_10(bool val) { return setValue("tweak_enable_10", val); }
	//! Enable tweak 10
 	//! [Default value] false
	bool get_tweak_enable_10() const { return getBool("tweak_enable_10"); }

	//! Tweak 10 name
 	bool set_tweak_name_10(const char* str) { return setValue("tweak_name_10", str); }
	//! Tweak 10 name
 	bool set_tweak_name_10(const std::string& str) { return setValue("tweak_name_10", str); }
	//! Tweak 10 name
 	std::string get_tweak_name_10() const { return getString("tweak_name_10"); }

	//! Tweak 10 int/bool value
 	bool set_tweak_int_10(const Plugin& textureint) { return setValue("tweak_int_10", textureint); }
	//! Tweak 10 int/bool value
 	bool set_tweak_int_10(int textureint) { return setValue("tweak_int_10", textureint); }
	//! Tweak 10 int/bool value
 	Value get_tweak_int_10() const { return getValue("tweak_int_10"); }

	//! Tweak 10 float value
 	bool set_tweak_float_10(const Plugin& texturefloat) { return setValue("tweak_float_10", texturefloat); }
	//! Tweak 10 float value
 	bool set_tweak_float_10(float texturefloat) { return setValue("tweak_float_10", texturefloat); }
	//! Tweak 10 float value
 	Value get_tweak_float_10() const { return getValue("tweak_float_10"); }

	//! Tweak 10 color value
 	bool set_tweak_color_10(const Plugin& texture) { return setValue("tweak_color_10", texture); }
	//! Tweak 10 color value
 	bool set_tweak_color_10(const AColor& texture) { return setValue("tweak_color_10", texture); }
	//! Tweak 10 color value
 	Value get_tweak_color_10() const { return getValue("tweak_color_10"); }

	//! Enable tweak 11
 	//! [Default value] false
	bool set_tweak_enable_11(bool val) { return setValue("tweak_enable_11", val); }
	//! Enable tweak 11
 	//! [Default value] false
	bool get_tweak_enable_11() const { return getBool("tweak_enable_11"); }

	//! Tweak 11 name
 	bool set_tweak_name_11(const char* str) { return setValue("tweak_name_11", str); }
	//! Tweak 11 name
 	bool set_tweak_name_11(const std::string& str) { return setValue("tweak_name_11", str); }
	//! Tweak 11 name
 	std::string get_tweak_name_11() const { return getString("tweak_name_11"); }

	//! Tweak 11 int/bool value
 	bool set_tweak_int_11(const Plugin& textureint) { return setValue("tweak_int_11", textureint); }
	//! Tweak 11 int/bool value
 	bool set_tweak_int_11(int textureint) { return setValue("tweak_int_11", textureint); }
	//! Tweak 11 int/bool value
 	Value get_tweak_int_11() const { return getValue("tweak_int_11"); }

	//! Tweak 11 float value
 	bool set_tweak_float_11(const Plugin& texturefloat) { return setValue("tweak_float_11", texturefloat); }
	//! Tweak 11 float value
 	bool set_tweak_float_11(float texturefloat) { return setValue("tweak_float_11", texturefloat); }
	//! Tweak 11 float value
 	Value get_tweak_float_11() const { return getValue("tweak_float_11"); }

	//! Tweak 11 color value
 	bool set_tweak_color_11(const Plugin& texture) { return setValue("tweak_color_11", texture); }
	//! Tweak 11 color value
 	bool set_tweak_color_11(const AColor& texture) { return setValue("tweak_color_11", texture); }
	//! Tweak 11 color value
 	Value get_tweak_color_11() const { return getValue("tweak_color_11"); }
};

class BRDFSkinComplex : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "BRDFSkinComplex"; }

	//! Values below 1.0 will make the object look as if it is bigger. Values above 1.0 will make it look as if it is smaller
 	//! [UI Guides] startTab=V-Ray Skin, startRollout=General parameters, minValue=0, maxValue=10000
 	//! [Default value] 1
	bool set_scale(float val) { return setValue("scale", val); }
	//! Values below 1.0 will make the object look as if it is bigger. Values above 1.0 will make it look as if it is smaller
 	//! [UI Guides] startTab=V-Ray Skin, startRollout=General parameters, minValue=0, maxValue=10000
 	//! [Default value] 1
	float get_scale() const { return getFloat("scale"); }

	//! The maximum summed weight of the SSS components
 	//! [UI Guides] displayName=Max SSS amount, minValue=0, maxValue=10000
 	bool set_max_sss_amount(const Plugin& texturefloat) { return setValue("max_sss_amount", texturefloat); }
	//! The maximum summed weight of the SSS components
 	//! [UI Guides] displayName=Max SSS amount, minValue=0, maxValue=10000
 	bool set_max_sss_amount(float texturefloat) { return setValue("max_sss_amount", texturefloat); }
	//! The maximum summed weight of the SSS components
 	//! [UI Guides] displayName=Max SSS amount, minValue=0, maxValue=10000
 	Value get_max_sss_amount() const { return getValue("max_sss_amount"); }

	//! The maximum summed weight of the reflection components
 	//! [UI Guides] displayName=Max refl amount, minValue=0, maxValue=10000
 	bool set_max_reflection_amount(const Plugin& texturefloat) { return setValue("max_reflection_amount", texturefloat); }
	//! The maximum summed weight of the reflection components
 	//! [UI Guides] displayName=Max refl amount, minValue=0, maxValue=10000
 	bool set_max_reflection_amount(float texturefloat) { return setValue("max_reflection_amount", texturefloat); }
	//! The maximum summed weight of the reflection components
 	//! [UI Guides] displayName=Max refl amount, minValue=0, maxValue=10000
 	Value get_max_reflection_amount() const { return getValue("max_reflection_amount"); }

	//! Opacity
 	bool set_opacity(const Plugin& texture) { return setValue("opacity", texture); }
	//! Opacity
 	bool set_opacity(const AColor& texture) { return setValue("opacity", texture); }
	//! Opacity
 	Value get_opacity() const { return getValue("opacity"); }

	//! [UI Guides] startRollout=
 	bool set_diffuse_color(const Plugin& texture) { return setValue("diffuse_color", texture); }
	//! [UI Guides] startRollout=
 	bool set_diffuse_color(const AColor& texture) { return setValue("diffuse_color", texture); }
	//! [UI Guides] startRollout=
 	Value get_diffuse_color() const { return getValue("diffuse_color"); }

	//! [UI Guides] minValue=0, maxValue=1000
 	bool set_diffuse_amount(const Plugin& texturefloat) { return setValue("diffuse_amount", texturefloat); }
	//! [UI Guides] minValue=0, maxValue=1000
 	bool set_diffuse_amount(float texturefloat) { return setValue("diffuse_amount", texturefloat); }
	//! [UI Guides] minValue=0, maxValue=1000
 	Value get_diffuse_amount() const { return getValue("diffuse_amount"); }

	//! [UI Guides] startRollout=
 	bool set_shallow_color(const Plugin& texture) { return setValue("shallow_color", texture); }
	//! [UI Guides] startRollout=
 	bool set_shallow_color(const AColor& texture) { return setValue("shallow_color", texture); }
	//! [UI Guides] startRollout=
 	Value get_shallow_color() const { return getValue("shallow_color"); }

	//! [UI Guides] minValue=0, maxValue=1000
 	bool set_shallow_amount(const Plugin& texturefloat) { return setValue("shallow_amount", texturefloat); }
	//! [UI Guides] minValue=0, maxValue=1000
 	bool set_shallow_amount(float texturefloat) { return setValue("shallow_amount", texturefloat); }
	//! [UI Guides] minValue=0, maxValue=1000
 	Value get_shallow_amount() const { return getValue("shallow_amount"); }

	//! The radius for shallow scattering, in cm
 	//! [UI Guides] displayName=Shallow Radius in cm, minValue=0
 	bool set_shallow_radius(const Plugin& texturefloat) { return setValue("shallow_radius", texturefloat); }
	//! The radius for shallow scattering, in cm
 	//! [UI Guides] displayName=Shallow Radius in cm, minValue=0
 	bool set_shallow_radius(float texturefloat) { return setValue("shallow_radius", texturefloat); }
	//! The radius for shallow scattering, in cm
 	//! [UI Guides] displayName=Shallow Radius in cm, minValue=0
 	Value get_shallow_radius() const { return getValue("shallow_radius"); }

	//! [UI Guides] startRollout=
 	bool set_medium_color(const Plugin& texture) { return setValue("medium_color", texture); }
	//! [UI Guides] startRollout=
 	bool set_medium_color(const AColor& texture) { return setValue("medium_color", texture); }
	//! [UI Guides] startRollout=
 	Value get_medium_color() const { return getValue("medium_color"); }

	//! [UI Guides] minValue=0, maxValue=1000
 	bool set_medium_amount(const Plugin& texturefloat) { return setValue("medium_amount", texturefloat); }
	//! [UI Guides] minValue=0, maxValue=1000
 	bool set_medium_amount(float texturefloat) { return setValue("medium_amount", texturefloat); }
	//! [UI Guides] minValue=0, maxValue=1000
 	Value get_medium_amount() const { return getValue("medium_amount"); }

	//! The radius for medium scattering, in cm
 	//! [UI Guides] displayName=Medium Radius in cm, minValue=0
 	bool set_medium_radius(const Plugin& texturefloat) { return setValue("medium_radius", texturefloat); }
	//! The radius for medium scattering, in cm
 	//! [UI Guides] displayName=Medium Radius in cm, minValue=0
 	bool set_medium_radius(float texturefloat) { return setValue("medium_radius", texturefloat); }
	//! The radius for medium scattering, in cm
 	//! [UI Guides] displayName=Medium Radius in cm, minValue=0
 	Value get_medium_radius() const { return getValue("medium_radius"); }

	//! [UI Guides] startRollout=
 	bool set_deep_color(const Plugin& texture) { return setValue("deep_color", texture); }
	//! [UI Guides] startRollout=
 	bool set_deep_color(const AColor& texture) { return setValue("deep_color", texture); }
	//! [UI Guides] startRollout=
 	Value get_deep_color() const { return getValue("deep_color"); }

	//! [UI Guides] minValue=0, maxValue=1000
 	bool set_deep_amount(const Plugin& texturefloat) { return setValue("deep_amount", texturefloat); }
	//! [UI Guides] minValue=0, maxValue=1000
 	bool set_deep_amount(float texturefloat) { return setValue("deep_amount", texturefloat); }
	//! [UI Guides] minValue=0, maxValue=1000
 	Value get_deep_amount() const { return getValue("deep_amount"); }

	//! The radius for deep scattering, in cm
 	//! [UI Guides] displayName=Deep Radius in cm, minValue=0
 	bool set_deep_radius(const Plugin& texturefloat) { return setValue("deep_radius", texturefloat); }
	//! The radius for deep scattering, in cm
 	//! [UI Guides] displayName=Deep Radius in cm, minValue=0
 	bool set_deep_radius(float texturefloat) { return setValue("deep_radius", texturefloat); }
	//! The radius for deep scattering, in cm
 	//! [UI Guides] displayName=Deep Radius in cm, minValue=0
 	Value get_deep_radius() const { return getValue("deep_radius"); }

	//! [UI Guides] displayName=Prim. refl. color, startRollout=Primary reflection
 	bool set_primary_reflecton_color(const Plugin& texture) { return setValue("primary_reflecton_color", texture); }
	//! [UI Guides] displayName=Prim. refl. color, startRollout=Primary reflection
 	bool set_primary_reflecton_color(const AColor& texture) { return setValue("primary_reflecton_color", texture); }
	//! [UI Guides] displayName=Prim. refl. color, startRollout=Primary reflection
 	Value get_primary_reflecton_color() const { return getValue("primary_reflecton_color"); }

	//! [UI Guides] displayName=Prim. refl. amount, minValue=0, maxValue=1000
 	bool set_primary_reflection_amount(const Plugin& texturefloat) { return setValue("primary_reflection_amount", texturefloat); }
	//! [UI Guides] displayName=Prim. refl. amount, minValue=0, maxValue=1000
 	bool set_primary_reflection_amount(float texturefloat) { return setValue("primary_reflection_amount", texturefloat); }
	//! [UI Guides] displayName=Prim. refl. amount, minValue=0, maxValue=1000
 	Value get_primary_reflection_amount() const { return getValue("primary_reflection_amount"); }

	//! [UI Guides] displayName=Prim. refl. glossiness, minValue=0, maxValue=1
 	bool set_primary_reflection_glossiness(const Plugin& texturefloat) { return setValue("primary_reflection_glossiness", texturefloat); }
	//! [UI Guides] displayName=Prim. refl. glossiness, minValue=0, maxValue=1
 	bool set_primary_reflection_glossiness(float texturefloat) { return setValue("primary_reflection_glossiness", texturefloat); }
	//! [UI Guides] displayName=Prim. refl. glossiness, minValue=0, maxValue=1
 	Value get_primary_reflection_glossiness() const { return getValue("primary_reflection_glossiness"); }

	//! [UI Guides] displayName=Prim. refl. subdivs, minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	bool set_primary_reflection_subdivs(int val) { return setValue("primary_reflection_subdivs", val); }
	//! [UI Guides] displayName=Prim. refl. subdivs, minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	int get_primary_reflection_subdivs() const { return getInt("primary_reflection_subdivs"); }

	//! [UI Guides] displayName=Prim. refl. fresnel
 	//! [Default value] true
	bool set_primary_reflection_fresnel(bool val) { return setValue("primary_reflection_fresnel", val); }
	//! [UI Guides] displayName=Prim. refl. fresnel
 	//! [Default value] true
	bool get_primary_reflection_fresnel() const { return getBool("primary_reflection_fresnel"); }

	//! [UI Guides] displayName=Prim. refl. fresnel IOR, enableIf: ?primary_reflection_fresnel=1, minValue=1, maxValue=100
 	//! [Default value] 1.33
	bool set_primary_reflection_fresnel_ior(float val) { return setValue("primary_reflection_fresnel_ior", val); }
	//! [UI Guides] displayName=Prim. refl. fresnel IOR, enableIf: ?primary_reflection_fresnel=1, minValue=1, maxValue=100
 	//! [Default value] 1.33
	float get_primary_reflection_fresnel_ior() const { return getFloat("primary_reflection_fresnel_ior"); }

	//! [UI Guides] displayName=Sec. refl. color, startRollout=Secondary reflection
 	bool set_secondary_reflecton_color(const Plugin& texture) { return setValue("secondary_reflecton_color", texture); }
	//! [UI Guides] displayName=Sec. refl. color, startRollout=Secondary reflection
 	bool set_secondary_reflecton_color(const AColor& texture) { return setValue("secondary_reflecton_color", texture); }
	//! [UI Guides] displayName=Sec. refl. color, startRollout=Secondary reflection
 	Value get_secondary_reflecton_color() const { return getValue("secondary_reflecton_color"); }

	//! [UI Guides] displayName=Sec. refl. amount, minValue=0, maxValue=1000
 	bool set_secondary_reflection_amount(const Plugin& texturefloat) { return setValue("secondary_reflection_amount", texturefloat); }
	//! [UI Guides] displayName=Sec. refl. amount, minValue=0, maxValue=1000
 	bool set_secondary_reflection_amount(float texturefloat) { return setValue("secondary_reflection_amount", texturefloat); }
	//! [UI Guides] displayName=Sec. refl. amount, minValue=0, maxValue=1000
 	Value get_secondary_reflection_amount() const { return getValue("secondary_reflection_amount"); }

	//! [UI Guides] displayName=Sec. refl. glossiness, minValue=0, maxValue=1
 	bool set_secondary_reflection_glossiness(const Plugin& texturefloat) { return setValue("secondary_reflection_glossiness", texturefloat); }
	//! [UI Guides] displayName=Sec. refl. glossiness, minValue=0, maxValue=1
 	bool set_secondary_reflection_glossiness(float texturefloat) { return setValue("secondary_reflection_glossiness", texturefloat); }
	//! [UI Guides] displayName=Sec. refl. glossiness, minValue=0, maxValue=1
 	Value get_secondary_reflection_glossiness() const { return getValue("secondary_reflection_glossiness"); }

	//! [UI Guides] displayName=Sec. refl. subdivs, minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	bool set_secondary_reflection_subdivs(int val) { return setValue("secondary_reflection_subdivs", val); }
	//! [UI Guides] displayName=Sec. refl. subdivs, minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	int get_secondary_reflection_subdivs() const { return getInt("secondary_reflection_subdivs"); }

	//! [UI Guides] displayName=Sec. refl. fresnel
 	//! [Default value] true
	bool set_secondary_reflection_fresnel(bool val) { return setValue("secondary_reflection_fresnel", val); }
	//! [UI Guides] displayName=Sec. refl. fresnel
 	//! [Default value] true
	bool get_secondary_reflection_fresnel() const { return getBool("secondary_reflection_fresnel"); }

	//! [UI Guides] displayName=Sec. refl. fresnel IOR, enableIf: ?secondary_reflection_fresnel=1, minValue=1, maxValue=100
 	//! [Default value] 1.33
	bool set_secondary_reflection_fresnel_ior(float val) { return setValue("secondary_reflection_fresnel_ior", val); }
	//! [UI Guides] displayName=Sec. refl. fresnel IOR, enableIf: ?secondary_reflection_fresnel=1, minValue=1, maxValue=100
 	//! [Default value] 1.33
	float get_secondary_reflection_fresnel_ior() const { return getFloat("secondary_reflection_fresnel_ior"); }

	//! The algorithm used to compute multiple scattering: 0 - prepass-based illumination map; 1 - object space illumination map; 2 - raytraced; 3 - none (diffuse approx.)
 	//! [UI Guides] startRollout=Multiple scattering options, enum=0:Prepass-based illumination map;1:Object-based illumination map;2:Raytraced;3:None
 	//! [Default value] 2
	bool set_multiple_scattering(int val) { return setValue("multiple_scattering", val); }
	//! The algorithm used to compute multiple scattering: 0 - prepass-based illumination map; 1 - object space illumination map; 2 - raytraced; 3 - none (diffuse approx.)
 	//! [UI Guides] startRollout=Multiple scattering options, enum=0:Prepass-based illumination map;1:Object-based illumination map;2:Raytraced;3:None
 	//! [Default value] 2
	int get_multiple_scattering() const { return getInt("multiple_scattering"); }

	//! true to enable scattering of GI rays
 	//! [UI Guides] displayName=Scatter GI
 	//! [Default value] false
	bool set_scatter_gi(bool val) { return setValue("scatter_gi", val); }
	//! true to enable scattering of GI rays
 	//! [UI Guides] displayName=Scatter GI
 	//! [Default value] false
	bool get_scatter_gi() const { return getBool("scatter_gi"); }

	//! true to scatter SSS textures when using raytraced scattering
 	//! [UI Guides] enableIf: ?multiple_scattering=2
 	//! [Default value] false
	bool set_raytraced_scatter_textures(bool val) { return setValue("raytraced_scatter_textures", val); }
	//! true to scatter SSS textures when using raytraced scattering
 	//! [UI Guides] enableIf: ?multiple_scattering=2
 	//! [Default value] false
	bool get_raytraced_scatter_textures() const { return getBool("raytraced_scatter_textures"); }

	//! [UI Guides] enableIf: ?multiple_scattering=2, minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	bool set_raytraced_subdivs(int val) { return setValue("raytraced_subdivs", val); }
	//! [UI Guides] enableIf: ?multiple_scattering=2, minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	int get_raytraced_subdivs() const { return getInt("raytraced_subdivs"); }

	//! Sampling density for the illumination map
 	//! [UI Guides] enableIf: ?multiple_scattering=0, minValue=-100, maxValue=100
 	//! [Default value] -1
	bool set_prepass_rate(int val) { return setValue("prepass_rate", val); }
	//! Sampling density for the illumination map
 	//! [UI Guides] enableIf: ?multiple_scattering=0, minValue=-100, maxValue=100
 	//! [Default value] -1
	int get_prepass_rate() const { return getInt("prepass_rate"); }

	//! 0 to calculate a separate illuminataion map for this shader; otherwise all shaders with the same prepass ID will share the same illumination map
 	//! [UI Guides] enableIf: ?multiple_scattering=0
 	//! [Default value] 0
	bool set_prepass_id(int val) { return setValue("prepass_id", val); }
	//! 0 to calculate a separate illuminataion map for this shader; otherwise all shaders with the same prepass ID will share the same illumination map
 	//! [UI Guides] enableIf: ?multiple_scattering=0
 	//! [Default value] 0
	int get_prepass_id() const { return getInt("prepass_id"); }

	//! Interpolation accuracy for the illumination map; normally 1.0 is fine.
 	//! [UI Guides] enableIf: ?multiple_scattering<2
 	//! [Default value] 1
	bool set_prepass_interpolation_accuracy(float val) { return setValue("prepass_interpolation_accuracy", val); }
	//! Interpolation accuracy for the illumination map; normally 1.0 is fine.
 	//! [UI Guides] enableIf: ?multiple_scattering<2
 	//! [Default value] 1
	float get_prepass_interpolation_accuracy() const { return getFloat("prepass_interpolation_accuracy"); }

	//! [UI Guides] displayName=Auto density, enableIf: ?multiple_scattering=1
 	//! [Default value] false
	bool set_geom_auto_density(bool val) { return setValue("geom_auto_density", val); }
	//! [UI Guides] displayName=Auto density, enableIf: ?multiple_scattering=1
 	//! [Default value] false
	bool get_geom_auto_density() const { return getBool("geom_auto_density"); }

	//! [UI Guides] displayName=Samples per unit area, enableIf: ?geom_auto_density=0, ?multiple_scattering=1, minValue=0
 	//! [Default value] 16
	bool set_geom_samples_per_unit_area(float val) { return setValue("geom_samples_per_unit_area", val); }
	//! [UI Guides] displayName=Samples per unit area, enableIf: ?geom_auto_density=0, ?multiple_scattering=1, minValue=0
 	//! [Default value] 16
	float get_geom_samples_per_unit_area() const { return getFloat("geom_samples_per_unit_area"); }

	//! An offset along the geometric surface normal at which to perform shading in order to avoid surface acne.
 	//! [UI Guides] displayName=Surface offset, enableIf: ?multiple_scattering=1, minValue=0
 	//! [Default value] 0.001
	bool set_geom_surface_offset(float val) { return setValue("geom_surface_offset", val); }
	//! An offset along the geometric surface normal at which to perform shading in order to avoid surface acne.
 	//! [UI Guides] displayName=Surface offset, enableIf: ?multiple_scattering=1, minValue=0
 	//! [Default value] 0.001
	float get_geom_surface_offset() const { return getFloat("geom_surface_offset"); }

	//! [UI Guides] displayName=Preview samples, enableIf: ?multiple_scattering=1
 	//! [Default value] false
	bool set_geom_preview_samples(bool val) { return setValue("geom_preview_samples", val); }
	//! [UI Guides] displayName=Preview samples, enableIf: ?multiple_scattering=1
 	//! [Default value] false
	bool get_geom_preview_samples() const { return getBool("geom_preview_samples"); }

	//! [UI Guides] displayName=Max distance, enableIf: ?multiple_scattering=1, ?geom_preview_samples=1, quantityType=distance, minValue=0, maxValue=10000
 	//! [Default value] 0.1
	bool set_geom_max_distance(float val) { return setValue("geom_max_distance", val); }
	//! [UI Guides] displayName=Max distance, enableIf: ?multiple_scattering=1, ?geom_preview_samples=1, quantityType=distance, minValue=0, maxValue=10000
 	//! [Default value] 0.1
	float get_geom_max_distance() const { return getFloat("geom_max_distance"); }

	//! [UI Guides] displayName=Background color, enableIf: ?multiple_scattering=1, ?geom_preview_samples=1
 	//! [Default value] Color(0, 0, 0)
	bool set_geom_background_color(const Color& color) { return setValue("geom_background_color", color); }
	//! [UI Guides] displayName=Background color, enableIf: ?multiple_scattering=1, ?geom_preview_samples=1
 	//! [Default value] Color(0, 0, 0)
	Color get_geom_background_color() const { return getColor("geom_background_color"); }

	//! [UI Guides] displayName=Samples color, enableIf: ?multiple_scattering=1, ?geom_preview_samples=1
 	//! [Default value] Color(1, 1, 1)
	bool set_geom_samples_color(const Color& color) { return setValue("geom_samples_color", color); }
	//! [UI Guides] displayName=Samples color, enableIf: ?multiple_scattering=1, ?geom_preview_samples=1
 	//! [Default value] Color(1, 1, 1)
	Color get_geom_samples_color() const { return getColor("geom_samples_color"); }

	//! [UI Guides] displayName=Trace reflections, startRollout=Options
 	//! [Default value] true
	bool set_option_reflections_trace(bool val) { return setValue("option_reflections_trace", val); }
	//! [UI Guides] displayName=Trace reflections, startRollout=Options
 	//! [Default value] true
	bool get_option_reflections_trace() const { return getBool("option_reflections_trace"); }

	//! [UI Guides] displayName=Reflection max depth, minValue=1, maxValue=100
 	//! [Default value] 5
	bool set_option_reflections_maxDepth(int val) { return setValue("option_reflections_maxDepth", val); }
	//! [UI Guides] displayName=Reflection max depth, minValue=1, maxValue=100
 	//! [Default value] 5
	int get_option_reflections_maxDepth() const { return getInt("option_reflections_maxDepth"); }

	//! [UI Guides] displayName=Reflection cutoff, minValue=0
 	//! [Default value] 0.001
	bool set_option_reflections_cutoff(float val) { return setValue("option_reflections_cutoff", val); }
	//! [UI Guides] displayName=Reflection cutoff, minValue=0
 	//! [Default value] 0.001
	float get_option_reflections_cutoff() const { return getFloat("option_reflections_cutoff"); }

	//! Render channels the result of this BRDF will be written to
 	bool set_channels(const ValueList& pluginList) { return setValue("channels", pluginList); }
	//! Render channels the result of this BRDF will be written to
 	ValueList get_channels() const { return getValueList("channels"); }
};

class BRDFStochasticFlakes : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "BRDFStochasticFlakes"; }

	//! Turn on the stochastic flakes. If this option is off, the underlying smooth distribution is used.
 	//! [UI Guides] startTab=V-Ray Stochastic Flakes, startRollout=Basic parameters
 	//! [Default value] true
	bool set_enable_flakes(bool val) { return setValue("enable_flakes", val); }
	//! Turn on the stochastic flakes. If this option is off, the underlying smooth distribution is used.
 	//! [UI Guides] startTab=V-Ray Stochastic Flakes, startRollout=Basic parameters
 	//! [Default value] true
	bool get_enable_flakes() const { return getBool("enable_flakes"); }

	//! The square root of the number of flakes per unit area in the texture space.
 	//! [UI Guides] displayName=Number of Flakes, minValue=1, maxValue46340, enableIf: ?enable_flakes=1
 	//! [Default value] 3000
	bool set_num_flakes(int val) { return setValue("num_flakes", val); }
	//! The square root of the number of flakes per unit area in the texture space.
 	//! [UI Guides] displayName=Number of Flakes, minValue=1, maxValue46340, enableIf: ?enable_flakes=1
 	//! [Default value] 3000
	int get_num_flakes() const { return getInt("num_flakes"); }

	//! [UI Guides] minValue=0, maxValue=1
 	bool set_hilight_glossiness(const Plugin& texturefloat) { return setValue("hilight_glossiness", texturefloat); }
	//! [UI Guides] minValue=0, maxValue=1
 	bool set_hilight_glossiness(float texturefloat) { return setValue("hilight_glossiness", texturefloat); }
	//! [UI Guides] minValue=0, maxValue=1
 	Value get_hilight_glossiness() const { return getValue("hilight_glossiness"); }

	//! The angle of the cone, in which flakes transfer light. The more narrow the angle the sharper the flakes.
 	//! [UI Guides] minValue=0, maxValue=20, enableIf: ?enable_flakes=1
 	//! [Default value] 3
	bool set_blur_angle(float val) { return setValue("blur_angle", val); }
	//! The angle of the cone, in which flakes transfer light. The more narrow the angle the sharper the flakes.
 	//! [UI Guides] minValue=0, maxValue=20, enableIf: ?enable_flakes=1
 	//! [Default value] 3
	float get_blur_angle() const { return getFloat("blur_angle"); }

	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	bool set_subdivs(int val) { return setValue("subdivs", val); }
	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	int get_subdivs() const { return getInt("subdivs"); }

	//! Flakes reflection filter color.
 	bool set_reflect_filter(const Plugin& texture) { return setValue("reflect_filter", texture); }
	//! Flakes reflection filter color.
 	bool set_reflect_filter(const AColor& texture) { return setValue("reflect_filter", texture); }
	//! Flakes reflection filter color.
 	Value get_reflect_filter() const { return getValue("reflect_filter"); }

	//! The mapping method for the flakes (0 - explicit mapping channel, 1 - triplanar projection in object space)
 	//! [UI Guides] enum=0:Mapping channel;1:Triplanar, enableIf: ?enable_flakes=1
 	//! [Default value] 0
	bool set_mapping_type(int val) { return setValue("mapping_type", val); }
	//! The mapping method for the flakes (0 - explicit mapping channel, 1 - triplanar projection in object space)
 	//! [UI Guides] enum=0:Mapping channel;1:Triplanar, enableIf: ?enable_flakes=1
 	//! [Default value] 0
	int get_mapping_type() const { return getInt("mapping_type"); }

	//! If specified and mapping type is Explicit mapping channel, will be used instead of map_channel.
 	//! [UI Guides] enableIf: ?enable_flakes=1
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! If specified and mapping type is Explicit mapping channel, will be used instead of map_channel.
 	//! [UI Guides] enableIf: ?enable_flakes=1
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! The mapping channel when the mapping_type is 0
 	//! [UI Guides] enableIf: ?enable_flakes=1,?mapping_type=0
 	//! [Default value] 0
	bool set_map_channel(int val) { return setValue("map_channel", val); }
	//! The mapping channel when the mapping_type is 0
 	//! [UI Guides] enableIf: ?enable_flakes=1,?mapping_type=0
 	//! [Default value] 0
	int get_map_channel() const { return getInt("map_channel"); }

	//! Locally scale the flakes pattern.
 	//! [UI Guides] enableIf: ?enable_flakes=1
 	//! [Default value] 1
	bool set_flake_scale(float val) { return setValue("flake_scale", val); }
	//! Locally scale the flakes pattern.
 	//! [UI Guides] enableIf: ?enable_flakes=1
 	//! [Default value] 1
	float get_flake_scale() const { return getFloat("flake_scale"); }

	//! BRDF type (0 - Beckmann, 1 - GGX)
 	//! [UI Guides] displayName=BRDF Type, enum=0:Beckmann;1:GGX
 	//! [Default value] 1
	bool set_brdf_type(int val) { return setValue("brdf_type", val); }
	//! BRDF type (0 - Beckmann, 1 - GGX)
 	//! [UI Guides] displayName=BRDF Type, enum=0:Beckmann;1:GGX
 	//! [Default value] 1
	int get_brdf_type() const { return getInt("brdf_type"); }

	//! Seed generating completely different random pattern
 	//! [UI Guides] minValue=0, maxValue=1000000000, enableIf: ?enable_flakes=1
 	//! [Default value] 0
	bool set_seed(int val) { return setValue("seed", val); }
	//! Seed generating completely different random pattern
 	//! [UI Guides] minValue=0, maxValue=1000000000, enableIf: ?enable_flakes=1
 	//! [Default value] 0
	int get_seed() const { return getInt("seed"); }

	//! Colored flakes option (0 - Off, 1 - Random hue, 2 - Random from map)
 	//! [UI Guides] startRollout=Colored flakes parameters, displayName=Colored flakes, enum=0:Off;1:Random hue;2:Random from map, enableIf: ?enable_flakes=1
 	//! [Default value] 0
	bool set_colored_flakes_option(int val) { return setValue("colored_flakes_option", val); }
	//! Colored flakes option (0 - Off, 1 - Random hue, 2 - Random from map)
 	//! [UI Guides] startRollout=Colored flakes parameters, displayName=Colored flakes, enum=0:Off;1:Random hue;2:Random from map, enableIf: ?enable_flakes=1
 	//! [Default value] 0
	int get_colored_flakes_option() const { return getInt("colored_flakes_option"); }

	//! Flake color saturation when "Random saturation" is disabled
 	//! [UI Guides] enableIf: ?random_hue=1, ?random_saturation=0, minValue=0, maxValue=1, enable=?enable_flakes=1,?colored_flakes_option=1
 	//! [Default value] 1
	bool set_saturation(float val) { return setValue("saturation", val); }
	//! Flake color saturation when "Random saturation" is disabled
 	//! [UI Guides] enableIf: ?random_hue=1, ?random_saturation=0, minValue=0, maxValue=1, enable=?enable_flakes=1,?colored_flakes_option=1
 	//! [Default value] 1
	float get_saturation() const { return getFloat("saturation"); }

	//! Flake color lightness when "Random lightness" is disabled
 	//! [UI Guides] enableIf: ?random_hue=1, ?random_lightness=0, minValue=0, maxValue=1, enable=?enable_flakes=1,?colored_flakes_option=1
 	//! [Default value] 0.5
	bool set_lightness(float val) { return setValue("lightness", val); }
	//! Flake color lightness when "Random lightness" is disabled
 	//! [UI Guides] enableIf: ?random_hue=1, ?random_lightness=0, minValue=0, maxValue=1, enable=?enable_flakes=1,?colored_flakes_option=1
 	//! [Default value] 0.5
	float get_lightness() const { return getFloat("lightness"); }

	//! Texture to sample random flake colors. The u coordinate is sampled in uv space.
 	//! [UI Guides] enableIf: ?enable_flakes=1,?colored_flakes_option=2
 	bool set_random_color_map(const Plugin& texture) { return setValue("random_color_map", texture); }
	//! Texture to sample random flake colors. The u coordinate is sampled in uv space.
 	//! [UI Guides] enableIf: ?enable_flakes=1,?colored_flakes_option=2
 	bool set_random_color_map(const AColor& texture) { return setValue("random_color_map", texture); }
	//! Texture to sample random flake colors. The u coordinate is sampled in uv space.
 	//! [UI Guides] enableIf: ?enable_flakes=1,?colored_flakes_option=2
 	Value get_random_color_map() const { return getValue("random_color_map"); }

	//! Normalize flakes colors to be white (1, 1, 1) on avarage.
 	//! [UI Guides] enableIf: ?enable_flakes=1,?colored_flakes_option>0
 	//! [Default value] false
	bool set_white_average(bool val) { return setValue("white_average", val); }
	//! Normalize flakes colors to be white (1, 1, 1) on avarage.
 	//! [UI Guides] enableIf: ?enable_flakes=1,?colored_flakes_option>0
 	//! [Default value] false
	bool get_white_average() const { return getBool("white_average"); }

	//! The subdivisions of a unit square in texture space. Increase only if you observe square-like artefacts in zoomed regions.
 	//! [UI Guides] minValue=10, maxValue=24, enableIf: ?enable_flakes=1
 	//! [Default value] 12
	bool set_tex_subdivs(int val) { return setValue("tex_subdivs", val); }
	//! The subdivisions of a unit square in texture space. Increase only if you observe square-like artefacts in zoomed regions.
 	//! [UI Guides] minValue=10, maxValue=24, enableIf: ?enable_flakes=1
 	//! [Default value] 12
	int get_tex_subdivs() const { return getInt("tex_subdivs"); }

	//! Number of flakes per pixel, below which the smooth distribution is not computed and blended.
 	//! [UI Guides] startRollout=Advanced parameters, minValue=0, maxValue=10000, enableIf: ?enable_flakes=1
 	//! [Default value] 500
	bool set_blend_min(float val) { return setValue("blend_min", val); }
	//! Number of flakes per pixel, below which the smooth distribution is not computed and blended.
 	//! [UI Guides] startRollout=Advanced parameters, minValue=0, maxValue=10000, enableIf: ?enable_flakes=1
 	//! [Default value] 500
	float get_blend_min() const { return getFloat("blend_min"); }

	//! Number of flakes per pixel, above which only the smooth distribution is computed.
 	//! [UI Guides] minValue=0, maxValue=10000, enableIf: ?enable_flakes=1
 	//! [Default value] 2000
	bool set_blend_max(float val) { return setValue("blend_max", val); }
	//! Number of flakes per pixel, above which only the smooth distribution is computed.
 	//! [UI Guides] minValue=0, maxValue=10000, enableIf: ?enable_flakes=1
 	//! [Default value] 2000
	float get_blend_max() const { return getFloat("blend_max"); }
};

class BRDFVRayMtl : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "BRDFVRayMtl"; }

	//! Choose between grayscale or colored opacity.
 	//! [UI Guides] startTab=V-Ray Material Basic, startRollout=Basic, enum=0:Opacity Grayscale;1:Opacity Colored
 	//! [Default value] 0
	bool set_opacity_source(int val) { return setValue("opacity_source", val); }
	//! Choose between grayscale or colored opacity.
 	//! [UI Guides] startTab=V-Ray Material Basic, startRollout=Basic, enum=0:Opacity Grayscale;1:Opacity Colored
 	//! [Default value] 0
	int get_opacity_source() const { return getInt("opacity_source"); }

	//! The opacity of the material
 	//! [UI Guides] displayName=Opacity Grayscale, enableIf: ?opacity_source=0, minValue=0.0, maxValue=1.0
 	bool set_opacity(const Plugin& texturefloat) { return setValue("opacity", texturefloat); }
	//! The opacity of the material
 	//! [UI Guides] displayName=Opacity Grayscale, enableIf: ?opacity_source=0, minValue=0.0, maxValue=1.0
 	bool set_opacity(float texturefloat) { return setValue("opacity", texturefloat); }
	//! The opacity of the material
 	//! [UI Guides] displayName=Opacity Grayscale, enableIf: ?opacity_source=0, minValue=0.0, maxValue=1.0
 	Value get_opacity() const { return getValue("opacity"); }

	//! The color opacity map of the material
 	//! [UI Guides] displayName=Opacity Colored, enableIf: ?opacity_source=1
 	bool set_opacity_color(const Plugin& texture) { return setValue("opacity_color", texture); }
	//! The color opacity map of the material
 	//! [UI Guides] displayName=Opacity Colored, enableIf: ?opacity_source=1
 	bool set_opacity_color(const AColor& texture) { return setValue("opacity_color", texture); }
	//! The color opacity map of the material
 	//! [UI Guides] displayName=Opacity Colored, enableIf: ?opacity_source=1
 	Value get_opacity_color() const { return getValue("opacity_color"); }

	//! The diffuse color of the material
 	//! [UI Guides] displayName=Diffuse color
 	bool set_diffuse(const Plugin& texture) { return setValue("diffuse", texture); }
	//! The diffuse color of the material
 	//! [UI Guides] displayName=Diffuse color
 	bool set_diffuse(const AColor& texture) { return setValue("diffuse", texture); }
	//! The diffuse color of the material
 	//! [UI Guides] displayName=Diffuse color
 	Value get_diffuse() const { return getValue("diffuse"); }

	//! The roughness of the diffuse part of the material
 	//! [UI Guides] displayName=Diffuse roughness, minValue=0.0, maxValue=1.0
 	bool set_roughness(const Plugin& texturefloat) { return setValue("roughness", texturefloat); }
	//! The roughness of the diffuse part of the material
 	//! [UI Guides] displayName=Diffuse roughness, minValue=0.0, maxValue=1.0
 	bool set_roughness(float texturefloat) { return setValue("roughness", texturefloat); }
	//! The roughness of the diffuse part of the material
 	//! [UI Guides] displayName=Diffuse roughness, minValue=0.0, maxValue=1.0
 	Value get_roughness() const { return getValue("roughness"); }

	//! The self-illumination color of the material
 	//! [UI Guides] displayName=Self-Illumination color
 	bool set_self_illumination(const Plugin& texture) { return setValue("self_illumination", texture); }
	//! The self-illumination color of the material
 	//! [UI Guides] displayName=Self-Illumination color
 	bool set_self_illumination(const AColor& texture) { return setValue("self_illumination", texture); }
	//! The self-illumination color of the material
 	//! [UI Guides] displayName=Self-Illumination color
 	Value get_self_illumination() const { return getValue("self_illumination"); }

	//! True if the self-illumination should affect GI
 	//! [UI Guides] displayName=Self-Illumination affects GI
 	//! [Default value] true
	bool set_self_illumination_gi(bool val) { return setValue("self_illumination_gi", val); }
	//! True if the self-illumination should affect GI
 	//! [UI Guides] displayName=Self-Illumination affects GI
 	//! [Default value] true
	bool get_self_illumination_gi() const { return getBool("self_illumination_gi"); }

	//! The BRDF type (0 - Phong, 1 - Blinn, 2 - Ward, 3 - VRay, 4 - GGX)
 	//! [UI Guides] enum=0:Phong;1:Blinn;2:Ward;4:GGX, displayName=BRDF Type, startRollout=Reflection layer
 	//! [Default value] 1
	bool set_brdf_type(int val) { return setValue("brdf_type", val); }
	//! The BRDF type (0 - Phong, 1 - Blinn, 2 - Ward, 3 - VRay, 4 - GGX)
 	//! [UI Guides] enum=0:Phong;1:Blinn;2:Ward;4:GGX, displayName=BRDF Type, startRollout=Reflection layer
 	//! [Default value] 1
	int get_brdf_type() const { return getInt("brdf_type"); }

	//! The reflection color of the material
 	//! [UI Guides] displayName=Reflection color
 	bool set_reflect(const Plugin& texture) { return setValue("reflect", texture); }
	//! The reflection color of the material
 	//! [UI Guides] displayName=Reflection color
 	bool set_reflect(const AColor& texture) { return setValue("reflect", texture); }
	//! The reflection color of the material
 	//! [UI Guides] displayName=Reflection color
 	Value get_reflect() const { return getValue("reflect"); }

	//! The glossiness of the reflections
 	//! [UI Guides] displayName=Reflection glossiness, minValue=0.0, maxValue=1.0
 	bool set_reflect_glossiness(const Plugin& texturefloat) { return setValue("reflect_glossiness", texturefloat); }
	//! The glossiness of the reflections
 	//! [UI Guides] displayName=Reflection glossiness, minValue=0.0, maxValue=1.0
 	bool set_reflect_glossiness(float texturefloat) { return setValue("reflect_glossiness", texturefloat); }
	//! The glossiness of the reflections
 	//! [UI Guides] displayName=Reflection glossiness, minValue=0.0, maxValue=1.0
 	Value get_reflect_glossiness() const { return getValue("reflect_glossiness"); }

	//! The glossiness of the hilights
 	//! [UI Guides] displayName=Hilight glossiness, enableIf: ?hilight_glossiness_lock=0, minValue=0.0, maxValue=1.0
 	bool set_hilight_glossiness(const Plugin& texturefloat) { return setValue("hilight_glossiness", texturefloat); }
	//! The glossiness of the hilights
 	//! [UI Guides] displayName=Hilight glossiness, enableIf: ?hilight_glossiness_lock=0, minValue=0.0, maxValue=1.0
 	bool set_hilight_glossiness(float texturefloat) { return setValue("hilight_glossiness", texturefloat); }
	//! The glossiness of the hilights
 	//! [UI Guides] displayName=Hilight glossiness, enableIf: ?hilight_glossiness_lock=0, minValue=0.0, maxValue=1.0
 	Value get_hilight_glossiness() const { return getValue("hilight_glossiness"); }

	//! True to use the reflection glossiness also for hilights (hilight_glossiness is ignored)
 	//! [UI Guides] displayName=Lock hilight glossiness
 	//! [Default value] true
	bool set_hilight_glossiness_lock(bool val) { return setValue("hilight_glossiness_lock", val); }
	//! True to use the reflection glossiness also for hilights (hilight_glossiness is ignored)
 	//! [UI Guides] displayName=Lock hilight glossiness
 	//! [Default value] true
	bool get_hilight_glossiness_lock() const { return getBool("hilight_glossiness_lock"); }

	//! How much to increase/decrease the tail of the glossy highlight when using GGX reflection model
 	//! [UI Guides] displayName=GGX tail falloff, minValue=0.001, maxValue=1000.0, softMinValue=2.0, softMaxValue=10.0, enableIf: ?brdf_type=4
 	bool set_gtr_gamma(const Plugin& texturefloat) { return setValue("gtr_gamma", texturefloat); }
	//! How much to increase/decrease the tail of the glossy highlight when using GGX reflection model
 	//! [UI Guides] displayName=GGX tail falloff, minValue=0.001, maxValue=1000.0, softMinValue=2.0, softMaxValue=10.0, enableIf: ?brdf_type=4
 	bool set_gtr_gamma(float texturefloat) { return setValue("gtr_gamma", texturefloat); }
	//! How much to increase/decrease the tail of the glossy highlight when using GGX reflection model
 	//! [UI Guides] displayName=GGX tail falloff, minValue=0.001, maxValue=1000.0, softMinValue=2.0, softMaxValue=10.0, enableIf: ?brdf_type=4
 	Value get_gtr_gamma() const { return getValue("gtr_gamma"); }

	//! true to use the old (and incorrect) shadow masking function when gtr_gamma is different from 2.0
 	//! [Default value] false
	bool set_gtr_oldGamma(bool val) { return setValue("gtr_oldGamma", val); }
	//! true to use the old (and incorrect) shadow masking function when gtr_gamma is different from 2.0
 	//! [Default value] false
	bool get_gtr_oldGamma() const { return getBool("gtr_oldGamma"); }

	//! True to enable fresnel reflections
 	//! [UI Guides] displayName=Fresnel reflections, startRollout=
 	//! [Default value] false
	bool set_fresnel(bool val) { return setValue("fresnel", val); }
	//! True to enable fresnel reflections
 	//! [UI Guides] displayName=Fresnel reflections, startRollout=
 	//! [Default value] false
	bool get_fresnel() const { return getBool("fresnel"); }

	//! The ior for calculating the Fresnel term
 	//! [UI Guides] displayName=Fresnel IOR, enableIf: ?fresnel=1, ?fresnel_ior_lock=0, minValue=0.000001, maxValue=100.0, softMaxValue=5.0
 	bool set_fresnel_ior(const Plugin& texturefloat) { return setValue("fresnel_ior", texturefloat); }
	//! The ior for calculating the Fresnel term
 	//! [UI Guides] displayName=Fresnel IOR, enableIf: ?fresnel=1, ?fresnel_ior_lock=0, minValue=0.000001, maxValue=100.0, softMaxValue=5.0
 	bool set_fresnel_ior(float texturefloat) { return setValue("fresnel_ior", texturefloat); }
	//! The ior for calculating the Fresnel term
 	//! [UI Guides] displayName=Fresnel IOR, enableIf: ?fresnel=1, ?fresnel_ior_lock=0, minValue=0.000001, maxValue=100.0, softMaxValue=5.0
 	Value get_fresnel_ior() const { return getValue("fresnel_ior"); }

	//! True to use the refraction ior also for the Fresnel term (fresnel_ior is ignored)
 	//! [UI Guides] displayName=Lock fresnel IOR, enableIf: ?fresnel=1
 	//! [Default value] true
	bool set_fresnel_ior_lock(bool val) { return setValue("fresnel_ior_lock", val); }
	//! True to use the refraction ior also for the Fresnel term (fresnel_ior is ignored)
 	//! [UI Guides] displayName=Lock fresnel IOR, enableIf: ?fresnel=1
 	//! [Default value] true
	bool get_fresnel_ior_lock() const { return getBool("fresnel_ior_lock"); }

	//! Subdivs for glossy reflectons
 	//! [UI Guides] displayName=Reflection Subdivs, minValue=1, maxValue=1000, softMaxValue=20, quantityType=localSubdivs, startRollout=
 	//! [Default value] 8
	bool set_reflect_subdivs(int val) { return setValue("reflect_subdivs", val); }
	//! Subdivs for glossy reflectons
 	//! [UI Guides] displayName=Reflection Subdivs, minValue=1, maxValue=1000, softMaxValue=20, quantityType=localSubdivs, startRollout=
 	//! [Default value] 8
	int get_reflect_subdivs() const { return getInt("reflect_subdivs"); }

	//! true to trace reflections and false to only do hilights
 	//! [UI Guides] displayName=Trace reflections
 	//! [Default value] true
	bool set_reflect_trace(bool val) { return setValue("reflect_trace", val); }
	//! true to trace reflections and false to only do hilights
 	//! [UI Guides] displayName=Trace reflections
 	//! [Default value] true
	bool get_reflect_trace() const { return getBool("reflect_trace"); }

	//! The maximum depth for reflections
 	//! [UI Guides] displayName=Max depth, minValue=1, maxValue=1000, softMaxValue=10
 	//! [Default value] 5
	bool set_reflect_depth(int val) { return setValue("reflect_depth", val); }
	//! The maximum depth for reflections
 	//! [UI Guides] displayName=Max depth, minValue=1, maxValue=1000, softMaxValue=10
 	//! [Default value] 5
	int get_reflect_depth() const { return getInt("reflect_depth"); }

	//! The color to use when the maximum depth is reached
 	//! [UI Guides] displayName=Exit color
 	//! [Default value] Color(0, 0, 0)
	bool set_reflect_exit_color(const Color& color) { return setValue("reflect_exit_color", color); }
	//! The color to use when the maximum depth is reached
 	//! [UI Guides] displayName=Exit color
 	//! [Default value] Color(0, 0, 0)
	Color get_reflect_exit_color() const { return getColor("reflect_exit_color"); }

	//! How much to soften hilights and reflections at grazing light angles
 	//! [UI Guides] displayName=Soften, minValue=-1.0, maxValue=1.0
 	//! [Default value] 0
	bool set_hilight_soften(float val) { return setValue("hilight_soften", val); }
	//! How much to soften hilights and reflections at grazing light angles
 	//! [UI Guides] displayName=Soften, minValue=-1.0, maxValue=1.0
 	//! [Default value] 0
	float get_hilight_soften() const { return getFloat("hilight_soften"); }

	//! True to enable dim distance
 	//! [UI Guides] displayName=Enable dim distance, startRollout=
 	//! [Default value] false
	bool set_reflect_dim_distance_on(bool val) { return setValue("reflect_dim_distance_on", val); }
	//! True to enable dim distance
 	//! [UI Guides] displayName=Enable dim distance, startRollout=
 	//! [Default value] false
	bool get_reflect_dim_distance_on() const { return getBool("reflect_dim_distance_on"); }

	//! How much to dim reflection as length of rays increases
 	//! [UI Guides] displayName=Dim distance, enableIf: ?reflect_dim_distance_on=1, quantityType=distance, minValue=0.0
 	//! [Default value] 1e+018
	bool set_reflect_dim_distance(float val) { return setValue("reflect_dim_distance", val); }
	//! How much to dim reflection as length of rays increases
 	//! [UI Guides] displayName=Dim distance, enableIf: ?reflect_dim_distance_on=1, quantityType=distance, minValue=0.0
 	//! [Default value] 1e+018
	float get_reflect_dim_distance() const { return getFloat("reflect_dim_distance"); }

	//! Fall off for the dim distance
 	//! [UI Guides] displayName=Dim fall-off, enableIf: ?reflect_dim_distance_on=1, minValue=0.0, maxValue=1.0
 	//! [Default value] 0
	bool set_reflect_dim_distance_falloff(float val) { return setValue("reflect_dim_distance_falloff", val); }
	//! Fall off for the dim distance
 	//! [UI Guides] displayName=Dim fall-off, enableIf: ?reflect_dim_distance_on=1, minValue=0.0, maxValue=1.0
 	//! [Default value] 0
	float get_reflect_dim_distance_falloff() const { return getFloat("reflect_dim_distance_falloff"); }

	//! Determines how reflections affect the alpha channel (0 - opaque alpha; 1 - alpha is taken from refractions; 2 - all channels are propagated
 	//! [UI Guides] enum=0:Color only;1:Color+alpha;2:All channels, displayName=Affect Channels
 	//! [Default value] 0
	bool set_reflect_affect_alpha(int val) { return setValue("reflect_affect_alpha", val); }
	//! Determines how reflections affect the alpha channel (0 - opaque alpha; 1 - alpha is taken from refractions; 2 - all channels are propagated
 	//! [UI Guides] enum=0:Color only;1:Color+alpha;2:All channels, displayName=Affect Channels
 	//! [Default value] 0
	int get_reflect_affect_alpha() const { return getInt("reflect_affect_alpha"); }

	//! The anisotropy for glossy reflections, from -1 to 1 (0.0 is isotropic reflections)
 	//! [UI Guides] displayName=Anisotropy-1..1, minValue=-0.99, maxValue=0.99, startRollout=
 	bool set_anisotropy(const Plugin& texturefloat) { return setValue("anisotropy", texturefloat); }
	//! The anisotropy for glossy reflections, from -1 to 1 (0.0 is isotropic reflections)
 	//! [UI Guides] displayName=Anisotropy-1..1, minValue=-0.99, maxValue=0.99, startRollout=
 	bool set_anisotropy(float texturefloat) { return setValue("anisotropy", texturefloat); }
	//! The anisotropy for glossy reflections, from -1 to 1 (0.0 is isotropic reflections)
 	//! [UI Guides] displayName=Anisotropy-1..1, minValue=-0.99, maxValue=0.99, startRollout=
 	Value get_anisotropy() const { return getValue("anisotropy"); }

	//! The rotation of the anisotropy axes, from 0.0 to 1.0
 	//! [UI Guides] displayName=Anisotropy rotation, softMinValue=0.0, softMaxValue=1.0
 	bool set_anisotropy_rotation(const Plugin& texturefloat) { return setValue("anisotropy_rotation", texturefloat); }
	//! The rotation of the anisotropy axes, from 0.0 to 1.0
 	//! [UI Guides] displayName=Anisotropy rotation, softMinValue=0.0, softMaxValue=1.0
 	bool set_anisotropy_rotation(float texturefloat) { return setValue("anisotropy_rotation", texturefloat); }
	//! The rotation of the anisotropy axes, from 0.0 to 1.0
 	//! [UI Guides] displayName=Anisotropy rotation, softMinValue=0.0, softMaxValue=1.0
 	Value get_anisotropy_rotation() const { return getValue("anisotropy_rotation"); }

	//! What method to use for deriving anisotropy axes (0 - local object axis; 1 - a specified uvw generator)
 	//! [UI Guides] enum=0:Local object axis;1:Specified uvw generator, displayName=UV Vectors Derivation
 	//! [Default value] 0
	bool set_anisotropy_derivation(int val) { return setValue("anisotropy_derivation", val); }
	//! What method to use for deriving anisotropy axes (0 - local object axis; 1 - a specified uvw generator)
 	//! [UI Guides] enum=0:Local object axis;1:Specified uvw generator, displayName=UV Vectors Derivation
 	//! [Default value] 0
	int get_anisotropy_derivation() const { return getInt("anisotropy_derivation"); }

	//! Which local object axis to use when anisotropy_derivation is 0. (0 - X; 1 - Y; 2 - Z)
 	//! [UI Guides] displayName=Anisotropy Axis, enableIf: ?anisotropy_derivation=0, enum=0:X;1:Y;2:Z
 	//! [Default value] 2
	bool set_anisotropy_axis(int val) { return setValue("anisotropy_axis", val); }
	//! Which local object axis to use when anisotropy_derivation is 0. (0 - X; 1 - Y; 2 - Z)
 	//! [UI Guides] displayName=Anisotropy Axis, enableIf: ?anisotropy_derivation=0, enum=0:X;1:Y;2:Z
 	//! [Default value] 2
	int get_anisotropy_axis() const { return getInt("anisotropy_axis"); }

	//! The uvw generator to use for anisotropy when anisotropy_derivation is 1
 	bool set_anisotropy_uvwgen(const Plugin& plugin) { return setValue("anisotropy_uvwgen", plugin); }
	//! The uvw generator to use for anisotropy when anisotropy_derivation is 1
 	Plugin get_anisotropy_uvwgen() const { return getPlugin("anisotropy_uvwgen"); }

	//! The refraction color of the material
 	//! [UI Guides] displayName=Refraction color, startRollout=Refraction layer
 	bool set_refract(const Plugin& texture) { return setValue("refract", texture); }
	//! The refraction color of the material
 	//! [UI Guides] displayName=Refraction color, startRollout=Refraction layer
 	bool set_refract(const AColor& texture) { return setValue("refract", texture); }
	//! The refraction color of the material
 	//! [UI Guides] displayName=Refraction color, startRollout=Refraction layer
 	Value get_refract() const { return getValue("refract"); }

	//! The IOR for refractions
 	//! [UI Guides] displayName=Refraction IOR, minValue=0.000001, maxValue=100.0, softMaxValue=5.0
 	bool set_refract_ior(const Plugin& texturefloat) { return setValue("refract_ior", texturefloat); }
	//! The IOR for refractions
 	//! [UI Guides] displayName=Refraction IOR, minValue=0.000001, maxValue=100.0, softMaxValue=5.0
 	bool set_refract_ior(float texturefloat) { return setValue("refract_ior", texturefloat); }
	//! The IOR for refractions
 	//! [UI Guides] displayName=Refraction IOR, minValue=0.000001, maxValue=100.0, softMaxValue=5.0
 	Value get_refract_ior() const { return getValue("refract_ior"); }

	//! Glossiness for refractions
 	//! [UI Guides] displayName=Refraction glossiness, minValue=0.0, maxValue=1.0
 	bool set_refract_glossiness(const Plugin& texturefloat) { return setValue("refract_glossiness", texturefloat); }
	//! Glossiness for refractions
 	//! [UI Guides] displayName=Refraction glossiness, minValue=0.0, maxValue=1.0
 	bool set_refract_glossiness(float texturefloat) { return setValue("refract_glossiness", texturefloat); }
	//! Glossiness for refractions
 	//! [UI Guides] displayName=Refraction glossiness, minValue=0.0, maxValue=1.0
 	Value get_refract_glossiness() const { return getValue("refract_glossiness"); }

	//! Subdivs for glossy refractions
 	//! [UI Guides] displayName=Refraction Subdivs, minValue=1, maxValue=1000, softMaxValue=20, quantityType=localSubdivs, startRollout=
 	//! [Default value] 8
	bool set_refract_subdivs(int val) { return setValue("refract_subdivs", val); }
	//! Subdivs for glossy refractions
 	//! [UI Guides] displayName=Refraction Subdivs, minValue=1, maxValue=1000, softMaxValue=20, quantityType=localSubdivs, startRollout=
 	//! [Default value] 8
	int get_refract_subdivs() const { return getInt("refract_subdivs"); }

	//! 1 to trace refractions; 0 to disable them
 	//! [UI Guides] displayName=Trace refractions
 	//! [Default value] true
	bool set_refract_trace(bool val) { return setValue("refract_trace", val); }
	//! 1 to trace refractions; 0 to disable them
 	//! [UI Guides] displayName=Trace refractions
 	//! [Default value] true
	bool get_refract_trace() const { return getBool("refract_trace"); }

	//! The maximum depth for refractions
 	//! [UI Guides] displayName=Max depth, minValue=1, maxValue=1000, softMaxValue=10
 	//! [Default value] 5
	bool set_refract_depth(int val) { return setValue("refract_depth", val); }
	//! The maximum depth for refractions
 	//! [UI Guides] displayName=Max depth, minValue=1, maxValue=1000, softMaxValue=10
 	//! [Default value] 5
	int get_refract_depth() const { return getInt("refract_depth"); }

	//! If false, when the maximum refraction depth is reached, the material is assumed transparent, instead of terminating the ray
 	//! [UI Guides] displayName=Use exit color
 	//! [Default value] false
	bool set_refract_exit_color_on(bool val) { return setValue("refract_exit_color_on", val); }
	//! If false, when the maximum refraction depth is reached, the material is assumed transparent, instead of terminating the ray
 	//! [UI Guides] displayName=Use exit color
 	//! [Default value] false
	bool get_refract_exit_color_on() const { return getBool("refract_exit_color_on"); }

	//! The color to use when maximum depth is reached when refract_exit_color_on is true
 	//! [UI Guides] displayName=Exit color, enableIf: ?refract_exit_color_on=1
 	//! [Default value] Color(0, 0, 0)
	bool set_refract_exit_color(const Color& color) { return setValue("refract_exit_color", color); }
	//! The color to use when maximum depth is reached when refract_exit_color_on is true
 	//! [UI Guides] displayName=Exit color, enableIf: ?refract_exit_color_on=1
 	//! [Default value] Color(0, 0, 0)
	Color get_refract_exit_color() const { return getColor("refract_exit_color"); }

	//! Determines how refractions affect the alpha channel (0 - opaque alpha; 1 - alpha is taken from refractions; 2 - all channels are propagated
 	//! [UI Guides] enum=0:Color only;1:Color+alpha;2:All channels, displayName=Affect alpha
 	//! [Default value] 0
	bool set_refract_affect_alpha(int val) { return setValue("refract_affect_alpha", val); }
	//! Determines how refractions affect the alpha channel (0 - opaque alpha; 1 - alpha is taken from refractions; 2 - all channels are propagated
 	//! [UI Guides] enum=0:Color only;1:Color+alpha;2:All channels, displayName=Affect alpha
 	//! [Default value] 0
	int get_refract_affect_alpha() const { return getInt("refract_affect_alpha"); }

	//! True to enable the refraction to affect the shadows cast by the material (as transparent shadows)
 	//! [UI Guides] displayName=Affect shadows
 	//! [Default value] false
	bool set_refract_affect_shadows(bool val) { return setValue("refract_affect_shadows", val); }
	//! True to enable the refraction to affect the shadows cast by the material (as transparent shadows)
 	//! [UI Guides] displayName=Affect shadows
 	//! [Default value] false
	bool get_refract_affect_shadows() const { return getBool("refract_affect_shadows"); }

	//! True to enable dispersion
 	//! [UI Guides] displayName=Enable dispersion, startRollout=
 	//! [Default value] false
	bool set_dispersion_on(bool val) { return setValue("dispersion_on", val); }
	//! True to enable dispersion
 	//! [UI Guides] displayName=Enable dispersion, startRollout=
 	//! [Default value] false
	bool get_dispersion_on() const { return getBool("dispersion_on"); }

	//! Abbe value
 	//! [UI Guides] displayName=Abberation, enableIf: ?dispersion_on=1, minValue=1, maxValue=150
 	//! [Default value] 50
	bool set_dispersion(float val) { return setValue("dispersion", val); }
	//! Abbe value
 	//! [UI Guides] displayName=Abberation, enableIf: ?dispersion_on=1, minValue=1, maxValue=150
 	//! [Default value] 50
	float get_dispersion() const { return getFloat("dispersion"); }

	//! The absorption (fog) color
 	//! [UI Guides] displayName=Fog color, startTab=V-Ray Material Advanced, startRollout=Fog, overridenBy=fog_color_tex
 	//! [Default value] Color(1, 1, 1)
	bool set_fog_color(const Color& color) { return setValue("fog_color", color); }
	//! The absorption (fog) color
 	//! [UI Guides] displayName=Fog color, startTab=V-Ray Material Advanced, startRollout=Fog, overridenBy=fog_color_tex
 	//! [Default value] Color(1, 1, 1)
	Color get_fog_color() const { return getColor("fog_color"); }

	//! The absorption (fog) color texture
 	//! [UI Guides] displayName=Fog color, overrides=fog_color
 	bool set_fog_color_tex(const Plugin& texture) { return setValue("fog_color_tex", texture); }
	//! The absorption (fog) color texture
 	//! [UI Guides] displayName=Fog color, overrides=fog_color
 	bool set_fog_color_tex(const AColor& texture) { return setValue("fog_color_tex", texture); }
	//! The absorption (fog) color texture
 	//! [UI Guides] displayName=Fog color, overrides=fog_color
 	Value get_fog_color_tex() const { return getValue("fog_color_tex"); }

	//! Multiplier for the absorption
 	//! [UI Guides] displayName=Fog multiplier, minValue=0.0
 	//! [Default value] 1
	bool set_fog_mult(float val) { return setValue("fog_mult", val); }
	//! Multiplier for the absorption
 	//! [UI Guides] displayName=Fog multiplier, minValue=0.0
 	//! [Default value] 1
	float get_fog_mult() const { return getFloat("fog_mult"); }

	//! Bias for the absorption
 	//! [UI Guides] displayName=Fog bias
 	//! [Default value] 0
	bool set_fog_bias(float val) { return setValue("fog_bias", val); }
	//! Bias for the absorption
 	//! [UI Guides] displayName=Fog bias
 	//! [Default value] 0
	float get_fog_bias() const { return getFloat("fog_bias"); }

	//! Enable unit scale multiplication, when calculating absorption. When this is enabled, the fog multiplier is in cm^-1. When this is disabled, the fog multiplier is in scene_units^-1.
 	//! [UI Guides] displayName=Fog multiplier in centimeters^-1
 	//! [Default value] true
	bool set_fog_unit_scale_on(bool val) { return setValue("fog_unit_scale_on", val); }
	//! Enable unit scale multiplication, when calculating absorption. When this is enabled, the fog multiplier is in cm^-1. When this is disabled, the fog multiplier is in scene_units^-1.
 	//! [UI Guides] displayName=Fog multiplier in centimeters^-1
 	//! [Default value] true
	bool get_fog_unit_scale_on() const { return getBool("fog_unit_scale_on"); }

	//! Translucency mode (0 - None; 1 - Hard (wax) model; 2 - Soft (water) model; 3 - Hybrid model)
 	//! [UI Guides] displayName=Translucency type, enum=0:None;1:Hard wax model;2:Soft water model;3:Hybrid model, startRollout=Translucency SSS
 	//! [Default value] 0
	bool set_translucency(int val) { return setValue("translucency", val); }
	//! Translucency mode (0 - None; 1 - Hard (wax) model; 2 - Soft (water) model; 3 - Hybrid model)
 	//! [UI Guides] displayName=Translucency type, enum=0:None;1:Hard wax model;2:Soft water model;3:Hybrid model, startRollout=Translucency SSS
 	//! [Default value] 0
	int get_translucency() const { return getInt("translucency"); }

	//! Filter color for the translucency effect
 	//! [UI Guides] displayName=Translucency color, enableIf: ?translucency!=0
 	bool set_translucency_color(const Plugin& texture) { return setValue("translucency_color", texture); }
	//! Filter color for the translucency effect
 	//! [UI Guides] displayName=Translucency color, enableIf: ?translucency!=0
 	bool set_translucency_color(const AColor& texture) { return setValue("translucency_color", texture); }
	//! Filter color for the translucency effect
 	//! [UI Guides] displayName=Translucency color, enableIf: ?translucency!=0
 	Value get_translucency_color() const { return getValue("translucency_color"); }

	//! A multiplier for the calculated lighting for the translucency effect
 	//! [UI Guides] displayName=Light multiplier, enableIf: ?translucency!=0, minValue=0.0
 	//! [Default value] 1
	bool set_translucency_light_mult(float val) { return setValue("translucency_light_mult", val); }
	//! A multiplier for the calculated lighting for the translucency effect
 	//! [UI Guides] displayName=Light multiplier, enableIf: ?translucency!=0, minValue=0.0
 	//! [Default value] 1
	float get_translucency_light_mult() const { return getFloat("translucency_light_mult"); }

	//! Scatter direction (0.0f is backward, 1.0f is forward)
 	//! [UI Guides] displayName=Scatter direction, enableIf: ?translucency!=0, minValue=0.0, maxValue=1.0
 	//! [Default value] 0.5
	bool set_translucency_scatter_dir(float val) { return setValue("translucency_scatter_dir", val); }
	//! Scatter direction (0.0f is backward, 1.0f is forward)
 	//! [UI Guides] displayName=Scatter direction, enableIf: ?translucency!=0, minValue=0.0, maxValue=1.0
 	//! [Default value] 0.5
	float get_translucency_scatter_dir() const { return getFloat("translucency_scatter_dir"); }

	//! Scattering cone (0.0f - no scattering, 1.0f - full scattering
 	//! [UI Guides] displayName=Scatter coeff, enableIf: ?translucency!=0, minValue=0.0, maxValue=1.0
 	//! [Default value] 0
	bool set_translucency_scatter_coeff(float val) { return setValue("translucency_scatter_coeff", val); }
	//! Scattering cone (0.0f - no scattering, 1.0f - full scattering
 	//! [UI Guides] displayName=Scatter coeff, enableIf: ?translucency!=0, minValue=0.0, maxValue=1.0
 	//! [Default value] 0
	float get_translucency_scatter_coeff() const { return getFloat("translucency_scatter_coeff"); }

	//! Maximum distance to trace inside the object
 	//! [UI Guides] displayName=Maximum thickness, enableIf: ?translucency!=0, quantityType=distance, minValue=0.0
 	//! [Default value] 1e+018
	bool set_translucency_thickness(float val) { return setValue("translucency_thickness", val); }
	//! Maximum distance to trace inside the object
 	//! [UI Guides] displayName=Maximum thickness, enableIf: ?translucency!=0, quantityType=distance, minValue=0.0
 	//! [Default value] 1e+018
	float get_translucency_thickness() const { return getFloat("translucency_thickness"); }

	//! true if the material is double-sided
 	//! [UI Guides] displayName=Double-sided, startRollout=Options
 	//! [Default value] true
	bool set_option_double_sided(bool val) { return setValue("option_double_sided", val); }
	//! true if the material is double-sided
 	//! [UI Guides] displayName=Double-sided, startRollout=Options
 	//! [Default value] true
	bool get_option_double_sided() const { return getBool("option_double_sided"); }

	//! true to compute reflections for back sides of objects
 	//! [UI Guides] displayName=Reflect on back side
 	//! [Default value] false
	bool set_option_reflect_on_back(bool val) { return setValue("option_reflect_on_back", val); }
	//! true to compute reflections for back sides of objects
 	//! [UI Guides] displayName=Reflect on back side
 	//! [Default value] false
	bool get_option_reflect_on_back() const { return getBool("option_reflect_on_back"); }

	//! Specifies when to treat GI rays as glossy rays (0 - never; 1 - only for rays that are already GI rays; 2 - always
 	//! [UI Guides] enum=0:Never;1:GI rays only;2:Always, displayName=Glossy rays as GI
 	//! [Default value] 1
	bool set_option_glossy_rays_as_gi(int val) { return setValue("option_glossy_rays_as_gi", val); }
	//! Specifies when to treat GI rays as glossy rays (0 - never; 1 - only for rays that are already GI rays; 2 - always
 	//! [UI Guides] enum=0:Never;1:GI rays only;2:Always, displayName=Glossy rays as GI
 	//! [Default value] 1
	int get_option_glossy_rays_as_gi() const { return getInt("option_glossy_rays_as_gi"); }

	//! Specifies a cutoff threshold for tracing reflections/refractions
 	//! [UI Guides] displayName=Cutoff, minValue=0.0, maxValue=1.0
 	//! [Default value] 0.001
	bool set_option_cutoff(float val) { return setValue("option_cutoff", val); }
	//! Specifies a cutoff threshold for tracing reflections/refractions
 	//! [UI Guides] displayName=Cutoff, minValue=0.0, maxValue=1.0
 	//! [Default value] 0.001
	float get_option_cutoff() const { return getFloat("option_cutoff"); }

	//! false to perform local brute-force GI calculatons and true to use the current GI engine
 	//! [UI Guides] displayName=Use irradiance map
 	//! [Default value] true
	bool set_option_use_irradiance_map(bool val) { return setValue("option_use_irradiance_map", val); }
	//! false to perform local brute-force GI calculatons and true to use the current GI engine
 	//! [UI Guides] displayName=Use irradiance map
 	//! [Default value] true
	bool get_option_use_irradiance_map() const { return getBool("option_use_irradiance_map"); }

	//! Energy preservation mode for reflections and refractions (0 - color, 1 - monochrome)
 	//! [UI Guides] enum=0:Color;1:Monochrome, displayName=Energy preservation
 	//! [Default value] 0
	bool set_option_energy_mode(int val) { return setValue("option_energy_mode", val); }
	//! Energy preservation mode for reflections and refractions (0 - color, 1 - monochrome)
 	//! [UI Guides] enum=0:Color;1:Monochrome, displayName=Energy preservation
 	//! [Default value] 0
	int get_option_energy_mode() const { return getInt("option_energy_mode"); }

	//! true to fix dark edges for glossy reflections with low samples; only set this to false for compatibility with older versions
 	//! [UI Guides] displayName=Fix dark edges
 	//! [Default value] true
	bool set_option_fix_dark_edges(bool val) { return setValue("option_fix_dark_edges", val); }
	//! true to fix dark edges for glossy reflections with low samples; only set this to false for compatibility with older versions
 	//! [UI Guides] displayName=Fix dark edges
 	//! [Default value] true
	bool get_option_fix_dark_edges() const { return getBool("option_fix_dark_edges"); }

	//! true to enable glossy Fresnel
 	//! [Default value] false
	bool set_option_glossy_fresnel(bool val) { return setValue("option_glossy_fresnel", val); }
	//! true to enable glossy Fresnel
 	//! [Default value] false
	bool get_option_glossy_fresnel() const { return getBool("option_glossy_fresnel"); }

	//! true to invert all glossiness values and use roughness instead
 	//! [Default value] false
	bool set_option_use_roughness(bool val) { return setValue("option_use_roughness", val); }
	//! true to invert all glossiness values and use roughness instead
 	//! [Default value] false
	bool get_option_use_roughness() const { return getBool("option_use_roughness"); }

	//! True to use the 'environment override' texture.
 	//! [UI Guides] startRollout=Environment override
 	//! [Default value] false
	bool set_use_environment_override(bool val) { return setValue("use_environment_override", val); }
	//! True to use the 'environment override' texture.
 	//! [UI Guides] startRollout=Environment override
 	//! [Default value] false
	bool get_use_environment_override() const { return getBool("use_environment_override"); }

	//! Environment override texture
 	//! [UI Guides] enableIf: ?use_environment_override=1
 	bool set_environment_override(const Plugin& texture) { return setValue("environment_override", texture); }
	//! Environment override texture
 	//! [UI Guides] enableIf: ?use_environment_override=1
 	bool set_environment_override(const AColor& texture) { return setValue("environment_override", texture); }
	//! Environment override texture
 	//! [UI Guides] enableIf: ?use_environment_override=1
 	Value get_environment_override() const { return getValue("environment_override"); }

	//! Environment override priority (used when several materials override it along a ray path)
 	//! [UI Guides] enableIf: ?use_environment_override=1, minValue=-1000, maxValue=1000
 	//! [Default value] 0
	bool set_environment_priority(int val) { return setValue("environment_priority", val); }
	//! Environment override priority (used when several materials override it along a ray path)
 	//! [UI Guides] enableIf: ?use_environment_override=1, minValue=-1000, maxValue=1000
 	//! [Default value] 0
	int get_environment_priority() const { return getInt("environment_priority"); }

	//! [UI Guides] displayName=Use reflection interpolation, startRollout=Reflection interpolation
 	//! [Default value] false
	bool set_refl_interpolation_on(bool val) { return setValue("refl_interpolation_on", val); }
	//! [UI Guides] displayName=Use reflection interpolation, startRollout=Reflection interpolation
 	//! [Default value] false
	bool get_refl_interpolation_on() const { return getBool("refl_interpolation_on"); }

	//! [UI Guides] displayName=Min rate, enableIf: ?refl_interpolation_on=1, minValue=-10, maxValue=10
 	//! [Default value] -1
	bool set_refl_imap_min_rate(int val) { return setValue("refl_imap_min_rate", val); }
	//! [UI Guides] displayName=Min rate, enableIf: ?refl_interpolation_on=1, minValue=-10, maxValue=10
 	//! [Default value] -1
	int get_refl_imap_min_rate() const { return getInt("refl_imap_min_rate"); }

	//! [UI Guides] displayName=Max rate, enableIf: ?refl_interpolation_on=1, minValue=-10, maxValue=10
 	//! [Default value] 1
	bool set_refl_imap_max_rate(int val) { return setValue("refl_imap_max_rate", val); }
	//! [UI Guides] displayName=Max rate, enableIf: ?refl_interpolation_on=1, minValue=-10, maxValue=10
 	//! [Default value] 1
	int get_refl_imap_max_rate() const { return getInt("refl_imap_max_rate"); }

	//! [UI Guides] displayName=Color threshold, enableIf: ?refl_interpolation_on=1, minValue=0.0, maxValue=1.0
 	//! [Default value] 0.25
	bool set_refl_imap_color_thresh(float val) { return setValue("refl_imap_color_thresh", val); }
	//! [UI Guides] displayName=Color threshold, enableIf: ?refl_interpolation_on=1, minValue=0.0, maxValue=1.0
 	//! [Default value] 0.25
	float get_refl_imap_color_thresh() const { return getFloat("refl_imap_color_thresh"); }

	//! [UI Guides] displayName=Normal threshold, enableIf: ?refl_interpolation_on=1, minValue=0.0, maxValue=1.0
 	//! [Default value] 0.4
	bool set_refl_imap_norm_thresh(float val) { return setValue("refl_imap_norm_thresh", val); }
	//! [UI Guides] displayName=Normal threshold, enableIf: ?refl_interpolation_on=1, minValue=0.0, maxValue=1.0
 	//! [Default value] 0.4
	float get_refl_imap_norm_thresh() const { return getFloat("refl_imap_norm_thresh"); }

	//! [UI Guides] displayName=Interpolation samples, enableIf: ?refl_interpolation_on=1, minValue=1, maxValue=1000
 	//! [Default value] 20
	bool set_refl_imap_samples(int val) { return setValue("refl_imap_samples", val); }
	//! [UI Guides] displayName=Interpolation samples, enableIf: ?refl_interpolation_on=1, minValue=1, maxValue=1000
 	//! [Default value] 20
	int get_refl_imap_samples() const { return getInt("refl_imap_samples"); }

	//! [UI Guides] displayName=Use refraction interpolation, startRollout=Refraction interpolation
 	//! [Default value] false
	bool set_refr_interpolation_on(bool val) { return setValue("refr_interpolation_on", val); }
	//! [UI Guides] displayName=Use refraction interpolation, startRollout=Refraction interpolation
 	//! [Default value] false
	bool get_refr_interpolation_on() const { return getBool("refr_interpolation_on"); }

	//! [UI Guides] displayName=Min rate, enableIf: ?refr_interpolation_on=1, minValue=-10, maxValue=10
 	//! [Default value] -1
	bool set_refr_imap_min_rate(int val) { return setValue("refr_imap_min_rate", val); }
	//! [UI Guides] displayName=Min rate, enableIf: ?refr_interpolation_on=1, minValue=-10, maxValue=10
 	//! [Default value] -1
	int get_refr_imap_min_rate() const { return getInt("refr_imap_min_rate"); }

	//! [UI Guides] displayName=Max rate, enableIf: ?refr_interpolation_on=1, minValue=-10, maxValue=10
 	//! [Default value] 1
	bool set_refr_imap_max_rate(int val) { return setValue("refr_imap_max_rate", val); }
	//! [UI Guides] displayName=Max rate, enableIf: ?refr_interpolation_on=1, minValue=-10, maxValue=10
 	//! [Default value] 1
	int get_refr_imap_max_rate() const { return getInt("refr_imap_max_rate"); }

	//! [UI Guides] displayName=Color threshold, enableIf: ?refr_interpolation_on=1, minValue=0.0, maxValue=1.0
 	//! [Default value] 0.25
	bool set_refr_imap_color_thresh(float val) { return setValue("refr_imap_color_thresh", val); }
	//! [UI Guides] displayName=Color threshold, enableIf: ?refr_interpolation_on=1, minValue=0.0, maxValue=1.0
 	//! [Default value] 0.25
	float get_refr_imap_color_thresh() const { return getFloat("refr_imap_color_thresh"); }

	//! [UI Guides] displayName=Normal threshold, enableIf: ?refr_interpolation_on=1, minValue=0.0, maxValue=1.0
 	//! [Default value] 0.4
	bool set_refr_imap_norm_thresh(float val) { return setValue("refr_imap_norm_thresh", val); }
	//! [UI Guides] displayName=Normal threshold, enableIf: ?refr_interpolation_on=1, minValue=0.0, maxValue=1.0
 	//! [Default value] 0.4
	float get_refr_imap_norm_thresh() const { return getFloat("refr_imap_norm_thresh"); }

	//! [UI Guides] displayName=Interpolation samples, enableIf: ?refr_interpolation_on=1, minValue=1, maxValue=1000
 	//! [Default value] 20
	bool set_refr_imap_samples(int val) { return setValue("refr_imap_samples", val); }
	//! [UI Guides] displayName=Interpolation samples, enableIf: ?refr_interpolation_on=1, minValue=1, maxValue=1000
 	//! [Default value] 20
	int get_refr_imap_samples() const { return getInt("refr_imap_samples"); }

	//! Render channels in which the result of this material will be written to.
 	bool set_channels(const ValueList& pluginList) { return setValue("channels", pluginList); }
	//! Render channels in which the result of this material will be written to.
 	ValueList get_channels() const { return getValueList("channels"); }
};

class BRDFWard : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "BRDFWard"; }

	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	bool set_color(const Color& color) { return setValue("color", color); }
	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	Color get_color() const { return getColor("color"); }

	//! (description missing)
	bool set_color_tex(const Plugin& texture) { return setValue("color_tex", texture); }
	//! (description missing)
	bool set_color_tex(const AColor& texture) { return setValue("color_tex", texture); }
	//! (description missing)
	Value get_color_tex() const { return getValue("color_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_color_tex_mult(float val) { return setValue("color_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_color_tex_mult() const { return getFloat("color_tex_mult"); }

	//! (description missing)
	//! [Default value] Color(0, 0, 0)
	bool set_transparency(const Color& color) { return setValue("transparency", color); }
	//! (description missing)
	//! [Default value] Color(0, 0, 0)
	Color get_transparency() const { return getColor("transparency"); }

	//! (description missing)
	bool set_transparency_tex(const Plugin& texture) { return setValue("transparency_tex", texture); }
	//! (description missing)
	bool set_transparency_tex(const AColor& texture) { return setValue("transparency_tex", texture); }
	//! (description missing)
	Value get_transparency_tex() const { return getValue("transparency_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_transparency_tex_mult(float val) { return setValue("transparency_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_transparency_tex_mult() const { return getFloat("transparency_tex_mult"); }

	//! (description missing)
	//! [Default value] 0.01
	bool set_cutoff(float val) { return setValue("cutoff", val); }
	//! (description missing)
	//! [Default value] 0.01
	float get_cutoff() const { return getFloat("cutoff"); }

	//! (description missing)
	//! [Default value] false
	bool set_back_side(bool val) { return setValue("back_side", val); }
	//! (description missing)
	//! [Default value] false
	bool get_back_side() const { return getBool("back_side"); }

	//! (description missing)
	//! [Default value] true
	bool set_trace_reflections(bool val) { return setValue("trace_reflections", val); }
	//! (description missing)
	//! [Default value] true
	bool get_trace_reflections() const { return getBool("trace_reflections"); }

	//! The maximum reflection depth (-1 is controlled by the global options)
 	//! [Default value] -1
	bool set_trace_depth(int val) { return setValue("trace_depth", val); }
	//! The maximum reflection depth (-1 is controlled by the global options)
 	//! [Default value] -1
	int get_trace_depth() const { return getInt("trace_depth"); }

	//! Specifies how render channels are propagated through the BRDF (0 - only the color channel; 1 - color and alpha; 2 - all channels
 	//! [Default value] 0
	bool set_affect_alpha(int val) { return setValue("affect_alpha", val); }
	//! Specifies how render channels are propagated through the BRDF (0 - only the color channel; 1 - color and alpha; 2 - all channels
 	//! [Default value] 0
	int get_affect_alpha() const { return getInt("affect_alpha"); }

	//! The color to use when the maximum depth is reached
 	bool set_reflect_exit_color(const Plugin& texture) { return setValue("reflect_exit_color", texture); }
	//! The color to use when the maximum depth is reached
 	bool set_reflect_exit_color(const AColor& texture) { return setValue("reflect_exit_color", texture); }
	//! The color to use when the maximum depth is reached
 	Value get_reflect_exit_color() const { return getValue("reflect_exit_color"); }

	//! True to enable dim distance
 	//! [Default value] false
	bool set_reflect_dim_distance_on(bool val) { return setValue("reflect_dim_distance_on", val); }
	//! True to enable dim distance
 	//! [Default value] false
	bool get_reflect_dim_distance_on() const { return getBool("reflect_dim_distance_on"); }

	//! How much to dim reflection as length of rays increases
 	//! [UI Guides] quantityType=distance
 	//! [Default value] 1e+018
	bool set_reflect_dim_distance(float val) { return setValue("reflect_dim_distance", val); }
	//! How much to dim reflection as length of rays increases
 	//! [UI Guides] quantityType=distance
 	//! [Default value] 1e+018
	float get_reflect_dim_distance() const { return getFloat("reflect_dim_distance"); }

	//! Fall off for the dim distance
 	//! [Default value] 0
	bool set_reflect_dim_distance_falloff(float val) { return setValue("reflect_dim_distance_falloff", val); }
	//! Fall off for the dim distance
 	//! [Default value] 0
	float get_reflect_dim_distance_falloff() const { return getFloat("reflect_dim_distance_falloff"); }

	//! (description missing)
	//! [Default value] 0.8
	bool set_hilightGlossiness(float val) { return setValue("hilightGlossiness", val); }
	//! (description missing)
	//! [Default value] 0.8
	float get_hilightGlossiness() const { return getFloat("hilightGlossiness"); }

	//! (description missing)
	bool set_hilightGlossiness_tex(const Plugin& texturefloat) { return setValue("hilightGlossiness_tex", texturefloat); }
	//! (description missing)
	bool set_hilightGlossiness_tex(float texturefloat) { return setValue("hilightGlossiness_tex", texturefloat); }
	//! (description missing)
	Value get_hilightGlossiness_tex() const { return getValue("hilightGlossiness_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_hilightGlossiness_tex_mult(float val) { return setValue("hilightGlossiness_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_hilightGlossiness_tex_mult() const { return getFloat("hilightGlossiness_tex_mult"); }

	//! (description missing)
	//! [Default value] 0.8
	bool set_reflectionGlossiness(float val) { return setValue("reflectionGlossiness", val); }
	//! (description missing)
	//! [Default value] 0.8
	float get_reflectionGlossiness() const { return getFloat("reflectionGlossiness"); }

	//! (description missing)
	bool set_reflectionGlossiness_tex(const Plugin& texturefloat) { return setValue("reflectionGlossiness_tex", texturefloat); }
	//! (description missing)
	bool set_reflectionGlossiness_tex(float texturefloat) { return setValue("reflectionGlossiness_tex", texturefloat); }
	//! (description missing)
	Value get_reflectionGlossiness_tex() const { return getValue("reflectionGlossiness_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_reflectionGlossiness_tex_mult(float val) { return setValue("reflectionGlossiness_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_reflectionGlossiness_tex_mult() const { return getFloat("reflectionGlossiness_tex_mult"); }

	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	bool set_subdivs(int val) { return setValue("subdivs", val); }
	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	int get_subdivs() const { return getInt("subdivs"); }

	//! Determines if the glossy rays are treated by V-Ray as GI rays: 0 - never; 1 - only for rays that are already marked as GI rays; 2 - always
 	//! [Default value] 1
	bool set_glossyAsGI(int val) { return setValue("glossyAsGI", val); }
	//! Determines if the glossy rays are treated by V-Ray as GI rays: 0 - never; 1 - only for rays that are already marked as GI rays; 2 - always
 	//! [Default value] 1
	int get_glossyAsGI() const { return getInt("glossyAsGI"); }

	//! Soften edge of the BRDF at light/shadow transition
 	//! [Default value] 0
	bool set_soften_edge(float val) { return setValue("soften_edge", val); }
	//! Soften edge of the BRDF at light/shadow transition
 	//! [Default value] 0
	float get_soften_edge() const { return getFloat("soften_edge"); }

	//! (description missing)
	//! [Default value] 0
	bool set_interpolation_on(int val) { return setValue("interpolation_on", val); }
	//! (description missing)
	//! [Default value] 0
	int get_interpolation_on() const { return getInt("interpolation_on"); }

	//! (description missing)
	//! [Default value] -1
	bool set_imap_min_rate(int val) { return setValue("imap_min_rate", val); }
	//! (description missing)
	//! [Default value] -1
	int get_imap_min_rate() const { return getInt("imap_min_rate"); }

	//! (description missing)
	//! [Default value] 1
	bool set_imap_max_rate(int val) { return setValue("imap_max_rate", val); }
	//! (description missing)
	//! [Default value] 1
	int get_imap_max_rate() const { return getInt("imap_max_rate"); }

	//! (description missing)
	//! [Default value] 0.25
	bool set_imap_color_thresh(float val) { return setValue("imap_color_thresh", val); }
	//! (description missing)
	//! [Default value] 0.25
	float get_imap_color_thresh() const { return getFloat("imap_color_thresh"); }

	//! (description missing)
	//! [Default value] 0.4
	bool set_imap_norm_thresh(float val) { return setValue("imap_norm_thresh", val); }
	//! (description missing)
	//! [Default value] 0.4
	float get_imap_norm_thresh() const { return getFloat("imap_norm_thresh"); }

	//! (description missing)
	//! [Default value] 20
	bool set_imap_samples(int val) { return setValue("imap_samples", val); }
	//! (description missing)
	//! [Default value] 20
	int get_imap_samples() const { return getInt("imap_samples"); }

	//! Reflection anisotropy in the range (-1, 1)
 	bool set_anisotropy(const Plugin& texturefloat) { return setValue("anisotropy", texturefloat); }
	//! Reflection anisotropy in the range (-1, 1)
 	bool set_anisotropy(float texturefloat) { return setValue("anisotropy", texturefloat); }
	//! Reflection anisotropy in the range (-1, 1)
 	Value get_anisotropy() const { return getValue("anisotropy"); }

	//! (description missing)
	bool set_anisotropy_uvwgen(const Plugin& plugin) { return setValue("anisotropy_uvwgen", plugin); }
	//! (description missing)
	Plugin get_anisotropy_uvwgen() const { return getPlugin("anisotropy_uvwgen"); }

	//! Anisotropy rotation in the range [0, 1]
 	bool set_anisotropy_rotation(const Plugin& texturefloat) { return setValue("anisotropy_rotation", texturefloat); }
	//! Anisotropy rotation in the range [0, 1]
 	bool set_anisotropy_rotation(float texturefloat) { return setValue("anisotropy_rotation", texturefloat); }
	//! Anisotropy rotation in the range [0, 1]
 	Value get_anisotropy_rotation() const { return getValue("anisotropy_rotation"); }

	//! true to fix dark edges with glossy reflections; only set this to false for compatibility with older versions
 	//! [Default value] true
	bool set_fix_dark_edges(bool val) { return setValue("fix_dark_edges", val); }
	//! true to fix dark edges with glossy reflections; only set this to false for compatibility with older versions
 	//! [Default value] true
	bool get_fix_dark_edges() const { return getBool("fix_dark_edges"); }
};

class BSDFPointParticle : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "BSDFPointParticle"; }

	//! Diffuse color
 	//! [UI Guides] startTab=V-Ray Point Particle Material, startRollout=V-Ray Point Particle Material
 	bool set_diffuse_color(const Plugin& texture) { return setValue("diffuse_color", texture); }
	//! Diffuse color
 	//! [UI Guides] startTab=V-Ray Point Particle Material, startRollout=V-Ray Point Particle Material
 	bool set_diffuse_color(const AColor& texture) { return setValue("diffuse_color", texture); }
	//! Diffuse color
 	//! [UI Guides] startTab=V-Ray Point Particle Material, startRollout=V-Ray Point Particle Material
 	Value get_diffuse_color() const { return getValue("diffuse_color"); }

	//! true to render the particle colors instead of using the diffuse color
 	//! [Default value] false
	bool set_use_particle_color(bool val) { return setValue("use_particle_color", val); }
	//! true to render the particle colors instead of using the diffuse color
 	//! [Default value] false
	bool get_use_particle_color() const { return getBool("use_particle_color"); }

	//! Parameter used to determine the phase function of the brdf
 	//! [UI Guides] minValue=-1.0, maxValue=1.0
 	//! [Default value] 0
	bool set_phase_function(float val) { return setValue("phase_function", val); }
	//! Parameter used to determine the phase function of the brdf
 	//! [UI Guides] minValue=-1.0, maxValue=1.0
 	//! [Default value] 0
	float get_phase_function() const { return getFloat("phase_function"); }
};

class BakeView : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "BakeView"; }

	//! The node to bake
 	bool set_bake_node(const Plugin& plugin) { return setValue("bake_node", plugin); }
	//! The node to bake
 	Plugin get_bake_node() const { return getPlugin("bake_node"); }

	//! The target objects for projection baking
 	//! [UI Guides] attributes=objectSet
 	bool set_target_nodes(const ValueList& pluginList) { return setValue("target_nodes", pluginList); }
	//! The target objects for projection baking
 	//! [UI Guides] attributes=objectSet
 	ValueList get_target_nodes() const { return getValueList("target_nodes"); }

	//! The uvw generator
 	bool set_bake_uvwgen(const Plugin& plugin) { return setValue("bake_uvwgen", plugin); }
	//! The uvw generator
 	Plugin get_bake_uvwgen() const { return getPlugin("bake_uvwgen"); }

	//! Number of pixels to expand around geometry
 	//! [Default value] 2
	bool set_dilation(float val) { return setValue("dilation", val); }
	//! Number of pixels to expand around geometry
 	//! [Default value] 2
	float get_dilation() const { return getFloat("dilation"); }

	//! true to flip the texture direction derivatives (reverses bump mapping)
 	//! [Default value] false
	bool set_flip_derivs(bool val) { return setValue("flip_derivs", val); }
	//! true to flip the texture direction derivatives (reverses bump mapping)
 	//! [Default value] false
	bool get_flip_derivs() const { return getBool("flip_derivs"); }

	//! The minimum u value to bake
 	//! [Default value] 0
	bool set_u_min(float val) { return setValue("u_min", val); }
	//! The minimum u value to bake
 	//! [Default value] 0
	float get_u_min() const { return getFloat("u_min"); }

	//! The minimum v value to bake
 	//! [Default value] 0
	bool set_v_min(float val) { return setValue("v_min", val); }
	//! The minimum v value to bake
 	//! [Default value] 0
	float get_v_min() const { return getFloat("v_min"); }

	//! The maximum u value to bake
 	//! [Default value] 1
	bool set_u_max(float val) { return setValue("u_max", val); }
	//! The maximum u value to bake
 	//! [Default value] 1
	float get_u_max() const { return getFloat("u_max"); }

	//! The maximum v value to bake
 	//! [Default value] 1
	bool set_v_max(float val) { return setValue("v_max", val); }
	//! The maximum v value to bake
 	//! [Default value] 1
	float get_v_max() const { return getFloat("v_max"); }

	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	bool set_transform(const Transform& transform) { return setValue("transform", transform); }
	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	Transform get_transform() const { return getTransform("transform"); }

	//! (description missing)
	//! [Default value] 0.785398
	bool set_fov(float val) { return setValue("fov", val); }
	//! (description missing)
	//! [Default value] 0.785398
	float get_fov() const { return getFloat("fov"); }

	//! 0 - normal baking, 1 - projection baking
 	//! [Default value] 0
	bool set_projection_baking(int val) { return setValue("projection_baking", val); }
	//! 0 - normal baking, 1 - projection baking
 	//! [Default value] 0
	int get_projection_baking() const { return getInt("projection_baking"); }

	//! 0 - outside, 1 - inside, 2 - outside first, the inside, 3 - inside first, the outside, 4 - closest
 	//! [Default value] 0
	bool set_mode(int val) { return setValue("mode", val); }
	//! 0 - outside, 1 - inside, 2 - outside first, the inside, 3 - inside first, the outside, 4 - closest
 	//! [Default value] 0
	int get_mode() const { return getInt("mode"); }

	//! 0 - Smooth normal, 1 - Geometry normal
 	//! [Default value] 0
	bool set_normal(int val) { return setValue("normal", val); }
	//! 0 - Smooth normal, 1 - Geometry normal
 	//! [Default value] 0
	int get_normal() const { return getInt("normal"); }

	//! Geometry that is intersected further than this value along the ray will be ignored. If the value is zero then no geometry will be ignored.
 	//! [Default value] 0
	bool set_max_depth(float val) { return setValue("max_depth", val); }
	//! Geometry that is intersected further than this value along the ray will be ignored. If the value is zero then no geometry will be ignored.
 	//! [Default value] 0
	float get_max_depth() const { return getFloat("max_depth"); }

	//! The ray's beginning will be offseted this much along the normal.
 	//! [Default value] 0
	bool set_ray_offset(float val) { return setValue("ray_offset", val); }
	//! The ray's beginning will be offseted this much along the normal.
 	//! [Default value] 0
	float get_ray_offset() const { return getFloat("ray_offset"); }

	//! 0 - shade reflections, etc. from rays along surface normal; 1 - bake from rays originating from camera.
 	//! [Default value] 0
	bool set_from_camera(int val) { return setValue("from_camera", val); }
	//! 0 - shade reflections, etc. from rays along surface normal; 1 - bake from rays originating from camera.
 	//! [Default value] 0
	int get_from_camera() const { return getInt("from_camera"); }
};

class BitmapBuffer : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "BitmapBuffer"; }

	//! -1 - nearest; 0 - no filtering; 1 - mip-map filtering; 2 - summed area table filtering; 3 - elliptical filtering
 	//! [UI Guides] enum=-1:Nearest;0:No filtering;1:Mip-map filtering;2:Summed are table filtering;3:Elliptical filtering
 	//! [Default value] 1
	bool set_filter_type(int val) { return setValue("filter_type", val); }
	//! -1 - nearest; 0 - no filtering; 1 - mip-map filtering; 2 - summed area table filtering; 3 - elliptical filtering
 	//! [UI Guides] enum=-1:Nearest;0:No filtering;1:Mip-map filtering;2:Summed are table filtering;3:Elliptical filtering
 	//! [Default value] 1
	int get_filter_type() const { return getInt("filter_type"); }

	//! (description missing)
	//! [Default value] 1
	bool set_filter_blur(float val) { return setValue("filter_blur", val); }
	//! (description missing)
	//! [Default value] 1
	float get_filter_blur() const { return getFloat("filter_blur"); }

	//! 0 - linear, 1 - gamma corrected, 2 - sRGB
 	//! [UI Guides] enum=0:Linear;1:Gamma corrected;2:sRGB
 	//! [Default value] 1
	bool set_color_space(int val) { return setValue("color_space", val); }
	//! 0 - linear, 1 - gamma corrected, 2 - sRGB
 	//! [UI Guides] enum=0:Linear;1:Gamma corrected;2:sRGB
 	//! [Default value] 1
	int get_color_space() const { return getInt("color_space"); }

	//! (description missing)
	//! [Default value] 1
	bool set_gamma(float val) { return setValue("gamma", val); }
	//! (description missing)
	//! [Default value] 1
	float get_gamma() const { return getFloat("gamma"); }

	//! (description missing)
	//! [Default value] false
	bool set_maya_compatible(bool val) { return setValue("maya_compatible", val); }
	//! (description missing)
	//! [Default value] false
	bool get_maya_compatible() const { return getBool("maya_compatible"); }

	//! if false negative colors will be clamped
 	//! [Default value] false
	bool set_allow_negative_colors(bool val) { return setValue("allow_negative_colors", val); }
	//! if false negative colors will be clamped
 	//! [Default value] false
	bool get_allow_negative_colors() const { return getBool("allow_negative_colors"); }

	//! Interpolation method for the mip-map filtering (0 - bilinear, 1 - bicubic, 2 - biquadratic)
 	//! [UI Guides] enum=0:Bilinear;1:Bicubic;2:Biquadratic
 	//! [Default value] 0
	bool set_interpolation(int val) { return setValue("interpolation", val); }
	//! Interpolation method for the mip-map filtering (0 - bilinear, 1 - bicubic, 2 - biquadratic)
 	//! [UI Guides] enum=0:Bilinear;1:Bicubic;2:Biquadratic
 	//! [Default value] 0
	int get_interpolation() const { return getInt("interpolation"); }

	//! When working with image sequences, this parameter specifies which image out of the sequence should be used.  If parameter is omitted or defaulted, the frame number depends on the current frame time value.
 	//! [Default value] -2147483648
	bool set_frame_number(int val) { return setValue("frame_number", val); }
	//! When working with image sequences, this parameter specifies which image out of the sequence should be used.  If parameter is omitted or defaulted, the frame number depends on the current frame time value.
 	//! [Default value] -2147483648
	int get_frame_number() const { return getInt("frame_number"); }

	//! Start frame offset for image sequences
 	//! [Default value] 0
	bool set_frame_offset(int val) { return setValue("frame_offset", val); }
	//! Start frame offset for image sequences
 	//! [Default value] 0
	int get_frame_offset() const { return getInt("frame_offset"); }

	//! The file name; can contain <UDIM> or <UVTILE> tags for Mari or Mudbox tiles respectively,or $nU and $nV for explicit tiles; lower-case tags consider the tiles as starting from 0 whereas upper-case tags start from 1
 	//! [UI Guides] fileAsset=exr;png;bmp;tga;hdr;jpg;jpeg;pic;tif;tiff;psd;vrimg;sgi;rgb;rgba
 	bool set_file(const char* str) { return setValue("file", str); }
	//! The file name; can contain <UDIM> or <UVTILE> tags for Mari or Mudbox tiles respectively,or $nU and $nV for explicit tiles; lower-case tags consider the tiles as starting from 0 whereas upper-case tags start from 1
 	//! [UI Guides] fileAsset=exr;png;bmp;tga;hdr;jpg;jpeg;pic;tif;tiff;psd;vrimg;sgi;rgb;rgba
 	bool set_file(const std::string& str) { return setValue("file", str); }
	//! The file name; can contain <UDIM> or <UVTILE> tags for Mari or Mudbox tiles respectively,or $nU and $nV for explicit tiles; lower-case tags consider the tiles as starting from 0 whereas upper-case tags start from 1
 	//! [UI Guides] fileAsset=exr;png;bmp;tga;hdr;jpg;jpeg;pic;tif;tiff;psd;vrimg;sgi;rgb;rgba
 	std::string get_file() const { return getString("file"); }

	//! if set to false, the file would not be loaded
 	//! [Default value] true
	bool set_load_file(bool val) { return setValue("load_file", val); }
	//! if set to false, the file would not be loaded
 	//! [Default value] true
	bool get_load_file() const { return getBool("load_file"); }

	//! (description missing)
	//! [Default value] false
	bool set_frame_sequence(bool val) { return setValue("frame_sequence", val); }
	//! (description missing)
	//! [Default value] false
	bool get_frame_sequence() const { return getBool("frame_sequence"); }

	//! true to use the data window information in e.g. OpenEXR files; otherwise false
 	//! [Default value] true
	bool set_use_data_window(bool val) { return setValue("use_data_window", val); }
	//! true to use the data window information in e.g. OpenEXR files; otherwise false
 	//! [Default value] true
	bool get_use_data_window() const { return getBool("use_data_window"); }

	//! (description missing)
	bool set_psd_group_name(const IntList& intList) { return setValue("psd_group_name", intList); }
	//! (description missing)
	bool set_psd_group_name(const int* ints, size_t count) { return setArray("psd_group_name", ints, count); }
	//! (description missing)
	template<size_t count> bool set_psd_group_name(const int (&ints)[count]) { return setArray("psd_group_name", ints, count); }
	//! (description missing)
	IntList get_psd_group_name() const { return getIntList("psd_group_name"); }

	//! (description missing)
	bool set_psd_alpha_name(const IntList& intList) { return setValue("psd_alpha_name", intList); }
	//! (description missing)
	bool set_psd_alpha_name(const int* ints, size_t count) { return setArray("psd_alpha_name", ints, count); }
	//! (description missing)
	template<size_t count> bool set_psd_alpha_name(const int (&ints)[count]) { return setArray("psd_alpha_name", ints, count); }
	//! (description missing)
	IntList get_psd_alpha_name() const { return getIntList("psd_alpha_name"); }

	//! (description missing)
	//! [Default value] 0
	bool set_ifl_start_frame(int val) { return setValue("ifl_start_frame", val); }
	//! (description missing)
	//! [Default value] 0
	int get_ifl_start_frame() const { return getInt("ifl_start_frame"); }

	//! (description missing)
	//! [Default value] 1
	bool set_ifl_playback_rate(float val) { return setValue("ifl_playback_rate", val); }
	//! (description missing)
	//! [Default value] 1
	float get_ifl_playback_rate() const { return getFloat("ifl_playback_rate"); }

	//! Image file list (IFL) end condition: 0 - Loop; 1 - Ping Pong; 2 - Hold;
 	//! [UI Guides] enum=0:Loop;1:Ping Pong;2:Hold
 	//! [Default value] 0
	bool set_ifl_end_condition(int val) { return setValue("ifl_end_condition", val); }
	//! Image file list (IFL) end condition: 0 - Loop; 1 - Ping Pong; 2 - Hold;
 	//! [UI Guides] enum=0:Loop;1:Ping Pong;2:Hold
 	//! [Default value] 0
	int get_ifl_end_condition() const { return getInt("ifl_end_condition"); }
};

class CameraDefault : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "CameraDefault"; }

	//! (description missing)
	//! [Default value] false
	bool set_orthographic(bool val) { return setValue("orthographic", val); }
	//! (description missing)
	//! [Default value] false
	bool get_orthographic() const { return getBool("orthographic"); }
};

class CameraDome : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "CameraDome"; }

	//! Flip in the horizontal image direction
 	//! [Default value] false
	bool set_flip_x(bool val) { return setValue("flip_x", val); }
	//! Flip in the horizontal image direction
 	//! [Default value] false
	bool get_flip_x() const { return getBool("flip_x"); }

	//! Flip in the vertical image direction
 	//! [Default value] false
	bool set_flip_y(bool val) { return setValue("flip_y", val); }
	//! Flip in the vertical image direction
 	//! [Default value] false
	bool get_flip_y() const { return getBool("flip_y"); }

	//! Field of view (radians)
 	//! [Default value] 0.785398
	bool set_fov(float val) { return setValue("fov", val); }
	//! Field of view (radians)
 	//! [Default value] 0.785398
	float get_fov() const { return getFloat("fov"); }
};

class CameraFilmTransform : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "CameraFilmTransform"; }

	//! The prescale that will be applied to the camera
 	//! [Default value] 1
	bool set_prescale(float val) { return setValue("prescale", val); }
	//! The prescale that will be applied to the camera
 	//! [Default value] 1
	float get_prescale() const { return getFloat("prescale"); }

	//! The postScale that will be applied to the camera
 	//! [Default value] 1
	bool set_postscale(float val) { return setValue("postscale", val); }
	//! The postScale that will be applied to the camera
 	//! [Default value] 1
	float get_postscale() const { return getFloat("postscale"); }

	//! The normalized translation along x axis that will be applied to the camera
 	//! [Default value] 0
	bool set_transx(float val) { return setValue("transx", val); }
	//! The normalized translation along x axis that will be applied to the camera
 	//! [Default value] 0
	float get_transx() const { return getFloat("transx"); }

	//! The normalized translation along y axis that will be applied to the camera
 	//! [Default value] 0
	bool set_transy(float val) { return setValue("transy", val); }
	//! The normalized translation along y axis that will be applied to the camera
 	//! [Default value] 0
	float get_transy() const { return getFloat("transy"); }

	//! The rotation pivot y coordinate
 	//! [Default value] 0
	bool set_pivotx(float val) { return setValue("pivotx", val); }
	//! The rotation pivot y coordinate
 	//! [Default value] 0
	float get_pivotx() const { return getFloat("pivotx"); }

	//! The rotation pivot x coordinate
 	//! [Default value] 0
	bool set_pivoty(float val) { return setValue("pivoty", val); }
	//! The rotation pivot x coordinate
 	//! [Default value] 0
	float get_pivoty() const { return getFloat("pivoty"); }

	//! The rotation around the pivot that will be applied to the camera
 	//! [Default value] 0
	bool set_rotation(float val) { return setValue("rotation", val); }
	//! The rotation around the pivot that will be applied to the camera
 	//! [Default value] 0
	float get_rotation() const { return getFloat("rotation"); }

	//! If true, the rotation will be applied before the translation
 	//! [Default value] true
	bool set_rot_before_trans(bool val) { return setValue("rot_before_trans", val); }
	//! If true, the rotation will be applied before the translation
 	//! [Default value] true
	bool get_rot_before_trans() const { return getBool("rot_before_trans"); }
};

class CameraPhysical : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "CameraPhysical"; }

	//! 0-still camera; 1-movie camera; 2- video camera
 	//! [UI Guides] enum=0:Still;1:Movie;2:Video, minValue=0
 	//! [Default value] 0
	bool set_type(int val) { return setValue("type", val); }
	//! 0-still camera; 1-movie camera; 2- video camera
 	//! [UI Guides] enum=0:Still;1:Movie;2:Video, minValue=0
 	//! [Default value] 0
	int get_type() const { return getInt("type"); }

	//! film gate in mm
 	//! [UI Guides] minValue=0
 	//! [Default value] 36
	bool set_film_width(float val) { return setValue("film_width", val); }
	//! film gate in mm
 	//! [UI Guides] minValue=0
 	//! [Default value] 36
	float get_film_width() const { return getFloat("film_width"); }

	//! focal length in mm
 	//! [UI Guides] minValue=0
 	//! [Default value] 40
	bool set_focal_length(float val) { return setValue("focal_length", val); }
	//! focal length in mm
 	//! [UI Guides] minValue=0
 	//! [Default value] 40
	float get_focal_length() const { return getFloat("focal_length"); }

	//! zoom factor
 	//! [UI Guides] minValue=0
 	//! [Default value] 1
	bool set_zoom_factor(float val) { return setValue("zoom_factor", val); }
	//! zoom factor
 	//! [UI Guides] minValue=0
 	//! [Default value] 1
	float get_zoom_factor() const { return getFloat("zoom_factor"); }

	//! distortion
 	//! [UI Guides] enableIf: ?distortion_type=0; ?distortion_type=1
 	//! [Default value] 0
	bool set_distortion(float val) { return setValue("distortion", val); }
	//! distortion
 	//! [UI Guides] enableIf: ?distortion_type=0; ?distortion_type=1
 	//! [Default value] 0
	float get_distortion() const { return getFloat("distortion"); }

	//! 0-quadratic; 1-cubic; 2-lens file; 3-texture
 	//! [UI Guides] enum=0:Quadratic;1:Cubic;2:Lens file;3:Texture
 	//! [Default value] 0
	bool set_distortion_type(int val) { return setValue("distortion_type", val); }
	//! 0-quadratic; 1-cubic; 2-lens file; 3-texture
 	//! [UI Guides] enum=0:Quadratic;1:Cubic;2:Lens file;3:Texture
 	//! [Default value] 0
	int get_distortion_type() const { return getInt("distortion_type"); }

	//! f-stop
 	//! [UI Guides] displayName=F-stop, minValue=0.01
 	//! [Default value] 8
	bool set_f_number(float val) { return setValue("f_number", val); }
	//! f-stop
 	//! [UI Guides] displayName=F-stop, minValue=0.01
 	//! [Default value] 8
	float get_f_number() const { return getFloat("f_number"); }

	//! lens shift
 	//! [UI Guides] displayName=Vertical tilt
 	//! [Default value] 0
	bool set_lens_shift(float val) { return setValue("lens_shift", val); }
	//! lens shift
 	//! [UI Guides] displayName=Vertical tilt
 	//! [Default value] 0
	float get_lens_shift() const { return getFloat("lens_shift"); }

	//! the shutter speed in seconds^-1
 	//! [UI Guides] enableIf: ?type=0, minValue=0
 	//! [Default value] 300
	bool set_shutter_speed(float val) { return setValue("shutter_speed", val); }
	//! the shutter speed in seconds^-1
 	//! [UI Guides] enableIf: ?type=0, minValue=0
 	//! [Default value] 300
	float get_shutter_speed() const { return getFloat("shutter_speed"); }

	//! shutter angle in degrees
 	//! [UI Guides] enableIf: ?type=1, minValue=0, maxValue=360
 	//! [Default value] 180
	bool set_shutter_angle(float val) { return setValue("shutter_angle", val); }
	//! shutter angle in degrees
 	//! [UI Guides] enableIf: ?type=1, minValue=0, maxValue=360
 	//! [Default value] 180
	float get_shutter_angle() const { return getFloat("shutter_angle"); }

	//! shutter offset in degrees
 	//! [UI Guides] enableIf: ?type=1, minValue=-360, maxValue=360
 	//! [Default value] 0
	bool set_shutter_offset(float val) { return setValue("shutter_offset", val); }
	//! shutter offset in degrees
 	//! [UI Guides] enableIf: ?type=1, minValue=-360, maxValue=360
 	//! [Default value] 0
	float get_shutter_offset() const { return getFloat("shutter_offset"); }

	//! shutter latency in seconds
 	//! [UI Guides] enableIf: ?type=2
 	//! [Default value] 0
	bool set_latency(float val) { return setValue("latency", val); }
	//! shutter latency in seconds
 	//! [UI Guides] enableIf: ?type=2
 	//! [Default value] 0
	float get_latency() const { return getFloat("latency"); }

	//! [UI Guides] minValue=0
 	//! [Default value] 200
	bool set_ISO(float val) { return setValue("ISO", val); }
	//! [UI Guides] minValue=0
 	//! [Default value] 200
	float get_ISO() const { return getFloat("ISO"); }

	//! (description missing)
	//! [Default value] false
	bool set_specify_focus(bool val) { return setValue("specify_focus", val); }
	//! (description missing)
	//! [Default value] false
	bool get_specify_focus() const { return getBool("specify_focus"); }

	//! focus distance in world units
 	//! [UI Guides] enableIf: ?specify_focus=1, quantityType=distance, minValue=0
 	//! [Default value] 200
	bool set_focus_distance(float val) { return setValue("focus_distance", val); }
	//! focus distance in world units
 	//! [UI Guides] enableIf: ?specify_focus=1, quantityType=distance, minValue=0
 	//! [Default value] 200
	float get_focus_distance() const { return getFloat("focus_distance"); }

	//! 1-specify a target distance; 0-target distance not specified
 	//! [Default value] true
	bool set_targeted(bool val) { return setValue("targeted", val); }
	//! 1-specify a target distance; 0-target distance not specified
 	//! [Default value] true
	bool get_targeted() const { return getBool("targeted"); }

	//! target distance
 	//! [UI Guides] enableIf: ?specify_focus=0, quantityType=distance, minValue=0
 	//! [Default value] 200
	bool set_target_distance(float val) { return setValue("target_distance", val); }
	//! target distance
 	//! [UI Guides] enableIf: ?specify_focus=0, quantityType=distance, minValue=0
 	//! [Default value] 200
	float get_target_distance() const { return getFloat("target_distance"); }

	//! display threshold for depth-of-field
 	//! [Default value] 0.001
	bool set_dof_display_threshold(float val) { return setValue("dof_display_threshold", val); }
	//! display threshold for depth-of-field
 	//! [Default value] 0.001
	float get_dof_display_threshold() const { return getFloat("dof_display_threshold"); }

	//! 1- exposure color correction; 0-disable exposure color correction
 	//! [Default value] true
	bool set_exposure(bool val) { return setValue("exposure", val); }
	//! 1- exposure color correction; 0-disable exposure color correction
 	//! [Default value] true
	bool get_exposure() const { return getBool("exposure"); }

	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	bool set_white_balance(const Color& color) { return setValue("white_balance", color); }
	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	Color get_white_balance() const { return getColor("white_balance"); }

	//! Strength of vignetting effect
 	//! [UI Guides] minValue=0
 	//! [Default value] 1
	bool set_vignetting(float val) { return setValue("vignetting", val); }
	//! Strength of vignetting effect
 	//! [UI Guides] minValue=0
 	//! [Default value] 1
	float get_vignetting() const { return getFloat("vignetting"); }

	//! 1- enable Bokeh effects; 0- disable Bokeh effects
 	//! [Default value] false
	bool set_blades_enable(bool val) { return setValue("blades_enable", val); }
	//! 1- enable Bokeh effects; 0- disable Bokeh effects
 	//! [Default value] false
	bool get_blades_enable() const { return getBool("blades_enable"); }

	//! number of blades - 0 means its disabled
 	//! [UI Guides] enableIf: ?blades_enable=1, minValue=2, maxValue=20
 	//! [Default value] 5
	bool set_blades_num(int val) { return setValue("blades_num", val); }
	//! number of blades - 0 means its disabled
 	//! [UI Guides] enableIf: ?blades_enable=1, minValue=2, maxValue=20
 	//! [Default value] 5
	int get_blades_num() const { return getInt("blades_num"); }

	//! blade rotation in radians
 	//! [Default value] 0
	bool set_blades_rotation(float val) { return setValue("blades_rotation", val); }
	//! blade rotation in radians
 	//! [Default value] 0
	float get_blades_rotation() const { return getFloat("blades_rotation"); }

	//! center bias
 	//! [UI Guides] minValue=-100, maxValue=100
 	//! [Default value] 0
	bool set_center_bias(float val) { return setValue("center_bias", val); }
	//! center bias
 	//! [UI Guides] minValue=-100, maxValue=100
 	//! [Default value] 0
	float get_center_bias() const { return getFloat("center_bias"); }

	//! Bokeh anisotropy
 	//! [UI Guides] minValue=-1, maxValue=1
 	//! [Default value] 0
	bool set_anisotropy(float val) { return setValue("anisotropy", val); }
	//! Bokeh anisotropy
 	//! [UI Guides] minValue=-1, maxValue=1
 	//! [Default value] 0
	float get_anisotropy() const { return getFloat("anisotropy"); }

	//! [UI Guides] displayName=Enable DOF
 	//! [Default value] false
	bool set_use_dof(bool val) { return setValue("use_dof", val); }
	//! [UI Guides] displayName=Enable DOF
 	//! [Default value] false
	bool get_use_dof() const { return getBool("use_dof"); }

	//! [UI Guides] displayName=Enable Motion Blur
 	//! [Default value] false
	bool set_use_moblur(bool val) { return setValue("use_moblur", val); }
	//! [UI Guides] displayName=Enable Motion Blur
 	//! [Default value] false
	bool get_use_moblur() const { return getBool("use_moblur"); }

	//! (description missing)
	//! [Default value] 1
	bool set_subdivs(int val) { return setValue("subdivs", val); }
	//! (description missing)
	//! [Default value] 1
	int get_subdivs() const { return getInt("subdivs"); }

	//! This is here so we can suppress a PhysicalCamera node from affecting the main VRayRenderer sequence and frame data.
 	//! [Default value] false
	bool set_dont_affect_settings(bool val) { return setValue("dont_affect_settings", val); }
	//! This is here so we can suppress a PhysicalCamera node from affecting the main VRayRenderer sequence and frame data.
 	//! [Default value] false
	bool get_dont_affect_settings() const { return getBool("dont_affect_settings"); }

	//! LENS file with camera lens-type image distortion description
 	//! [UI Guides] fileAsset=vrlens, enableIf: ?distortion_type=2
 	bool set_lens_file(const char* str) { return setValue("lens_file", str); }
	//! LENS file with camera lens-type image distortion description
 	//! [UI Guides] fileAsset=vrlens, enableIf: ?distortion_type=2
 	bool set_lens_file(const std::string& str) { return setValue("lens_file", str); }
	//! LENS file with camera lens-type image distortion description
 	//! [UI Guides] fileAsset=vrlens, enableIf: ?distortion_type=2
 	std::string get_lens_file() const { return getString("lens_file"); }

	//! true to use explicit field of view and false to use the focal length
 	//! [Default value] false
	bool set_specify_fov(bool val) { return setValue("specify_fov", val); }
	//! true to use explicit field of view and false to use the focal length
 	//! [Default value] false
	bool get_specify_fov() const { return getBool("specify_fov"); }

	//! the FOV value (in radians) to use when specify_fov is true
 	//! [UI Guides] enableIf: ?specify_fov=1
 	//! [Default value] 1.5708
	bool set_fov(float val) { return setValue("fov", val); }
	//! the FOV value (in radians) to use when specify_fov is true
 	//! [UI Guides] enableIf: ?specify_fov=1
 	//! [Default value] 1.5708
	float get_fov() const { return getFloat("fov"); }

	//! the horizontal lens shift
 	//! [UI Guides] displayName=Horizontal tilt
 	//! [Default value] 0
	bool set_horizontal_shift(float val) { return setValue("horizontal_shift", val); }
	//! the horizontal lens shift
 	//! [UI Guides] displayName=Horizontal tilt
 	//! [Default value] 0
	float get_horizontal_shift() const { return getFloat("horizontal_shift"); }

	//! The horizontal offset
 	//! [UI Guides] displayName=Horizontal shift
 	//! [Default value] 0
	bool set_horizontal_offset(float val) { return setValue("horizontal_offset", val); }
	//! The horizontal offset
 	//! [UI Guides] displayName=Horizontal shift
 	//! [Default value] 0
	float get_horizontal_offset() const { return getFloat("horizontal_offset"); }

	//! The vertical offset
 	//! [UI Guides] displayName=Vertical shift
 	//! [Default value] 0
	bool set_vertical_offset(float val) { return setValue("vertical_offset", val); }
	//! The vertical offset
 	//! [UI Guides] displayName=Vertical shift
 	//! [Default value] 0
	float get_vertical_offset() const { return getFloat("vertical_offset"); }

	//! [UI Guides] displayName=Distortion texture, enableIf: ?distortion_type=3
 	bool set_distortion_tex(const Plugin& texture) { return setValue("distortion_tex", texture); }
	//! [UI Guides] displayName=Distortion texture, enableIf: ?distortion_type=3
 	bool set_distortion_tex(const AColor& texture) { return setValue("distortion_tex", texture); }
	//! [UI Guides] displayName=Distortion texture, enableIf: ?distortion_type=3
 	Value get_distortion_tex() const { return getValue("distortion_tex"); }

	//! 1- enable the use of bitmap aperture; 0- disable bitmap aperture
 	//! [UI Guides] displayName=Bitmap aperture, minValue=1, maxValue=2048
 	//! [Default value] false
	bool set_bmpaperture_enable(bool val) { return setValue("bmpaperture_enable", val); }
	//! 1- enable the use of bitmap aperture; 0- disable bitmap aperture
 	//! [UI Guides] displayName=Bitmap aperture, minValue=1, maxValue=2048
 	//! [Default value] false
	bool get_bmpaperture_enable() const { return getBool("bmpaperture_enable"); }

	//! texture sampling resolution for the importance sampling
 	//! [UI Guides] enableIf: ?bmpaperture_enable=1, displayName=Bitmap resolution
 	//! [Default value] 512
	bool set_bmpaperture_resolution(int val) { return setValue("bmpaperture_resolution", val); }
	//! texture sampling resolution for the importance sampling
 	//! [UI Guides] enableIf: ?bmpaperture_enable=1, displayName=Bitmap resolution
 	//! [Default value] 512
	int get_bmpaperture_resolution() const { return getInt("bmpaperture_resolution"); }

	//! [UI Guides] enableIf: ?bmpaperture_enable=1, displayName=Bitmap aperture texture, attributes=textureSlot
 	bool set_bmpaperture_tex(const Plugin& texture) { return setValue("bmpaperture_tex", texture); }
	//! [UI Guides] enableIf: ?bmpaperture_enable=1, displayName=Bitmap aperture texture, attributes=textureSlot
 	bool set_bmpaperture_tex(const AColor& texture) { return setValue("bmpaperture_tex", texture); }
	//! [UI Guides] enableIf: ?bmpaperture_enable=1, displayName=Bitmap aperture texture, attributes=textureSlot
 	Value get_bmpaperture_tex() const { return getValue("bmpaperture_tex"); }

	//! optical vignetting ("cat's eye bokeh") amount
 	//! [UI Guides] minValue=-3, maxValue=3
 	//! [Default value] 0
	bool set_optical_vignetting(float val) { return setValue("optical_vignetting", val); }
	//! optical vignetting ("cat's eye bokeh") amount
 	//! [UI Guides] minValue=-3, maxValue=3
 	//! [Default value] 0
	float get_optical_vignetting() const { return getFloat("optical_vignetting"); }

	//! This will make the Bitmap Aperture's size and shape affect the exposure
 	//! [UI Guides] enableIf: ?bmpaperture_enable=1, displayName=Bitmap affects exposure
 	//! [Default value] true
	bool set_bmpaperture_affects_exposure(bool val) { return setValue("bmpaperture_affects_exposure", val); }
	//! This will make the Bitmap Aperture's size and shape affect the exposure
 	//! [UI Guides] enableIf: ?bmpaperture_enable=1, displayName=Bitmap affects exposure
 	//! [Default value] true
	bool get_bmpaperture_affects_exposure() const { return getBool("bmpaperture_affects_exposure"); }

	//! Determine if the focus distance will affect the fov or focal length calculation due to thin lens equation
 	//! [UI Guides] displayName=Enable thin lens equation
 	//! [Default value] true
	bool set_enable_thin_lens_equation(bool val) { return setValue("enable_thin_lens_equation", val); }
	//! Determine if the focus distance will affect the fov or focal length calculation due to thin lens equation
 	//! [UI Guides] displayName=Enable thin lens equation
 	//! [Default value] true
	bool get_enable_thin_lens_equation() const { return getBool("enable_thin_lens_equation"); }
};

class ColorCorrect : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "ColorCorrect"; }

	//! Source color
 	//! [Default value] AColor(0, 0, 0, 0)
	bool set_source_color(const AColor& acolor) { return setValue("source_color", acolor); }
	//! Source color
 	//! [Default value] AColor(0, 0, 0, 0)
	AColor get_source_color() const { return getAColor("source_color"); }

	//! The texture being color corrected
 	bool set_texture_map(const Plugin& texture) { return setValue("texture_map", texture); }
	//! The texture being color corrected
 	bool set_texture_map(const AColor& texture) { return setValue("texture_map", texture); }
	//! The texture being color corrected
 	Value get_texture_map() const { return getValue("texture_map"); }

	//! true to enable preprocessing
 	//! [UI Guides] startRollout=RGB Pre-process, displayName=Pre-process On
 	//! [Default value] false
	bool set_preprocess(bool val) { return setValue("preprocess", val); }
	//! true to enable preprocessing
 	//! [UI Guides] startRollout=RGB Pre-process, displayName=Pre-process On
 	//! [Default value] false
	bool get_preprocess() const { return getBool("preprocess"); }

	//! Added to the texture brightness
 	//! [UI Guides] enableIf: ?preprocess=1
 	//! [Default value] 0
	bool set_pre_brightness(float val) { return setValue("pre_brightness", val); }
	//! Added to the texture brightness
 	//! [UI Guides] enableIf: ?preprocess=1
 	//! [Default value] 0
	float get_pre_brightness() const { return getFloat("pre_brightness"); }

	//! Contrast
 	//! [UI Guides] enableIf: ?preprocess=1
 	//! [Default value] 1
	bool set_pre_contrast(float val) { return setValue("pre_contrast", val); }
	//! Contrast
 	//! [UI Guides] enableIf: ?preprocess=1
 	//! [Default value] 1
	float get_pre_contrast() const { return getFloat("pre_contrast"); }

	//! Gamma
 	//! [UI Guides] enableIf: ?preprocess=1
 	//! [Default value] 1
	bool set_pre_gamma(float val) { return setValue("pre_gamma", val); }
	//! Gamma
 	//! [UI Guides] enableIf: ?preprocess=1
 	//! [Default value] 1
	float get_pre_gamma() const { return getFloat("pre_gamma"); }

	//! true to convert to grayscale
 	//! [UI Guides] enableIf: ?preprocess=1
 	//! [Default value] false
	bool set_pre_mono(bool val) { return setValue("pre_mono", val); }
	//! true to convert to grayscale
 	//! [UI Guides] enableIf: ?preprocess=1
 	//! [Default value] false
	bool get_pre_mono() const { return getBool("pre_mono"); }

	//! true to invert the input color
 	//! [UI Guides] enableIf: ?preprocess=1
 	//! [Default value] false
	bool set_pre_invert(bool val) { return setValue("pre_invert", val); }
	//! true to invert the input color
 	//! [UI Guides] enableIf: ?preprocess=1
 	//! [Default value] false
	bool get_pre_invert() const { return getBool("pre_invert"); }

	//! true to unmultiply alpha
 	//! [UI Guides] enableIf: ?preprocess=1
 	//! [Default value] false
	bool set_pre_unmult_alpha(bool val) { return setValue("pre_unmult_alpha", val); }
	//! true to unmultiply alpha
 	//! [UI Guides] enableIf: ?preprocess=1
 	//! [Default value] false
	bool get_pre_unmult_alpha() const { return getBool("pre_unmult_alpha"); }

	//! true to clamp the input color
 	//! [UI Guides] enableIf: ?preprocess=1
 	//! [Default value] false
	bool set_pre_clamp(bool val) { return setValue("pre_clamp", val); }
	//! true to clamp the input color
 	//! [UI Guides] enableIf: ?preprocess=1
 	//! [Default value] false
	bool get_pre_clamp() const { return getBool("pre_clamp"); }

	//! low clamp value
 	//! [UI Guides] enableIf: ?preprocess=1, ?pre_clamp=1
 	//! [Default value] 0
	bool set_pre_clamp_min(float val) { return setValue("pre_clamp_min", val); }
	//! low clamp value
 	//! [UI Guides] enableIf: ?preprocess=1, ?pre_clamp=1
 	//! [Default value] 0
	float get_pre_clamp_min() const { return getFloat("pre_clamp_min"); }

	//! high clamp value
 	//! [UI Guides] enableIf: ?preprocess=1, ?pre_clamp=1
 	//! [Default value] 1
	bool set_pre_clamp_max(float val) { return setValue("pre_clamp_max", val); }
	//! high clamp value
 	//! [UI Guides] enableIf: ?preprocess=1, ?pre_clamp=1
 	//! [Default value] 1
	float get_pre_clamp_max() const { return getFloat("pre_clamp_max"); }

	//! true to normalize the clamped input to 0.0-1.0
 	//! [UI Guides] enableIf: ?preprocess=1, ?pre_clamp=1
 	//! [Default value] false
	bool set_pre_clamp_normalize(bool val) { return setValue("pre_clamp_normalize", val); }
	//! true to normalize the clamped input to 0.0-1.0
 	//! [UI Guides] enableIf: ?preprocess=1, ?pre_clamp=1
 	//! [Default value] false
	bool get_pre_clamp_normalize() const { return getBool("pre_clamp_normalize"); }

	//! [UI Guides] startRollout=HSL, displayName=HSL On
 	//! [Default value] false
	bool set_hsl_on(bool val) { return setValue("hsl_on", val); }
	//! [UI Guides] startRollout=HSL, displayName=HSL On
 	//! [Default value] false
	bool get_hsl_on() const { return getBool("hsl_on"); }

	//! [UI Guides] enableIf: ?hsl_on=1
 	bool set_hsl_hue_offset(const Plugin& texturefloat) { return setValue("hsl_hue_offset", texturefloat); }
	//! [UI Guides] enableIf: ?hsl_on=1
 	bool set_hsl_hue_offset(float texturefloat) { return setValue("hsl_hue_offset", texturefloat); }
	//! [UI Guides] enableIf: ?hsl_on=1
 	Value get_hsl_hue_offset() const { return getValue("hsl_hue_offset"); }

	//! [UI Guides] enableIf: ?hsl_on=1
 	bool set_hsl_hue_gain(const Plugin& texturefloat) { return setValue("hsl_hue_gain", texturefloat); }
	//! [UI Guides] enableIf: ?hsl_on=1
 	bool set_hsl_hue_gain(float texturefloat) { return setValue("hsl_hue_gain", texturefloat); }
	//! [UI Guides] enableIf: ?hsl_on=1
 	Value get_hsl_hue_gain() const { return getValue("hsl_hue_gain"); }

	//! [UI Guides] enableIf: ?hsl_on=1
 	bool set_hsl_saturation_offset(const Plugin& texturefloat) { return setValue("hsl_saturation_offset", texturefloat); }
	//! [UI Guides] enableIf: ?hsl_on=1
 	bool set_hsl_saturation_offset(float texturefloat) { return setValue("hsl_saturation_offset", texturefloat); }
	//! [UI Guides] enableIf: ?hsl_on=1
 	Value get_hsl_saturation_offset() const { return getValue("hsl_saturation_offset"); }

	//! [UI Guides] enableIf: ?hsl_on=1
 	bool set_hsl_saturation_gain(const Plugin& texturefloat) { return setValue("hsl_saturation_gain", texturefloat); }
	//! [UI Guides] enableIf: ?hsl_on=1
 	bool set_hsl_saturation_gain(float texturefloat) { return setValue("hsl_saturation_gain", texturefloat); }
	//! [UI Guides] enableIf: ?hsl_on=1
 	Value get_hsl_saturation_gain() const { return getValue("hsl_saturation_gain"); }

	//! [UI Guides] enableIf: ?hsl_on=1
 	bool set_hsl_lightness_offset(const Plugin& texturefloat) { return setValue("hsl_lightness_offset", texturefloat); }
	//! [UI Guides] enableIf: ?hsl_on=1
 	bool set_hsl_lightness_offset(float texturefloat) { return setValue("hsl_lightness_offset", texturefloat); }
	//! [UI Guides] enableIf: ?hsl_on=1
 	Value get_hsl_lightness_offset() const { return getValue("hsl_lightness_offset"); }

	//! [UI Guides] enableIf: ?hsl_on=1
 	bool set_hsl_lightness_gain(const Plugin& texturefloat) { return setValue("hsl_lightness_gain", texturefloat); }
	//! [UI Guides] enableIf: ?hsl_on=1
 	bool set_hsl_lightness_gain(float texturefloat) { return setValue("hsl_lightness_gain", texturefloat); }
	//! [UI Guides] enableIf: ?hsl_on=1
 	Value get_hsl_lightness_gain() const { return getValue("hsl_lightness_gain"); }

	//! [UI Guides] startRollout=HSV, displayName=HSV On
 	//! [Default value] false
	bool set_hsv_on(bool val) { return setValue("hsv_on", val); }
	//! [UI Guides] startRollout=HSV, displayName=HSV On
 	//! [Default value] false
	bool get_hsv_on() const { return getBool("hsv_on"); }

	//! [UI Guides] enableIf: ?hsv_on=1
 	bool set_hsv_hue_offset(const Plugin& texturefloat) { return setValue("hsv_hue_offset", texturefloat); }
	//! [UI Guides] enableIf: ?hsv_on=1
 	bool set_hsv_hue_offset(float texturefloat) { return setValue("hsv_hue_offset", texturefloat); }
	//! [UI Guides] enableIf: ?hsv_on=1
 	Value get_hsv_hue_offset() const { return getValue("hsv_hue_offset"); }

	//! [UI Guides] enableIf: ?hsv_on=1
 	bool set_hsv_hue_gain(const Plugin& texturefloat) { return setValue("hsv_hue_gain", texturefloat); }
	//! [UI Guides] enableIf: ?hsv_on=1
 	bool set_hsv_hue_gain(float texturefloat) { return setValue("hsv_hue_gain", texturefloat); }
	//! [UI Guides] enableIf: ?hsv_on=1
 	Value get_hsv_hue_gain() const { return getValue("hsv_hue_gain"); }

	//! [UI Guides] enableIf: ?hsv_on=1
 	bool set_hsv_saturation_offset(const Plugin& texturefloat) { return setValue("hsv_saturation_offset", texturefloat); }
	//! [UI Guides] enableIf: ?hsv_on=1
 	bool set_hsv_saturation_offset(float texturefloat) { return setValue("hsv_saturation_offset", texturefloat); }
	//! [UI Guides] enableIf: ?hsv_on=1
 	Value get_hsv_saturation_offset() const { return getValue("hsv_saturation_offset"); }

	//! [UI Guides] enableIf: ?hsv_on=1
 	bool set_hsv_saturation_gain(const Plugin& texturefloat) { return setValue("hsv_saturation_gain", texturefloat); }
	//! [UI Guides] enableIf: ?hsv_on=1
 	bool set_hsv_saturation_gain(float texturefloat) { return setValue("hsv_saturation_gain", texturefloat); }
	//! [UI Guides] enableIf: ?hsv_on=1
 	Value get_hsv_saturation_gain() const { return getValue("hsv_saturation_gain"); }

	//! [UI Guides] enableIf: ?hsv_on=1
 	bool set_hsv_value_offset(const Plugin& texturefloat) { return setValue("hsv_value_offset", texturefloat); }
	//! [UI Guides] enableIf: ?hsv_on=1
 	bool set_hsv_value_offset(float texturefloat) { return setValue("hsv_value_offset", texturefloat); }
	//! [UI Guides] enableIf: ?hsv_on=1
 	Value get_hsv_value_offset() const { return getValue("hsv_value_offset"); }

	//! [UI Guides] enableIf: ?hsv_on=1
 	bool set_hsv_value_gain(const Plugin& texturefloat) { return setValue("hsv_value_gain", texturefloat); }
	//! [UI Guides] enableIf: ?hsv_on=1
 	bool set_hsv_value_gain(float texturefloat) { return setValue("hsv_value_gain", texturefloat); }
	//! [UI Guides] enableIf: ?hsv_on=1
 	Value get_hsv_value_gain() const { return getValue("hsv_value_gain"); }

	//! [UI Guides] startRollout=RGBA Channel Mapping, displayName=RGBA Channel Mapping On
 	//! [Default value] false
	bool set_rgba_on(bool val) { return setValue("rgba_on", val); }
	//! [UI Guides] startRollout=RGBA Channel Mapping, displayName=RGBA Channel Mapping On
 	//! [Default value] false
	bool get_rgba_on() const { return getBool("rgba_on"); }

	//! 0-red, 1-green, 2-blue, 3-alpha, 4-intensity, 5-in_red, 6-in_green, 7-in_blue, 8-in_alpha, 9-in_intensity, 10-hsl_hue, 11-hsl_saturation, 12-hsl_lightness, 13-hsv_hue, 14-hsv_saturation, 15-hsv_value
 	//! [UI Guides] enum=0:Red;1:Green;2:Blue;3:Alpha;4:Intensity;5:In Red;6:In Green;7:In Blue;8:In Alpha;9:In Intensity;10:HSL hue;11:HSL saturation;12:HSL lightness;13:HSV hue;14:HSV saturation;15:HSV value, enableIf: ?rgba_on=1
 	//! [Default value] 0
	bool set_red_channel(int val) { return setValue("red_channel", val); }
	//! 0-red, 1-green, 2-blue, 3-alpha, 4-intensity, 5-in_red, 6-in_green, 7-in_blue, 8-in_alpha, 9-in_intensity, 10-hsl_hue, 11-hsl_saturation, 12-hsl_lightness, 13-hsv_hue, 14-hsv_saturation, 15-hsv_value
 	//! [UI Guides] enum=0:Red;1:Green;2:Blue;3:Alpha;4:Intensity;5:In Red;6:In Green;7:In Blue;8:In Alpha;9:In Intensity;10:HSL hue;11:HSL saturation;12:HSL lightness;13:HSV hue;14:HSV saturation;15:HSV value, enableIf: ?rgba_on=1
 	//! [Default value] 0
	int get_red_channel() const { return getInt("red_channel"); }

	//! [UI Guides] enableIf: ?rgba_on=1
 	bool set_red_offset(const Plugin& texturefloat) { return setValue("red_offset", texturefloat); }
	//! [UI Guides] enableIf: ?rgba_on=1
 	bool set_red_offset(float texturefloat) { return setValue("red_offset", texturefloat); }
	//! [UI Guides] enableIf: ?rgba_on=1
 	Value get_red_offset() const { return getValue("red_offset"); }

	//! [UI Guides] enableIf: ?rgba_on=1
 	bool set_red_gain(const Plugin& texturefloat) { return setValue("red_gain", texturefloat); }
	//! [UI Guides] enableIf: ?rgba_on=1
 	bool set_red_gain(float texturefloat) { return setValue("red_gain", texturefloat); }
	//! [UI Guides] enableIf: ?rgba_on=1
 	Value get_red_gain() const { return getValue("red_gain"); }

	//! 0-red, 1-green, 2-blue, 3-alpha, 4-intensity, 5-in_red, 6-in_green, 7-in_blue, 8-in_alpha, 9-in_intensity, 10-hsl_hue, 11-hsl_saturation, 12-hsl_lightness, 13-hsv_hue, 14-hsv_saturation, 15-hsv_value
 	//! [UI Guides] enum=0:Red;1:Green;2:Blue;3:Alpha;4:Intensity;5:In Red;6:In Green;7:In Blue;8:In Alpha;9:In Intensity;10:HSL hue;11:HSL saturation;12:HSL lightness;13:HSV hue;14:HSV saturation;15:HSV value, enableIf: ?rgba_on=1
 	//! [Default value] 0
	bool set_green_channel(int val) { return setValue("green_channel", val); }
	//! 0-red, 1-green, 2-blue, 3-alpha, 4-intensity, 5-in_red, 6-in_green, 7-in_blue, 8-in_alpha, 9-in_intensity, 10-hsl_hue, 11-hsl_saturation, 12-hsl_lightness, 13-hsv_hue, 14-hsv_saturation, 15-hsv_value
 	//! [UI Guides] enum=0:Red;1:Green;2:Blue;3:Alpha;4:Intensity;5:In Red;6:In Green;7:In Blue;8:In Alpha;9:In Intensity;10:HSL hue;11:HSL saturation;12:HSL lightness;13:HSV hue;14:HSV saturation;15:HSV value, enableIf: ?rgba_on=1
 	//! [Default value] 0
	int get_green_channel() const { return getInt("green_channel"); }

	//! [UI Guides] enableIf: ?rgba_on=1
 	bool set_green_offset(const Plugin& texturefloat) { return setValue("green_offset", texturefloat); }
	//! [UI Guides] enableIf: ?rgba_on=1
 	bool set_green_offset(float texturefloat) { return setValue("green_offset", texturefloat); }
	//! [UI Guides] enableIf: ?rgba_on=1
 	Value get_green_offset() const { return getValue("green_offset"); }

	//! [UI Guides] enableIf: ?rgba_on=1
 	bool set_green_gain(const Plugin& texturefloat) { return setValue("green_gain", texturefloat); }
	//! [UI Guides] enableIf: ?rgba_on=1
 	bool set_green_gain(float texturefloat) { return setValue("green_gain", texturefloat); }
	//! [UI Guides] enableIf: ?rgba_on=1
 	Value get_green_gain() const { return getValue("green_gain"); }

	//! 0-red, 1-green, 2-blue, 3-alpha, 4-intensity, 5-in_red, 6-in_green, 7-in_blue, 8-in_alpha, 9-in_intensity, 10-hsl_hue, 11-hsl_saturation, 12-hsl_lightness, 13-hsv_hue, 14-hsv_saturation, 15-hsv_value
 	//! [UI Guides] enum=0:Red;1:Green;2:Blue;3:Alpha;4:Intensity;5:In Red;6:In Green;7:In Blue;8:In Alpha;9:In Intensity;10:HSL hue;11:HSL saturation;12:HSL lightness;13:HSV hue;14:HSV saturation;15:HSV value, enableIf: ?rgba_on=1
 	//! [Default value] 0
	bool set_blue_channel(int val) { return setValue("blue_channel", val); }
	//! 0-red, 1-green, 2-blue, 3-alpha, 4-intensity, 5-in_red, 6-in_green, 7-in_blue, 8-in_alpha, 9-in_intensity, 10-hsl_hue, 11-hsl_saturation, 12-hsl_lightness, 13-hsv_hue, 14-hsv_saturation, 15-hsv_value
 	//! [UI Guides] enum=0:Red;1:Green;2:Blue;3:Alpha;4:Intensity;5:In Red;6:In Green;7:In Blue;8:In Alpha;9:In Intensity;10:HSL hue;11:HSL saturation;12:HSL lightness;13:HSV hue;14:HSV saturation;15:HSV value, enableIf: ?rgba_on=1
 	//! [Default value] 0
	int get_blue_channel() const { return getInt("blue_channel"); }

	//! [UI Guides] enableIf: ?rgba_on=1
 	bool set_blue_offset(const Plugin& texturefloat) { return setValue("blue_offset", texturefloat); }
	//! [UI Guides] enableIf: ?rgba_on=1
 	bool set_blue_offset(float texturefloat) { return setValue("blue_offset", texturefloat); }
	//! [UI Guides] enableIf: ?rgba_on=1
 	Value get_blue_offset() const { return getValue("blue_offset"); }

	//! [UI Guides] enableIf: ?rgba_on=1
 	bool set_blue_gain(const Plugin& texturefloat) { return setValue("blue_gain", texturefloat); }
	//! [UI Guides] enableIf: ?rgba_on=1
 	bool set_blue_gain(float texturefloat) { return setValue("blue_gain", texturefloat); }
	//! [UI Guides] enableIf: ?rgba_on=1
 	Value get_blue_gain() const { return getValue("blue_gain"); }

	//! 0-red, 1-green, 2-blue, 3-alpha, 4-intensity, 5-in_red, 6-in_green, 7-in_blue, 8-in_alpha, 9-in_intensity, 10-hsl_hue, 11-hsl_saturation, 12-hsl_lightness, 13-hsv_hue, 14-hsv_saturation, 15-hsv_value
 	//! [UI Guides] enum=0:Red;1:Green;2:Blue;3:Alpha;4:Intensity;5:In Red;6:In Green;7:In Blue;8:In Alpha;9:In Intensity;10:HSL hue;11:HSL saturation;12:HSL lightness;13:HSV hue;14:HSV saturation;15:HSV value, enableIf: ?rgba_on=1
 	//! [Default value] 0
	bool set_alpha_channel(int val) { return setValue("alpha_channel", val); }
	//! 0-red, 1-green, 2-blue, 3-alpha, 4-intensity, 5-in_red, 6-in_green, 7-in_blue, 8-in_alpha, 9-in_intensity, 10-hsl_hue, 11-hsl_saturation, 12-hsl_lightness, 13-hsv_hue, 14-hsv_saturation, 15-hsv_value
 	//! [UI Guides] enum=0:Red;1:Green;2:Blue;3:Alpha;4:Intensity;5:In Red;6:In Green;7:In Blue;8:In Alpha;9:In Intensity;10:HSL hue;11:HSL saturation;12:HSL lightness;13:HSV hue;14:HSV saturation;15:HSV value, enableIf: ?rgba_on=1
 	//! [Default value] 0
	int get_alpha_channel() const { return getInt("alpha_channel"); }

	//! [UI Guides] enableIf: ?rgba_on=1
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! [UI Guides] enableIf: ?rgba_on=1
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! [UI Guides] enableIf: ?rgba_on=1
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! [UI Guides] enableIf: ?rgba_on=1
 	bool set_alpha_gain(const Plugin& texturefloat) { return setValue("alpha_gain", texturefloat); }
	//! [UI Guides] enableIf: ?rgba_on=1
 	bool set_alpha_gain(float texturefloat) { return setValue("alpha_gain", texturefloat); }
	//! [UI Guides] enableIf: ?rgba_on=1
 	Value get_alpha_gain() const { return getValue("alpha_gain"); }

	//! [UI Guides] enableIf: ?rgba_on=1
 	//! [Default value] false
	bool set_premultiply_new_alpha(bool val) { return setValue("premultiply_new_alpha", val); }
	//! [UI Guides] enableIf: ?rgba_on=1
 	//! [Default value] false
	bool get_premultiply_new_alpha() const { return getBool("premultiply_new_alpha"); }

	//! [UI Guides] startRollout=RGB Post-process, displayName=Post-process On
 	//! [Default value] false
	bool set_postprocess(bool val) { return setValue("postprocess", val); }
	//! [UI Guides] startRollout=RGB Post-process, displayName=Post-process On
 	//! [Default value] false
	bool get_postprocess() const { return getBool("postprocess"); }

	//! [UI Guides] enableIf: ?postprocess=1
 	//! [Default value] false
	bool set_post_mono(bool val) { return setValue("post_mono", val); }
	//! [UI Guides] enableIf: ?postprocess=1
 	//! [Default value] false
	bool get_post_mono() const { return getBool("post_mono"); }

	//! [UI Guides] enableIf: ?postprocess=1
 	//! [Default value] false
	bool set_post_invert(bool val) { return setValue("post_invert", val); }
	//! [UI Guides] enableIf: ?postprocess=1
 	//! [Default value] false
	bool get_post_invert() const { return getBool("post_invert"); }

	//! [UI Guides] enableIf: ?postprocess=1
 	//! [Default value] false
	bool set_post_clamp(bool val) { return setValue("post_clamp", val); }
	//! [UI Guides] enableIf: ?postprocess=1
 	//! [Default value] false
	bool get_post_clamp() const { return getBool("post_clamp"); }

	//! [UI Guides] enableIf: ?postprocess=1, ?post_clamp=1
 	//! [Default value] 0
	bool set_post_clamp_min(float val) { return setValue("post_clamp_min", val); }
	//! [UI Guides] enableIf: ?postprocess=1, ?post_clamp=1
 	//! [Default value] 0
	float get_post_clamp_min() const { return getFloat("post_clamp_min"); }

	//! [UI Guides] enableIf: ?postprocess=1, ?post_clamp=1
 	//! [Default value] 1
	bool set_post_clamp_max(float val) { return setValue("post_clamp_max", val); }
	//! [UI Guides] enableIf: ?postprocess=1, ?post_clamp=1
 	//! [Default value] 1
	float get_post_clamp_max() const { return getFloat("post_clamp_max"); }

	//! [UI Guides] enableIf: ?postprocess=1, ?post_clamp=1
 	//! [Default value] false
	bool set_post_clamp_normalize(bool val) { return setValue("post_clamp_normalize", val); }
	//! [UI Guides] enableIf: ?postprocess=1, ?post_clamp=1
 	//! [Default value] false
	bool get_post_clamp_normalize() const { return getBool("post_clamp_normalize"); }
};

class ColorCorrection : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "ColorCorrection"; }

	//! Source color
 	//! [Default value] AColor(0, 0, 0, 0)
	bool set_source_color(const AColor& acolor) { return setValue("source_color", acolor); }
	//! Source color
 	//! [Default value] AColor(0, 0, 0, 0)
	AColor get_source_color() const { return getAColor("source_color"); }

	//! The texture being color corrected
 	bool set_texture_map(const Plugin& texture) { return setValue("texture_map", texture); }
	//! The texture being color corrected
 	bool set_texture_map(const AColor& texture) { return setValue("texture_map", texture); }
	//! The texture being color corrected
 	Value get_texture_map() const { return getValue("texture_map"); }

	//! 0-red, 1-green, 2-blue, 3-alpha, 4-redinv, 5-greeninv, 6-blueinv, 7-alphainv, 8-monochrome, 9-One, 10-Zero
 	//! [UI Guides] enum=0:Red;1:Green;2:Blue;3:Alpha;4:Redinv;5:Greeninv;6:Blueinv;7:Alphainv;8:Monochrome;9:One;10:Zero
 	//! [Default value] 0
	bool set_rewire_red(int val) { return setValue("rewire_red", val); }
	//! 0-red, 1-green, 2-blue, 3-alpha, 4-redinv, 5-greeninv, 6-blueinv, 7-alphainv, 8-monochrome, 9-One, 10-Zero
 	//! [UI Guides] enum=0:Red;1:Green;2:Blue;3:Alpha;4:Redinv;5:Greeninv;6:Blueinv;7:Alphainv;8:Monochrome;9:One;10:Zero
 	//! [Default value] 0
	int get_rewire_red() const { return getInt("rewire_red"); }

	//! 0-red, 1-green, 2-blue, 3-alpha, 4-redinv, 5-greeninv, 6-blueinv, 7-alphainv, 8-monochrome, 9-One, 10-Zero
 	//! [UI Guides] enum=0:Red;1:Green;2:Blue;3:Alpha;4:Redinv;5:Greeninv;6:Blueinv;7:Alphainv;8:Monochrome;9:One;10:Zero
 	//! [Default value] 1
	bool set_rewire_green(int val) { return setValue("rewire_green", val); }
	//! 0-red, 1-green, 2-blue, 3-alpha, 4-redinv, 5-greeninv, 6-blueinv, 7-alphainv, 8-monochrome, 9-One, 10-Zero
 	//! [UI Guides] enum=0:Red;1:Green;2:Blue;3:Alpha;4:Redinv;5:Greeninv;6:Blueinv;7:Alphainv;8:Monochrome;9:One;10:Zero
 	//! [Default value] 1
	int get_rewire_green() const { return getInt("rewire_green"); }

	//! 0-red, 1-green, 2-blue, 3-alpha, 4-redinv, 5-greeninv, 6-blueinv, 7-alphainv, 8-monochrome, 9-One, 10-Zero
 	//! [UI Guides] enum=0:Red;1:Green;2:Blue;3:Alpha;4:Redinv;5:Greeninv;6:Blueinv;7:Alphainv;8:Monochrome;9:One;10:Zero
 	//! [Default value] 2
	bool set_rewire_blue(int val) { return setValue("rewire_blue", val); }
	//! 0-red, 1-green, 2-blue, 3-alpha, 4-redinv, 5-greeninv, 6-blueinv, 7-alphainv, 8-monochrome, 9-One, 10-Zero
 	//! [UI Guides] enum=0:Red;1:Green;2:Blue;3:Alpha;4:Redinv;5:Greeninv;6:Blueinv;7:Alphainv;8:Monochrome;9:One;10:Zero
 	//! [Default value] 2
	int get_rewire_blue() const { return getInt("rewire_blue"); }

	//! 0-red, 1-green, 2-blue, 3-alpha, 4-redinv, 5-greeninv, 6-blueinv, 7-alphainv, 8-monochrome, 9-One, 10-Zero
 	//! [UI Guides] enum=0:Red;1:Green;2:Blue;3:Alpha;4:Redinv;5:Greeninv;6:Blueinv;7:Alphainv;8:Monochrome;9:One;10:Zero
 	//! [Default value] 3
	bool set_rewire_alpha(int val) { return setValue("rewire_alpha", val); }
	//! 0-red, 1-green, 2-blue, 3-alpha, 4-redinv, 5-greeninv, 6-blueinv, 7-alphainv, 8-monochrome, 9-One, 10-Zero
 	//! [UI Guides] enum=0:Red;1:Green;2:Blue;3:Alpha;4:Redinv;5:Greeninv;6:Blueinv;7:Alphainv;8:Monochrome;9:One;10:Zero
 	//! [Default value] 3
	int get_rewire_alpha() const { return getInt("rewire_alpha"); }

	//! added to the color hue
 	//! [Default value] 0
	bool set_hue_shift(float val) { return setValue("hue_shift", val); }
	//! added to the color hue
 	//! [Default value] 0
	float get_hue_shift() const { return getFloat("hue_shift"); }

	//! added to the color saturation
 	//! [Default value] 0
	bool set_saturation(float val) { return setValue("saturation", val); }
	//! added to the color saturation
 	//! [Default value] 0
	float get_saturation() const { return getFloat("saturation"); }

	//! Hue tint
 	//! [Default value] AColor(0, 0, 0, 0)
	bool set_hue_tint(const AColor& acolor) { return setValue("hue_tint", acolor); }
	//! Hue tint
 	//! [Default value] AColor(0, 0, 0, 0)
	AColor get_hue_tint() const { return getAColor("hue_tint"); }

	//! default = 0
 	//! [Default value] 0
	bool set_tint_strength(float val) { return setValue("tint_strength", val); }
	//! default = 0
 	//! [Default value] 0
	float get_tint_strength() const { return getFloat("tint_strength"); }

	//! default = 0.0 - value is added to the texture brightness
 	//! [Default value] 0
	bool set_brightness(float val) { return setValue("brightness", val); }
	//! default = 0.0 - value is added to the texture brightness
 	//! [Default value] 0
	float get_brightness() const { return getFloat("brightness"); }

	//! default = 1.0f
 	//! [Default value] 1
	bool set_contrast(float val) { return setValue("contrast", val); }
	//! default = 1.0f
 	//! [Default value] 1
	float get_contrast() const { return getFloat("contrast"); }

	//! Lightness mode (0 - standard, 1 - advanced)
 	//! [UI Guides] enum=0:Standard;1:Advanced
 	//! [Default value] 0
	bool set_lightness_mode(int val) { return setValue("lightness_mode", val); }
	//! Lightness mode (0 - standard, 1 - advanced)
 	//! [UI Guides] enum=0:Standard;1:Advanced
 	//! [Default value] 0
	int get_lightness_mode() const { return getInt("lightness_mode"); }

	//! Exposure mode (0 - Gain, 1 - F-Stops, 2 - Printer Lights)
 	//! [UI Guides] enum=0:Gain;1:F-Stops;2:Printer Lights
 	//! [Default value] 0
	bool set_adv_exposure_mode(int val) { return setValue("adv_exposure_mode", val); }
	//! Exposure mode (0 - Gain, 1 - F-Stops, 2 - Printer Lights)
 	//! [UI Guides] enum=0:Gain;1:F-Stops;2:Printer Lights
 	//! [Default value] 0
	int get_adv_exposure_mode() const { return getInt("adv_exposure_mode"); }

	//! Color multiplier
 	//! [Default value] 1
	bool set_adv_brightness(float val) { return setValue("adv_brightness", val); }
	//! Color multiplier
 	//! [Default value] 1
	float get_adv_brightness() const { return getFloat("adv_brightness"); }

	//! Color contrast
 	//! [Default value] 1
	bool set_adv_contrast(float val) { return setValue("adv_contrast", val); }
	//! Color contrast
 	//! [Default value] 1
	float get_adv_contrast() const { return getFloat("adv_contrast"); }

	//! Contrast base
 	//! [Default value] 1
	bool set_adv_base(float val) { return setValue("adv_base", val); }
	//! Contrast base
 	//! [Default value] 1
	float get_adv_base() const { return getFloat("adv_base"); }

	//! Color offset
 	//! [Default value] 0
	bool set_adv_offset(float val) { return setValue("adv_offset", val); }
	//! Color offset
 	//! [Default value] 0
	float get_adv_offset() const { return getFloat("adv_offset"); }

	//! true to use the red component ov the adv_rgb_* parameters
 	//! [Default value] false
	bool set_adv_use_red(bool val) { return setValue("adv_use_red", val); }
	//! true to use the red component ov the adv_rgb_* parameters
 	//! [Default value] false
	bool get_adv_use_red() const { return getBool("adv_use_red"); }

	//! true to use the green component ov the adv_rgb_* parameters
 	//! [Default value] false
	bool set_adv_use_green(bool val) { return setValue("adv_use_green", val); }
	//! true to use the green component ov the adv_rgb_* parameters
 	//! [Default value] false
	bool get_adv_use_green() const { return getBool("adv_use_green"); }

	//! true to use the blue component ov the adv_rgb_* parameters
 	//! [Default value] false
	bool set_adv_use_blue(bool val) { return setValue("adv_use_blue", val); }
	//! true to use the blue component ov the adv_rgb_* parameters
 	//! [Default value] false
	bool get_adv_use_blue() const { return getBool("adv_use_blue"); }

	//! Color multiplier rgb
 	//! [Default value] Color(1, 1, 1)
	bool set_adv_rgb_brightness(const Color& color) { return setValue("adv_rgb_brightness", color); }
	//! Color multiplier rgb
 	//! [Default value] Color(1, 1, 1)
	Color get_adv_rgb_brightness() const { return getColor("adv_rgb_brightness"); }

	//! Color contrast rgb
 	//! [Default value] Color(1, 1, 1)
	bool set_adv_rgb_contrast(const Color& color) { return setValue("adv_rgb_contrast", color); }
	//! Color contrast rgb
 	//! [Default value] Color(1, 1, 1)
	Color get_adv_rgb_contrast() const { return getColor("adv_rgb_contrast"); }

	//! Contrast base rgb
 	//! [Default value] Color(1, 1, 1)
	bool set_adv_rgb_base(const Color& color) { return setValue("adv_rgb_base", color); }
	//! Contrast base rgb
 	//! [Default value] Color(1, 1, 1)
	Color get_adv_rgb_base() const { return getColor("adv_rgb_base"); }

	//! Color offset rgb
 	//! [Default value] Color(0, 0, 0)
	bool set_adv_rgb_offset(const Color& color) { return setValue("adv_rgb_offset", color); }
	//! Color offset rgb
 	//! [Default value] Color(0, 0, 0)
	Color get_adv_rgb_offset() const { return getColor("adv_rgb_offset"); }

	//! Printer lights per
 	//! [Default value] 0
	bool set_adv_printer_lights_per(float val) { return setValue("adv_printer_lights_per", val); }
	//! Printer lights per
 	//! [Default value] 0
	float get_adv_printer_lights_per() const { return getFloat("adv_printer_lights_per"); }
};

class ColorMapperTest : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "ColorMapperTest"; }

	//! The type of color mapping: 0 - linear, 1 - sRGB, 2 - gamma
 	//! [Default value] 0
	bool set_type(int val) { return setValue("type", val); }
	//! The type of color mapping: 0 - linear, 1 - sRGB, 2 - gamma
 	//! [Default value] 0
	int get_type() const { return getInt("type"); }

	//! The gamma value if type is set to 2.
 	//! [Default value] 1
	bool set_gamma(float val) { return setValue("gamma", val); }
	//! The gamma value if type is set to 2.
 	//! [Default value] 1
	float get_gamma() const { return getFloat("gamma"); }

	//! The clamp level
 	//! [Default value] 20
	bool set_clamp_level(float val) { return setValue("clamp_level", val); }
	//! The clamp level
 	//! [Default value] 20
	float get_clamp_level() const { return getFloat("clamp_level"); }
};

class ColorTextureToMono : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "ColorTextureToMono"; }

	//! (description missing)
	//! [Default value] 0
	bool set_value(float val) { return setValue("value", val); }
	//! (description missing)
	//! [Default value] 0
	float get_value() const { return getFloat("value"); }

	//! (description missing)
	bool set_color_texture(const Plugin& texture) { return setValue("color_texture", texture); }
	//! (description missing)
	bool set_color_texture(const AColor& texture) { return setValue("color_texture", texture); }
	//! (description missing)
	Value get_color_texture() const { return getValue("color_texture"); }
};

class CustomGlsl : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "CustomGlsl"; }
};

class EnvFogMeshGizmo : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "EnvFogMeshGizmo"; }

	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	bool set_transform(const Transform& transform) { return setValue("transform", transform); }
	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	Transform get_transform() const { return getTransform("transform"); }

	//! (description missing)
	bool set_geometry(const Plugin& plugin) { return setValue("geometry", plugin); }
	//! (description missing)
	Plugin get_geometry() const { return getPlugin("geometry"); }

	//! (description missing)
	bool set_lights(const ValueList& pluginList) { return setValue("lights", pluginList); }
	//! (description missing)
	ValueList get_lights() const { return getValueList("lights"); }

	//! fade out effect for the edges
 	//! [Default value] 0
	bool set_fade_out_radius(float val) { return setValue("fade_out_radius", val); }
	//! fade out effect for the edges
 	//! [Default value] 0
	float get_fade_out_radius() const { return getFloat("fade_out_radius"); }
};

class EnvironmentFog : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "EnvironmentFog"; }

	//! If false, disable the rendering
 	//! [UI Guides] startTab=V-Ray Environment Fog, startRollout=Basic Parameters
 	//! [Default value] true
	bool set_enabled(bool val) { return setValue("enabled", val); }
	//! If false, disable the rendering
 	//! [UI Guides] startTab=V-Ray Environment Fog, startRollout=Basic Parameters
 	//! [Default value] true
	bool get_enabled() const { return getBool("enabled"); }

	//! List of gizmos
 	bool set_gizmos(const ValueList& pluginList) { return setValue("gizmos", pluginList); }
	//! List of gizmos
 	ValueList get_gizmos() const { return getValueList("gizmos"); }

	//! Defines the color of the fog, when it is illuminated by light sources.
 	//! [UI Guides] displayName=Fog Color, overridenBy=color_tex
 	//! [Default value] Color(0, 0, 0)
	bool set_color(const Color& color) { return setValue("color", color); }
	//! Defines the color of the fog, when it is illuminated by light sources.
 	//! [UI Guides] displayName=Fog Color, overridenBy=color_tex
 	//! [Default value] Color(0, 0, 0)
	Color get_color() const { return getColor("color"); }

	//! Defines the color of the fog, when it is illuminated by light sources. You can also use a texture map to drive the fog color.
 	//! [UI Guides] displayName=Fog Color map, overrides=color
 	bool set_color_tex(const Plugin& texture) { return setValue("color_tex", texture); }
	//! Defines the color of the fog, when it is illuminated by light sources. You can also use a texture map to drive the fog color.
 	//! [UI Guides] displayName=Fog Color map, overrides=color
 	bool set_color_tex(const AColor& texture) { return setValue("color_tex", texture); }
	//! Defines the color of the fog, when it is illuminated by light sources. You can also use a texture map to drive the fog color.
 	//! [UI Guides] displayName=Fog Color map, overrides=color
 	Value get_color_tex() const { return getValue("color_tex"); }

	//! Fog color multiplier
 	//! [UI Guides] displayName=Fog Color Multiplier, minValue=0, maxValue=1
 	//! [Default value] 1
	bool set_color_mult(float val) { return setValue("color_mult", val); }
	//! Fog color multiplier
 	//! [UI Guides] displayName=Fog Color Multiplier, minValue=0, maxValue=1
 	//! [Default value] 1
	float get_color_mult() const { return getFloat("color_mult"); }

	//! Fog emission color. Controls the fog emission (self-illumination). You can use this parameter to substitute the ambient illumination inside the fog, instead of using GI.
 	//! [UI Guides] displayName=Emission Color, overridenBy=emission_tex
 	//! [Default value] Color(0, 0, 0)
	bool set_emission(const Color& color) { return setValue("emission", color); }
	//! Fog emission color. Controls the fog emission (self-illumination). You can use this parameter to substitute the ambient illumination inside the fog, instead of using GI.
 	//! [UI Guides] displayName=Emission Color, overridenBy=emission_tex
 	//! [Default value] Color(0, 0, 0)
	Color get_emission() const { return getColor("emission"); }

	//! Fog emission texture. Controls the fog emission (self-illumination). You can use this parameter to substitute the ambient illumination inside the fog, instead of using GI.
 	//! [UI Guides] displayName=Emission Color map, overrides=emission
 	bool set_emission_tex(const Plugin& texture) { return setValue("emission_tex", texture); }
	//! Fog emission texture. Controls the fog emission (self-illumination). You can use this parameter to substitute the ambient illumination inside the fog, instead of using GI.
 	//! [UI Guides] displayName=Emission Color map, overrides=emission
 	bool set_emission_tex(const AColor& texture) { return setValue("emission_tex", texture); }
	//! Fog emission texture. Controls the fog emission (self-illumination). You can use this parameter to substitute the ambient illumination inside the fog, instead of using GI.
 	//! [UI Guides] displayName=Emission Color map, overrides=emission
 	Value get_emission_tex() const { return getValue("emission_tex"); }

	//! Fog emission multiplier.
 	//! [UI Guides] displayName=Emission Multiplier, minValue=0.0, overridenBy=emission_mult_tex
 	//! [Default value] 1
	bool set_emission_mult(float val) { return setValue("emission_mult", val); }
	//! Fog emission multiplier.
 	//! [UI Guides] displayName=Emission Multiplier, minValue=0.0, overridenBy=emission_mult_tex
 	//! [Default value] 1
	float get_emission_mult() const { return getFloat("emission_mult"); }

	//! Fog emission multiplier texture.
 	//! [UI Guides] displayName=Emission Multiplier map, minValue=0.0, overrides=emission_mult
 	bool set_emission_mult_tex(const Plugin& texturefloat) { return setValue("emission_mult_tex", texturefloat); }
	//! Fog emission multiplier texture.
 	//! [UI Guides] displayName=Emission Multiplier map, minValue=0.0, overrides=emission_mult
 	bool set_emission_mult_tex(float texturefloat) { return setValue("emission_mult_tex", texturefloat); }
	//! Fog emission multiplier texture.
 	//! [UI Guides] displayName=Emission Multiplier map, minValue=0.0, overrides=emission_mult
 	Value get_emission_mult_tex() const { return getValue("emission_mult_tex"); }

	//! Distance between fog particles. Controls the fog density. Larger values make the fog more transparent, while smaller values make it more dense.
 	//! [UI Guides] displayName=Fog Distance, quantityType=distance, minValue=0.0
 	//! [Default value] 10
	bool set_distance(float val) { return setValue("distance", val); }
	//! Distance between fog particles. Controls the fog density. Larger values make the fog more transparent, while smaller values make it more dense.
 	//! [UI Guides] displayName=Fog Distance, quantityType=distance, minValue=0.0
 	//! [Default value] 10
	float get_distance() const { return getFloat("distance"); }

	//! Fog density. A multiplier for the Fog distance parameter.
 	//! [UI Guides] displayName=Fog Density, minValue=0.0, overridenBy=density_tex
 	//! [Default value] 1
	bool set_density(float val) { return setValue("density", val); }
	//! Fog density. A multiplier for the Fog distance parameter.
 	//! [UI Guides] displayName=Fog Density, minValue=0.0, overridenBy=density_tex
 	//! [Default value] 1
	float get_density() const { return getFloat("density"); }

	//! Texture for fog density. A multiplier for the Fog distance parameter that allows a texture to be used for the density of the fog.
 	//! [UI Guides] displayName=Fog Density map, minValue=0.0, overrides=density
 	bool set_density_tex(const Plugin& texturefloat) { return setValue("density_tex", texturefloat); }
	//! Texture for fog density. A multiplier for the Fog distance parameter that allows a texture to be used for the density of the fog.
 	//! [UI Guides] displayName=Fog Density map, minValue=0.0, overrides=density
 	bool set_density_tex(float texturefloat) { return setValue("density_tex", texturefloat); }
	//! Texture for fog density. A multiplier for the Fog distance parameter that allows a texture to be used for the density of the fog.
 	//! [UI Guides] displayName=Fog Density map, minValue=0.0, overrides=density
 	Value get_density_tex() const { return getValue("density_tex"); }

	//! If true, density will be treated as opacity.
 	//! [Default value] false
	bool set_opacity_mode(bool val) { return setValue("opacity_mode", val); }
	//! If true, density will be treated as opacity.
 	//! [Default value] false
	bool get_opacity_mode() const { return getBool("opacity_mode"); }

	//! This parameter determines the number of points inside the fog at which volumetric lighting is evaluated. Smaller values for this parameter render faster, but may produce noise in the image. Higher values render longer, but with less noise. It is only used when there are no texture maps specified, in which case the volume properties are the same everywhere.
 	//! [UI Guides] minValue=1, maxValue=10000, quantityType=localSubdivs
 	//! [Default value] 8
	bool set_subdivs(int val) { return setValue("subdivs", val); }
	//! This parameter determines the number of points inside the fog at which volumetric lighting is evaluated. Smaller values for this parameter render faster, but may produce noise in the image. Higher values render longer, but with less noise. It is only used when there are no texture maps specified, in which case the volume properties are the same everywhere.
 	//! [UI Guides] minValue=1, maxValue=10000, quantityType=localSubdivs
 	//! [Default value] 8
	int get_subdivs() const { return getInt("subdivs"); }

	//! Whether or not the height should be taken into account.
 	//! [UI Guides] startRollout=
 	//! [Default value] true
	bool set_use_height(bool val) { return setValue("use_height", val); }
	//! Whether or not the height should be taken into account.
 	//! [UI Guides] startRollout=
 	//! [Default value] true
	bool get_use_height() const { return getBool("use_height"); }

	//! Fog starting point along the up-axis. By default the up axis is Z.
 	//! [UI Guides] enableIf: ?use_height=1, quantityType=distance
 	//! [Default value] 100
	bool set_height(float val) { return setValue("height", val); }
	//! Fog starting point along the up-axis. By default the up axis is Z.
 	//! [UI Guides] enableIf: ?use_height=1, quantityType=distance
 	//! [Default value] 100
	float get_height() const { return getFloat("height"); }

	//! If true, y is the up axis, not z.
 	//! [UI Guides] displayName=Y is up, enableIf: ?use_height=1
 	//! [Default value] false
	bool set_yup(bool val) { return setValue("yup", val); }
	//! If true, y is the up axis, not z.
 	//! [UI Guides] displayName=Y is up, enableIf: ?use_height=1
 	//! [Default value] false
	bool get_yup() const { return getBool("yup"); }

	//! If true, this will cause to disable randomization when sampling and take 1 sample at 0.5 density.
 	//! [UI Guides] startRollout=Advanced Parameters
 	//! [Default value] false
	bool set_solid_mode(bool val) { return setValue("solid_mode", val); }
	//! If true, this will cause to disable randomization when sampling and take 1 sample at 0.5 density.
 	//! [UI Guides] startRollout=Advanced Parameters
 	//! [Default value] false
	bool get_solid_mode() const { return getBool("solid_mode"); }

	//! Solid mode transparency threshold
 	//! [UI Guides] enableIf: ?solid_mode=1
 	//! [Default value] 0.5
	bool set_solid_threshold(float val) { return setValue("solid_threshold", val); }
	//! Solid mode transparency threshold
 	//! [UI Guides] enableIf: ?solid_mode=1
 	//! [Default value] 0.5
	float get_solid_threshold() const { return getFloat("solid_threshold"); }

	//! If true, add a random offset when starting sampling.
 	//! [Default value] false
	bool set_jitter(bool val) { return setValue("jitter", val); }
	//! If true, add a random offset when starting sampling.
 	//! [Default value] false
	bool get_jitter() const { return getBool("jitter"); }

	//! Volume opacity scale for shadow rays.
 	//! [UI Guides] minValue=0.0
 	//! [Default value] 1
	bool set_shadow_opacity(float val) { return setValue("shadow_opacity", val); }
	//! Volume opacity scale for shadow rays.
 	//! [UI Guides] minValue=0.0
 	//! [Default value] 1
	float get_shadow_opacity() const { return getFloat("shadow_opacity"); }

	//! stretch aspect for the 3 axis, when the fog container must grow/shrink preserving its original density
 	//! [Default value] 1
	bool set_scale(const FloatList& floatList) { return setValue("scale", floatList); }
	//! stretch aspect for the 3 axis, when the fog container must grow/shrink preserving its original density
 	//! [Default value] 1
	bool set_scale(const float* floats, size_t count) { return setArray("scale", floats, count); }
	//! stretch aspect for the 3 axis, when the fog container must grow/shrink preserving its original density
 	//! [Default value] 1
	template<size_t count> bool set_scale(const float (&floats)[count]) { return setArray("scale", floats, count); }
	//! stretch aspect for the 3 axis, when the fog container must grow/shrink preserving its original density
 	//! [Default value] 1
	FloatList get_scale() const { return getFloatList("scale"); }

	//! Toggle the deep image output. Note that enabling this option will force ray marching even for simple volumetrics, which can cause slower rendering.
 	//! [Default value] false
	bool set_deep_output(bool val) { return setValue("deep_output", val); }
	//! Toggle the deep image output. Note that enabling this option will force ray marching even for simple volumetrics, which can cause slower rendering.
 	//! [Default value] false
	bool get_deep_output() const { return getBool("deep_output"); }

	//! Index of refraction for the volume, which describes the way light bends when crossing the material surface. A value of 1.0 means the light will not change direction.
 	//! [UI Guides] displayName=IOR, minValue=0.0, maxValue=100.0
 	//! [Default value] 1
	bool set_ior(float val) { return setValue("ior", val); }
	//! Index of refraction for the volume, which describes the way light bends when crossing the material surface. A value of 1.0 means the light will not change direction.
 	//! [UI Guides] displayName=IOR, minValue=0.0, maxValue=100.0
 	//! [Default value] 1
	float get_ior() const { return getFloat("ior"); }

	//! fade out mode 0: Multiply by density, 1: Add density to falloff
 	//! [UI Guides] enum=0:Multiply by density; 1:Add density to falloff, startRollout=Fade Out
 	//! [Default value] 0
	bool set_fade_out_mode(int val) { return setValue("fade_out_mode", val); }
	//! fade out mode 0: Multiply by density, 1: Add density to falloff
 	//! [UI Guides] enum=0:Multiply by density; 1:Add density to falloff, startRollout=Fade Out
 	//! [Default value] 0
	int get_fade_out_mode() const { return getInt("fade_out_mode"); }

	//! fade out effect for the edges
 	//! [UI Guides] quantityType=distance, minValue=0
 	//! [Default value] 0
	bool set_fade_out_radius(float val) { return setValue("fade_out_radius", val); }
	//! fade out effect for the edges
 	//! [UI Guides] quantityType=distance, minValue=0
 	//! [Default value] 0
	float get_fade_out_radius() const { return getFloat("fade_out_radius"); }

	//! fade out effect for the edges per object
 	//! [Default value] false
	bool set_per_object_fade_out_radius(bool val) { return setValue("per_object_fade_out_radius", val); }
	//! fade out effect for the edges per object
 	//! [Default value] false
	bool get_per_object_fade_out_radius() const { return getBool("per_object_fade_out_radius"); }

	//! When on, the fog will also scatter global illumination. Note that this can be quite slow. In many cases, global illumination within the fog can be substituted with a simple emission term. When this option is on, the currently selected global illumination algorithm in the V-Ray settings will be used to accelerate GI inside the volume (e.g. the irradiance map, light cache, photon map or brute-force).
 	//! [UI Guides] startRollout=GI, displayName=Scatter GI
 	//! [Default value] false
	bool set_scatter_gi(bool val) { return setValue("scatter_gi", val); }
	//! When on, the fog will also scatter global illumination. Note that this can be quite slow. In many cases, global illumination within the fog can be substituted with a simple emission term. When this option is on, the currently selected global illumination algorithm in the V-Ray settings will be used to accelerate GI inside the volume (e.g. the irradiance map, light cache, photon map or brute-force).
 	//! [UI Guides] startRollout=GI, displayName=Scatter GI
 	//! [Default value] false
	bool get_scatter_gi() const { return getBool("scatter_gi"); }

	//! Number of GI bounces calculated inside the fog.
 	//! [UI Guides] enableIf: ?scatter_gi=1, minValue=1, maxValue=1000
 	//! [Default value] 8
	bool set_scatter_bounces(int val) { return setValue("scatter_bounces", val); }
	//! Number of GI bounces calculated inside the fog.
 	//! [UI Guides] enableIf: ?scatter_gi=1, minValue=1, maxValue=1000
 	//! [Default value] 8
	int get_scatter_bounces() const { return getInt("scatter_bounces"); }

	//! Simplify global illumination. When this option is checked V-Ray will use a simplified method for calculating the GI when rendering parts of the fog that are textured or are being faded out.
 	//! [UI Guides] startRollout=Raymarching, displayName=Simplify Textures for GI
 	//! [Default value] false
	bool set_simplify_gi(bool val) { return setValue("simplify_gi", val); }
	//! Simplify global illumination. When this option is checked V-Ray will use a simplified method for calculating the GI when rendering parts of the fog that are textured or are being faded out.
 	//! [UI Guides] startRollout=Raymarching, displayName=Simplify Textures for GI
 	//! [Default value] false
	bool get_simplify_gi() const { return getBool("simplify_gi"); }

	//! Determines the size of one step through the volume. Smaller steps produce more accurate results but are slower to render. In general, dense volumes require smaller step sizes than more transparent volumes. In practice, step sizes that are two to three times smaller than the Fog distance parameter work well.
 	//! [UI Guides] quantityType=distance, minValue=0.0
 	//! [Default value] 1
	bool set_step_size(float val) { return setValue("step_size", val); }
	//! Determines the size of one step through the volume. Smaller steps produce more accurate results but are slower to render. In general, dense volumes require smaller step sizes than more transparent volumes. In practice, step sizes that are two to three times smaller than the Fog distance parameter work well.
 	//! [UI Guides] quantityType=distance, minValue=0.0
 	//! [Default value] 1
	float get_step_size() const { return getFloat("step_size"); }

	//! Maximum number of steps through the volume.
 	//! [UI Guides] minValue=1
 	//! [Default value] 1000
	bool set_max_steps(int val) { return setValue("max_steps", val); }
	//! Maximum number of steps through the volume.
 	//! [UI Guides] minValue=1
 	//! [Default value] 1000
	int get_max_steps() const { return getInt("max_steps"); }

	//! Number of texture samples for each step through the volume. This allows to sample textures more accurately than the volumetric lighting. It is useful in cases where the textures vary much faster than the lighting itself (e.g. for detailed fractal textures).
 	//! [UI Guides] displayName=Texture Samples, minValue=1, maxValue=10000
 	//! [Default value] 4
	bool set_tex_samples(int val) { return setValue("tex_samples", val); }
	//! Number of texture samples for each step through the volume. This allows to sample textures more accurately than the volumetric lighting. It is useful in cases where the textures vary much faster than the lighting itself (e.g. for detailed fractal textures).
 	//! [UI Guides] displayName=Texture Samples, minValue=1, maxValue=10000
 	//! [Default value] 4
	int get_tex_samples() const { return getInt("tex_samples"); }

	//! Controls when the raymarcher will stop traversing the volume. If the accumulated volume transparency falls below this threshold, the volume will be considered opaque and tracing will be aborted. Higher values make the rendering faster but may introduce artifacts.
 	//! [UI Guides] minValue=0, maxValue=1
 	//! [Default value] 0.001
	bool set_cutoff_threshold(float val) { return setValue("cutoff_threshold", val); }
	//! Controls when the raymarcher will stop traversing the volume. If the accumulated volume transparency falls below this threshold, the volume will be considered opaque and tracing will be aborted. Higher values make the rendering faster but may introduce artifacts.
 	//! [UI Guides] minValue=0, maxValue=1
 	//! [Default value] 0.001
	float get_cutoff_threshold() const { return getFloat("cutoff_threshold"); }

	//! light mode 0: no lights, 1: Use per-gizmo lights, 2: Override per-gizmo lights, 3: Intersect with per-gizmo lights, 4: Add to per-gizmo lights
 	//! [UI Guides] enum=0:No lights; 1:Use per-gizmo lights; 2:Override per-gizmo lights; 3:Intersect with per-gizmo lights; 4:Add to per-gizmo lights, startRollout=Lights
 	//! [Default value] 1
	bool set_light_mode(int val) { return setValue("light_mode", val); }
	//! light mode 0: no lights, 1: Use per-gizmo lights, 2: Override per-gizmo lights, 3: Intersect with per-gizmo lights, 4: Add to per-gizmo lights
 	//! [UI Guides] enum=0:No lights; 1:Use per-gizmo lights; 2:Override per-gizmo lights; 3:Intersect with per-gizmo lights; 4:Add to per-gizmo lights, startRollout=Lights
 	//! [Default value] 1
	int get_light_mode() const { return getInt("light_mode"); }

	//! A list with lights. How they affect the fog depends on the 'Light mode' paramter as well.
 	//! [UI Guides] attributes=lightSet
 	bool set_lights(const ValueList& pluginList) { return setValue("lights", pluginList); }
	//! A list with lights. How they affect the fog depends on the 'Light mode' paramter as well.
 	//! [UI Guides] attributes=lightSet
 	ValueList get_lights() const { return getValueList("lights"); }

	//! True if the shade instance should be used when sampling textures.
 	//! [Default value] false
	bool set_use_shade_instance(bool val) { return setValue("use_shade_instance", val); }
	//! True if the shade instance should be used when sampling textures.
 	//! [Default value] false
	bool get_use_shade_instance() const { return getBool("use_shade_instance"); }

	//! True if the shade data should be used when sampling textures. The light mode will be ignored if this is true and the shader is not global!
 	//! [Default value] true
	bool set_use_shade_data(bool val) { return setValue("use_shade_data", val); }
	//! True if the shade data should be used when sampling textures. The light mode will be ignored if this is true and the shader is not global!
 	//! [Default value] true
	bool get_use_shade_data() const { return getBool("use_shade_data"); }

	//! When this option is off, the background will not be obscured by the fog.
 	//! [UI Guides] startRollout=Ray Filter
 	//! [Default value] false
	bool set_affect_background(bool val) { return setValue("affect_background", val); }
	//! When this option is off, the background will not be obscured by the fog.
 	//! [UI Guides] startRollout=Ray Filter
 	//! [Default value] false
	bool get_affect_background() const { return getBool("affect_background"); }

	//! Specifies whether the fog will be rendered in reflections.
 	//! [Default value] true
	bool set_affect_reflections(bool val) { return setValue("affect_reflections", val); }
	//! Specifies whether the fog will be rendered in reflections.
 	//! [Default value] true
	bool get_affect_reflections() const { return getBool("affect_reflections"); }

	//! Specifies whether the fog will be rendered in refractions.
 	//! [Default value] true
	bool set_affect_refractions(bool val) { return setValue("affect_refractions", val); }
	//! Specifies whether the fog will be rendered in refractions.
 	//! [Default value] true
	bool get_affect_refractions() const { return getBool("affect_refractions"); }

	//! Specifies if the fog should affect shadow rays.
 	//! [Default value] true
	bool set_affect_shadows(bool val) { return setValue("affect_shadows", val); }
	//! Specifies if the fog should affect shadow rays.
 	//! [Default value] true
	bool get_affect_shadows() const { return getBool("affect_shadows"); }

	//! Specifies if the fog should affect GI rays.
 	//! [UI Guides] displayName=Affect GI
 	//! [Default value] true
	bool set_affect_gi(bool val) { return setValue("affect_gi", val); }
	//! Specifies if the fog should affect GI rays.
 	//! [UI Guides] displayName=Affect GI
 	//! [Default value] true
	bool get_affect_gi() const { return getBool("affect_gi"); }

	//! Specifies if the fog will be visible to camera rays.
 	//! [Default value] true
	bool set_affect_camera(bool val) { return setValue("affect_camera", val); }
	//! Specifies if the fog will be visible to camera rays.
 	//! [Default value] true
	bool get_affect_camera() const { return getBool("affect_camera"); }
};

class FilterArea : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "FilterArea"; }

	//! Filter width
 	//! [Default value] 1.5
	bool set_size(float val) { return setValue("size", val); }
	//! Filter width
 	//! [Default value] 1.5
	float get_size() const { return getFloat("size"); }
};

class FilterBox : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "FilterBox"; }

	//! Filter width
 	//! [Default value] 1.5
	bool set_size(float val) { return setValue("size", val); }
	//! Filter width
 	//! [Default value] 1.5
	float get_size() const { return getFloat("size"); }
};

class FilterCatmullRom : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "FilterCatmullRom"; }
};

class FilterCookVariable : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "FilterCookVariable"; }

	//! Filter width
 	//! [Default value] 3
	bool set_size(float val) { return setValue("size", val); }
	//! Filter width
 	//! [Default value] 3
	float get_size() const { return getFloat("size"); }
};

class FilterGaussian : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "FilterGaussian"; }

	//! Filter width
 	//! [Default value] 3
	bool set_size(float val) { return setValue("size", val); }
	//! Filter width
 	//! [Default value] 3
	float get_size() const { return getFloat("size"); }
};

class FilterLanczos : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "FilterLanczos"; }

	//! Filter width
 	//! [Default value] 1.5
	bool set_size(float val) { return setValue("size", val); }
	//! Filter width
 	//! [Default value] 1.5
	float get_size() const { return getFloat("size"); }
};

class FilterMitNet : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "FilterMitNet"; }

	//! Filter width
 	//! [Default value] 4
	bool set_size(float val) { return setValue("size", val); }
	//! Filter width
 	//! [Default value] 4
	float get_size() const { return getFloat("size"); }

	//! (description missing)
	//! [Default value] 0.333333
	bool set_blur(float val) { return setValue("blur", val); }
	//! (description missing)
	//! [Default value] 0.333333
	float get_blur() const { return getFloat("blur"); }

	//! (description missing)
	//! [Default value] 0.333333
	bool set_ringing(float val) { return setValue("ringing", val); }
	//! (description missing)
	//! [Default value] 0.333333
	float get_ringing() const { return getFloat("ringing"); }
};

class FilterPoint : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "FilterPoint"; }
};

class FilterSinc : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "FilterSinc"; }

	//! Filter width
 	//! [Default value] 4
	bool set_size(float val) { return setValue("size", val); }
	//! Filter width
 	//! [Default value] 4
	float get_size() const { return getFloat("size"); }
};

class FilterTriangle : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "FilterTriangle"; }

	//! Filter width
 	//! [Default value] 1.5
	bool set_size(float val) { return setValue("size", val); }
	//! Filter width
 	//! [Default value] 1.5
	float get_size() const { return getFloat("size"); }
};

class Float3ToAColor : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "Float3ToAColor"; }

	//! First color
 	bool set_float1(const Plugin& texturefloat) { return setValue("float1", texturefloat); }
	//! First color
 	bool set_float1(float texturefloat) { return setValue("float1", texturefloat); }
	//! First color
 	Value get_float1() const { return getValue("float1"); }

	//! Second color
 	bool set_float2(const Plugin& texturefloat) { return setValue("float2", texturefloat); }
	//! Second color
 	bool set_float2(float texturefloat) { return setValue("float2", texturefloat); }
	//! Second color
 	Value get_float2() const { return getValue("float2"); }

	//! Third color
 	bool set_float3(const Plugin& texturefloat) { return setValue("float3", texturefloat); }
	//! Third color
 	bool set_float3(float texturefloat) { return setValue("float3", texturefloat); }
	//! Third color
 	Value get_float3() const { return getValue("float3"); }

	//! Alpha
 	bool set_alpha(const Plugin& texturefloat) { return setValue("alpha", texturefloat); }
	//! Alpha
 	bool set_alpha(float texturefloat) { return setValue("alpha", texturefloat); }
	//! Alpha
 	Value get_alpha() const { return getValue("alpha"); }

	//! (description missing)
	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! (description missing)
	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }
};

class FloatToTex : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "FloatToTex"; }

	//! (description missing)
	bool set_input(const Plugin& texturefloat) { return setValue("input", texturefloat); }
	//! (description missing)
	bool set_input(float texturefloat) { return setValue("input", texturefloat); }
	//! (description missing)
	Value get_input() const { return getValue("input"); }
};

class GeomBifrost : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "GeomBifrost"; }

	//! The path to the OpenVDB file
 	//! [UI Guides] fileAsset=vdb.
 	bool set_file(const char* str) { return setValue("file", str); }
	//! The path to the OpenVDB file
 	//! [UI Guides] fileAsset=vdb.
 	bool set_file(const std::string& str) { return setValue("file", str); }
	//! The path to the OpenVDB file
 	//! [UI Guides] fileAsset=vdb.
 	std::string get_file() const { return getString("file"); }

	//! If "file" is missing, read the vdb data from a memory stream.
 	//! [Default value] 0
	bool set_stream(const IntList& intList) { return setValue("stream", intList); }
	//! If "file" is missing, read the vdb data from a memory stream.
 	//! [Default value] 0
	bool set_stream(const int* ints, size_t count) { return setArray("stream", ints, count); }
	//! If "file" is missing, read the vdb data from a memory stream.
 	//! [Default value] 0
	template<size_t count> bool set_stream(const int (&ints)[count]) { return setArray("stream", ints, count); }
	//! If "file" is missing, read the vdb data from a memory stream.
 	//! [Default value] 0
	IntList get_stream() const { return getIntList("stream"); }

	//! The name of the OpenVDB grid to render.
 	bool set_render_grid(const char* str) { return setValue("render_grid", str); }
	//! The name of the OpenVDB grid to render.
 	bool set_render_grid(const std::string& str) { return setValue("render_grid", str); }
	//! The name of the OpenVDB grid to render.
 	std::string get_render_grid() const { return getString("render_grid"); }

	//! The name of the OpenVDB velocity grid to use for motion blur.
 	bool set_velocity_grid(const char* str) { return setValue("velocity_grid", str); }
	//! The name of the OpenVDB velocity grid to use for motion blur.
 	bool set_velocity_grid(const std::string& str) { return setValue("velocity_grid", str); }
	//! The name of the OpenVDB velocity grid to use for motion blur.
 	std::string get_velocity_grid() const { return getString("velocity_grid"); }

	//! If true, delay load the OpenVDB voxels until requested.
 	//! [Default value] true
	bool set_delay_load(bool val) { return setValue("delay_load", val); }
	//! If true, delay load the OpenVDB voxels until requested.
 	//! [Default value] true
	bool get_delay_load() const { return getBool("delay_load"); }

	//! The grid interpolation sampler (0:linear, 1:quadratic: 2:none).
 	//! [UI Guides] enum=0:Linear;1:Quadratic;2:None
 	//! [Default value] 1
	bool set_interpolation(int val) { return setValue("interpolation", val); }
	//! The grid interpolation sampler (0:linear, 1:quadratic: 2:none).
 	//! [UI Guides] enum=0:Linear;1:Quadratic;2:None
 	//! [Default value] 1
	int get_interpolation() const { return getInt("interpolation"); }

	//! If off, shading an intersection with this mesh will not generate a gbuffer.
 	//! [Default value] true
	bool set_primary_visibility(bool val) { return setValue("primary_visibility", val); }
	//! If off, shading an intersection with this mesh will not generate a gbuffer.
 	//! [Default value] true
	bool get_primary_visibility() const { return getBool("primary_visibility"); }

	//! The positions of the particles.
 	//! [Default value] Vector(0, 0, 0)
	bool set_positions(const VectorList& vectorList) { return setValue("positions", vectorList); }
	//! The positions of the particles.
 	//! [Default value] Vector(0, 0, 0)
	bool set_positions(const Vector* vectors, size_t count) { return setArray("positions", vectors, count); }
	//! The positions of the particles.
 	//! [Default value] Vector(0, 0, 0)
	template<size_t count> bool set_positions(const Vector (&vectors)[count]) { return setArray("positions", vectors, count); }
	//! The positions of the particles.
 	//! [Default value] Vector(0, 0, 0)
	VectorList get_positions() const { return getVectorList("positions"); }

	//! The velocities of the particles.
 	//! [Default value] Vector(0, 0, 0)
	bool set_velocities(const VectorList& vectorList) { return setValue("velocities", vectorList); }
	//! The velocities of the particles.
 	//! [Default value] Vector(0, 0, 0)
	bool set_velocities(const Vector* vectors, size_t count) { return setArray("velocities", vectors, count); }
	//! The velocities of the particles.
 	//! [Default value] Vector(0, 0, 0)
	template<size_t count> bool set_velocities(const Vector (&vectors)[count]) { return setArray("velocities", vectors, count); }
	//! The velocities of the particles.
 	//! [Default value] Vector(0, 0, 0)
	VectorList get_velocities() const { return getVectorList("velocities"); }

	//! Custom per particle user scalar.
 	//! [Default value] 0
	bool set_userScalar1PP(const FloatList& floatList) { return setValue("userScalar1PP", floatList); }
	//! Custom per particle user scalar.
 	//! [Default value] 0
	bool set_userScalar1PP(const float* floats, size_t count) { return setArray("userScalar1PP", floats, count); }
	//! Custom per particle user scalar.
 	//! [Default value] 0
	template<size_t count> bool set_userScalar1PP(const float (&floats)[count]) { return setArray("userScalar1PP", floats, count); }
	//! Custom per particle user scalar.
 	//! [Default value] 0
	FloatList get_userScalar1PP() const { return getFloatList("userScalar1PP"); }

	//! The particle ids.
 	//! [Default value] 0
	bool set_ids(const IntList& intList) { return setValue("ids", intList); }
	//! The particle ids.
 	//! [Default value] 0
	bool set_ids(const int* ints, size_t count) { return setArray("ids", ints, count); }
	//! The particle ids.
 	//! [Default value] 0
	template<size_t count> bool set_ids(const int (&ints)[count]) { return setArray("ids", ints, count); }
	//! The particle ids.
 	//! [Default value] 0
	IntList get_ids() const { return getIntList("ids"); }

	//! Per-particle age.
 	//! [Default value] 0
	bool set_age_pp(const FloatList& floatList) { return setValue("age_pp", floatList); }
	//! Per-particle age.
 	//! [Default value] 0
	bool set_age_pp(const float* floats, size_t count) { return setArray("age_pp", floats, count); }
	//! Per-particle age.
 	//! [Default value] 0
	template<size_t count> bool set_age_pp(const float (&floats)[count]) { return setArray("age_pp", floats, count); }
	//! Per-particle age.
 	//! [Default value] 0
	FloatList get_age_pp() const { return getFloatList("age_pp"); }

	//! Per-particle acceleration.
 	//! [Default value] Color(0, 0, 0)
	bool set_acceleration_pp(const ColorList& colorList) { return setValue("acceleration_pp", colorList); }
	//! Per-particle acceleration.
 	//! [Default value] Color(0, 0, 0)
	bool set_acceleration_pp(const Color* colors, size_t count) { return setArray("acceleration_pp", colors, count); }
	//! Per-particle acceleration.
 	//! [Default value] Color(0, 0, 0)
	template<size_t count> bool set_acceleration_pp(const Color (&colors)[count]) { return setArray("acceleration_pp", colors, count); }
	//! Per-particle acceleration.
 	//! [Default value] Color(0, 0, 0)
	ColorList get_acceleration_pp() const { return getColorList("acceleration_pp"); }

	//! The u texture coordinate of the particles.
 	//! [Default value] 0
	bool set_texture_coord_u(const FloatList& floatList) { return setValue("texture_coord_u", floatList); }
	//! The u texture coordinate of the particles.
 	//! [Default value] 0
	bool set_texture_coord_u(const float* floats, size_t count) { return setArray("texture_coord_u", floats, count); }
	//! The u texture coordinate of the particles.
 	//! [Default value] 0
	template<size_t count> bool set_texture_coord_u(const float (&floats)[count]) { return setArray("texture_coord_u", floats, count); }
	//! The u texture coordinate of the particles.
 	//! [Default value] 0
	FloatList get_texture_coord_u() const { return getFloatList("texture_coord_u"); }

	//! The v texture coordinate of the particles.
 	//! [Default value] 0
	bool set_texture_coord_v(const FloatList& floatList) { return setValue("texture_coord_v", floatList); }
	//! The v texture coordinate of the particles.
 	//! [Default value] 0
	bool set_texture_coord_v(const float* floats, size_t count) { return setArray("texture_coord_v", floats, count); }
	//! The v texture coordinate of the particles.
 	//! [Default value] 0
	template<size_t count> bool set_texture_coord_v(const float (&floats)[count]) { return setArray("texture_coord_v", floats, count); }
	//! The v texture coordinate of the particles.
 	//! [Default value] 0
	FloatList get_texture_coord_v() const { return getFloatList("texture_coord_v"); }
};

class GeomBox : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "GeomBox"; }

	//! The size in the X direction
 	//! [Default value] 1
	bool set_size_x(float val) { return setValue("size_x", val); }
	//! The size in the X direction
 	//! [Default value] 1
	float get_size_x() const { return getFloat("size_x"); }

	//! The size in the X direction
 	//! [Default value] 1
	bool set_size_y(float val) { return setValue("size_y", val); }
	//! The size in the X direction
 	//! [Default value] 1
	float get_size_y() const { return getFloat("size_y"); }

	//! The size in the X direction
 	//! [Default value] 1
	bool set_size_z(float val) { return setValue("size_z", val); }
	//! The size in the X direction
 	//! [Default value] 1
	float get_size_z() const { return getFloat("size_z"); }

	//! true to handle the case when the camera is inside the box
 	//! [Default value] false
	bool set_is_volumetric(bool val) { return setValue("is_volumetric", val); }
	//! true to handle the case when the camera is inside the box
 	//! [Default value] false
	bool get_is_volumetric() const { return getBool("is_volumetric"); }
};

class GeomDisplacedMesh : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "GeomDisplacedMesh"; }

	//! The triangle mesh that will be displaced
 	bool set_mesh(const Plugin& plugin) { return setValue("mesh", plugin); }
	//! The triangle mesh that will be displaced
 	Plugin get_mesh() const { return getPlugin("mesh"); }

	//! The displacement texture
 	bool set_displacement_tex_color(const Plugin& texture) { return setValue("displacement_tex_color", texture); }
	//! The displacement texture
 	bool set_displacement_tex_color(const AColor& texture) { return setValue("displacement_tex_color", texture); }
	//! The displacement texture
 	Value get_displacement_tex_color() const { return getValue("displacement_tex_color"); }

	//! The displacement texture
 	bool set_displacement_tex_float(const Plugin& texturefloat) { return setValue("displacement_tex_float", texturefloat); }
	//! The displacement texture
 	bool set_displacement_tex_float(float texturefloat) { return setValue("displacement_tex_float", texturefloat); }
	//! The displacement texture
 	Value get_displacement_tex_float() const { return getValue("displacement_tex_float"); }

	//! Determines the displacement amount for white areas in the displacement map; if use_globals is true this is multiplied by the global displacement amount option.
 	//! [UI Guides] quantityType=distance
 	//! [Default value] 1
	bool set_displacement_amount(float val) { return setValue("displacement_amount", val); }
	//! Determines the displacement amount for white areas in the displacement map; if use_globals is true this is multiplied by the global displacement amount option.
 	//! [UI Guides] quantityType=distance
 	//! [Default value] 1
	float get_displacement_amount() const { return getFloat("displacement_amount"); }

	//! This constant value is added to the displacement map
 	//! [UI Guides] quantityType=distance
 	//! [Default value] 0
	bool set_displacement_shift(float val) { return setValue("displacement_shift", val); }
	//! This constant value is added to the displacement map
 	//! [UI Guides] quantityType=distance
 	//! [Default value] 0
	float get_displacement_shift() const { return getFloat("displacement_shift"); }

	//! If true, the global displacement quality settings will be used.
 	//! [UI Guides] displayName=Use global settings
 	//! [Default value] true
	bool set_use_globals(bool val) { return setValue("use_globals", val); }
	//! If true, the global displacement quality settings will be used.
 	//! [UI Guides] displayName=Use global settings
 	//! [Default value] true
	bool get_use_globals() const { return getBool("use_globals"); }

	//! If use_globals is false, this determines if view-dependent tesselation is used.
 	//! [UI Guides] displayName=View dependent, enableIf: ?use_globals=0
 	//! [Default value] true
	bool set_view_dep(bool val) { return setValue("view_dep", val); }
	//! If use_globals is false, this determines if view-dependent tesselation is used.
 	//! [UI Guides] displayName=View dependent, enableIf: ?use_globals=0
 	//! [Default value] true
	bool get_view_dep() const { return getBool("view_dep"); }

	//! If use_globals is false, this determines the approximate edge length for the sub-triangles.
 	//! [UI Guides] displayName=Edge length, enableIf: ?use_globals=0, minValue=0
 	//! [Default value] 4
	bool set_edge_length(float val) { return setValue("edge_length", val); }
	//! If use_globals is false, this determines the approximate edge length for the sub-triangles.
 	//! [UI Guides] displayName=Edge length, enableIf: ?use_globals=0, minValue=0
 	//! [Default value] 4
	float get_edge_length() const { return getFloat("edge_length"); }

	//! If use_globals is false, this determines the maximum subdivisions for a triangle of the original mesh.
 	//! [UI Guides] displayName=Max subdivisions, enableIf: ?use_globals=0, minValue=0
 	//! [Default value] 256
	bool set_max_subdivs(int val) { return setValue("max_subdivs", val); }
	//! If use_globals is false, this determines the maximum subdivisions for a triangle of the original mesh.
 	//! [UI Guides] displayName=Max subdivisions, enableIf: ?use_globals=0, minValue=0
 	//! [Default value] 256
	int get_max_subdivs() const { return getInt("max_subdivs"); }

	//! If true, the plugin will attempt to keep the continuity of the displaced surface.
 	//! [Default value] false
	bool set_keep_continuity(bool val) { return setValue("keep_continuity", val); }
	//! If true, the plugin will attempt to keep the continuity of the displaced surface.
 	//! [Default value] false
	bool get_keep_continuity() const { return getBool("keep_continuity"); }

	//! Geometry below this displacement level will be clipped away.
 	//! [UI Guides] quantityType=distance
 	//! [Default value] -1e+030
	bool set_water_level(float val) { return setValue("water_level", val); }
	//! Geometry below this displacement level will be clipped away.
 	//! [UI Guides] quantityType=distance
 	//! [Default value] -1e+030
	float get_water_level() const { return getFloat("water_level"); }

	//! When this is 1, the red, green and blue channels of displacement_tex_color will be used to perform vector displacement with base 0.5; if this is 2, then the map matches the Mudbox displacement maps.
 	//! [Default value] 0
	bool set_vector_displacement(int val) { return setValue("vector_displacement", val); }
	//! When this is 1, the red, green and blue channels of displacement_tex_color will be used to perform vector displacement with base 0.5; if this is 2, then the map matches the Mudbox displacement maps.
 	//! [Default value] 0
	int get_vector_displacement() const { return getInt("vector_displacement"); }

	//! The mapping channel to use for vector and 2d displacement.
 	//! [Default value] 0
	bool set_map_channel(int val) { return setValue("map_channel", val); }
	//! The mapping channel to use for vector and 2d displacement.
 	//! [Default value] 0
	int get_map_channel() const { return getInt("map_channel"); }

	//! If true, the resulting triangles of the displacement algorithm will be inserted into the rayserver as static geometry.
 	//! [Default value] false
	bool set_static_displacement(bool val) { return setValue("static_displacement", val); }
	//! If true, the resulting triangles of the displacement algorithm will be inserted into the rayserver as static geometry.
 	//! [Default value] false
	bool get_static_displacement() const { return getBool("static_displacement"); }

	//! This parameter overrides the imgWidth parameter from VRayFrameData during the calculation of the subdivision depth.
 	//! [Default value] 0
	bool set_image_width(int val) { return setValue("image_width", val); }
	//! This parameter overrides the imgWidth parameter from VRayFrameData during the calculation of the subdivision depth.
 	//! [Default value] 0
	int get_image_width() const { return getInt("image_width"); }

	//! If this option is equal to 1 then the normals of the generated triangles are cached.
 	//! [Default value] false
	bool set_cache_normals(bool val) { return setValue("cache_normals", val); }
	//! If this option is equal to 1 then the normals of the generated triangles are cached.
 	//! [Default value] false
	bool get_cache_normals() const { return getBool("cache_normals"); }

	//! If true, the parent transformation will affect the amount of displacement. Used only when doing 3D displacement.
 	//! [Default value] false
	bool set_object_space_displacement(bool val) { return setValue("object_space_displacement", val); }
	//! If true, the parent transformation will affect the amount of displacement. Used only when doing 3D displacement.
 	//! [Default value] false
	bool get_object_space_displacement() const { return getBool("object_space_displacement"); }

	//! If true, the min/max values for the displacement texture are specified by the min_bound and max_bound parameters; if false, these are calculated automatically.
 	//! [Default value] false
	bool set_use_bounds(bool val) { return setValue("use_bounds", val); }
	//! If true, the min/max values for the displacement texture are specified by the min_bound and max_bound parameters; if false, these are calculated automatically.
 	//! [Default value] false
	bool get_use_bounds() const { return getBool("use_bounds"); }

	//! The lowest value for the displacement texture.
 	//! [UI Guides] enableIf: ?use_bounds=1
 	//! [Default value] Color(0, 0, 0)
	bool set_min_bound(const Color& color) { return setValue("min_bound", color); }
	//! The lowest value for the displacement texture.
 	//! [UI Guides] enableIf: ?use_bounds=1
 	//! [Default value] Color(0, 0, 0)
	Color get_min_bound() const { return getColor("min_bound"); }

	//! The biggest value for the displacement texture.
 	//! [UI Guides] enableIf: ?use_bounds=1
 	//! [Default value] Color(1, 1, 1)
	bool set_max_bound(const Color& color) { return setValue("max_bound", color); }
	//! The biggest value for the displacement texture.
 	//! [UI Guides] enableIf: ?use_bounds=1
 	//! [Default value] Color(1, 1, 1)
	Color get_max_bound() const { return getColor("max_bound"); }

	//! Use to enable 2d displacement. Overrides the vector_displacement flag.
 	//! [UI Guides] displayName=2D Displacement
 	//! [Default value] false
	bool set_displace_2d(bool val) { return setValue("displace_2d", val); }
	//! Use to enable 2d displacement. Overrides the vector_displacement flag.
 	//! [UI Guides] displayName=2D Displacement
 	//! [Default value] false
	bool get_displace_2d() const { return getBool("displace_2d"); }

	//! Enable or disable support for tiled textures (UDIM/UVTILE) when generating 2d displacement.
 	//! [UI Guides] enableIf: ?displace_2d=1
 	//! [Default value] false
	bool set_displace_2d_multi_tile(bool val) { return setValue("displace_2d_multi_tile", val); }
	//! Enable or disable support for tiled textures (UDIM/UVTILE) when generating 2d displacement.
 	//! [UI Guides] enableIf: ?displace_2d=1
 	//! [Default value] false
	bool get_displace_2d_multi_tile() const { return getBool("displace_2d_multi_tile"); }

	//! Resolution at which to sample the displacement map for 2d displacement.
 	//! [UI Guides] enableIf: ?displace_2d=1, minValue=8
 	//! [Default value] 256
	bool set_resolution(int val) { return setValue("resolution", val); }
	//! Resolution at which to sample the displacement map for 2d displacement.
 	//! [UI Guides] enableIf: ?displace_2d=1, minValue=8
 	//! [Default value] 256
	int get_resolution() const { return getInt("resolution"); }

	//! Increase for curved surfaces to avoid artifacts.
 	//! [UI Guides] enableIf: ?displace_2d=1, minValue=1
 	//! [Default value] 8
	bool set_precision(int val) { return setValue("precision", val); }
	//! Increase for curved surfaces to avoid artifacts.
 	//! [UI Guides] enableIf: ?displace_2d=1, minValue=1
 	//! [Default value] 8
	int get_precision() const { return getInt("precision"); }

	//! When this is on, initialization will be slower, but tighter bounds will be computed for the displaced triangles making rendering faster.
 	//! [UI Guides] enableIf: ?displace_2d=1
 	//! [Default value] false
	bool set_tight_bounds(bool val) { return setValue("tight_bounds", val); }
	//! When this is on, initialization will be slower, but tighter bounds will be computed for the displaced triangles making rendering faster.
 	//! [UI Guides] enableIf: ?displace_2d=1
 	//! [Default value] false
	bool get_tight_bounds() const { return getBool("tight_bounds"); }

	//! Filter the texture for 2d displacement.
 	//! [UI Guides] enableIf: ?displace_2d=1
 	//! [Default value] false
	bool set_filter_texture(bool val) { return setValue("filter_texture", val); }
	//! Filter the texture for 2d displacement.
 	//! [UI Guides] enableIf: ?displace_2d=1
 	//! [Default value] false
	bool get_filter_texture() const { return getBool("filter_texture"); }

	//! The amount of UV space to average for filtering purposes. A value of 1.0 will average thw whole texture.
 	//! [UI Guides] enableIf: ?displace_2d=1, ?filter_texture=1, minValue=0
 	//! [Default value] 0.001
	bool set_filter_blur(float val) { return setValue("filter_blur", val); }
	//! The amount of UV space to average for filtering purposes. A value of 1.0 will average thw whole texture.
 	//! [UI Guides] enableIf: ?displace_2d=1, ?filter_texture=1, minValue=0
 	//! [Default value] 0.001
	float get_filter_blur() const { return getFloat("filter_blur"); }
};

class GeomHair : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "GeomHair"; }

	//! The triangle mesh that will have hairs generated on it.
 	bool set_mesh(const Plugin& plugin) { return setValue("mesh", plugin); }
	//! The triangle mesh that will have hairs generated on it.
 	Plugin get_mesh() const { return getPlugin("mesh"); }

	//! The base hair length.
 	//! [Default value] 100
	bool set_length_base(float val) { return setValue("length_base", val); }
	//! The base hair length.
 	//! [Default value] 100
	float get_length_base() const { return getFloat("length_base"); }

	//! The base hair thickness.
 	//! [Default value] 0.01
	bool set_thickness_base(float val) { return setValue("thickness_base", val); }
	//! The base hair thickness.
 	//! [Default value] 0.01
	float get_thickness_base() const { return getFloat("thickness_base"); }

	//! The base gravity.
 	//! [Default value] 10
	bool set_gravity_base(float val) { return setValue("gravity_base", val); }
	//! The base gravity.
 	//! [Default value] 10
	float get_gravity_base() const { return getFloat("gravity_base"); }

	//! The gravity force direction vector.
 	//! [Default value] Vector(0, 1, 0)
	bool set_gravity_vector(const Vector& vector) { return setValue("gravity_vector", vector); }
	//! The gravity force direction vector.
 	//! [Default value] Vector(0, 1, 0)
	Vector get_gravity_vector() const { return getVector("gravity_vector"); }

	//! The direction variation.
 	//! [Default value] 0
	bool set_dir_var(float val) { return setValue("dir_var", val); }
	//! The direction variation.
 	//! [Default value] 0
	float get_dir_var() const { return getFloat("dir_var"); }

	//! The hair length variation.
 	//! [Default value] 0
	bool set_length_var(float val) { return setValue("length_var", val); }
	//! The hair length variation.
 	//! [Default value] 0
	float get_length_var() const { return getFloat("length_var"); }

	//! The hair thickness variation.
 	//! [Default value] 0
	bool set_thickness_var(float val) { return setValue("thickness_var", val); }
	//! The hair thickness variation.
 	//! [Default value] 0
	float get_thickness_var() const { return getFloat("thickness_var"); }

	//! The gravity variation.
 	//! [Default value] 0
	bool set_gravity_var(float val) { return setValue("gravity_var", val); }
	//! The gravity variation.
 	//! [Default value] 0
	float get_gravity_var() const { return getFloat("gravity_var"); }

	//! The curl radius variation.
 	//! [Default value] 0
	bool set_curl_radius_var(float val) { return setValue("curl_radius_var", val); }
	//! The curl radius variation.
 	//! [Default value] 0
	float get_curl_radius_var() const { return getFloat("curl_radius_var"); }

	//! The amount of hair bending.
 	//! [Default value] 0
	bool set_bend(float val) { return setValue("bend", val); }
	//! The amount of hair bending.
 	//! [Default value] 0
	float get_bend() const { return getFloat("bend"); }

	//! The amount of taper applied to hairs.
 	//! [Default value] 0
	bool set_taper(float val) { return setValue("taper", val); }
	//! The amount of taper applied to hairs.
 	//! [Default value] 0
	float get_taper() const { return getFloat("taper"); }

	//! True if curl should be applied to the hair.
 	//! [Default value] false
	bool set_curl_enabled(bool val) { return setValue("curl_enabled", val); }
	//! True if curl should be applied to the hair.
 	//! [Default value] false
	bool get_curl_enabled() const { return getBool("curl_enabled"); }

	//! The angle of the curl applied at yeach knot.
 	//! [Default value] 0
	bool set_curl_angle(float val) { return setValue("curl_angle", val); }
	//! The angle of the curl applied at yeach knot.
 	//! [Default value] 0
	float get_curl_angle() const { return getFloat("curl_angle"); }

	//! The radius of the curls.
 	//! [Default value] 0
	bool set_curl_radius(float val) { return setValue("curl_radius", val); }
	//! The radius of the curls.
 	//! [Default value] 0
	float get_curl_radius() const { return getFloat("curl_radius"); }

	//! Number of segments along the circumference of a single hair.
 	//! [Default value] 3
	bool set_hair_sides(int val) { return setValue("hair_sides", val); }
	//! Number of segments along the circumference of a single hair.
 	//! [Default value] 3
	int get_hair_sides() const { return getInt("hair_sides"); }

	//! Number of segments along the length of a single hair.
 	//! [Default value] 8
	bool set_hair_knots(int val) { return setValue("hair_knots", val); }
	//! Number of segments along the length of a single hair.
 	//! [Default value] 8
	int get_hair_knots() const { return getInt("hair_knots"); }

	//! Level of detail toggle. Enables detail decrease along distance form the camera.
 	//! [Default value] false
	bool set_lod_enabled(bool val) { return setValue("lod_enabled", val); }
	//! Level of detail toggle. Enables detail decrease along distance form the camera.
 	//! [Default value] false
	bool get_lod_enabled() const { return getBool("lod_enabled"); }

	//! Level of detail starting distance. The distance from wich the effect is applied.
 	//! [Default value] 1000
	bool set_lod_startDistance(float val) { return setValue("lod_startDistance", val); }
	//! Level of detail starting distance. The distance from wich the effect is applied.
 	//! [Default value] 1000
	float get_lod_startDistance() const { return getFloat("lod_startDistance"); }

	//! Level of detail rate. Rate of decrease. The distance to reach half the hairs count with twice the thickness.
 	//! [Default value] 1000
	bool set_lod_rate(float val) { return setValue("lod_rate", val); }
	//! Level of detail rate. Rate of decrease. The distance to reach half the hairs count with twice the thickness.
 	//! [Default value] 1000
	float get_lod_rate() const { return getFloat("lod_rate"); }

	//! A list of face indices that will have hair generated on them. If NULL all faces will have hair on them.
 	//! [Default value] 0
	bool set_faceList(const IntList& intList) { return setValue("faceList", intList); }
	//! A list of face indices that will have hair generated on them. If NULL all faces will have hair on them.
 	//! [Default value] 0
	bool set_faceList(const int* ints, size_t count) { return setArray("faceList", ints, count); }
	//! A list of face indices that will have hair generated on them. If NULL all faces will have hair on them.
 	//! [Default value] 0
	template<size_t count> bool set_faceList(const int (&ints)[count]) { return setArray("faceList", ints, count); }
	//! A list of face indices that will have hair generated on them. If NULL all faces will have hair on them.
 	//! [Default value] 0
	IntList get_faceList() const { return getIntList("faceList"); }

	//! True if areaList should be used to determine the number of hairs when distribution is 'per area'.
 	//! [Default value] 0
	bool set_fixed_areas(int val) { return setValue("fixed_areas", val); }
	//! True if areaList should be used to determine the number of hairs when distribution is 'per area'.
 	//! [Default value] 0
	int get_fixed_areas() const { return getInt("fixed_areas"); }

	//! A list of triangle surface areas. An element here corresponds to an element in faceList, if faceList is not NULL. 
 	//! [Default value] 0
	bool set_areaList(const FloatList& floatList) { return setValue("areaList", floatList); }
	//! A list of triangle surface areas. An element here corresponds to an element in faceList, if faceList is not NULL. 
 	//! [Default value] 0
	bool set_areaList(const float* floats, size_t count) { return setArray("areaList", floats, count); }
	//! A list of triangle surface areas. An element here corresponds to an element in faceList, if faceList is not NULL. 
 	//! [Default value] 0
	template<size_t count> bool set_areaList(const float (&floats)[count]) { return setArray("areaList", floats, count); }
	//! A list of triangle surface areas. An element here corresponds to an element in faceList, if faceList is not NULL. 
 	//! [Default value] 0
	FloatList get_areaList() const { return getFloatList("areaList"); }

	//! 0 : per face; 1 : per area
 	//! [UI Guides] enum=0:Per face;1:Per area
 	//! [Default value] 0
	bool set_distribution(int val) { return setValue("distribution", val); }
	//! 0 : per face; 1 : per area
 	//! [UI Guides] enum=0:Per face;1:Per area
 	//! [Default value] 0
	int get_distribution() const { return getInt("distribution"); }

	//! Number of hairs per face if distribution==0
 	//! [Default value] 10
	bool set_perFace(int val) { return setValue("perFace", val); }
	//! Number of hairs per face if distribution==0
 	//! [Default value] 10
	int get_perFace() const { return getInt("perFace"); }

	//! Number of hairs per unit area if distribution==1
 	//! [Default value] 10
	bool set_perArea(float val) { return setValue("perArea", val); }
	//! Number of hairs per unit area if distribution==1
 	//! [Default value] 10
	float get_perArea() const { return getFloat("perArea"); }

	//! (description missing)
	//! [Default value] 0
	bool set_flat_normals(int val) { return setValue("flat_normals", val); }
	//! (description missing)
	//! [Default value] 0
	int get_flat_normals() const { return getInt("flat_normals"); }

	//! Material ID will be overriden.
 	//! [Default value] false
	bool set_override_mtlID_on(bool val) { return setValue("override_mtlID_on", val); }
	//! Material ID will be overriden.
 	//! [Default value] false
	bool get_override_mtlID_on() const { return getBool("override_mtlID_on"); }

	//! The override material ID.
 	//! [Default value] 0
	bool set_override_mtlID(int val) { return setValue("override_mtlID", val); }
	//! The override material ID.
 	//! [Default value] 0
	int get_override_mtlID() const { return getInt("override_mtlID"); }

	//! If false, fur will be displaced via using the parent mesh displacement map.
 	//! [Default value] false
	bool set_ignore_base_mesh_displacement(bool val) { return setValue("ignore_base_mesh_displacement", val); }
	//! If false, fur will be displaced via using the parent mesh displacement map.
 	//! [Default value] false
	bool get_ignore_base_mesh_displacement() const { return getBool("ignore_base_mesh_displacement"); }

	//! The type of placement of the fur on the mesh. The possible values are 0 : Entire Object, 1 : Selected Faces, 2 : Material ID.
 	//! [UI Guides] enum=0:Entire Object;1:Selected Faces;2:Material ID
 	//! [Default value] 0
	bool set_placement(int val) { return setValue("placement", val); }
	//! The type of placement of the fur on the mesh. The possible values are 0 : Entire Object, 1 : Selected Faces, 2 : Material ID.
 	//! [UI Guides] enum=0:Entire Object;1:Selected Faces;2:Material ID
 	//! [Default value] 0
	int get_placement() const { return getInt("placement"); }

	//! Fur scaling factor.
 	//! [Default value] 1
	bool set_scale(float val) { return setValue("scale", val); }
	//! Fur scaling factor.
 	//! [Default value] 1
	float get_scale() const { return getFloat("scale"); }

	//! Material ID of the faces of the mesh. This is only valid if the placement is by material ID.
 	//! [UI Guides] enableIf: ?placement=2
 	//! [Default value] 0
	bool set_mtlID(int val) { return setValue("mtlID", val); }
	//! Material ID of the faces of the mesh. This is only valid if the placement is by material ID.
 	//! [UI Guides] enableIf: ?placement=2
 	//! [Default value] 0
	int get_mtlID() const { return getInt("mtlID"); }

	//! If true, V-Ray will generate a W mapping coordinate that represents the position of the shaded point along the hair strands.
 	//! [Default value] true
	bool set_generate_w_coord(bool val) { return setValue("generate_w_coord", val); }
	//! If true, V-Ray will generate a W mapping coordinate that represents the position of the shaded point along the hair strands.
 	//! [Default value] true
	bool get_generate_w_coord() const { return getBool("generate_w_coord"); }

	//! Map channel to derive the uv space from.
 	//! [Default value] 0
	bool set_map_channel(int val) { return setValue("map_channel", val); }
	//! Map channel to derive the uv space from.
 	//! [Default value] 0
	int get_map_channel() const { return getInt("map_channel"); }

	//! A texture for the bend direction of hair strands.
 	bool set_bend_direction_tex(const Plugin& texture) { return setValue("bend_direction_tex", texture); }
	//! A texture for the bend direction of hair strands.
 	bool set_bend_direction_tex(const AColor& texture) { return setValue("bend_direction_tex", texture); }
	//! A texture for the bend direction of hair strands.
 	Value get_bend_direction_tex() const { return getValue("bend_direction_tex"); }

	//! A texture for the initial direction of hair strands.
 	bool set_initial_direction_tex(const Plugin& texture) { return setValue("initial_direction_tex", texture); }
	//! A texture for the initial direction of hair strands.
 	bool set_initial_direction_tex(const AColor& texture) { return setValue("initial_direction_tex", texture); }
	//! A texture for the initial direction of hair strands.
 	Value get_initial_direction_tex() const { return getValue("initial_direction_tex"); }

	//! A texture for the length.
 	bool set_length_tex(const Plugin& texturefloat) { return setValue("length_tex", texturefloat); }
	//! A texture for the length.
 	bool set_length_tex(float texturefloat) { return setValue("length_tex", texturefloat); }
	//! A texture for the length.
 	Value get_length_tex() const { return getValue("length_tex"); }

	//! A texture for the thickness.
 	bool set_thickness_tex(const Plugin& texturefloat) { return setValue("thickness_tex", texturefloat); }
	//! A texture for the thickness.
 	bool set_thickness_tex(float texturefloat) { return setValue("thickness_tex", texturefloat); }
	//! A texture for the thickness.
 	Value get_thickness_tex() const { return getValue("thickness_tex"); }

	//! A texture for the gravity.
 	bool set_gravity_tex(const Plugin& texturefloat) { return setValue("gravity_tex", texturefloat); }
	//! A texture for the gravity.
 	bool set_gravity_tex(float texturefloat) { return setValue("gravity_tex", texturefloat); }
	//! A texture for the gravity.
 	Value get_gravity_tex() const { return getValue("gravity_tex"); }

	//! A texture for the bend.
 	bool set_bend_tex(const Plugin& texturefloat) { return setValue("bend_tex", texturefloat); }
	//! A texture for the bend.
 	bool set_bend_tex(float texturefloat) { return setValue("bend_tex", texturefloat); }
	//! A texture for the bend.
 	Value get_bend_tex() const { return getValue("bend_tex"); }

	//! A texture for the density.
 	bool set_density_tex(const Plugin& texturefloat) { return setValue("density_tex", texturefloat); }
	//! A texture for the density.
 	bool set_density_tex(float texturefloat) { return setValue("density_tex", texturefloat); }
	//! A texture for the density.
 	Value get_density_tex() const { return getValue("density_tex"); }

	//! (description missing)
	bool set_curl_tex(const Plugin& texture) { return setValue("curl_tex", texture); }
	//! (description missing)
	bool set_curl_tex(const AColor& texture) { return setValue("curl_tex", texture); }
	//! (description missing)
	Value get_curl_tex() const { return getValue("curl_tex"); }
};

class GeomImagePlane : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "GeomImagePlane"; }
};

class GeomInfinitePlane : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "GeomInfinitePlane"; }

	//! origin for plane
 	//! [Default value] Vector(0, 0, 0)
	bool set_origin(const Vector& vector) { return setValue("origin", vector); }
	//! origin for plane
 	//! [Default value] Vector(0, 0, 0)
	Vector get_origin() const { return getVector("origin"); }

	//! normal for plane
 	//! [Default value] Vector(0, 0, 1)
	bool set_normal(const Vector& vector) { return setValue("normal", vector); }
	//! normal for plane
 	//! [Default value] Vector(0, 0, 1)
	Vector get_normal() const { return getVector("normal"); }
};

class GeomLocalRayserver : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "GeomLocalRayserver"; }

	//! The source geometry.
 	bool set_source_geometry(const Plugin& plugin) { return setValue("source_geometry", plugin); }
	//! The source geometry.
 	Plugin get_source_geometry() const { return getPlugin("source_geometry"); }
};

class GeomMayaHair : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "GeomMayaHair"; }

	//! A list of the number of hair vertices, one for each hair strand.
 	//! [Default value] 0
	bool set_num_hair_vertices(const IntList& intList) { return setValue("num_hair_vertices", intList); }
	//! A list of the number of hair vertices, one for each hair strand.
 	//! [Default value] 0
	bool set_num_hair_vertices(const int* ints, size_t count) { return setArray("num_hair_vertices", ints, count); }
	//! A list of the number of hair vertices, one for each hair strand.
 	//! [Default value] 0
	template<size_t count> bool set_num_hair_vertices(const int (&ints)[count]) { return setArray("num_hair_vertices", ints, count); }
	//! A list of the number of hair vertices, one for each hair strand.
 	//! [Default value] 0
	IntList get_num_hair_vertices() const { return getIntList("num_hair_vertices"); }

	//! A list with the positions of the hair vertices in object space. The number of elements should be equal to the sum of the elements of the num_hair_vertices parameter.
 	//! [Default value] Vector(0, 0, 0)
	bool set_hair_vertices(const VectorList& vectorList) { return setValue("hair_vertices", vectorList); }
	//! A list with the positions of the hair vertices in object space. The number of elements should be equal to the sum of the elements of the num_hair_vertices parameter.
 	//! [Default value] Vector(0, 0, 0)
	bool set_hair_vertices(const Vector* vectors, size_t count) { return setArray("hair_vertices", vectors, count); }
	//! A list with the positions of the hair vertices in object space. The number of elements should be equal to the sum of the elements of the num_hair_vertices parameter.
 	//! [Default value] Vector(0, 0, 0)
	template<size_t count> bool set_hair_vertices(const Vector (&vectors)[count]) { return setArray("hair_vertices", vectors, count); }
	//! A list with the positions of the hair vertices in object space. The number of elements should be equal to the sum of the elements of the num_hair_vertices parameter.
 	//! [Default value] Vector(0, 0, 0)
	VectorList get_hair_vertices() const { return getVectorList("hair_vertices"); }

	//! The width of the hair strands at each vertex.Should have the same number of elements as hair_vertices.
 	//! [Default value] 0
	bool set_widths(const FloatList& floatList) { return setValue("widths", floatList); }
	//! The width of the hair strands at each vertex.Should have the same number of elements as hair_vertices.
 	//! [Default value] 0
	bool set_widths(const float* floats, size_t count) { return setArray("widths", floats, count); }
	//! The width of the hair strands at each vertex.Should have the same number of elements as hair_vertices.
 	//! [Default value] 0
	template<size_t count> bool set_widths(const float (&floats)[count]) { return setArray("widths", floats, count); }
	//! The width of the hair strands at each vertex.Should have the same number of elements as hair_vertices.
 	//! [Default value] 0
	FloatList get_widths() const { return getFloatList("widths"); }

	//! Color values for each hair vertex.Should have the same number of elements as hair_vertices.
 	//! [Default value] Color(1, 1, 1)
	bool set_colors(const ColorList& colorList) { return setValue("colors", colorList); }
	//! Color values for each hair vertex.Should have the same number of elements as hair_vertices.
 	//! [Default value] Color(1, 1, 1)
	bool set_colors(const Color* colors, size_t count) { return setArray("colors", colors, count); }
	//! Color values for each hair vertex.Should have the same number of elements as hair_vertices.
 	//! [Default value] Color(1, 1, 1)
	template<size_t count> bool set_colors(const Color (&colors)[count]) { return setArray("colors", colors, count); }
	//! Color values for each hair vertex.Should have the same number of elements as hair_vertices.
 	//! [Default value] Color(1, 1, 1)
	ColorList get_colors() const { return getColorList("colors"); }

	//! Incandescence values for each hair vertex.Should have the same number of elements as hair_vertices.
 	//! [Default value] Color(0, 0, 0)
	bool set_incandescence(const ColorList& colorList) { return setValue("incandescence", colorList); }
	//! Incandescence values for each hair vertex.Should have the same number of elements as hair_vertices.
 	//! [Default value] Color(0, 0, 0)
	bool set_incandescence(const Color* colors, size_t count) { return setArray("incandescence", colors, count); }
	//! Incandescence values for each hair vertex.Should have the same number of elements as hair_vertices.
 	//! [Default value] Color(0, 0, 0)
	template<size_t count> bool set_incandescence(const Color (&colors)[count]) { return setArray("incandescence", colors, count); }
	//! Incandescence values for each hair vertex.Should have the same number of elements as hair_vertices.
 	//! [Default value] Color(0, 0, 0)
	ColorList get_incandescence() const { return getColorList("incandescence"); }

	//! Transparency values for each hair vertex.Should have the same number of elements as hair_vertices.
 	//! [Default value] Color(0, 0, 0)
	bool set_transparency(const ColorList& colorList) { return setValue("transparency", colorList); }
	//! Transparency values for each hair vertex.Should have the same number of elements as hair_vertices.
 	//! [Default value] Color(0, 0, 0)
	bool set_transparency(const Color* colors, size_t count) { return setArray("transparency", colors, count); }
	//! Transparency values for each hair vertex.Should have the same number of elements as hair_vertices.
 	//! [Default value] Color(0, 0, 0)
	template<size_t count> bool set_transparency(const Color (&colors)[count]) { return setArray("transparency", colors, count); }
	//! Transparency values for each hair vertex.Should have the same number of elements as hair_vertices.
 	//! [Default value] Color(0, 0, 0)
	ColorList get_transparency() const { return getColorList("transparency"); }

	//! The Maya hair shader does not allow for different transparency on each hair vertex. Instead it uses a single opacity parameter for all of them.
 	//! [Default value] 1
	bool set_opacity(float val) { return setValue("opacity", val); }
	//! The Maya hair shader does not allow for different transparency on each hair vertex. Instead it uses a single opacity parameter for all of them.
 	//! [Default value] 1
	float get_opacity() const { return getFloat("opacity"); }

	//! UVW values for each hair strand.Should have the same number of elements as num_hair_vertices.
 	//! [Default value] Vector(0, 0, 0)
	bool set_strand_uvw(const VectorList& vectorList) { return setValue("strand_uvw", vectorList); }
	//! UVW values for each hair strand.Should have the same number of elements as num_hair_vertices.
 	//! [Default value] Vector(0, 0, 0)
	bool set_strand_uvw(const Vector* vectors, size_t count) { return setArray("strand_uvw", vectors, count); }
	//! UVW values for each hair strand.Should have the same number of elements as num_hair_vertices.
 	//! [Default value] Vector(0, 0, 0)
	template<size_t count> bool set_strand_uvw(const Vector (&vectors)[count]) { return setArray("strand_uvw", vectors, count); }
	//! UVW values for each hair strand.Should have the same number of elements as num_hair_vertices.
 	//! [Default value] Vector(0, 0, 0)
	VectorList get_strand_uvw() const { return getVectorList("strand_uvw"); }

	//! If true, hair strands geometry will be represented as splines, instead of line segments.
 	//! [Default value] false
	bool set_geom_splines(bool val) { return setValue("geom_splines", val); }
	//! If true, hair strands geometry will be represented as splines, instead of line segments.
 	//! [Default value] false
	bool get_geom_splines() const { return getBool("geom_splines"); }

	//! If true, the hair will be added to the global static hair tree.
 	//! [Default value] true
	bool set_use_global_hair_tree(bool val) { return setValue("use_global_hair_tree", val); }
	//! If true, the hair will be added to the global static hair tree.
 	//! [Default value] true
	bool get_use_global_hair_tree() const { return getBool("use_global_hair_tree"); }

	//! Manual control over the number of subdivisions when intersecting the spline based hairs.
 	//! [Default value] 4
	bool set_geom_tesselation_mult(float val) { return setValue("geom_tesselation_mult", val); }
	//! Manual control over the number of subdivisions when intersecting the spline based hairs.
 	//! [Default value] 4
	float get_geom_tesselation_mult() const { return getFloat("geom_tesselation_mult"); }

	//! If true, the hair is xgen generated.
 	//! [Default value] false
	bool set_xgen_generated(bool val) { return setValue("xgen_generated", val); }
	//! If true, the hair is xgen generated.
 	//! [Default value] false
	bool get_xgen_generated() const { return getBool("xgen_generated"); }

	//! If true, the widths parameter is in pixels, otherwise it is in world units.
 	//! [Default value] false
	bool set_widths_in_pixels(bool val) { return setValue("widths_in_pixels", val); }
	//! If true, the widths parameter is in pixels, otherwise it is in world units.
 	//! [Default value] false
	bool get_widths_in_pixels() const { return getBool("widths_in_pixels"); }

	//! A list of mapping channels; each channel itself is a list of 4 elements - the channel index, number of knots per strand, the knots array (vectors) and channel name. Channel index 0 is used for UVW coordinates if and only if strand_uvw is not set.
 	bool set_map_channels(const ValueList& list) { return setValue("map_channels", list); }
	//! A list of mapping channels; each channel itself is a list of 4 elements - the channel index, number of knots per strand, the knots array (vectors) and channel name. Channel index 0 is used for UVW coordinates if and only if strand_uvw is not set.
 	ValueList get_map_channels() const { return getValueList("map_channels"); }

	//! If true, V-Ray will generate a W mapping coordinate that represents the position of the shaded point along the hair strands.
 	//! [Default value] false
	bool set_generate_w_coord(bool val) { return setValue("generate_w_coord", val); }
	//! If true, V-Ray will generate a W mapping coordinate that represents the position of the shaded point along the hair strands.
 	//! [Default value] false
	bool get_generate_w_coord() const { return getBool("generate_w_coord"); }

	//! Restricts the hair strands to not be thinner than the specified value, in pixels. The V-Ray hair shader will make the hairs more transparent instead to achieve the same density.
 	//! [Default value] 0
	bool set_min_pixel_width(float val) { return setValue("min_pixel_width", val); }
	//! Restricts the hair strands to not be thinner than the specified value, in pixels. The V-Ray hair shader will make the hairs more transparent instead to achieve the same density.
 	//! [Default value] 0
	float get_min_pixel_width() const { return getFloat("min_pixel_width"); }
};

class GeomMeshFile : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "GeomMeshFile"; }

	//! [UI Guides] displayName=Mesh File, fileAsset=vrmesh;abc, fileAssetNames=V-Ray Mesh;Alembic, fileAssetOp=load
 	bool set_file(const char* str) { return setValue("file", str); }
	//! [UI Guides] displayName=Mesh File, fileAsset=vrmesh;abc, fileAssetNames=V-Ray Mesh;Alembic, fileAssetOp=load
 	bool set_file(const std::string& str) { return setValue("file", str); }
	//! [UI Guides] displayName=Mesh File, fileAsset=vrmesh;abc, fileAssetNames=V-Ray Mesh;Alembic, fileAssetOp=load
 	std::string get_file() const { return getString("file"); }

	//! Animated proxy playback speed
 	//! [UI Guides] displayName=Playback speed
 	//! [Default value] 1
	bool set_anim_speed(float val) { return setValue("anim_speed", val); }
	//! Animated proxy playback speed
 	//! [UI Guides] displayName=Playback speed
 	//! [Default value] 1
	float get_anim_speed() const { return getFloat("anim_speed"); }

	//! Animated proxy playback type (0 - loop; 1 - once; 2 - ping-pong; 3 - still)
 	//! [UI Guides] enum=0:Loop;1:Once;2:Ping-pong;3:Still, displayName=Playback type
 	//! [Default value] 0
	bool set_anim_type(int val) { return setValue("anim_type", val); }
	//! Animated proxy playback type (0 - loop; 1 - once; 2 - ping-pong; 3 - still)
 	//! [UI Guides] enum=0:Loop;1:Once;2:Ping-pong;3:Still, displayName=Playback type
 	//! [Default value] 0
	int get_anim_type() const { return getInt("anim_type"); }

	//! Animated proxy initial frame offset
 	//! [UI Guides] displayName=Start offset
 	//! [Default value] 0
	bool set_anim_offset(float val) { return setValue("anim_offset", val); }
	//! Animated proxy initial frame offset
 	//! [UI Guides] displayName=Start offset
 	//! [Default value] 0
	float get_anim_offset() const { return getFloat("anim_offset"); }

	//! Controls if 'Sequence start'(anim_start) and 'Sequence length'(anim_length) are taken in consideration. Useful only, when the file name contains frame filter.
 	//! [UI Guides] displayName=Sequence override
 	//! [Default value] false
	bool set_anim_override(bool val) { return setValue("anim_override", val); }
	//! Controls if 'Sequence start'(anim_start) and 'Sequence length'(anim_length) are taken in consideration. Useful only, when the file name contains frame filter.
 	//! [UI Guides] displayName=Sequence override
 	//! [Default value] false
	bool get_anim_override() const { return getBool("anim_override"); }

	//! Specifies the first frame of the animation sequence.
 	//! [UI Guides] enableIf: ?anim_override!=0, displayName=Sequence start
 	//! [Default value] 0
	bool set_anim_start(int val) { return setValue("anim_start", val); }
	//! Specifies the first frame of the animation sequence.
 	//! [UI Guides] enableIf: ?anim_override!=0, displayName=Sequence start
 	//! [Default value] 0
	int get_anim_start() const { return getInt("anim_start"); }

	//! Specifies the length of the animation sequence.
 	//! [UI Guides] enableIf: ?anim_override!=0, displayName=Sequence length
 	//! [Default value] 0
	bool set_anim_length(int val) { return setValue("anim_length", val); }
	//! Specifies the length of the animation sequence.
 	//! [UI Guides] enableIf: ?anim_override!=0, displayName=Sequence length
 	//! [Default value] 0
	int get_anim_length() const { return getInt("anim_length"); }

	//! (description missing)
	//! [Default value] true
	bool set_primary_visibility(bool val) { return setValue("primary_visibility", val); }
	//! (description missing)
	//! [Default value] true
	bool get_primary_visibility() const { return getBool("primary_visibility"); }

	//! Size scaling factor
 	//! [Default value] 1
	bool set_scale(float val) { return setValue("scale", val); }
	//! Size scaling factor
 	//! [Default value] 1
	float get_scale() const { return getFloat("scale"); }

	//! 0 do not rotate the coordinate system; 1 to transform the proxy from Maya to Max coordinate system; 2 to transform from Max to Maya
 	//! [Default value] 0
	bool set_flip_axis(int val) { return setValue("flip_axis", val); }
	//! 0 do not rotate the coordinate system; 1 to transform the proxy from Maya to Max coordinate system; 2 to transform from Max to Maya
 	//! [Default value] 0
	int get_flip_axis() const { return getInt("flip_axis"); }

	//! True to smooth UVs at mesh borders when rendering this mesh as a subdivision surface
 	//! [Default value] true
	bool set_smooth_uv_borders(bool val) { return setValue("smooth_uv_borders", val); }
	//! True to smooth UVs at mesh borders when rendering this mesh as a subdivision surface
 	//! [Default value] true
	bool get_smooth_uv_borders() const { return getBool("smooth_uv_borders"); }

	//! True to smooth UVs when rendering this mesh as a subdivision surface
 	//! [Default value] true
	bool set_smooth_uv(bool val) { return setValue("smooth_uv", val); }
	//! True to smooth UVs when rendering this mesh as a subdivision surface
 	//! [Default value] true
	bool get_smooth_uv() const { return getBool("smooth_uv"); }

	//! True to calculate smooth normals
 	//! [UI Guides] displayName=Compute normals
 	//! [Default value] true
	bool set_compute_normals(bool val) { return setValue("compute_normals", val); }
	//! True to calculate smooth normals
 	//! [UI Guides] displayName=Compute normals
 	//! [Default value] true
	bool get_compute_normals() const { return getBool("compute_normals"); }

	//! Smooth angle in degrees
 	//! [UI Guides] enableIf: ?compute_normals!=0, displayName=Smooth angle, minValue=0.0, maxValue=180.0f
 	//! [Default value] 30
	bool set_smooth_angle(float val) { return setValue("smooth_angle", val); }
	//! Smooth angle in degrees
 	//! [UI Guides] enableIf: ?compute_normals!=0, displayName=Smooth angle, minValue=0.0, maxValue=180.0f
 	//! [Default value] 30
	float get_smooth_angle() const { return getFloat("smooth_angle"); }

	//! True to flip the vertex normals
 	//! [UI Guides] displayName=Flip normals
 	//! [Default value] false
	bool set_flip_normals(bool val) { return setValue("flip_normals", val); }
	//! True to flip the vertex normals
 	//! [UI Guides] displayName=Flip normals
 	//! [Default value] false
	bool get_flip_normals() const { return getBool("flip_normals"); }

	//! True to compute the bounding box, false to read it from the file
 	//! [UI Guides] displayName=Recompute bounding box
 	//! [Default value] false
	bool set_compute_bbox(bool val) { return setValue("compute_bbox", val); }
	//! True to compute the bounding box, false to read it from the file
 	//! [UI Guides] displayName=Recompute bounding box
 	//! [Default value] false
	bool get_compute_bbox() const { return getBool("compute_bbox"); }

	//! number of faces in preview
 	//! [UI Guides] displayName=Preview faces
 	//! [Default value] 10000
	bool set_num_preview_faces(int val) { return setValue("num_preview_faces", val); }
	//! number of faces in preview
 	//! [UI Guides] displayName=Preview faces
 	//! [Default value] 10000
	int get_num_preview_faces() const { return getInt("num_preview_faces"); }

	//! Turn on/off face sets
 	//! [Default value] true
	bool set_use_face_sets(bool val) { return setValue("use_face_sets", val); }
	//! Turn on/off face sets
 	//! [Default value] true
	bool get_use_face_sets() const { return getBool("use_face_sets"); }

	//! Read the full path instead of only the name
 	//! [UI Guides] displayName=Use full names
 	//! [Default value] false
	bool set_use_full_names(bool val) { return setValue("use_full_names", val); }
	//! Read the full path instead of only the name
 	//! [UI Guides] displayName=Use full names
 	//! [Default value] false
	bool get_use_full_names() const { return getBool("use_full_names"); }

	//! Starting object path in Alembic hierarchy
 	//! [UI Guides] displayName=Starting object path
 	bool set_object_path(const char* str) { return setValue("object_path", str); }
	//! Starting object path in Alembic hierarchy
 	//! [UI Guides] displayName=Starting object path
 	bool set_object_path(const std::string& str) { return setValue("object_path", str); }
	//! Starting object path in Alembic hierarchy
 	//! [UI Guides] displayName=Starting object path
 	std::string get_object_path() const { return getString("object_path"); }

	//! Hair width multiplier
 	//! [UI Guides] displayName=Hair width multiplier, minValue=0.0
 	//! [Default value] 1
	bool set_hair_width_multiplier(float val) { return setValue("hair_width_multiplier", val); }
	//! Hair width multiplier
 	//! [UI Guides] displayName=Hair width multiplier, minValue=0.0
 	//! [Default value] 1
	float get_hair_width_multiplier() const { return getFloat("hair_width_multiplier"); }

	//! Particle width multiplier
 	//! [UI Guides] displayName=Particle width multiplier, minValue=0.0
 	//! [Default value] 1
	bool set_particle_width_multiplier(float val) { return setValue("particle_width_multiplier", val); }
	//! Particle width multiplier
 	//! [UI Guides] displayName=Particle width multiplier, minValue=0.0
 	//! [Default value] 1
	float get_particle_width_multiplier() const { return getFloat("particle_width_multiplier"); }

	//! Alembic velocity multiplier
 	//! [UI Guides] displayName=Velocity multiplier
 	//! [Default value] 1
	bool set_velocity_multiplier(float val) { return setValue("velocity_multiplier", val); }
	//! Alembic velocity multiplier
 	//! [UI Guides] displayName=Velocity multiplier
 	//! [Default value] 1
	float get_velocity_multiplier() const { return getFloat("velocity_multiplier"); }

	//! Specifies the type of both names and ids lists. 0 - exclude; 1 - include
 	//! [Default value] 0
	bool set_visibility_lists_type(int val) { return setValue("visibility_lists_type", val); }
	//! Specifies the type of both names and ids lists. 0 - exclude; 1 - include
 	//! [Default value] 0
	int get_visibility_lists_type() const { return getInt("visibility_lists_type"); }

	//! Visibility list of mesh names. Either include or exclude
 	bool set_visibility_list_names(const ValueList& stringList) { return setValue("visibility_list_names", stringList); }
	//! Visibility list of mesh names. Either include or exclude
 	ValueList get_visibility_list_names() const { return getValueList("visibility_list_names"); }

	//! Visibility list of mesh ids. Either include or exclude
 	bool set_visibility_list_ids(const IntList& intList) { return setValue("visibility_list_ids", intList); }
	//! Visibility list of mesh ids. Either include or exclude
 	bool set_visibility_list_ids(const int* ints, size_t count) { return setArray("visibility_list_ids", ints, count); }
	//! Visibility list of mesh ids. Either include or exclude
 	template<size_t count> bool set_visibility_list_ids(const int (&ints)[count]) { return setArray("visibility_list_ids", ints, count); }
	//! Visibility list of mesh ids. Either include or exclude
 	IntList get_visibility_list_ids() const { return getIntList("visibility_list_ids"); }

	//! Specifies the type of both names and ids lists. 0 - exclude; 1 - include
 	//! [UI Guides] enum=0:Exclude;1:Include
 	//! [Default value] 0
	bool set_hair_visibility_lists_type(int val) { return setValue("hair_visibility_lists_type", val); }
	//! Specifies the type of both names and ids lists. 0 - exclude; 1 - include
 	//! [UI Guides] enum=0:Exclude;1:Include
 	//! [Default value] 0
	int get_hair_visibility_lists_type() const { return getInt("hair_visibility_lists_type"); }

	//! Visibility list of hair names. Either include or exclude
 	bool set_hair_visibility_list_names(const ValueList& stringList) { return setValue("hair_visibility_list_names", stringList); }
	//! Visibility list of hair names. Either include or exclude
 	ValueList get_hair_visibility_list_names() const { return getValueList("hair_visibility_list_names"); }

	//! Visibility list of hair ids. Either include or exclude
 	bool set_hair_visibility_list_ids(const IntList& intList) { return setValue("hair_visibility_list_ids", intList); }
	//! Visibility list of hair ids. Either include or exclude
 	bool set_hair_visibility_list_ids(const int* ints, size_t count) { return setArray("hair_visibility_list_ids", ints, count); }
	//! Visibility list of hair ids. Either include or exclude
 	template<size_t count> bool set_hair_visibility_list_ids(const int (&ints)[count]) { return setArray("hair_visibility_list_ids", ints, count); }
	//! Visibility list of hair ids. Either include or exclude
 	IntList get_hair_visibility_list_ids() const { return getIntList("hair_visibility_list_ids"); }

	//! Specifies the type of both names and ids lists. 0 - exclude; 1 - include
 	//! [UI Guides] enum=0:Exclude;1:Include
 	//! [Default value] 0
	bool set_particle_visibility_lists_type(int val) { return setValue("particle_visibility_lists_type", val); }
	//! Specifies the type of both names and ids lists. 0 - exclude; 1 - include
 	//! [UI Guides] enum=0:Exclude;1:Include
 	//! [Default value] 0
	int get_particle_visibility_lists_type() const { return getInt("particle_visibility_lists_type"); }

	//! Visibility list of particle system names. Either include or exclude
 	bool set_particle_visibility_list_names(const ValueList& stringList) { return setValue("particle_visibility_list_names", stringList); }
	//! Visibility list of particle system names. Either include or exclude
 	ValueList get_particle_visibility_list_names() const { return getValueList("particle_visibility_list_names"); }

	//! Visibility list of particle system ids. Either include or exclude
 	bool set_particle_visibility_list_ids(const IntList& intList) { return setValue("particle_visibility_list_ids", intList); }
	//! Visibility list of particle system ids. Either include or exclude
 	bool set_particle_visibility_list_ids(const int* ints, size_t count) { return setArray("particle_visibility_list_ids", ints, count); }
	//! Visibility list of particle system ids. Either include or exclude
 	template<size_t count> bool set_particle_visibility_list_ids(const int (&ints)[count]) { return setArray("particle_visibility_list_ids", ints, count); }
	//! Visibility list of particle system ids. Either include or exclude
 	IntList get_particle_visibility_list_ids() const { return getIntList("particle_visibility_list_ids"); }

	//! Sort Alembic voxels after reading by their names. 0 - skip sorting; 1 - sort
 	//! [Default value] 0
	bool set_sort_voxels(int val) { return setValue("sort_voxels", val); }
	//! Sort Alembic voxels after reading by their names. 0 - skip sorting; 1 - sort
 	//! [Default value] 0
	int get_sort_voxels() const { return getInt("sort_voxels"); }

	//! Specifies how to remap the mapping channels: -1 - no remapping; 0 - channel 0, 1 - channel 1
 	//! [Default value] -1
	bool set_first_map_channel(int val) { return setValue("first_map_channel", val); }
	//! Specifies how to remap the mapping channels: -1 - no remapping; 0 - channel 0, 1 - channel 1
 	//! [Default value] -1
	int get_first_map_channel() const { return getInt("first_map_channel"); }

	//! Set to 0 to render particles as spheres. Set it to 1 to render them as points
 	//! [UI Guides] enum=0:Spheres;1:Points;, displayName=Particle render mode
 	//! [Default value] 0
	bool set_particle_render_mode(int val) { return setValue("particle_render_mode", val); }
	//! Set to 0 to render particles as spheres. Set it to 1 to render them as points
 	//! [UI Guides] enum=0:Spheres;1:Points;, displayName=Particle render mode
 	//! [Default value] 0
	int get_particle_render_mode() const { return getInt("particle_render_mode"); }

	//! True to use alembic animation frame offset
 	//! [Default value] false
	bool set_use_alembic_offset(bool val) { return setValue("use_alembic_offset", val); }
	//! True to use alembic animation frame offset
 	//! [Default value] false
	bool get_use_alembic_offset() const { return getBool("use_alembic_offset"); }

	//! Optional name for the color set where the velocity is written.
 	bool set_velocity_color_set(const char* str) { return setValue("velocity_color_set", str); }
	//! Optional name for the color set where the velocity is written.
 	bool set_velocity_color_set(const std::string& str) { return setValue("velocity_color_set", str); }
	//! Optional name for the color set where the velocity is written.
 	std::string get_velocity_color_set() const { return getString("velocity_color_set"); }

	//! Turns on/off the instancing of alembic duplicated objects
 	//! [Default value] true
	bool set_instancing(bool val) { return setValue("instancing", val); }
	//! Turns on/off the instancing of alembic duplicated objects
 	//! [Default value] true
	bool get_instancing() const { return getBool("instancing"); }

	//! Tessellate hair with respect to the camera position.
 	//! [Default value] false
	bool set_tessellate_hair(bool val) { return setValue("tessellate_hair", val); }
	//! Tessellate hair with respect to the camera position.
 	//! [Default value] false
	bool get_tessellate_hair() const { return getBool("tessellate_hair"); }

	//! Hair tessellation edge length in pixels.
 	//! [Default value] 4
	bool set_hair_tessellation_length(float val) { return setValue("hair_tessellation_length", val); }
	//! Hair tessellation edge length in pixels.
 	//! [Default value] 4
	float get_hair_tessellation_length() const { return getFloat("hair_tessellation_length"); }

	//! True to subdivide alembic PolyMesh and SubD objects; false to subdivide only SubD objects
 	//! [UI Guides] displayName=Subdivide all meshes
 	//! [Default value] false
	bool set_subdiv_all_meshes(bool val) { return setValue("subdiv_all_meshes", val); }
	//! True to subdivide alembic PolyMesh and SubD objects; false to subdivide only SubD objects
 	//! [UI Guides] displayName=Subdivide all meshes
 	//! [Default value] false
	bool get_subdiv_all_meshes() const { return getBool("subdiv_all_meshes"); }

	//! 0 for Catmull-Clark subdivision and 1 for Loop subdivision
 	//! [Default value] 0
	bool set_subdiv_type(int val) { return setValue("subdiv_type", val); }
	//! 0 for Catmull-Clark subdivision and 1 for Loop subdivision
 	//! [Default value] 0
	int get_subdiv_type() const { return getInt("subdiv_type"); }

	//! The subdivision level
 	//! [UI Guides] displayName=Subdivision level, minValue=0
 	//! [Default value] 1
	bool set_subdiv_level(int val) { return setValue("subdiv_level", val); }
	//! The subdivision level
 	//! [UI Guides] displayName=Subdivision level, minValue=0
 	//! [Default value] 1
	int get_subdiv_level() const { return getInt("subdiv_level"); }

	//! Subdivide or skip mapping channels
 	//! [UI Guides] displayName=Subdivide UVs
 	//! [Default value] true
	bool set_subdiv_uvs(bool val) { return setValue("subdiv_uvs", val); }
	//! Subdivide or skip mapping channels
 	//! [UI Guides] displayName=Subdivide UVs
 	//! [Default value] true
	bool get_subdiv_uvs() const { return getBool("subdiv_uvs"); }

	//! If true, the borders won't be subdivided
 	//! [UI Guides] displayName=Preserve geometry borders
 	//! [Default value] false
	bool set_subdiv_preserve_geom_borders(bool val) { return setValue("subdiv_preserve_geom_borders", val); }
	//! If true, the borders won't be subdivided
 	//! [UI Guides] displayName=Preserve geometry borders
 	//! [Default value] false
	bool get_subdiv_preserve_geom_borders() const { return getBool("subdiv_preserve_geom_borders"); }

	//! Determines the smoothing mode of the mapping channels' borders. 0-None, 1-Internal and 2-All
 	//! [UI Guides] enum=0:None;1:Internal;2:All, displayName=Preserve map borders
 	//! [Default value] 1
	bool set_subdiv_preserve_map_borders(int val) { return setValue("subdiv_preserve_map_borders", val); }
	//! Determines the smoothing mode of the mapping channels' borders. 0-None, 1-Internal and 2-All
 	//! [UI Guides] enum=0:None;1:Internal;2:All, displayName=Preserve map borders
 	//! [Default value] 1
	int get_subdiv_preserve_map_borders() const { return getInt("subdiv_preserve_map_borders"); }

	//! If true, use the point cloud inside the vrmesh if available.
 	//! [Default value] false
	bool set_use_point_cloud(bool val) { return setValue("use_point_cloud", val); }
	//! If true, use the point cloud inside the vrmesh if available.
 	//! [Default value] false
	bool get_use_point_cloud() const { return getBool("use_point_cloud"); }

	//! A LOD multiplier. A value smaller than 1.0 means that the level will be of greater detail than required by distance to the object.
 	//! [Default value] 1
	bool set_point_cloud_mult(float val) { return setValue("point_cloud_mult", val); }
	//! A LOD multiplier. A value smaller than 1.0 means that the level will be of greater detail than required by distance to the object.
 	//! [Default value] 1
	float get_point_cloud_mult() const { return getFloat("point_cloud_mult"); }

	//! Modifies the loaded level of detail; larger values reduce the detail level
 	//! [Default value] 1
	bool set_pixel_scale(float val) { return setValue("pixel_scale", val); }
	//! Modifies the loaded level of detail; larger values reduce the detail level
 	//! [Default value] 1
	float get_pixel_scale() const { return getFloat("pixel_scale"); }

	//! [UI Guides] fileAsset=xml, fileAssetNames=XML, fileAssetOp=load, displayName=Material assignments file
 	bool set_material_assignments_file(const char* str) { return setValue("material_assignments_file", str); }
	//! [UI Guides] fileAsset=xml, fileAssetNames=XML, fileAssetOp=load, displayName=Material assignments file
 	bool set_material_assignments_file(const std::string& str) { return setValue("material_assignments_file", str); }
	//! [UI Guides] fileAsset=xml, fileAssetNames=XML, fileAssetOp=load, displayName=Material assignments file
 	std::string get_material_assignments_file() const { return getString("material_assignments_file"); }
};

class GeomMeshLoader : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "GeomMeshLoader"; }

	//! Sphere size
 	//! [Default value] 3
	bool set_sphere_size(float val) { return setValue("sphere_size", val); }
	//! Sphere size
 	//! [Default value] 3
	float get_sphere_size() const { return getFloat("sphere_size"); }

	//! Sphere segments
 	//! [Default value] 10
	bool set_sphere_segments(int val) { return setValue("sphere_segments", val); }
	//! Sphere segments
 	//! [Default value] 10
	int get_sphere_segments() const { return getInt("sphere_segments"); }

	//! Number of spheres
 	//! [Default value] 100
	bool set_num_spheres(int val) { return setValue("num_spheres", val); }
	//! Number of spheres
 	//! [Default value] 100
	int get_num_spheres() const { return getInt("num_spheres"); }

	//! Box size to fill with spheres
 	//! [Default value] 30
	bool set_bbox_size(float val) { return setValue("bbox_size", val); }
	//! Box size to fill with spheres
 	//! [Default value] 30
	float get_bbox_size() const { return getFloat("bbox_size"); }
};

class GeomMeshLoader1 : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "GeomMeshLoader1"; }

	//! Sphere size
 	//! [Default value] 3
	bool set_sphere_size(float val) { return setValue("sphere_size", val); }
	//! Sphere size
 	//! [Default value] 3
	float get_sphere_size() const { return getFloat("sphere_size"); }

	//! Sphere segments
 	//! [Default value] 10
	bool set_sphere_segments(int val) { return setValue("sphere_segments", val); }
	//! Sphere segments
 	//! [Default value] 10
	int get_sphere_segments() const { return getInt("sphere_segments"); }

	//! Number of spheres
 	//! [Default value] 100
	bool set_num_spheres(int val) { return setValue("num_spheres", val); }
	//! Number of spheres
 	//! [Default value] 100
	int get_num_spheres() const { return getInt("num_spheres"); }

	//! Box size to fill with spheres
 	//! [Default value] 30
	bool set_bbox_size(float val) { return setValue("bbox_size", val); }
	//! Box size to fill with spheres
 	//! [Default value] 30
	float get_bbox_size() const { return getFloat("bbox_size"); }

	//! true to enable noise displacement texture
 	//! [Default value] false
	bool set_use_displacement(bool val) { return setValue("use_displacement", val); }
	//! true to enable noise displacement texture
 	//! [Default value] false
	bool get_use_displacement() const { return getBool("use_displacement"); }
};

class GeomMeshTest : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "GeomMeshTest"; }

	//! Sphere size
 	//! [Default value] 3
	bool set_sphere_size(float val) { return setValue("sphere_size", val); }
	//! Sphere size
 	//! [Default value] 3
	float get_sphere_size() const { return getFloat("sphere_size"); }

	//! Sphere segments
 	//! [Default value] 10
	bool set_sphere_segments(int val) { return setValue("sphere_segments", val); }
	//! Sphere segments
 	//! [Default value] 10
	int get_sphere_segments() const { return getInt("sphere_segments"); }

	//! Number of spheres
 	//! [Default value] 100
	bool set_num_spheres(int val) { return setValue("num_spheres", val); }
	//! Number of spheres
 	//! [Default value] 100
	int get_num_spheres() const { return getInt("num_spheres"); }

	//! Box size to fill with spheres
 	//! [Default value] 30
	bool set_bbox_size(float val) { return setValue("bbox_size", val); }
	//! Box size to fill with spheres
 	//! [Default value] 30
	float get_bbox_size() const { return getFloat("bbox_size"); }
};

class GeomMetaballSystem : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "GeomMetaballSystem"; }

	//! true : use particle size; false : use particleRadius for size
 	//! [UI Guides] enum=0:Use particle size;1:Use particleRadius for size
 	//! [Default value] 0
	bool set_useParticleSize(int val) { return setValue("useParticleSize", val); }
	//! true : use particle size; false : use particleRadius for size
 	//! [UI Guides] enum=0:Use particle size;1:Use particleRadius for size
 	//! [Default value] 0
	int get_useParticleSize() const { return getInt("useParticleSize"); }

	//! Size of partiles when useParticleSize is false
 	//! [Default value] 1
	bool set_particleRadius(float val) { return setValue("particleRadius", val); }
	//! Size of partiles when useParticleSize is false
 	//! [Default value] 1
	float get_particleRadius() const { return getFloat("particleRadius"); }

	//! Field threshold value
 	//! [Default value] 0.5
	bool set_threshold(float val) { return setValue("threshold", val); }
	//! Field threshold value
 	//! [Default value] 0.5
	float get_threshold() const { return getFloat("threshold"); }

	//! Ray marching step length
 	//! [Default value] 0.1
	bool set_stepLength(float val) { return setValue("stepLength", val); }
	//! Ray marching step length
 	//! [Default value] 0.1
	float get_stepLength() const { return getFloat("stepLength"); }

	//! Number of samples for motion blur. 0 - Use global settings
 	//! [Default value] 0
	bool set_mbSamples(int val) { return setValue("mbSamples", val); }
	//! Number of samples for motion blur. 0 - Use global settings
 	//! [Default value] 0
	int get_mbSamples() const { return getInt("mbSamples"); }

	//! Distance function - 0: Power of two; 1: Power of three; 2: Power of four; 3: Power of five; 4: Hermit in power of two; 5: Hermit in power of three; 6: Hermit in power of five; 7: Wyvill;
 	//! [UI Guides] enum=0:Power of two;1:Power of three;2:Power of four;3:Power of five;4:Hermit in power of two;5:Hermit in power of three;6:Hermit in power of five;7:Wyvill
 	//! [Default value] 0
	bool set_distanceFunction(int val) { return setValue("distanceFunction", val); }
	//! Distance function - 0: Power of two; 1: Power of three; 2: Power of four; 3: Power of five; 4: Hermit in power of two; 5: Hermit in power of three; 6: Hermit in power of five; 7: Wyvill;
 	//! [UI Guides] enum=0:Power of two;1:Power of three;2:Power of four;3:Power of five;4:Hermit in power of two;5:Hermit in power of three;6:Hermit in power of five;7:Wyvill
 	//! [Default value] 0
	int get_distanceFunction() const { return getInt("distanceFunction"); }

	//! If true - smoothing of the field bump will be performed
 	//! [Default value] 0
	bool set_smoothingBumps(int val) { return setValue("smoothingBumps", val); }
	//! If true - smoothing of the field bump will be performed
 	//! [Default value] 0
	int get_smoothingBumps() const { return getInt("smoothingBumps"); }

	//! Radius of the smoothing filter
 	//! [Default value] 0.5
	bool set_smoothRadius(float val) { return setValue("smoothRadius", val); }
	//! Radius of the smoothing filter
 	//! [Default value] 0.5
	float get_smoothRadius() const { return getFloat("smoothRadius"); }

	//! Correction coefficient for surface expansion: from 0.0 to 1.0
 	//! [Default value] 0.25
	bool set_smoothExpansion(float val) { return setValue("smoothExpansion", val); }
	//! Correction coefficient for surface expansion: from 0.0 to 1.0
 	//! [Default value] 0.25
	float get_smoothExpansion() const { return getFloat("smoothExpansion"); }

	//! List with positive particle systems
 	bool set_positiveParticles(const ValueList& pluginList) { return setValue("positiveParticles", pluginList); }
	//! List with positive particle systems
 	ValueList get_positiveParticles() const { return getValueList("positiveParticles"); }

	//! List with negative particle systems
 	bool set_negativeParticles(const ValueList& pluginList) { return setValue("negativeParticles", pluginList); }
	//! List with negative particle systems
 	ValueList get_negativeParticles() const { return getValueList("negativeParticles"); }

	//! If true - texture will be applied on field
 	//! [Default value] 0
	bool set_useTexture(int val) { return setValue("useTexture", val); }
	//! If true - texture will be applied on field
 	//! [Default value] 0
	int get_useTexture() const { return getInt("useTexture"); }

	//! Field texture
 	bool set_fieldTexture(const Plugin& texture) { return setValue("fieldTexture", texture); }
	//! Field texture
 	bool set_fieldTexture(const AColor& texture) { return setValue("fieldTexture", texture); }
	//! Field texture
 	Value get_fieldTexture() const { return getValue("fieldTexture"); }

	//! 0 - Multiplication; 1 - Addition;
 	//! [UI Guides] enum=0:Multiplication;1:Addition
 	//! [Default value] 0
	bool set_textureFunction(int val) { return setValue("textureFunction", val); }
	//! 0 - Multiplication; 1 - Addition;
 	//! [UI Guides] enum=0:Multiplication;1:Addition
 	//! [Default value] 0
	int get_textureFunction() const { return getInt("textureFunction"); }

	//! Multiplier of the texture
 	//! [Default value] 1
	bool set_textureMultiplier(float val) { return setValue("textureMultiplier", val); }
	//! Multiplier of the texture
 	//! [Default value] 1
	float get_textureMultiplier() const { return getFloat("textureMultiplier"); }

	//! If true - the field will be clamped before texturing
 	//! [Default value] 0
	bool set_clampField(int val) { return setValue("clampField", val); }
	//! If true - the field will be clamped before texturing
 	//! [Default value] 0
	int get_clampField() const { return getInt("clampField"); }

	//! Field clamping level
 	//! [Default value] 1
	bool set_clampThreshold(float val) { return setValue("clampThreshold", val); }
	//! Field clamping level
 	//! [Default value] 1
	float get_clampThreshold() const { return getFloat("clampThreshold"); }

	//! If true - voxel cache will be used for intersection speed-up
 	//! [Default value] 0
	bool set_useCache(int val) { return setValue("useCache", val); }
	//! If true - voxel cache will be used for intersection speed-up
 	//! [Default value] 0
	int get_useCache() const { return getInt("useCache"); }

	//! If true - voxel cache will be build recursively
 	//! [Default value] 0
	bool set_cacheRecursiveBuild(int val) { return setValue("cacheRecursiveBuild", val); }
	//! If true - voxel cache will be build recursively
 	//! [Default value] 0
	int get_cacheRecursiveBuild() const { return getInt("cacheRecursiveBuild"); }

	//! Cache size: from 1 to 5
 	//! [Default value] 3
	bool set_cacheSize(int val) { return setValue("cacheSize", val); }
	//! Cache size: from 1 to 5
 	//! [Default value] 3
	int get_cacheSize() const { return getInt("cacheSize"); }

	//! Cache consolidation block size: from 1 to 8
 	//! [Default value] 4
	bool set_cacheBlockSize(int val) { return setValue("cacheBlockSize", val); }
	//! Cache consolidation block size: from 1 to 8
 	//! [Default value] 4
	int get_cacheBlockSize() const { return getInt("cacheBlockSize"); }

	//! If off shading an intersection with this geometry will not generate a gbuffer.
 	//! [Default value] true
	bool set_primary_visibility(bool val) { return setValue("primary_visibility", val); }
	//! If off shading an intersection with this geometry will not generate a gbuffer.
 	//! [Default value] true
	bool get_primary_visibility() const { return getBool("primary_visibility"); }
};

class GeomParticleSystem : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "GeomParticleSystem"; }

	//! Per-particle acceleration.
 	//! [Default value] Color(0, 0, 0)
	bool set_acceleration_pp(const ColorList& colorList) { return setValue("acceleration_pp", colorList); }
	//! Per-particle acceleration.
 	//! [Default value] Color(0, 0, 0)
	bool set_acceleration_pp(const Color* colors, size_t count) { return setArray("acceleration_pp", colors, count); }
	//! Per-particle acceleration.
 	//! [Default value] Color(0, 0, 0)
	template<size_t count> bool set_acceleration_pp(const Color (&colors)[count]) { return setArray("acceleration_pp", colors, count); }
	//! Per-particle acceleration.
 	//! [Default value] Color(0, 0, 0)
	ColorList get_acceleration_pp() const { return getColorList("acceleration_pp"); }

	//! Per-particle diffuse color.
 	//! [Default value] Color(1, 1, 1)
	bool set_colors(const ColorList& colorList) { return setValue("colors", colorList); }
	//! Per-particle diffuse color.
 	//! [Default value] Color(1, 1, 1)
	bool set_colors(const Color* colors, size_t count) { return setArray("colors", colors, count); }
	//! Per-particle diffuse color.
 	//! [Default value] Color(1, 1, 1)
	template<size_t count> bool set_colors(const Color (&colors)[count]) { return setArray("colors", colors, count); }
	//! Per-particle diffuse color.
 	//! [Default value] Color(1, 1, 1)
	ColorList get_colors() const { return getColorList("colors"); }

	//! Per-particle emission color.
 	//! [Default value] Color(0, 0, 0)
	bool set_emission_pp(const ColorList& colorList) { return setValue("emission_pp", colorList); }
	//! Per-particle emission color.
 	//! [Default value] Color(0, 0, 0)
	bool set_emission_pp(const Color* colors, size_t count) { return setArray("emission_pp", colors, count); }
	//! Per-particle emission color.
 	//! [Default value] Color(0, 0, 0)
	template<size_t count> bool set_emission_pp(const Color (&colors)[count]) { return setArray("emission_pp", colors, count); }
	//! Per-particle emission color.
 	//! [Default value] Color(0, 0, 0)
	ColorList get_emission_pp() const { return getColorList("emission_pp"); }

	//! Corresponds to Maya's userVector1PP.
 	//! [Default value] Color(0, 0, 0)
	bool set_user_color_pp_1(const ColorList& colorList) { return setValue("user_color_pp_1", colorList); }
	//! Corresponds to Maya's userVector1PP.
 	//! [Default value] Color(0, 0, 0)
	bool set_user_color_pp_1(const Color* colors, size_t count) { return setArray("user_color_pp_1", colors, count); }
	//! Corresponds to Maya's userVector1PP.
 	//! [Default value] Color(0, 0, 0)
	template<size_t count> bool set_user_color_pp_1(const Color (&colors)[count]) { return setArray("user_color_pp_1", colors, count); }
	//! Corresponds to Maya's userVector1PP.
 	//! [Default value] Color(0, 0, 0)
	ColorList get_user_color_pp_1() const { return getColorList("user_color_pp_1"); }

	//! Corresponds to Maya's userVector2PP.
 	//! [Default value] Color(0, 0, 0)
	bool set_user_color_pp_2(const ColorList& colorList) { return setValue("user_color_pp_2", colorList); }
	//! Corresponds to Maya's userVector2PP.
 	//! [Default value] Color(0, 0, 0)
	bool set_user_color_pp_2(const Color* colors, size_t count) { return setArray("user_color_pp_2", colors, count); }
	//! Corresponds to Maya's userVector2PP.
 	//! [Default value] Color(0, 0, 0)
	template<size_t count> bool set_user_color_pp_2(const Color (&colors)[count]) { return setArray("user_color_pp_2", colors, count); }
	//! Corresponds to Maya's userVector2PP.
 	//! [Default value] Color(0, 0, 0)
	ColorList get_user_color_pp_2() const { return getColorList("user_color_pp_2"); }

	//! Corresponds to Maya's userVector3PP.
 	//! [Default value] Color(0, 0, 0)
	bool set_user_color_pp_3(const ColorList& colorList) { return setValue("user_color_pp_3", colorList); }
	//! Corresponds to Maya's userVector3PP.
 	//! [Default value] Color(0, 0, 0)
	bool set_user_color_pp_3(const Color* colors, size_t count) { return setArray("user_color_pp_3", colors, count); }
	//! Corresponds to Maya's userVector3PP.
 	//! [Default value] Color(0, 0, 0)
	template<size_t count> bool set_user_color_pp_3(const Color (&colors)[count]) { return setArray("user_color_pp_3", colors, count); }
	//! Corresponds to Maya's userVector3PP.
 	//! [Default value] Color(0, 0, 0)
	ColorList get_user_color_pp_3() const { return getColorList("user_color_pp_3"); }

	//! Corresponds to Maya's userVector4PP.
 	//! [Default value] Color(0, 0, 0)
	bool set_user_color_pp_4(const ColorList& colorList) { return setValue("user_color_pp_4", colorList); }
	//! Corresponds to Maya's userVector4PP.
 	//! [Default value] Color(0, 0, 0)
	bool set_user_color_pp_4(const Color* colors, size_t count) { return setArray("user_color_pp_4", colors, count); }
	//! Corresponds to Maya's userVector4PP.
 	//! [Default value] Color(0, 0, 0)
	template<size_t count> bool set_user_color_pp_4(const Color (&colors)[count]) { return setArray("user_color_pp_4", colors, count); }
	//! Corresponds to Maya's userVector4PP.
 	//! [Default value] Color(0, 0, 0)
	ColorList get_user_color_pp_4() const { return getColorList("user_color_pp_4"); }

	//! Corresponds to Maya's userVector5PP.
 	//! [Default value] Color(0, 0, 0)
	bool set_user_color_pp_5(const ColorList& colorList) { return setValue("user_color_pp_5", colorList); }
	//! Corresponds to Maya's userVector5PP.
 	//! [Default value] Color(0, 0, 0)
	bool set_user_color_pp_5(const Color* colors, size_t count) { return setArray("user_color_pp_5", colors, count); }
	//! Corresponds to Maya's userVector5PP.
 	//! [Default value] Color(0, 0, 0)
	template<size_t count> bool set_user_color_pp_5(const Color (&colors)[count]) { return setArray("user_color_pp_5", colors, count); }
	//! Corresponds to Maya's userVector5PP.
 	//! [Default value] Color(0, 0, 0)
	ColorList get_user_color_pp_5() const { return getColorList("user_color_pp_5"); }

	//! Per-particle age.
 	//! [Default value] 0
	bool set_age_pp(const FloatList& floatList) { return setValue("age_pp", floatList); }
	//! Per-particle age.
 	//! [Default value] 0
	bool set_age_pp(const float* floats, size_t count) { return setArray("age_pp", floats, count); }
	//! Per-particle age.
 	//! [Default value] 0
	template<size_t count> bool set_age_pp(const float (&floats)[count]) { return setArray("age_pp", floats, count); }
	//! Per-particle age.
 	//! [Default value] 0
	FloatList get_age_pp() const { return getFloatList("age_pp"); }

	//! Per-particle lifespan.
 	//! [Default value] 0
	bool set_lifespan_pp(const FloatList& floatList) { return setValue("lifespan_pp", floatList); }
	//! Per-particle lifespan.
 	//! [Default value] 0
	bool set_lifespan_pp(const float* floats, size_t count) { return setArray("lifespan_pp", floats, count); }
	//! Per-particle lifespan.
 	//! [Default value] 0
	template<size_t count> bool set_lifespan_pp(const float (&floats)[count]) { return setArray("lifespan_pp", floats, count); }
	//! Per-particle lifespan.
 	//! [Default value] 0
	FloatList get_lifespan_pp() const { return getFloatList("lifespan_pp"); }

	//! Per-particle opacity.
 	//! [Default value] 0
	bool set_opacity_pp(const FloatList& floatList) { return setValue("opacity_pp", floatList); }
	//! Per-particle opacity.
 	//! [Default value] 0
	bool set_opacity_pp(const float* floats, size_t count) { return setArray("opacity_pp", floats, count); }
	//! Per-particle opacity.
 	//! [Default value] 0
	template<size_t count> bool set_opacity_pp(const float (&floats)[count]) { return setArray("opacity_pp", floats, count); }
	//! Per-particle opacity.
 	//! [Default value] 0
	FloatList get_opacity_pp() const { return getFloatList("opacity_pp"); }

	//! Corresponds to Maya's userScalar1PP.
 	//! [Default value] 0
	bool set_user_float_pp_1(const FloatList& floatList) { return setValue("user_float_pp_1", floatList); }
	//! Corresponds to Maya's userScalar1PP.
 	//! [Default value] 0
	bool set_user_float_pp_1(const float* floats, size_t count) { return setArray("user_float_pp_1", floats, count); }
	//! Corresponds to Maya's userScalar1PP.
 	//! [Default value] 0
	template<size_t count> bool set_user_float_pp_1(const float (&floats)[count]) { return setArray("user_float_pp_1", floats, count); }
	//! Corresponds to Maya's userScalar1PP.
 	//! [Default value] 0
	FloatList get_user_float_pp_1() const { return getFloatList("user_float_pp_1"); }

	//! Corresponds to Maya's userScalar2PP.
 	//! [Default value] 0
	bool set_user_float_pp_2(const FloatList& floatList) { return setValue("user_float_pp_2", floatList); }
	//! Corresponds to Maya's userScalar2PP.
 	//! [Default value] 0
	bool set_user_float_pp_2(const float* floats, size_t count) { return setArray("user_float_pp_2", floats, count); }
	//! Corresponds to Maya's userScalar2PP.
 	//! [Default value] 0
	template<size_t count> bool set_user_float_pp_2(const float (&floats)[count]) { return setArray("user_float_pp_2", floats, count); }
	//! Corresponds to Maya's userScalar2PP.
 	//! [Default value] 0
	FloatList get_user_float_pp_2() const { return getFloatList("user_float_pp_2"); }

	//! Corresponds to Maya's userScalar3PP.
 	//! [Default value] 0
	bool set_user_float_pp_3(const FloatList& floatList) { return setValue("user_float_pp_3", floatList); }
	//! Corresponds to Maya's userScalar3PP.
 	//! [Default value] 0
	bool set_user_float_pp_3(const float* floats, size_t count) { return setArray("user_float_pp_3", floats, count); }
	//! Corresponds to Maya's userScalar3PP.
 	//! [Default value] 0
	template<size_t count> bool set_user_float_pp_3(const float (&floats)[count]) { return setArray("user_float_pp_3", floats, count); }
	//! Corresponds to Maya's userScalar3PP.
 	//! [Default value] 0
	FloatList get_user_float_pp_3() const { return getFloatList("user_float_pp_3"); }

	//! Corresponds to Maya's userScalar4PP.
 	//! [Default value] 0
	bool set_user_float_pp_4(const FloatList& floatList) { return setValue("user_float_pp_4", floatList); }
	//! Corresponds to Maya's userScalar4PP.
 	//! [Default value] 0
	bool set_user_float_pp_4(const float* floats, size_t count) { return setArray("user_float_pp_4", floats, count); }
	//! Corresponds to Maya's userScalar4PP.
 	//! [Default value] 0
	template<size_t count> bool set_user_float_pp_4(const float (&floats)[count]) { return setArray("user_float_pp_4", floats, count); }
	//! Corresponds to Maya's userScalar4PP.
 	//! [Default value] 0
	FloatList get_user_float_pp_4() const { return getFloatList("user_float_pp_4"); }

	//! Corresponds to Maya's userScalar5PP.
 	//! [Default value] 0
	bool set_user_float_pp_5(const FloatList& floatList) { return setValue("user_float_pp_5", floatList); }
	//! Corresponds to Maya's userScalar5PP.
 	//! [Default value] 0
	bool set_user_float_pp_5(const float* floats, size_t count) { return setArray("user_float_pp_5", floats, count); }
	//! Corresponds to Maya's userScalar5PP.
 	//! [Default value] 0
	template<size_t count> bool set_user_float_pp_5(const float (&floats)[count]) { return setArray("user_float_pp_5", floats, count); }
	//! Corresponds to Maya's userScalar5PP.
 	//! [Default value] 0
	FloatList get_user_float_pp_5() const { return getFloatList("user_float_pp_5"); }

	//! The triangle mesh that will be instanced.This is used only for some of the particle render types.
 	bool set_mesh(const Plugin& plugin) { return setValue("mesh", plugin); }
	//! The triangle mesh that will be instanced.This is used only for some of the particle render types.
 	Plugin get_mesh() const { return getPlugin("mesh"); }

	//! 3 - multipoints; 4 - multistreak; 6 - points; 7 - Spheres; 8 - Sprites; 9 - Streak.Everything else gives a warning and renders as spheres.
 	//! [Default value] 7
	bool set_render_type(int val) { return setValue("render_type", val); }
	//! 3 - multipoints; 4 - multistreak; 6 - points; 7 - Spheres; 8 - Sprites; 9 - Streak.Everything else gives a warning and renders as spheres.
 	//! [Default value] 7
	int get_render_type() const { return getInt("render_type"); }

	//! The positions of the particles.
 	//! [Default value] Vector(0, 0, 0)
	bool set_positions(const VectorList& vectorList) { return setValue("positions", vectorList); }
	//! The positions of the particles.
 	//! [Default value] Vector(0, 0, 0)
	bool set_positions(const Vector* vectors, size_t count) { return setArray("positions", vectors, count); }
	//! The positions of the particles.
 	//! [Default value] Vector(0, 0, 0)
	template<size_t count> bool set_positions(const Vector (&vectors)[count]) { return setArray("positions", vectors, count); }
	//! The positions of the particles.
 	//! [Default value] Vector(0, 0, 0)
	VectorList get_positions() const { return getVectorList("positions"); }

	//! The velocities of the particles. This is in world units per frame.
 	//! [Default value] Vector(0, 0, 0)
	bool set_velocities(const VectorList& vectorList) { return setValue("velocities", vectorList); }
	//! The velocities of the particles. This is in world units per frame.
 	//! [Default value] Vector(0, 0, 0)
	bool set_velocities(const Vector* vectors, size_t count) { return setArray("velocities", vectors, count); }
	//! The velocities of the particles. This is in world units per frame.
 	//! [Default value] Vector(0, 0, 0)
	template<size_t count> bool set_velocities(const Vector (&vectors)[count]) { return setArray("velocities", vectors, count); }
	//! The velocities of the particles. This is in world units per frame.
 	//! [Default value] Vector(0, 0, 0)
	VectorList get_velocities() const { return getVectorList("velocities"); }

	//! The particle IDs. Some particles may disappear within the motion blur interval so we need these when storing moving primitives in MovingParticleGeomGen. This parameter is required to render motion blur.
 	//! [Default value] 0
	bool set_ids(const IntList& intList) { return setValue("ids", intList); }
	//! The particle IDs. Some particles may disappear within the motion blur interval so we need these when storing moving primitives in MovingParticleGeomGen. This parameter is required to render motion blur.
 	//! [Default value] 0
	bool set_ids(const int* ints, size_t count) { return setArray("ids", ints, count); }
	//! The particle IDs. Some particles may disappear within the motion blur interval so we need these when storing moving primitives in MovingParticleGeomGen. This parameter is required to render motion blur.
 	//! [Default value] 0
	template<size_t count> bool set_ids(const int (&ints)[count]) { return setArray("ids", ints, count); }
	//! The particle IDs. Some particles may disappear within the motion blur interval so we need these when storing moving primitives in MovingParticleGeomGen. This parameter is required to render motion blur.
 	//! [Default value] 0
	IntList get_ids() const { return getIntList("ids"); }

	//! The particle radii when the particles are spheres.
 	//! [Default value] 1
	bool set_radii(const FloatList& floatList) { return setValue("radii", floatList); }
	//! The particle radii when the particles are spheres.
 	//! [Default value] 1
	bool set_radii(const float* floats, size_t count) { return setArray("radii", floats, count); }
	//! The particle radii when the particles are spheres.
 	//! [Default value] 1
	template<size_t count> bool set_radii(const float (&floats)[count]) { return setArray("radii", floats, count); }
	//! The particle radii when the particles are spheres.
 	//! [Default value] 1
	FloatList get_radii() const { return getFloatList("radii"); }

	//! Per-Particle sprite number.
 	//! [Default value] 1
	bool set_sprite_num_pp(const IntList& intList) { return setValue("sprite_num_pp", intList); }
	//! Per-Particle sprite number.
 	//! [Default value] 1
	bool set_sprite_num_pp(const int* ints, size_t count) { return setArray("sprite_num_pp", ints, count); }
	//! Per-Particle sprite number.
 	//! [Default value] 1
	template<size_t count> bool set_sprite_num_pp(const int (&ints)[count]) { return setArray("sprite_num_pp", ints, count); }
	//! Per-Particle sprite number.
 	//! [Default value] 1
	IntList get_sprite_num_pp() const { return getIntList("sprite_num_pp"); }

	//! The constant particle radius when radii is empty.
 	//! [Default value] 1
	bool set_radius(float val) { return setValue("radius", val); }
	//! The constant particle radius when radii is empty.
 	//! [Default value] 1
	float get_radius() const { return getFloat("radius"); }

	//! The width of sprite particles in world units.
 	//! [Default value] 1
	bool set_sprite_size_x(float val) { return setValue("sprite_size_x", val); }
	//! The width of sprite particles in world units.
 	//! [Default value] 1
	float get_sprite_size_x() const { return getFloat("sprite_size_x"); }

	//! The height of sprite particles in world units.
 	//! [Default value] 1
	bool set_sprite_size_y(float val) { return setValue("sprite_size_y", val); }
	//! The height of sprite particles in world units.
 	//! [Default value] 1
	float get_sprite_size_y() const { return getFloat("sprite_size_y"); }

	//! The twist of sprite particles in degrees.
 	//! [Default value] 0
	bool set_sprite_twist(float val) { return setValue("sprite_twist", val); }
	//! The twist of sprite particles in degrees.
 	//! [Default value] 0
	float get_sprite_twist() const { return getFloat("sprite_twist"); }

	//! Parameter for per particle scale on the X-axis.
 	//! [Default value] 1
	bool set_sprite_scale_x(const FloatList& floatList) { return setValue("sprite_scale_x", floatList); }
	//! Parameter for per particle scale on the X-axis.
 	//! [Default value] 1
	bool set_sprite_scale_x(const float* floats, size_t count) { return setArray("sprite_scale_x", floats, count); }
	//! Parameter for per particle scale on the X-axis.
 	//! [Default value] 1
	template<size_t count> bool set_sprite_scale_x(const float (&floats)[count]) { return setArray("sprite_scale_x", floats, count); }
	//! Parameter for per particle scale on the X-axis.
 	//! [Default value] 1
	FloatList get_sprite_scale_x() const { return getFloatList("sprite_scale_x"); }

	//! Parameter for per particle scale on the Y-axis.
 	//! [Default value] 1
	bool set_sprite_scale_y(const FloatList& floatList) { return setValue("sprite_scale_y", floatList); }
	//! Parameter for per particle scale on the Y-axis.
 	//! [Default value] 1
	bool set_sprite_scale_y(const float* floats, size_t count) { return setArray("sprite_scale_y", floats, count); }
	//! Parameter for per particle scale on the Y-axis.
 	//! [Default value] 1
	template<size_t count> bool set_sprite_scale_y(const float (&floats)[count]) { return setArray("sprite_scale_y", floats, count); }
	//! Parameter for per particle scale on the Y-axis.
 	//! [Default value] 1
	FloatList get_sprite_scale_y() const { return getFloatList("sprite_scale_y"); }

	//! Parameter for per particle twist (z-axis rotation).
 	//! [Default value] 1
	bool set_sprite_rotate(const FloatList& floatList) { return setValue("sprite_rotate", floatList); }
	//! Parameter for per particle twist (z-axis rotation).
 	//! [Default value] 1
	bool set_sprite_rotate(const float* floats, size_t count) { return setArray("sprite_rotate", floats, count); }
	//! Parameter for per particle twist (z-axis rotation).
 	//! [Default value] 1
	template<size_t count> bool set_sprite_rotate(const float (&floats)[count]) { return setArray("sprite_rotate", floats, count); }
	//! Parameter for per particle twist (z-axis rotation).
 	//! [Default value] 1
	FloatList get_sprite_rotate() const { return getFloatList("sprite_rotate"); }

	//! 0 - orient sprites towards the camera center, 1 - orient sprites parallel to the camera plane
 	//! [Default value] 0
	bool set_sprite_orientation(int val) { return setValue("sprite_orientation", val); }
	//! 0 - orient sprites towards the camera center, 1 - orient sprites parallel to the camera plane
 	//! [Default value] 0
	int get_sprite_orientation() const { return getInt("sprite_orientation"); }

	//! The size of point and multipoint particles, in pixels.
 	//! [Default value] 1
	bool set_point_size(float val) { return setValue("point_size", val); }
	//! The size of point and multipoint particles, in pixels.
 	//! [Default value] 1
	float get_point_size() const { return getFloat("point_size"); }

	//! If true, the point size will be taken form radii parameter
 	//! [Default value] false
	bool set_point_radii(bool val) { return setValue("point_radii", val); }
	//! If true, the point size will be taken form radii parameter
 	//! [Default value] false
	bool get_point_radii() const { return getBool("point_radii"); }

	//! If true, the point size is in world space, not screen space
 	//! [Default value] false
	bool set_point_world_size(bool val) { return setValue("point_world_size", val); }
	//! If true, the point size is in world space, not screen space
 	//! [Default value] false
	bool get_point_world_size() const { return getBool("point_world_size"); }

	//! The number of particles generated for each input particle, when the render type is multipoints or multistreaks.
 	//! [Default value] 1
	bool set_multi_count(int val) { return setValue("multi_count", val); }
	//! The number of particles generated for each input particle, when the render type is multipoints or multistreaks.
 	//! [Default value] 1
	int get_multi_count() const { return getInt("multi_count"); }

	//! The maximum distance between the original and a generated particle when the render type is multipoints or multistreaks.
 	//! [Default value] 0
	bool set_multi_radius(float val) { return setValue("multi_radius", val); }
	//! The maximum distance between the original and a generated particle when the render type is multipoints or multistreaks.
 	//! [Default value] 0
	float get_multi_radius() const { return getFloat("multi_radius"); }

	//! The width of streak particles, in pixels
 	//! [Default value] 1
	bool set_line_width(float val) { return setValue("line_width", val); }
	//! The width of streak particles, in pixels
 	//! [Default value] 1
	float get_line_width() const { return getFloat("line_width"); }

	//! The length of streak particles, in world units, the actual length depends on the particle velocity as well.
 	//! [Default value] 1
	bool set_tail_length(float val) { return setValue("tail_length", val); }
	//! The length of streak particles, in world units, the actual length depends on the particle velocity as well.
 	//! [Default value] 1
	float get_tail_length() const { return getFloat("tail_length"); }

	//! If off, shading an intersection with this mesh will not generate a gbuffer.
 	//! [Default value] true
	bool set_primary_visibility(bool val) { return setValue("primary_visibility", val); }
	//! If off, shading an intersection with this mesh will not generate a gbuffer.
 	//! [Default value] true
	bool get_primary_visibility() const { return getBool("primary_visibility"); }

	//! External data source to be used instead of positions, velocities, ids and radii
 	bool set_data_source(const Plugin& plugin) { return setValue("data_source", plugin); }
	//! External data source to be used instead of positions, velocities, ids and radii
 	Plugin get_data_source() const { return getPlugin("data_source"); }
};

class GeomPartio : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "GeomPartio"; }

	//! (description missing)
	bool set_directory(const char* str) { return setValue("directory", str); }
	//! (description missing)
	bool set_directory(const std::string& str) { return setValue("directory", str); }
	//! (description missing)
	std::string get_directory() const { return getString("directory"); }

	//! (description missing)
	bool set_prefix(const char* str) { return setValue("prefix", str); }
	//! (description missing)
	bool set_prefix(const std::string& str) { return setValue("prefix", str); }
	//! (description missing)
	std::string get_prefix() const { return getString("prefix"); }

	//! (description missing)
	bool set_format(const char* str) { return setValue("format", str); }
	//! (description missing)
	bool set_format(const std::string& str) { return setValue("format", str); }
	//! (description missing)
	std::string get_format() const { return getString("format"); }

	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	bool set_default_color(const Color& color) { return setValue("default_color", color); }
	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	Color get_default_color() const { return getColor("default_color"); }

	//! (description missing)
	//! [Default value] 0
	bool set_cache_offset(int val) { return setValue("cache_offset", val); }
	//! (description missing)
	//! [Default value] 0
	int get_cache_offset() const { return getInt("cache_offset"); }

	//! (description missing)
	//! [Default value] 1
	bool set_by_frame(int val) { return setValue("by_frame", val); }
	//! (description missing)
	//! [Default value] 1
	int get_by_frame() const { return getInt("by_frame"); }

	//! (description missing)
	//! [Default value] false
	bool set_static(bool val) { return setValue("static", val); }
	//! (description missing)
	//! [Default value] false
	bool get_static() const { return getBool("static"); }
};

class GeomPlane : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "GeomPlane"; }
};

class GeomSphere : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "GeomSphere"; }

	//! Desired radius for the sphere
 	//! [Default value] 1
	bool set_radius(float val) { return setValue("radius", val); }
	//! Desired radius for the sphere
 	//! [Default value] 1
	float get_radius() const { return getFloat("radius"); }

	//! Number of subdivisions when generating sphere triangle mesh
 	//! [Default value] 8
	bool set_subdivs(int val) { return setValue("subdivs", val); }
	//! Number of subdivisions when generating sphere triangle mesh
 	//! [Default value] 8
	int get_subdivs() const { return getInt("subdivs"); }
};

class GeomStaticMesh : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "GeomStaticMesh"; }

	//! (description missing)
	bool set_vertices(const VectorList& vectorList) { return setValue("vertices", vectorList); }
	//! (description missing)
	bool set_vertices(const Vector* vectors, size_t count) { return setArray("vertices", vectors, count); }
	//! (description missing)
	template<size_t count> bool set_vertices(const Vector (&vectors)[count]) { return setArray("vertices", vectors, count); }
	//! (description missing)
	VectorList get_vertices() const { return getVectorList("vertices"); }

	//! (description missing)
	bool set_faces(const IntList& intList) { return setValue("faces", intList); }
	//! (description missing)
	bool set_faces(const int* ints, size_t count) { return setArray("faces", ints, count); }
	//! (description missing)
	template<size_t count> bool set_faces(const int (&ints)[count]) { return setArray("faces", ints, count); }
	//! (description missing)
	IntList get_faces() const { return getIntList("faces"); }

	//! (description missing)
	bool set_normals(const VectorList& vectorList) { return setValue("normals", vectorList); }
	//! (description missing)
	bool set_normals(const Vector* vectors, size_t count) { return setArray("normals", vectors, count); }
	//! (description missing)
	template<size_t count> bool set_normals(const Vector (&vectors)[count]) { return setArray("normals", vectors, count); }
	//! (description missing)
	VectorList get_normals() const { return getVectorList("normals"); }

	//! (description missing)
	bool set_faceNormals(const IntList& intList) { return setValue("faceNormals", intList); }
	//! (description missing)
	bool set_faceNormals(const int* ints, size_t count) { return setArray("faceNormals", ints, count); }
	//! (description missing)
	template<size_t count> bool set_faceNormals(const int (&ints)[count]) { return setArray("faceNormals", ints, count); }
	//! (description missing)
	IntList get_faceNormals() const { return getIntList("faceNormals"); }

	//! A list of mapping channels; each channel itself is a list of 3 elements - the channel index, the channel vertices and the channel faces.
 	bool set_map_channels(const ValueList& list) { return setValue("map_channels", list); }
	//! A list of mapping channels; each channel itself is a list of 3 elements - the channel index, the channel vertices and the channel faces.
 	ValueList get_map_channels() const { return getValueList("map_channels"); }

	//! A list containing the names of the mapping channels.
 	bool set_map_channels_names(const ValueList& stringList) { return setValue("map_channels_names", stringList); }
	//! A list containing the names of the mapping channels.
 	ValueList get_map_channels_names() const { return getValueList("map_channels_names"); }

	//! A list of edge visibility flags, each integer in the list has edge visibility information for 10 consecutive faces
 	bool set_edge_visibility(const IntList& intList) { return setValue("edge_visibility", intList); }
	//! A list of edge visibility flags, each integer in the list has edge visibility information for 10 consecutive faces
 	bool set_edge_visibility(const int* ints, size_t count) { return setArray("edge_visibility", ints, count); }
	//! A list of edge visibility flags, each integer in the list has edge visibility information for 10 consecutive faces
 	template<size_t count> bool set_edge_visibility(const int (&ints)[count]) { return setArray("edge_visibility", ints, count); }
	//! A list of edge visibility flags, each integer in the list has edge visibility information for 10 consecutive faces
 	IntList get_edge_visibility() const { return getIntList("edge_visibility"); }

	//! Material IDs for each face
 	bool set_face_mtlIDs(const IntList& intList) { return setValue("face_mtlIDs", intList); }
	//! Material IDs for each face
 	bool set_face_mtlIDs(const int* ints, size_t count) { return setArray("face_mtlIDs", ints, count); }
	//! Material IDs for each face
 	template<size_t count> bool set_face_mtlIDs(const int (&ints)[count]) { return setArray("face_mtlIDs", ints, count); }
	//! Material IDs for each face
 	IntList get_face_mtlIDs() const { return getIntList("face_mtlIDs"); }

	//! A list of mapping channels with smooth derivs; this can also be a single boolean value to specify whether all channels are smooth.
 	bool set_smooth_derivs(const ValueList& list) { return setValue("smooth_derivs", list); }
	//! A list of mapping channels with smooth derivs; this can also be a single boolean value to specify whether all channels are smooth.
 	ValueList get_smooth_derivs() const { return getValueList("smooth_derivs"); }

	//! If this parameter is present, the vertices of the mesh which are within the given threshold of one another will be welded. If absent or negative, no welding is performed.
 	//! [Default value] -1
	bool set_weld_threshold(float val) { return setValue("weld_threshold", val); }
	//! If this parameter is present, the vertices of the mesh which are within the given threshold of one another will be welded. If absent or negative, no welding is performed.
 	//! [Default value] -1
	float get_weld_threshold() const { return getFloat("weld_threshold"); }

	//! The reference mesh which is used to calculate the uvw coordinates when a 3d placement is used.
 	bool set_reference_mesh(const Plugin& plugin) { return setValue("reference_mesh", plugin); }
	//! The reference mesh which is used to calculate the uvw coordinates when a 3d placement is used.
 	Plugin get_reference_mesh() const { return getPlugin("reference_mesh"); }

	//! The transform of the reference mesh.
 	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	bool set_reference_transform(const Transform& transform) { return setValue("reference_transform", transform); }
	//! The transform of the reference mesh.
 	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	Transform get_reference_transform() const { return getTransform("reference_transform"); }

	//! If off shading an intersection with this mesh will not generate a gbuffer.
 	//! [Default value] true
	bool set_primary_visibility(bool val) { return setValue("primary_visibility", val); }
	//! If off shading an intersection with this mesh will not generate a gbuffer.
 	//! [Default value] true
	bool get_primary_visibility() const { return getBool("primary_visibility"); }

	//! When this flag is true V-Ray will use dynamic geometry for this mesh(instead of copying the mesh many times in the BSP tree, only the bounding box will be present many times and ray intersections will occur in a separate object space BSP tree)
 	//! [Default value] false
	bool set_dynamic_geometry(bool val) { return setValue("dynamic_geometry", val); }
	//! When this flag is true V-Ray will use dynamic geometry for this mesh(instead of copying the mesh many times in the BSP tree, only the bounding box will be present many times and ray intersections will occur in a separate object space BSP tree)
 	//! [Default value] false
	bool get_dynamic_geometry() const { return getBool("dynamic_geometry"); }

	//! True to smooth UVs at mesh borders when rendering this mesh as a subdivision surface.
 	//! [Default value] true
	bool set_smooth_uv_borders(bool val) { return setValue("smooth_uv_borders", val); }
	//! True to smooth UVs at mesh borders when rendering this mesh as a subdivision surface.
 	//! [Default value] true
	bool get_smooth_uv_borders() const { return getBool("smooth_uv_borders"); }

	//! True to smooth UVs when rendering this mesh as a subdivision surface.
 	//! [UI Guides] displayName=Smooth UVs
 	//! [Default value] true
	bool set_smooth_uv(bool val) { return setValue("smooth_uv", val); }
	//! True to smooth UVs when rendering this mesh as a subdivision surface.
 	//! [UI Guides] displayName=Smooth UVs
 	//! [Default value] true
	bool get_smooth_uv() const { return getBool("smooth_uv"); }

	//! Per vertex velocities, taken from a ColorSet in Maya
 	//! [Default value] Vector(0, 0, 0)
	bool set_velocities(const VectorList& vectorList) { return setValue("velocities", vectorList); }
	//! Per vertex velocities, taken from a ColorSet in Maya
 	//! [Default value] Vector(0, 0, 0)
	bool set_velocities(const Vector* vectors, size_t count) { return setArray("velocities", vectors, count); }
	//! Per vertex velocities, taken from a ColorSet in Maya
 	//! [Default value] Vector(0, 0, 0)
	template<size_t count> bool set_velocities(const Vector (&vectors)[count]) { return setArray("velocities", vectors, count); }
	//! Per vertex velocities, taken from a ColorSet in Maya
 	//! [Default value] Vector(0, 0, 0)
	VectorList get_velocities() const { return getVectorList("velocities"); }

	//! A list of indices of the first vertices of the polygons of degree greater than 4
 	bool set_first_poly_vertices(const IntList& intList) { return setValue("first_poly_vertices", intList); }
	//! A list of indices of the first vertices of the polygons of degree greater than 4
 	bool set_first_poly_vertices(const int* ints, size_t count) { return setArray("first_poly_vertices", ints, count); }
	//! A list of indices of the first vertices of the polygons of degree greater than 4
 	template<size_t count> bool set_first_poly_vertices(const int (&ints)[count]) { return setArray("first_poly_vertices", ints, count); }
	//! A list of indices of the first vertices of the polygons of degree greater than 4
 	IntList get_first_poly_vertices() const { return getIntList("first_poly_vertices"); }

	//! True to enable OpenSubdiv subdivision.
 	//! [UI Guides] startRollout=OpenSubdiv static subdivision, displayName=Enable OpenSubdiv
 	//! [Default value] true
	bool set_osd_subdiv_enable(bool val) { return setValue("osd_subdiv_enable", val); }
	//! True to enable OpenSubdiv subdivision.
 	//! [UI Guides] startRollout=OpenSubdiv static subdivision, displayName=Enable OpenSubdiv
 	//! [Default value] true
	bool get_osd_subdiv_enable() const { return getBool("osd_subdiv_enable"); }

	//! Level of OpenSubdiv subdivision. 0 means no subdivison.
 	//! [UI Guides] displayName=Subdivision level, minValue=0, enableIf: ?osd_subdiv_enable=1
 	//! [Default value] 0
	bool set_osd_subdiv_level(int val) { return setValue("osd_subdiv_level", val); }
	//! Level of OpenSubdiv subdivision. 0 means no subdivison.
 	//! [UI Guides] displayName=Subdivision level, minValue=0, enableIf: ?osd_subdiv_enable=1
 	//! [Default value] 0
	int get_osd_subdiv_level() const { return getInt("osd_subdiv_level"); }

	//! Type of OpenSubdiv subdivision. 0 - Catmull Clark, 1 - Loop
 	//! [UI Guides] displayName=Type, enum=0:Catmull-Clark;1:Loop, enableIf: ?osd_subdiv_level>0, ?osd_subdiv_enable=1
 	//! [Default value] 0
	bool set_osd_subdiv_type(int val) { return setValue("osd_subdiv_type", val); }
	//! Type of OpenSubdiv subdivision. 0 - Catmull Clark, 1 - Loop
 	//! [UI Guides] displayName=Type, enum=0:Catmull-Clark;1:Loop, enableIf: ?osd_subdiv_level>0, ?osd_subdiv_enable=1
 	//! [Default value] 0
	int get_osd_subdiv_type() const { return getInt("osd_subdiv_type"); }

	//! True to smooth UVs when applying subdivision with OpenSubdiv
 	//! [UI Guides] displayName=Subdivide UVs, enableIf: ?osd_subdiv_level>0, ?osd_subdiv_enable=1
 	//! [Default value] true
	bool set_osd_subdiv_uvs(bool val) { return setValue("osd_subdiv_uvs", val); }
	//! True to smooth UVs when applying subdivision with OpenSubdiv
 	//! [UI Guides] displayName=Subdivide UVs, enableIf: ?osd_subdiv_level>0, ?osd_subdiv_enable=1
 	//! [Default value] true
	bool get_osd_subdiv_uvs() const { return getBool("osd_subdiv_uvs"); }

	//! Different modes for subdividing the uv boundaries with OpenSubdiv. The valid values are: 0 - none; 1 - internal; 2 - all
 	//! [UI Guides] displayName=Preserve map borders, enum=0:None;1:Internal;2:All, enableIf: ?osd_subdiv_level>0, ?osd_subdiv_uvs=1, ?osd_subdiv_enable=1
 	//! [Default value] 1
	bool set_osd_preserve_map_borders(int val) { return setValue("osd_preserve_map_borders", val); }
	//! Different modes for subdividing the uv boundaries with OpenSubdiv. The valid values are: 0 - none; 1 - internal; 2 - all
 	//! [UI Guides] displayName=Preserve map borders, enum=0:None;1:Internal;2:All, enableIf: ?osd_subdiv_level>0, ?osd_subdiv_uvs=1, ?osd_subdiv_enable=1
 	//! [Default value] 1
	int get_osd_preserve_map_borders() const { return getInt("osd_preserve_map_borders"); }

	//! True to keep the geometry boundaries in place while subdividing the mesh with OpenSubdiv.
 	//! [UI Guides] displayName=Preserve geometry borders, enableIf: ?osd_subdiv_level>0, ?osd_subdiv_enable=1
 	//! [Default value] false
	bool set_osd_preserve_geometry_borders(bool val) { return setValue("osd_preserve_geometry_borders", val); }
	//! True to keep the geometry boundaries in place while subdividing the mesh with OpenSubdiv.
 	//! [UI Guides] displayName=Preserve geometry borders, enableIf: ?osd_subdiv_level>0, ?osd_subdiv_enable=1
 	//! [Default value] false
	bool get_osd_preserve_geometry_borders() const { return getBool("osd_preserve_geometry_borders"); }

	//! The indices of the vertices of the creased edges. Contains two indices per edge.
 	//! [Default value] 0
	bool set_edge_creases_vertices(const IntList& intList) { return setValue("edge_creases_vertices", intList); }
	//! The indices of the vertices of the creased edges. Contains two indices per edge.
 	//! [Default value] 0
	bool set_edge_creases_vertices(const int* ints, size_t count) { return setArray("edge_creases_vertices", ints, count); }
	//! The indices of the vertices of the creased edges. Contains two indices per edge.
 	//! [Default value] 0
	template<size_t count> bool set_edge_creases_vertices(const int (&ints)[count]) { return setArray("edge_creases_vertices", ints, count); }
	//! The indices of the vertices of the creased edges. Contains two indices per edge.
 	//! [Default value] 0
	IntList get_edge_creases_vertices() const { return getIntList("edge_creases_vertices"); }

	//! Sharpness values for each creased edge.
 	//! [Default value] 0
	bool set_edge_creases_sharpness(const FloatList& floatList) { return setValue("edge_creases_sharpness", floatList); }
	//! Sharpness values for each creased edge.
 	//! [Default value] 0
	bool set_edge_creases_sharpness(const float* floats, size_t count) { return setArray("edge_creases_sharpness", floats, count); }
	//! Sharpness values for each creased edge.
 	//! [Default value] 0
	template<size_t count> bool set_edge_creases_sharpness(const float (&floats)[count]) { return setArray("edge_creases_sharpness", floats, count); }
	//! Sharpness values for each creased edge.
 	//! [Default value] 0
	FloatList get_edge_creases_sharpness() const { return getFloatList("edge_creases_sharpness"); }

	//! A list of creased vertices.
 	//! [Default value] 0
	bool set_vertex_creases_vertices(const IntList& intList) { return setValue("vertex_creases_vertices", intList); }
	//! A list of creased vertices.
 	//! [Default value] 0
	bool set_vertex_creases_vertices(const int* ints, size_t count) { return setArray("vertex_creases_vertices", ints, count); }
	//! A list of creased vertices.
 	//! [Default value] 0
	template<size_t count> bool set_vertex_creases_vertices(const int (&ints)[count]) { return setArray("vertex_creases_vertices", ints, count); }
	//! A list of creased vertices.
 	//! [Default value] 0
	IntList get_vertex_creases_vertices() const { return getIntList("vertex_creases_vertices"); }

	//! The sharpness values of the creased vertices.
 	//! [Default value] 0
	bool set_vertex_creases_sharpness(const FloatList& floatList) { return setValue("vertex_creases_sharpness", floatList); }
	//! The sharpness values of the creased vertices.
 	//! [Default value] 0
	bool set_vertex_creases_sharpness(const float* floats, size_t count) { return setArray("vertex_creases_sharpness", floats, count); }
	//! The sharpness values of the creased vertices.
 	//! [Default value] 0
	template<size_t count> bool set_vertex_creases_sharpness(const float (&floats)[count]) { return setArray("vertex_creases_sharpness", floats, count); }
	//! The sharpness values of the creased vertices.
 	//! [Default value] 0
	FloatList get_vertex_creases_sharpness() const { return getFloatList("vertex_creases_sharpness"); }
};

class GeomStaticNURBS : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "GeomStaticNURBS"; }

	//! List of lists with the CVs of the NURBS.
 	bool set_cvs(const ValueList& list) { return setValue("cvs", list); }
	//! List of lists with the CVs of the NURBS.
 	ValueList get_cvs() const { return getValueList("cvs"); }

	//! List of lists with the weights for the NURBS's CVs.
 	bool set_weights(const ValueList& list) { return setValue("weights", list); }
	//! List of lists with the weights for the NURBS's CVs.
 	ValueList get_weights() const { return getValueList("weights"); }

	//! List of TrimmingRegion objects. The orientation is used to determine whether the trim will generate geometry inside of it or outside of it
 	bool set_trims(const ValueList& pluginList) { return setValue("trims", pluginList); }
	//! List of TrimmingRegion objects. The orientation is used to determine whether the trim will generate geometry inside of it or outside of it
 	ValueList get_trims() const { return getValueList("trims"); }

	//! List of NURBSCurve objects - the trimming curves
 	bool set_listTrimCurves(const ValueList& pluginList) { return setValue("listTrimCurves", pluginList); }
	//! List of NURBSCurve objects - the trimming curves
 	ValueList get_listTrimCurves() const { return getValueList("listTrimCurves"); }

	//! A single plug-in containing all the trim information.
 	bool set_trimsComplex(const Plugin& plugin) { return setValue("trimsComplex", plugin); }
	//! A single plug-in containing all the trim information.
 	Plugin get_trimsComplex() const { return getPlugin("trimsComplex"); }

	//! U direction knot values
 	//! [Default value] 0
	bool set_uKnots(const FloatList& floatList) { return setValue("uKnots", floatList); }
	//! U direction knot values
 	//! [Default value] 0
	bool set_uKnots(const float* floats, size_t count) { return setArray("uKnots", floats, count); }
	//! U direction knot values
 	//! [Default value] 0
	template<size_t count> bool set_uKnots(const float (&floats)[count]) { return setArray("uKnots", floats, count); }
	//! U direction knot values
 	//! [Default value] 0
	FloatList get_uKnots() const { return getFloatList("uKnots"); }

	//! V direction knot values
 	//! [Default value] 0
	bool set_vKnots(const FloatList& floatList) { return setValue("vKnots", floatList); }
	//! V direction knot values
 	//! [Default value] 0
	bool set_vKnots(const float* floats, size_t count) { return setArray("vKnots", floats, count); }
	//! V direction knot values
 	//! [Default value] 0
	template<size_t count> bool set_vKnots(const float (&floats)[count]) { return setArray("vKnots", floats, count); }
	//! V direction knot values
 	//! [Default value] 0
	FloatList get_vKnots() const { return getFloatList("vKnots"); }

	//! (description missing)
	//! [Default value] 5
	bool set_maxSubdivDepth(int val) { return setValue("maxSubdivDepth", val); }
	//! (description missing)
	//! [Default value] 5
	int get_maxSubdivDepth() const { return getInt("maxSubdivDepth"); }

	//! (description missing)
	//! [Default value] 0.01
	bool set_flatnessCoef(float val) { return setValue("flatnessCoef", val); }
	//! (description missing)
	//! [Default value] 0.01
	float get_flatnessCoef() const { return getFloat("flatnessCoef"); }

	//! (description missing)
	//! [Default value] false
	bool set_regularSubdiv(bool val) { return setValue("regularSubdiv", val); }
	//! (description missing)
	//! [Default value] false
	bool get_regularSubdiv() const { return getBool("regularSubdiv"); }

	//! (description missing)
	//! [Default value] 20
	bool set_regularUSteps(int val) { return setValue("regularUSteps", val); }
	//! (description missing)
	//! [Default value] 20
	int get_regularUSteps() const { return getInt("regularUSteps"); }

	//! (description missing)
	//! [Default value] 20
	bool set_regularVSteps(int val) { return setValue("regularVSteps", val); }
	//! (description missing)
	//! [Default value] 20
	int get_regularVSteps() const { return getInt("regularVSteps"); }

	//! (description missing)
	//! [Default value] 0
	bool set_uDirectionType(int val) { return setValue("uDirectionType", val); }
	//! (description missing)
	//! [Default value] 0
	int get_uDirectionType() const { return getInt("uDirectionType"); }

	//! (description missing)
	//! [Default value] 0
	bool set_vDirectionType(int val) { return setValue("vDirectionType", val); }
	//! (description missing)
	//! [Default value] 0
	int get_vDirectionType() const { return getInt("vDirectionType"); }

	//! (description missing)
	//! [Default value] 3
	bool set_uDegree(int val) { return setValue("uDegree", val); }
	//! (description missing)
	//! [Default value] 3
	int get_uDegree() const { return getInt("uDegree"); }

	//! (description missing)
	//! [Default value] 3
	bool set_vDegree(int val) { return setValue("vDegree", val); }
	//! (description missing)
	//! [Default value] 3
	int get_vDegree() const { return getInt("vDegree"); }

	//! (description missing)
	//! [Default value] false
	bool set_flipNormals(bool val) { return setValue("flipNormals", val); }
	//! (description missing)
	//! [Default value] false
	bool get_flipNormals() const { return getBool("flipNormals"); }

	//! (description missing)
	//! [Default value] false
	bool set_generateStatic(bool val) { return setValue("generateStatic", val); }
	//! (description missing)
	//! [Default value] false
	bool get_generateStatic() const { return getBool("generateStatic"); }

	//! (description missing)
	//! [Default value] true
	bool set_primary_visibility(bool val) { return setValue("primary_visibility", val); }
	//! (description missing)
	//! [Default value] true
	bool get_primary_visibility() const { return getBool("primary_visibility"); }

	//! The reference nurbs object which is used to calculate the uvw coordinates when a 3d placement is used.
 	bool set_reference_nurbs(const Plugin& plugin) { return setValue("reference_nurbs", plugin); }
	//! The reference nurbs object which is used to calculate the uvw coordinates when a 3d placement is used.
 	Plugin get_reference_nurbs() const { return getPlugin("reference_nurbs"); }

	//! The transform of the reference nurbs object.
 	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	bool set_reference_transform(const Transform& transform) { return setValue("reference_transform", transform); }
	//! The transform of the reference nurbs object.
 	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	Transform get_reference_transform() const { return getTransform("reference_transform"); }
};

class GeomStaticSmoothedMesh : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "GeomStaticSmoothedMesh"; }

	//! The triangle mesh that will be displaced
 	bool set_mesh(const Plugin& plugin) { return setValue("mesh", plugin); }
	//! The triangle mesh that will be displaced
 	Plugin get_mesh() const { return getPlugin("mesh"); }

	//! The displacement texture
 	bool set_displacement_tex_color(const Plugin& texture) { return setValue("displacement_tex_color", texture); }
	//! The displacement texture
 	bool set_displacement_tex_color(const AColor& texture) { return setValue("displacement_tex_color", texture); }
	//! The displacement texture
 	Value get_displacement_tex_color() const { return getValue("displacement_tex_color"); }

	//! The displacement texture
 	bool set_displacement_tex_float(const Plugin& texturefloat) { return setValue("displacement_tex_float", texturefloat); }
	//! The displacement texture
 	bool set_displacement_tex_float(float texturefloat) { return setValue("displacement_tex_float", texturefloat); }
	//! The displacement texture
 	Value get_displacement_tex_float() const { return getValue("displacement_tex_float"); }

	//! Determines the displacement amount for white areas in the displacement map; if use_globals is true this is multiplied by the global displacement amount option.
 	//! [Default value] 1
	bool set_displacement_amount(float val) { return setValue("displacement_amount", val); }
	//! Determines the displacement amount for white areas in the displacement map; if use_globals is true this is multiplied by the global displacement amount option.
 	//! [Default value] 1
	float get_displacement_amount() const { return getFloat("displacement_amount"); }

	//! This constant value is added to the displacement map
 	//! [Default value] 0
	bool set_displacement_shift(float val) { return setValue("displacement_shift", val); }
	//! This constant value is added to the displacement map
 	//! [Default value] 0
	float get_displacement_shift() const { return getFloat("displacement_shift"); }

	//! If true, the plugin will attempt to keep the continuity of the displaced surface
 	//! [Default value] false
	bool set_keep_continuity(bool val) { return setValue("keep_continuity", val); }
	//! If true, the plugin will attempt to keep the continuity of the displaced surface
 	//! [Default value] false
	bool get_keep_continuity() const { return getBool("keep_continuity"); }

	//! Geometry below this displacement level will be clipped away
 	//! [Default value] -1e+030
	bool set_water_level(float val) { return setValue("water_level", val); }
	//! Geometry below this displacement level will be clipped away
 	//! [Default value] -1e+030
	float get_water_level() const { return getFloat("water_level"); }

	//! When this is 1, the red, green and blue channels of displacement_tex_color will be used to perform vector displacement with base 0.5; if this is 2, then the map matches the Mudbox displacement maps in absolute tangent space; 3 - vector displacement in object space.
 	//! [Default value] 0
	bool set_vector_displacement(int val) { return setValue("vector_displacement", val); }
	//! When this is 1, the red, green and blue channels of displacement_tex_color will be used to perform vector displacement with base 0.5; if this is 2, then the map matches the Mudbox displacement maps in absolute tangent space; 3 - vector displacement in object space.
 	//! [Default value] 0
	int get_vector_displacement() const { return getInt("vector_displacement"); }

	//! The mapping channel to use for vector displacement.
 	//! [Default value] 0
	bool set_map_channel(int val) { return setValue("map_channel", val); }
	//! The mapping channel to use for vector displacement.
 	//! [Default value] 0
	int get_map_channel() const { return getInt("map_channel"); }

	//! This parameter overrides the imgWidth paramter from VRayFrameData during the calculation of the subdivision depth.
 	//! [Default value] 0
	bool set_image_width(int val) { return setValue("image_width", val); }
	//! This parameter overrides the imgWidth paramter from VRayFrameData during the calculation of the subdivision depth.
 	//! [Default value] 0
	int get_image_width() const { return getInt("image_width"); }

	//! If this option is equal to 1 then the normals of the generated triangles are cached. It has effect only if the surface is displaced.
 	//! [Default value] false
	bool set_cache_normals(bool val) { return setValue("cache_normals", val); }
	//! If this option is equal to 1 then the normals of the generated triangles are cached. It has effect only if the surface is displaced.
 	//! [Default value] false
	bool get_cache_normals() const { return getBool("cache_normals"); }

	//! If true, the parent transformation will affect the amount of displacement. Used only when doing 3D displacement.
 	//! [Default value] false
	bool set_object_space_displacement(bool val) { return setValue("object_space_displacement", val); }
	//! If true, the parent transformation will affect the amount of displacement. Used only when doing 3D displacement.
 	//! [Default value] false
	bool get_object_space_displacement() const { return getBool("object_space_displacement"); }

	//! True if the resulting triangles of the subdivision algorithm will be inserted into the rayserver as static geometry.
 	//! [UI Guides] displayName=Static subdivision
 	//! [Default value] false
	bool set_static_subdiv(bool val) { return setValue("static_subdiv", val); }
	//! True if the resulting triangles of the subdivision algorithm will be inserted into the rayserver as static geometry.
 	//! [UI Guides] displayName=Static subdivision
 	//! [Default value] false
	bool get_static_subdiv() const { return getBool("static_subdiv"); }

	//! If true, the global displacement quality settings will be used.
 	//! [UI Guides] displayName=Use global settings
 	//! [Default value] true
	bool set_use_globals(bool val) { return setValue("use_globals", val); }
	//! If true, the global displacement quality settings will be used.
 	//! [UI Guides] displayName=Use global settings
 	//! [Default value] true
	bool get_use_globals() const { return getBool("use_globals"); }

	//! If use_globals is false, this determines if view-dependent tesselation is used.
 	//! [UI Guides] displayName=View dependent, enableIf: ?use_globals=0
 	//! [Default value] true
	bool set_view_dep(bool val) { return setValue("view_dep", val); }
	//! If use_globals is false, this determines if view-dependent tesselation is used.
 	//! [UI Guides] displayName=View dependent, enableIf: ?use_globals=0
 	//! [Default value] true
	bool get_view_dep() const { return getBool("view_dep"); }

	//! If use_globals is false, this determines the approximate edge length for the sub-triangles.
 	//! [UI Guides] displayName=Edge length, enableIf: ?use_globals=0, minValue=0
 	//! [Default value] 4
	bool set_edge_length(float val) { return setValue("edge_length", val); }
	//! If use_globals is false, this determines the approximate edge length for the sub-triangles.
 	//! [UI Guides] displayName=Edge length, enableIf: ?use_globals=0, minValue=0
 	//! [Default value] 4
	float get_edge_length() const { return getFloat("edge_length"); }

	//! If use_globals is false, this determines the maximum subdivisions for a triangle of the original mesh.
 	//! [UI Guides] displayName=Max subdivisions, enableIf: ?use_globals=0, minValue=0
 	//! [Default value] 256
	bool set_max_subdivs(int val) { return setValue("max_subdivs", val); }
	//! If use_globals is false, this determines the maximum subdivisions for a triangle of the original mesh.
 	//! [UI Guides] displayName=Max subdivisions, enableIf: ?use_globals=0, minValue=0
 	//! [Default value] 256
	int get_max_subdivs() const { return getInt("max_subdivs"); }

	//! If true, the min/max values for the displacement texture are specified by the min_bound and max_bound parameters; if false, these are calculated automatically.
 	//! [Default value] false
	bool set_use_bounds(bool val) { return setValue("use_bounds", val); }
	//! If true, the min/max values for the displacement texture are specified by the min_bound and max_bound parameters; if false, these are calculated automatically.
 	//! [Default value] false
	bool get_use_bounds() const { return getBool("use_bounds"); }

	//! The lowest value for the displacement texture
 	//! [Default value] Color(0, 0, 0)
	bool set_min_bound(const Color& color) { return setValue("min_bound", color); }
	//! The lowest value for the displacement texture
 	//! [Default value] Color(0, 0, 0)
	Color get_min_bound() const { return getColor("min_bound"); }

	//! The biggest value for the displacement texture
 	//! [Default value] Color(1, 1, 1)
	bool set_max_bound(const Color& color) { return setValue("max_bound", color); }
	//! The biggest value for the displacement texture
 	//! [Default value] Color(1, 1, 1)
	Color get_max_bound() const { return getColor("max_bound"); }

	//! The valid values are: -1 - not set; 0 - none; 1 - internal; 2 - all
 	//! [UI Guides] displayName=Preserve map borders, enum=0:None;1:Internal;2:All
 	//! [Default value] -1
	bool set_preserve_map_borders(int val) { return setValue("preserve_map_borders", val); }
	//! The valid values are: -1 - not set; 0 - none; 1 - internal; 2 - all
 	//! [UI Guides] displayName=Preserve map borders, enum=0:None;1:Internal;2:All
 	//! [Default value] -1
	int get_preserve_map_borders() const { return getInt("preserve_map_borders"); }

	//! If equal to 1 then the classical Catmull-Clark masks will be used for meshes which contain only quadrangles.
 	//! [UI Guides] displayName=Classic Catmull-Clark
 	//! [Default value] false
	bool set_classic_catmark(bool val) { return setValue("classic_catmark", val); }
	//! If equal to 1 then the classical Catmull-Clark masks will be used for meshes which contain only quadrangles.
 	//! [UI Guides] displayName=Classic Catmull-Clark
 	//! [Default value] false
	bool get_classic_catmark() const { return getBool("classic_catmark"); }
};

class Instancer : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "Instancer"; }

	//! Per-particle acceleration.
 	//! [Default value] Color(0, 0, 0)
	bool set_acceleration_pp(const ColorList& colorList) { return setValue("acceleration_pp", colorList); }
	//! Per-particle acceleration.
 	//! [Default value] Color(0, 0, 0)
	bool set_acceleration_pp(const Color* colors, size_t count) { return setArray("acceleration_pp", colors, count); }
	//! Per-particle acceleration.
 	//! [Default value] Color(0, 0, 0)
	template<size_t count> bool set_acceleration_pp(const Color (&colors)[count]) { return setArray("acceleration_pp", colors, count); }
	//! Per-particle acceleration.
 	//! [Default value] Color(0, 0, 0)
	ColorList get_acceleration_pp() const { return getColorList("acceleration_pp"); }

	//! Per-particle diffuse color.
 	//! [Default value] Color(1, 1, 1)
	bool set_colors(const ColorList& colorList) { return setValue("colors", colorList); }
	//! Per-particle diffuse color.
 	//! [Default value] Color(1, 1, 1)
	bool set_colors(const Color* colors, size_t count) { return setArray("colors", colors, count); }
	//! Per-particle diffuse color.
 	//! [Default value] Color(1, 1, 1)
	template<size_t count> bool set_colors(const Color (&colors)[count]) { return setArray("colors", colors, count); }
	//! Per-particle diffuse color.
 	//! [Default value] Color(1, 1, 1)
	ColorList get_colors() const { return getColorList("colors"); }

	//! Per-particle emission color.
 	//! [Default value] Color(0, 0, 0)
	bool set_emission_pp(const ColorList& colorList) { return setValue("emission_pp", colorList); }
	//! Per-particle emission color.
 	//! [Default value] Color(0, 0, 0)
	bool set_emission_pp(const Color* colors, size_t count) { return setArray("emission_pp", colors, count); }
	//! Per-particle emission color.
 	//! [Default value] Color(0, 0, 0)
	template<size_t count> bool set_emission_pp(const Color (&colors)[count]) { return setArray("emission_pp", colors, count); }
	//! Per-particle emission color.
 	//! [Default value] Color(0, 0, 0)
	ColorList get_emission_pp() const { return getColorList("emission_pp"); }

	//! Corresponds to Maya's userVector1PP.
 	//! [Default value] Color(0, 0, 0)
	bool set_user_color_pp_1(const ColorList& colorList) { return setValue("user_color_pp_1", colorList); }
	//! Corresponds to Maya's userVector1PP.
 	//! [Default value] Color(0, 0, 0)
	bool set_user_color_pp_1(const Color* colors, size_t count) { return setArray("user_color_pp_1", colors, count); }
	//! Corresponds to Maya's userVector1PP.
 	//! [Default value] Color(0, 0, 0)
	template<size_t count> bool set_user_color_pp_1(const Color (&colors)[count]) { return setArray("user_color_pp_1", colors, count); }
	//! Corresponds to Maya's userVector1PP.
 	//! [Default value] Color(0, 0, 0)
	ColorList get_user_color_pp_1() const { return getColorList("user_color_pp_1"); }

	//! Corresponds to Maya's userVector2PP.
 	//! [Default value] Color(0, 0, 0)
	bool set_user_color_pp_2(const ColorList& colorList) { return setValue("user_color_pp_2", colorList); }
	//! Corresponds to Maya's userVector2PP.
 	//! [Default value] Color(0, 0, 0)
	bool set_user_color_pp_2(const Color* colors, size_t count) { return setArray("user_color_pp_2", colors, count); }
	//! Corresponds to Maya's userVector2PP.
 	//! [Default value] Color(0, 0, 0)
	template<size_t count> bool set_user_color_pp_2(const Color (&colors)[count]) { return setArray("user_color_pp_2", colors, count); }
	//! Corresponds to Maya's userVector2PP.
 	//! [Default value] Color(0, 0, 0)
	ColorList get_user_color_pp_2() const { return getColorList("user_color_pp_2"); }

	//! Corresponds to Maya's userVector3PP.
 	//! [Default value] Color(0, 0, 0)
	bool set_user_color_pp_3(const ColorList& colorList) { return setValue("user_color_pp_3", colorList); }
	//! Corresponds to Maya's userVector3PP.
 	//! [Default value] Color(0, 0, 0)
	bool set_user_color_pp_3(const Color* colors, size_t count) { return setArray("user_color_pp_3", colors, count); }
	//! Corresponds to Maya's userVector3PP.
 	//! [Default value] Color(0, 0, 0)
	template<size_t count> bool set_user_color_pp_3(const Color (&colors)[count]) { return setArray("user_color_pp_3", colors, count); }
	//! Corresponds to Maya's userVector3PP.
 	//! [Default value] Color(0, 0, 0)
	ColorList get_user_color_pp_3() const { return getColorList("user_color_pp_3"); }

	//! Corresponds to Maya's userVector4PP.
 	//! [Default value] Color(0, 0, 0)
	bool set_user_color_pp_4(const ColorList& colorList) { return setValue("user_color_pp_4", colorList); }
	//! Corresponds to Maya's userVector4PP.
 	//! [Default value] Color(0, 0, 0)
	bool set_user_color_pp_4(const Color* colors, size_t count) { return setArray("user_color_pp_4", colors, count); }
	//! Corresponds to Maya's userVector4PP.
 	//! [Default value] Color(0, 0, 0)
	template<size_t count> bool set_user_color_pp_4(const Color (&colors)[count]) { return setArray("user_color_pp_4", colors, count); }
	//! Corresponds to Maya's userVector4PP.
 	//! [Default value] Color(0, 0, 0)
	ColorList get_user_color_pp_4() const { return getColorList("user_color_pp_4"); }

	//! Corresponds to Maya's userVector5PP.
 	//! [Default value] Color(0, 0, 0)
	bool set_user_color_pp_5(const ColorList& colorList) { return setValue("user_color_pp_5", colorList); }
	//! Corresponds to Maya's userVector5PP.
 	//! [Default value] Color(0, 0, 0)
	bool set_user_color_pp_5(const Color* colors, size_t count) { return setArray("user_color_pp_5", colors, count); }
	//! Corresponds to Maya's userVector5PP.
 	//! [Default value] Color(0, 0, 0)
	template<size_t count> bool set_user_color_pp_5(const Color (&colors)[count]) { return setArray("user_color_pp_5", colors, count); }
	//! Corresponds to Maya's userVector5PP.
 	//! [Default value] Color(0, 0, 0)
	ColorList get_user_color_pp_5() const { return getColorList("user_color_pp_5"); }

	//! Per-particle age.
 	//! [Default value] 0
	bool set_age_pp(const FloatList& floatList) { return setValue("age_pp", floatList); }
	//! Per-particle age.
 	//! [Default value] 0
	bool set_age_pp(const float* floats, size_t count) { return setArray("age_pp", floats, count); }
	//! Per-particle age.
 	//! [Default value] 0
	template<size_t count> bool set_age_pp(const float (&floats)[count]) { return setArray("age_pp", floats, count); }
	//! Per-particle age.
 	//! [Default value] 0
	FloatList get_age_pp() const { return getFloatList("age_pp"); }

	//! Per-particle lifespan.
 	//! [Default value] 0
	bool set_lifespan_pp(const FloatList& floatList) { return setValue("lifespan_pp", floatList); }
	//! Per-particle lifespan.
 	//! [Default value] 0
	bool set_lifespan_pp(const float* floats, size_t count) { return setArray("lifespan_pp", floats, count); }
	//! Per-particle lifespan.
 	//! [Default value] 0
	template<size_t count> bool set_lifespan_pp(const float (&floats)[count]) { return setArray("lifespan_pp", floats, count); }
	//! Per-particle lifespan.
 	//! [Default value] 0
	FloatList get_lifespan_pp() const { return getFloatList("lifespan_pp"); }

	//! Per-particle opacity.
 	//! [Default value] 0
	bool set_opacity_pp(const FloatList& floatList) { return setValue("opacity_pp", floatList); }
	//! Per-particle opacity.
 	//! [Default value] 0
	bool set_opacity_pp(const float* floats, size_t count) { return setArray("opacity_pp", floats, count); }
	//! Per-particle opacity.
 	//! [Default value] 0
	template<size_t count> bool set_opacity_pp(const float (&floats)[count]) { return setArray("opacity_pp", floats, count); }
	//! Per-particle opacity.
 	//! [Default value] 0
	FloatList get_opacity_pp() const { return getFloatList("opacity_pp"); }

	//! Corresponds to Maya's userScalar1PP.
 	//! [Default value] 0
	bool set_user_float_pp_1(const FloatList& floatList) { return setValue("user_float_pp_1", floatList); }
	//! Corresponds to Maya's userScalar1PP.
 	//! [Default value] 0
	bool set_user_float_pp_1(const float* floats, size_t count) { return setArray("user_float_pp_1", floats, count); }
	//! Corresponds to Maya's userScalar1PP.
 	//! [Default value] 0
	template<size_t count> bool set_user_float_pp_1(const float (&floats)[count]) { return setArray("user_float_pp_1", floats, count); }
	//! Corresponds to Maya's userScalar1PP.
 	//! [Default value] 0
	FloatList get_user_float_pp_1() const { return getFloatList("user_float_pp_1"); }

	//! Corresponds to Maya's userScalar2PP.
 	//! [Default value] 0
	bool set_user_float_pp_2(const FloatList& floatList) { return setValue("user_float_pp_2", floatList); }
	//! Corresponds to Maya's userScalar2PP.
 	//! [Default value] 0
	bool set_user_float_pp_2(const float* floats, size_t count) { return setArray("user_float_pp_2", floats, count); }
	//! Corresponds to Maya's userScalar2PP.
 	//! [Default value] 0
	template<size_t count> bool set_user_float_pp_2(const float (&floats)[count]) { return setArray("user_float_pp_2", floats, count); }
	//! Corresponds to Maya's userScalar2PP.
 	//! [Default value] 0
	FloatList get_user_float_pp_2() const { return getFloatList("user_float_pp_2"); }

	//! Corresponds to Maya's userScalar3PP.
 	//! [Default value] 0
	bool set_user_float_pp_3(const FloatList& floatList) { return setValue("user_float_pp_3", floatList); }
	//! Corresponds to Maya's userScalar3PP.
 	//! [Default value] 0
	bool set_user_float_pp_3(const float* floats, size_t count) { return setArray("user_float_pp_3", floats, count); }
	//! Corresponds to Maya's userScalar3PP.
 	//! [Default value] 0
	template<size_t count> bool set_user_float_pp_3(const float (&floats)[count]) { return setArray("user_float_pp_3", floats, count); }
	//! Corresponds to Maya's userScalar3PP.
 	//! [Default value] 0
	FloatList get_user_float_pp_3() const { return getFloatList("user_float_pp_3"); }

	//! Corresponds to Maya's userScalar4PP.
 	//! [Default value] 0
	bool set_user_float_pp_4(const FloatList& floatList) { return setValue("user_float_pp_4", floatList); }
	//! Corresponds to Maya's userScalar4PP.
 	//! [Default value] 0
	bool set_user_float_pp_4(const float* floats, size_t count) { return setArray("user_float_pp_4", floats, count); }
	//! Corresponds to Maya's userScalar4PP.
 	//! [Default value] 0
	template<size_t count> bool set_user_float_pp_4(const float (&floats)[count]) { return setArray("user_float_pp_4", floats, count); }
	//! Corresponds to Maya's userScalar4PP.
 	//! [Default value] 0
	FloatList get_user_float_pp_4() const { return getFloatList("user_float_pp_4"); }

	//! Corresponds to Maya's userScalar5PP.
 	//! [Default value] 0
	bool set_user_float_pp_5(const FloatList& floatList) { return setValue("user_float_pp_5", floatList); }
	//! Corresponds to Maya's userScalar5PP.
 	//! [Default value] 0
	bool set_user_float_pp_5(const float* floats, size_t count) { return setArray("user_float_pp_5", floats, count); }
	//! Corresponds to Maya's userScalar5PP.
 	//! [Default value] 0
	template<size_t count> bool set_user_float_pp_5(const float (&floats)[count]) { return setArray("user_float_pp_5", floats, count); }
	//! Corresponds to Maya's userScalar5PP.
 	//! [Default value] 0
	FloatList get_user_float_pp_5() const { return getFloatList("user_float_pp_5"); }

	//! A list of N+1 elements where N is the number of instances; the first element is a time value, the rest are lists with elements: particle id, transform, velocity transform, hasInstanceTime, instanceTime, additional_params_flags, additional_param_1, ..., additional_param_N, visibility, node, node, node, ...
 	bool set_instances(const ValueList& list) { return setValue("instances", list); }
	//! A list of N+1 elements where N is the number of instances; the first element is a time value, the rest are lists with elements: particle id, transform, velocity transform, hasInstanceTime, instanceTime, additional_params_flags, additional_param_1, ..., additional_param_N, visibility, node, node, node, ...
 	ValueList get_instances() const { return getValueList("instances"); }

	//! Number of transform samples
 	//! [Default value] 0
	bool set_nsamples(int val) { return setValue("nsamples", val); }
	//! Number of transform samples
 	//! [Default value] 0
	int get_nsamples() const { return getInt("nsamples"); }

	//! (description missing)
	//! [Default value] true
	bool set_visible(bool val) { return setValue("visible", val); }
	//! (description missing)
	//! [Default value] true
	bool get_visible() const { return getBool("visible"); }

	//! Set to true if the particle shade data sent to the instanced geometry needs to include the particle ID.
 	//! [Default value] false
	bool set_shading_needs_ids(bool val) { return setValue("shading_needs_ids", val); }
	//! Set to true if the particle shade data sent to the instanced geometry needs to include the particle ID.
 	//! [Default value] false
	bool get_shading_needs_ids() const { return getBool("shading_needs_ids"); }

	//! If this is set to 'true' the lists in the 'instances' parameter have additional parameters after 'time instancing' parameters - an int with flags indicating what parameters follow and after that the parameters that follow. Their types depend on the flags in the int and are in a strictly defined order. New flags may be added and additional parameters for them can be added at the end of the chain. The flags are defined in HierarchicalParameterizedNodeParameters in an enum.
 	//! [Default value] false
	bool set_use_additional_params(bool val) { return setValue("use_additional_params", val); }
	//! If this is set to 'true' the lists in the 'instances' parameter have additional parameters after 'time instancing' parameters - an int with flags indicating what parameters follow and after that the parameters that follow. Their types depend on the flags in the int and are in a strictly defined order. New flags may be added and additional parameters for them can be added at the end of the chain. The flags are defined in HierarchicalParameterizedNodeParameters in an enum.
 	//! [Default value] false
	bool get_use_additional_params() const { return getBool("use_additional_params"); }

	//! Use particle visibility. If set to 'true' the lists in the 'instances' parameter have particle visibility parameter after 'additional parameters'.
 	//! [Default value] false
	bool set_use_visibility(bool val) { return setValue("use_visibility", val); }
	//! Use particle visibility. If set to 'true' the lists in the 'instances' parameter have particle visibility parameter after 'additional parameters'.
 	//! [Default value] false
	bool get_use_visibility() const { return getBool("use_visibility"); }

	//! If this is set to 'true' the 'instances' parameter will contain the elements hasInstanceTime (bool) and instanceTime (double). Otherwise, they should not be present.
 	//! [Default value] false
	bool set_use_time_instancing(bool val) { return setValue("use_time_instancing", val); }
	//! If this is set to 'true' the 'instances' parameter will contain the elements hasInstanceTime (bool) and instanceTime (double). Otherwise, they should not be present.
 	//! [Default value] false
	bool get_use_time_instancing() const { return getBool("use_time_instancing"); }
};

class Instancer2 : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "Instancer2"; }

	//! Per-particle acceleration.
 	//! [Default value] Color(0, 0, 0)
	bool set_acceleration_pp(const ColorList& colorList) { return setValue("acceleration_pp", colorList); }
	//! Per-particle acceleration.
 	//! [Default value] Color(0, 0, 0)
	bool set_acceleration_pp(const Color* colors, size_t count) { return setArray("acceleration_pp", colors, count); }
	//! Per-particle acceleration.
 	//! [Default value] Color(0, 0, 0)
	template<size_t count> bool set_acceleration_pp(const Color (&colors)[count]) { return setArray("acceleration_pp", colors, count); }
	//! Per-particle acceleration.
 	//! [Default value] Color(0, 0, 0)
	ColorList get_acceleration_pp() const { return getColorList("acceleration_pp"); }

	//! Per-particle diffuse color.
 	//! [Default value] Color(1, 1, 1)
	bool set_colors(const ColorList& colorList) { return setValue("colors", colorList); }
	//! Per-particle diffuse color.
 	//! [Default value] Color(1, 1, 1)
	bool set_colors(const Color* colors, size_t count) { return setArray("colors", colors, count); }
	//! Per-particle diffuse color.
 	//! [Default value] Color(1, 1, 1)
	template<size_t count> bool set_colors(const Color (&colors)[count]) { return setArray("colors", colors, count); }
	//! Per-particle diffuse color.
 	//! [Default value] Color(1, 1, 1)
	ColorList get_colors() const { return getColorList("colors"); }

	//! Per-particle emission color.
 	//! [Default value] Color(0, 0, 0)
	bool set_emission_pp(const ColorList& colorList) { return setValue("emission_pp", colorList); }
	//! Per-particle emission color.
 	//! [Default value] Color(0, 0, 0)
	bool set_emission_pp(const Color* colors, size_t count) { return setArray("emission_pp", colors, count); }
	//! Per-particle emission color.
 	//! [Default value] Color(0, 0, 0)
	template<size_t count> bool set_emission_pp(const Color (&colors)[count]) { return setArray("emission_pp", colors, count); }
	//! Per-particle emission color.
 	//! [Default value] Color(0, 0, 0)
	ColorList get_emission_pp() const { return getColorList("emission_pp"); }

	//! Corresponds to Maya's userVector1PP.
 	//! [Default value] Color(0, 0, 0)
	bool set_user_color_pp_1(const ColorList& colorList) { return setValue("user_color_pp_1", colorList); }
	//! Corresponds to Maya's userVector1PP.
 	//! [Default value] Color(0, 0, 0)
	bool set_user_color_pp_1(const Color* colors, size_t count) { return setArray("user_color_pp_1", colors, count); }
	//! Corresponds to Maya's userVector1PP.
 	//! [Default value] Color(0, 0, 0)
	template<size_t count> bool set_user_color_pp_1(const Color (&colors)[count]) { return setArray("user_color_pp_1", colors, count); }
	//! Corresponds to Maya's userVector1PP.
 	//! [Default value] Color(0, 0, 0)
	ColorList get_user_color_pp_1() const { return getColorList("user_color_pp_1"); }

	//! Corresponds to Maya's userVector2PP.
 	//! [Default value] Color(0, 0, 0)
	bool set_user_color_pp_2(const ColorList& colorList) { return setValue("user_color_pp_2", colorList); }
	//! Corresponds to Maya's userVector2PP.
 	//! [Default value] Color(0, 0, 0)
	bool set_user_color_pp_2(const Color* colors, size_t count) { return setArray("user_color_pp_2", colors, count); }
	//! Corresponds to Maya's userVector2PP.
 	//! [Default value] Color(0, 0, 0)
	template<size_t count> bool set_user_color_pp_2(const Color (&colors)[count]) { return setArray("user_color_pp_2", colors, count); }
	//! Corresponds to Maya's userVector2PP.
 	//! [Default value] Color(0, 0, 0)
	ColorList get_user_color_pp_2() const { return getColorList("user_color_pp_2"); }

	//! Corresponds to Maya's userVector3PP.
 	//! [Default value] Color(0, 0, 0)
	bool set_user_color_pp_3(const ColorList& colorList) { return setValue("user_color_pp_3", colorList); }
	//! Corresponds to Maya's userVector3PP.
 	//! [Default value] Color(0, 0, 0)
	bool set_user_color_pp_3(const Color* colors, size_t count) { return setArray("user_color_pp_3", colors, count); }
	//! Corresponds to Maya's userVector3PP.
 	//! [Default value] Color(0, 0, 0)
	template<size_t count> bool set_user_color_pp_3(const Color (&colors)[count]) { return setArray("user_color_pp_3", colors, count); }
	//! Corresponds to Maya's userVector3PP.
 	//! [Default value] Color(0, 0, 0)
	ColorList get_user_color_pp_3() const { return getColorList("user_color_pp_3"); }

	//! Corresponds to Maya's userVector4PP.
 	//! [Default value] Color(0, 0, 0)
	bool set_user_color_pp_4(const ColorList& colorList) { return setValue("user_color_pp_4", colorList); }
	//! Corresponds to Maya's userVector4PP.
 	//! [Default value] Color(0, 0, 0)
	bool set_user_color_pp_4(const Color* colors, size_t count) { return setArray("user_color_pp_4", colors, count); }
	//! Corresponds to Maya's userVector4PP.
 	//! [Default value] Color(0, 0, 0)
	template<size_t count> bool set_user_color_pp_4(const Color (&colors)[count]) { return setArray("user_color_pp_4", colors, count); }
	//! Corresponds to Maya's userVector4PP.
 	//! [Default value] Color(0, 0, 0)
	ColorList get_user_color_pp_4() const { return getColorList("user_color_pp_4"); }

	//! Corresponds to Maya's userVector5PP.
 	//! [Default value] Color(0, 0, 0)
	bool set_user_color_pp_5(const ColorList& colorList) { return setValue("user_color_pp_5", colorList); }
	//! Corresponds to Maya's userVector5PP.
 	//! [Default value] Color(0, 0, 0)
	bool set_user_color_pp_5(const Color* colors, size_t count) { return setArray("user_color_pp_5", colors, count); }
	//! Corresponds to Maya's userVector5PP.
 	//! [Default value] Color(0, 0, 0)
	template<size_t count> bool set_user_color_pp_5(const Color (&colors)[count]) { return setArray("user_color_pp_5", colors, count); }
	//! Corresponds to Maya's userVector5PP.
 	//! [Default value] Color(0, 0, 0)
	ColorList get_user_color_pp_5() const { return getColorList("user_color_pp_5"); }

	//! Per-particle age.
 	//! [Default value] 0
	bool set_age_pp(const FloatList& floatList) { return setValue("age_pp", floatList); }
	//! Per-particle age.
 	//! [Default value] 0
	bool set_age_pp(const float* floats, size_t count) { return setArray("age_pp", floats, count); }
	//! Per-particle age.
 	//! [Default value] 0
	template<size_t count> bool set_age_pp(const float (&floats)[count]) { return setArray("age_pp", floats, count); }
	//! Per-particle age.
 	//! [Default value] 0
	FloatList get_age_pp() const { return getFloatList("age_pp"); }

	//! Per-particle lifespan.
 	//! [Default value] 0
	bool set_lifespan_pp(const FloatList& floatList) { return setValue("lifespan_pp", floatList); }
	//! Per-particle lifespan.
 	//! [Default value] 0
	bool set_lifespan_pp(const float* floats, size_t count) { return setArray("lifespan_pp", floats, count); }
	//! Per-particle lifespan.
 	//! [Default value] 0
	template<size_t count> bool set_lifespan_pp(const float (&floats)[count]) { return setArray("lifespan_pp", floats, count); }
	//! Per-particle lifespan.
 	//! [Default value] 0
	FloatList get_lifespan_pp() const { return getFloatList("lifespan_pp"); }

	//! Per-particle opacity.
 	//! [Default value] 0
	bool set_opacity_pp(const FloatList& floatList) { return setValue("opacity_pp", floatList); }
	//! Per-particle opacity.
 	//! [Default value] 0
	bool set_opacity_pp(const float* floats, size_t count) { return setArray("opacity_pp", floats, count); }
	//! Per-particle opacity.
 	//! [Default value] 0
	template<size_t count> bool set_opacity_pp(const float (&floats)[count]) { return setArray("opacity_pp", floats, count); }
	//! Per-particle opacity.
 	//! [Default value] 0
	FloatList get_opacity_pp() const { return getFloatList("opacity_pp"); }

	//! Corresponds to Maya's userScalar1PP.
 	//! [Default value] 0
	bool set_user_float_pp_1(const FloatList& floatList) { return setValue("user_float_pp_1", floatList); }
	//! Corresponds to Maya's userScalar1PP.
 	//! [Default value] 0
	bool set_user_float_pp_1(const float* floats, size_t count) { return setArray("user_float_pp_1", floats, count); }
	//! Corresponds to Maya's userScalar1PP.
 	//! [Default value] 0
	template<size_t count> bool set_user_float_pp_1(const float (&floats)[count]) { return setArray("user_float_pp_1", floats, count); }
	//! Corresponds to Maya's userScalar1PP.
 	//! [Default value] 0
	FloatList get_user_float_pp_1() const { return getFloatList("user_float_pp_1"); }

	//! Corresponds to Maya's userScalar2PP.
 	//! [Default value] 0
	bool set_user_float_pp_2(const FloatList& floatList) { return setValue("user_float_pp_2", floatList); }
	//! Corresponds to Maya's userScalar2PP.
 	//! [Default value] 0
	bool set_user_float_pp_2(const float* floats, size_t count) { return setArray("user_float_pp_2", floats, count); }
	//! Corresponds to Maya's userScalar2PP.
 	//! [Default value] 0
	template<size_t count> bool set_user_float_pp_2(const float (&floats)[count]) { return setArray("user_float_pp_2", floats, count); }
	//! Corresponds to Maya's userScalar2PP.
 	//! [Default value] 0
	FloatList get_user_float_pp_2() const { return getFloatList("user_float_pp_2"); }

	//! Corresponds to Maya's userScalar3PP.
 	//! [Default value] 0
	bool set_user_float_pp_3(const FloatList& floatList) { return setValue("user_float_pp_3", floatList); }
	//! Corresponds to Maya's userScalar3PP.
 	//! [Default value] 0
	bool set_user_float_pp_3(const float* floats, size_t count) { return setArray("user_float_pp_3", floats, count); }
	//! Corresponds to Maya's userScalar3PP.
 	//! [Default value] 0
	template<size_t count> bool set_user_float_pp_3(const float (&floats)[count]) { return setArray("user_float_pp_3", floats, count); }
	//! Corresponds to Maya's userScalar3PP.
 	//! [Default value] 0
	FloatList get_user_float_pp_3() const { return getFloatList("user_float_pp_3"); }

	//! Corresponds to Maya's userScalar4PP.
 	//! [Default value] 0
	bool set_user_float_pp_4(const FloatList& floatList) { return setValue("user_float_pp_4", floatList); }
	//! Corresponds to Maya's userScalar4PP.
 	//! [Default value] 0
	bool set_user_float_pp_4(const float* floats, size_t count) { return setArray("user_float_pp_4", floats, count); }
	//! Corresponds to Maya's userScalar4PP.
 	//! [Default value] 0
	template<size_t count> bool set_user_float_pp_4(const float (&floats)[count]) { return setArray("user_float_pp_4", floats, count); }
	//! Corresponds to Maya's userScalar4PP.
 	//! [Default value] 0
	FloatList get_user_float_pp_4() const { return getFloatList("user_float_pp_4"); }

	//! Corresponds to Maya's userScalar5PP.
 	//! [Default value] 0
	bool set_user_float_pp_5(const FloatList& floatList) { return setValue("user_float_pp_5", floatList); }
	//! Corresponds to Maya's userScalar5PP.
 	//! [Default value] 0
	bool set_user_float_pp_5(const float* floats, size_t count) { return setArray("user_float_pp_5", floats, count); }
	//! Corresponds to Maya's userScalar5PP.
 	//! [Default value] 0
	template<size_t count> bool set_user_float_pp_5(const float (&floats)[count]) { return setArray("user_float_pp_5", floats, count); }
	//! Corresponds to Maya's userScalar5PP.
 	//! [Default value] 0
	FloatList get_user_float_pp_5() const { return getFloatList("user_float_pp_5"); }

	//! A list of N+1 elements where N is the number of instances; the first element is a time value, the rest are lists with elements: particle id, transform, velocity transform, hasInstanceTime, instanceTime, additional_params_flags, additional_param_1, ..., additional_param_N, visibility, node, node, node, ...
 	bool set_instances(const ValueList& list) { return setValue("instances", list); }
	//! A list of N+1 elements where N is the number of instances; the first element is a time value, the rest are lists with elements: particle id, transform, velocity transform, hasInstanceTime, instanceTime, additional_params_flags, additional_param_1, ..., additional_param_N, visibility, node, node, node, ...
 	ValueList get_instances() const { return getValueList("instances"); }

	//! Number of transform samples
 	//! [Default value] 0
	bool set_nsamples(int val) { return setValue("nsamples", val); }
	//! Number of transform samples
 	//! [Default value] 0
	int get_nsamples() const { return getInt("nsamples"); }

	//! (description missing)
	//! [Default value] true
	bool set_visible(bool val) { return setValue("visible", val); }
	//! (description missing)
	//! [Default value] true
	bool get_visible() const { return getBool("visible"); }

	//! Set to true if the particle shade data sent to the instanced geometry needs to include the particle ID.
 	//! [Default value] false
	bool set_shading_needs_ids(bool val) { return setValue("shading_needs_ids", val); }
	//! Set to true if the particle shade data sent to the instanced geometry needs to include the particle ID.
 	//! [Default value] false
	bool get_shading_needs_ids() const { return getBool("shading_needs_ids"); }

	//! If this is set to 'true' the lists in the 'instances' parameter have additional parameters after 'time instancing' parameters - an int with flags indicating what parameters follow and after that the parameters that follow. Their types depend on the flags in the int and are in a strictly defined order. New flags may be added and additional parameters for them can be added at the end of the chain. The flags are defined in HierarchicalParameterizedNodeParameters in an enum.
 	//! [Default value] false
	bool set_use_additional_params(bool val) { return setValue("use_additional_params", val); }
	//! If this is set to 'true' the lists in the 'instances' parameter have additional parameters after 'time instancing' parameters - an int with flags indicating what parameters follow and after that the parameters that follow. Their types depend on the flags in the int and are in a strictly defined order. New flags may be added and additional parameters for them can be added at the end of the chain. The flags are defined in HierarchicalParameterizedNodeParameters in an enum.
 	//! [Default value] false
	bool get_use_additional_params() const { return getBool("use_additional_params"); }

	//! Use particle visibility. If set to 'true' the lists in the 'instances' parameter have particle visibility parameter after 'additional parameters'.
 	//! [Default value] false
	bool set_use_visibility(bool val) { return setValue("use_visibility", val); }
	//! Use particle visibility. If set to 'true' the lists in the 'instances' parameter have particle visibility parameter after 'additional parameters'.
 	//! [Default value] false
	bool get_use_visibility() const { return getBool("use_visibility"); }

	//! If this is set to 'true' the 'instances' parameter will contain elements hasInstanceTime (bool) and instanceTime (double). Otherwise, they should not be present.
 	//! [Default value] true
	bool set_use_time_instancing(bool val) { return setValue("use_time_instancing", val); }
	//! If this is set to 'true' the 'instances' parameter will contain elements hasInstanceTime (bool) and instanceTime (double). Otherwise, they should not be present.
 	//! [Default value] true
	bool get_use_time_instancing() const { return getBool("use_time_instancing"); }
};

class LightAmbient : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "LightAmbient"; }

	//! true if the light is casting light (turned on) and false otherwise; it only makes sense to use this parameter if it is animated, or if another object depends on this node but it must not be rendered
 	//! [Default value] true
	bool set_enabled(bool val) { return setValue("enabled", val); }
	//! true if the light is casting light (turned on) and false otherwise; it only makes sense to use this parameter if it is animated, or if another object depends on this node but it must not be rendered
 	//! [Default value] true
	bool get_enabled() const { return getBool("enabled"); }

	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	bool set_transform(const Transform& transform) { return setValue("transform", transform); }
	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	Transform get_transform() const { return getTransform("transform"); }

	//! Color of the light
 	//! [UI Guides] overridenBy=color_tex
 	//! [Default value] Color(1, 1, 1)
	bool set_color(const Color& color) { return setValue("color", color); }
	//! Color of the light
 	//! [UI Guides] overridenBy=color_tex
 	//! [Default value] Color(1, 1, 1)
	Color get_color() const { return getColor("color"); }

	//! A color texture that if present will override the color parameter
 	//! [UI Guides] overrides=color
 	bool set_color_tex(const Plugin& texture) { return setValue("color_tex", texture); }
	//! A color texture that if present will override the color parameter
 	//! [UI Guides] overrides=color
 	bool set_color_tex(const AColor& texture) { return setValue("color_tex", texture); }
	//! A color texture that if present will override the color parameter
 	//! [UI Guides] overrides=color
 	Value get_color_tex() const { return getValue("color_tex"); }

	//! true if the light casts shadows and false otherwise
 	//! [Default value] true
	bool set_shadows(bool val) { return setValue("shadows", val); }
	//! true if the light casts shadows and false otherwise
 	//! [Default value] true
	bool get_shadows() const { return getBool("shadows"); }

	//! The shadow color. Anything but black is not physically accurate.
 	//! [UI Guides] overridenBy=shadowColor_tex
 	//! [Default value] Color(0, 0, 0)
	bool set_shadowColor(const Color& color) { return setValue("shadowColor", color); }
	//! The shadow color. Anything but black is not physically accurate.
 	//! [UI Guides] overridenBy=shadowColor_tex
 	//! [Default value] Color(0, 0, 0)
	Color get_shadowColor() const { return getColor("shadowColor"); }

	//! A color texture that if present will override the shadowColor parameter
 	//! [UI Guides] overrides=shadowColor
 	bool set_shadowColor_tex(const Plugin& texture) { return setValue("shadowColor_tex", texture); }
	//! A color texture that if present will override the shadowColor parameter
 	//! [UI Guides] overrides=shadowColor
 	bool set_shadowColor_tex(const AColor& texture) { return setValue("shadowColor_tex", texture); }
	//! A color texture that if present will override the shadowColor parameter
 	//! [UI Guides] overrides=shadowColor
 	Value get_shadowColor_tex() const { return getValue("shadowColor_tex"); }

	//! Shadow offset from the surface. Helps to prevent polygonal shadow artifacts on low-poly surfaces.
 	//! [UI Guides] displayName=Shadow bias, quantityType=distance
 	//! [Default value] 0
	bool set_shadowBias(float val) { return setValue("shadowBias", val); }
	//! Shadow offset from the surface. Helps to prevent polygonal shadow artifacts on low-poly surfaces.
 	//! [UI Guides] displayName=Shadow bias, quantityType=distance
 	//! [Default value] 0
	float get_shadowBias() const { return getFloat("shadowBias"); }

	//! Determines the number of photons emitted by this light when calculating the Global Photon Map. 1000 subdivs equal 1 million photons.
 	//! [UI Guides] displayName=Photon subdivs, minValue=0
 	//! [Default value] 500
	bool set_photonSubdivs(int val) { return setValue("photonSubdivs", val); }
	//! Determines the number of photons emitted by this light when calculating the Global Photon Map. 1000 subdivs equal 1 million photons.
 	//! [UI Guides] displayName=Photon subdivs, minValue=0
 	//! [Default value] 500
	int get_photonSubdivs() const { return getInt("photonSubdivs"); }

	//! Determines the number of photons emitted by this light when calculating the Caustics Photon Map. 1000 subdivs equal 1 million photons.
 	//! [UI Guides] displayName=Caustics subdivs, minValue=0
 	//! [Default value] 1000
	bool set_causticSubdivs(int val) { return setValue("causticSubdivs", val); }
	//! Determines the number of photons emitted by this light when calculating the Caustics Photon Map. 1000 subdivs equal 1 million photons.
 	//! [UI Guides] displayName=Caustics subdivs, minValue=0
 	//! [Default value] 1000
	int get_causticSubdivs() const { return getInt("causticSubdivs"); }

	//! Multiplier for the diffuse photons.
 	//! [UI Guides] displayName=Diffuse multiplier, minValue=0.0
 	//! [Default value] 1
	bool set_diffuseMult(float val) { return setValue("diffuseMult", val); }
	//! Multiplier for the diffuse photons.
 	//! [UI Guides] displayName=Diffuse multiplier, minValue=0.0
 	//! [Default value] 1
	float get_diffuseMult() const { return getFloat("diffuseMult"); }

	//! Multiplier for the caustics photons.
 	//! [UI Guides] displayName=Caustics multiplier, minValue=0.0
 	//! [Default value] 1
	bool set_causticMult(float val) { return setValue("causticMult", val); }
	//! Multiplier for the caustics photons.
 	//! [UI Guides] displayName=Caustics multiplier, minValue=0.0
 	//! [Default value] 1
	float get_causticMult() const { return getFloat("causticMult"); }

	//! Light cut-off threshold (speed optimization). If the light intensity for a point is below this threshold, the light will not be computed.
 	//! [UI Guides] displayName=Cut-off threshold, minValue=0.0
 	//! [Default value] 0.001
	bool set_cutoffThreshold(float val) { return setValue("cutoffThreshold", val); }
	//! Light cut-off threshold (speed optimization). If the light intensity for a point is below this threshold, the light will not be computed.
 	//! [UI Guides] displayName=Cut-off threshold, minValue=0.0
 	//! [Default value] 0.001
	float get_cutoffThreshold() const { return getFloat("cutoffThreshold"); }

	//! True if the light produces diffuse lighting and false otherwise.
 	//! [UI Guides] displayName=Affect diffuse
 	//! [Default value] true
	bool set_affectDiffuse(bool val) { return setValue("affectDiffuse", val); }
	//! True if the light produces diffuse lighting and false otherwise.
 	//! [UI Guides] displayName=Affect diffuse
 	//! [Default value] true
	bool get_affectDiffuse() const { return getBool("affectDiffuse"); }

	//! True if the light produces specular hilights and false otherwise.
 	//! [UI Guides] displayName=Affect specular
 	//! [Default value] true
	bool set_affectSpecular(bool val) { return setValue("affectSpecular", val); }
	//! True if the light produces specular hilights and false otherwise.
 	//! [UI Guides] displayName=Affect specular
 	//! [Default value] true
	bool get_affectSpecular() const { return getBool("affectSpecular"); }

	//! True if the bumped normal should be used to check if the light direction is below the surface.
 	//! [UI Guides] displayName=Bumped normal check
 	//! [Default value] false
	bool set_bumped_below_surface_check(bool val) { return setValue("bumped_below_surface_check", val); }
	//! True if the bumped normal should be used to check if the light direction is below the surface.
 	//! [UI Guides] displayName=Bumped normal check
 	//! [Default value] false
	bool get_bumped_below_surface_check() const { return getBool("bumped_below_surface_check"); }

	//! Number of parameter samples for motion blur.
 	//! [Default value] 0
	bool set_nsamples(int val) { return setValue("nsamples", val); }
	//! Number of parameter samples for motion blur.
 	//! [Default value] 0
	int get_nsamples() const { return getInt("nsamples"); }

	//! Diffuse contribution for the light.
 	//! [Default value] 1
	bool set_diffuse_contribution(float val) { return setValue("diffuse_contribution", val); }
	//! Diffuse contribution for the light.
 	//! [Default value] 1
	float get_diffuse_contribution() const { return getFloat("diffuse_contribution"); }

	//! Specular contribution for the light.
 	//! [Default value] 1
	bool set_specular_contribution(float val) { return setValue("specular_contribution", val); }
	//! Specular contribution for the light.
 	//! [Default value] 1
	float get_specular_contribution() const { return getFloat("specular_contribution"); }

	//! Render channels the result of this light will be written to
 	bool set_channels(const ValueList& pluginList) { return setValue("channels", pluginList); }
	//! Render channels the result of this light will be written to
 	ValueList get_channels() const { return getValueList("channels"); }

	//! Render channels the raw diffuse result of this light will be written to
 	bool set_channels_raw(const ValueList& pluginList) { return setValue("channels_raw", pluginList); }
	//! Render channels the raw diffuse result of this light will be written to
 	ValueList get_channels_raw() const { return getValueList("channels_raw"); }

	//! Render channels the diffuse result of this light will be written to
 	bool set_channels_diffuse(const ValueList& pluginList) { return setValue("channels_diffuse", pluginList); }
	//! Render channels the diffuse result of this light will be written to
 	ValueList get_channels_diffuse() const { return getValueList("channels_diffuse"); }

	//! Render channels the specular result of this light will be written to
 	bool set_channels_specular(const ValueList& pluginList) { return setValue("channels_specular", pluginList); }
	//! Render channels the specular result of this light will be written to
 	ValueList get_channels_specular() const { return getValueList("channels_specular"); }

	//! true if the light should use the global light level setting
 	//! [Default value] true
	bool set_use_global_light_level(bool val) { return setValue("use_global_light_level", val); }
	//! true if the light should use the global light level setting
 	//! [Default value] true
	bool get_use_global_light_level() const { return getBool("use_global_light_level"); }

	//! Units for the intensity (0 - default, 1 - lumens, 2 - lm/m/m/sr, 3 - watts, 4 - w/m/m/sr)
 	//! [UI Guides] enum=0:Default; 1:Lumens; 2:lm/m/m/sr; 3:Watts; 4:w/m/m/sr
 	//! [Default value] 0
	bool set_units(int val) { return setValue("units", val); }
	//! Units for the intensity (0 - default, 1 - lumens, 2 - lm/m/m/sr, 3 - watts, 4 - w/m/m/sr)
 	//! [UI Guides] enum=0:Default; 1:Lumens; 2:lm/m/m/sr; 3:Watts; 4:w/m/m/sr
 	//! [Default value] 0
	int get_units() const { return getInt("units"); }

	//! Light intensity
 	//! [UI Guides] overridenBy=intensity_tex
 	//! [Default value] 1
	bool set_intensity(float val) { return setValue("intensity", val); }
	//! Light intensity
 	//! [UI Guides] overridenBy=intensity_tex
 	//! [Default value] 1
	float get_intensity() const { return getFloat("intensity"); }

	//! A float texture that if present will override the intensity parameter
 	//! [UI Guides] overrides=intensity
 	bool set_intensity_tex(const Plugin& texturefloat) { return setValue("intensity_tex", texturefloat); }
	//! A float texture that if present will override the intensity parameter
 	//! [UI Guides] overrides=intensity
 	bool set_intensity_tex(float texturefloat) { return setValue("intensity_tex", texturefloat); }
	//! A float texture that if present will override the intensity parameter
 	//! [UI Guides] overrides=intensity
 	Value get_intensity_tex() const { return getValue("intensity_tex"); }

	//! The size of the light; 0.0 is a point light, larger values produces soft (area) shadows
 	//! [UI Guides] quantityType=distance, overridenBy=shadowRadius_tex
 	//! [Default value] 0
	bool set_shadowRadius(float val) { return setValue("shadowRadius", val); }
	//! The size of the light; 0.0 is a point light, larger values produces soft (area) shadows
 	//! [UI Guides] quantityType=distance, overridenBy=shadowRadius_tex
 	//! [Default value] 0
	float get_shadowRadius() const { return getFloat("shadowRadius"); }

	//! A float texture that if present will override the shadows radius parameter
 	//! [UI Guides] overrides=shadowRadius
 	bool set_shadowRadius_tex(const Plugin& texturefloat) { return setValue("shadowRadius_tex", texturefloat); }
	//! A float texture that if present will override the shadows radius parameter
 	//! [UI Guides] overrides=shadowRadius
 	bool set_shadowRadius_tex(float texturefloat) { return setValue("shadowRadius_tex", texturefloat); }
	//! A float texture that if present will override the shadows radius parameter
 	//! [UI Guides] overrides=shadowRadius
 	Value get_shadowRadius_tex() const { return getValue("shadowRadius_tex"); }

	//! If true, the hilights will match the shape of the light; if false, hilights will always be calculated as from a point light
 	//! [Default value] false
	bool set_areaSpeculars(bool val) { return setValue("areaSpeculars", val); }
	//! If true, the hilights will match the shape of the light; if false, hilights will always be calculated as from a point light
 	//! [Default value] false
	bool get_areaSpeculars() const { return getBool("areaSpeculars"); }

	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	bool set_shadowSubdivs(int val) { return setValue("shadowSubdivs", val); }
	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	int get_shadowSubdivs() const { return getInt("shadowSubdivs"); }

	//! When this option is on and GI calculation is set to Irradiance map V-Ray will calculate the effects of this light and store them in the irradiance map. The result is that the irradiance map is computed more slowly but the rendering takes less time. You can also save the irradiance map and reuse it later.
 	//! [UI Guides] displayName=Store with irradiance map
 	//! [Default value] false
	bool set_storeWithIrradianceMap(bool val) { return setValue("storeWithIrradianceMap", val); }
	//! When this option is on and GI calculation is set to Irradiance map V-Ray will calculate the effects of this light and store them in the irradiance map. The result is that the irradiance map is computed more slowly but the rendering takes less time. You can also save the irradiance map and reuse it later.
 	//! [UI Guides] displayName=Store with irradiance map
 	//! [Default value] false
	bool get_storeWithIrradianceMap() const { return getBool("storeWithIrradianceMap"); }

	//! (description missing)
	//! [Default value] 2
	bool set_decay(float val) { return setValue("decay", val); }
	//! (description missing)
	//! [Default value] 2
	float get_decay() const { return getFloat("decay"); }

	//! (description missing)
	bool set_ambient_shade(const Plugin& texturefloat) { return setValue("ambient_shade", texturefloat); }
	//! (description missing)
	bool set_ambient_shade(float texturefloat) { return setValue("ambient_shade", texturefloat); }
	//! (description missing)
	Value get_ambient_shade() const { return getValue("ambient_shade"); }
};

class LightAmbientMax : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "LightAmbientMax"; }

	//! true if the light is enabled
 	//! [Default value] true
	bool set_enabled(bool val) { return setValue("enabled", val); }
	//! true if the light is enabled
 	//! [Default value] true
	bool get_enabled() const { return getBool("enabled"); }

	//! light mode
 	//! [Default value] 0
	bool set_mode(int val) { return setValue("mode", val); }
	//! light mode
 	//! [Default value] 0
	int get_mode() const { return getInt("mode"); }

	//! minimal distance for gi rays
 	//! [Default value] 0
	bool set_gi_min_distance(float val) { return setValue("gi_min_distance", val); }
	//! minimal distance for gi rays
 	//! [Default value] 0
	float get_gi_min_distance() const { return getFloat("gi_min_distance"); }

	//! The ambient color
 	bool set_color(const Plugin& texture) { return setValue("color", texture); }
	//! The ambient color
 	bool set_color(const AColor& texture) { return setValue("color", texture); }
	//! The ambient color
 	Value get_color() const { return getValue("color"); }

	//! true to compensate for camera exposure
 	//! [Default value] true
	bool set_compensate_exposure(bool val) { return setValue("compensate_exposure", val); }
	//! true to compensate for camera exposure
 	//! [Default value] true
	bool get_compensate_exposure() const { return getBool("compensate_exposure"); }
};

class LightDirect : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "LightDirect"; }

	//! true if the light is casting light (turned on) and false otherwise; it only makes sense to use this parameter if it is animated, or if another object depends on this node but it must not be rendered
 	//! [Default value] true
	bool set_enabled(bool val) { return setValue("enabled", val); }
	//! true if the light is casting light (turned on) and false otherwise; it only makes sense to use this parameter if it is animated, or if another object depends on this node but it must not be rendered
 	//! [Default value] true
	bool get_enabled() const { return getBool("enabled"); }

	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	bool set_transform(const Transform& transform) { return setValue("transform", transform); }
	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	Transform get_transform() const { return getTransform("transform"); }

	//! Color of the light
 	//! [UI Guides] overridenBy=color_tex
 	//! [Default value] Color(1, 1, 1)
	bool set_color(const Color& color) { return setValue("color", color); }
	//! Color of the light
 	//! [UI Guides] overridenBy=color_tex
 	//! [Default value] Color(1, 1, 1)
	Color get_color() const { return getColor("color"); }

	//! A color texture that if present will override the color parameter
 	//! [UI Guides] overrides=color
 	bool set_color_tex(const Plugin& texture) { return setValue("color_tex", texture); }
	//! A color texture that if present will override the color parameter
 	//! [UI Guides] overrides=color
 	bool set_color_tex(const AColor& texture) { return setValue("color_tex", texture); }
	//! A color texture that if present will override the color parameter
 	//! [UI Guides] overrides=color
 	Value get_color_tex() const { return getValue("color_tex"); }

	//! true if the light casts shadows and false otherwise
 	//! [Default value] true
	bool set_shadows(bool val) { return setValue("shadows", val); }
	//! true if the light casts shadows and false otherwise
 	//! [Default value] true
	bool get_shadows() const { return getBool("shadows"); }

	//! The shadow color. Anything but black is not physically accurate.
 	//! [UI Guides] overridenBy=shadowColor_tex
 	//! [Default value] Color(0, 0, 0)
	bool set_shadowColor(const Color& color) { return setValue("shadowColor", color); }
	//! The shadow color. Anything but black is not physically accurate.
 	//! [UI Guides] overridenBy=shadowColor_tex
 	//! [Default value] Color(0, 0, 0)
	Color get_shadowColor() const { return getColor("shadowColor"); }

	//! A color texture that if present will override the shadowColor parameter
 	//! [UI Guides] overrides=shadowColor
 	bool set_shadowColor_tex(const Plugin& texture) { return setValue("shadowColor_tex", texture); }
	//! A color texture that if present will override the shadowColor parameter
 	//! [UI Guides] overrides=shadowColor
 	bool set_shadowColor_tex(const AColor& texture) { return setValue("shadowColor_tex", texture); }
	//! A color texture that if present will override the shadowColor parameter
 	//! [UI Guides] overrides=shadowColor
 	Value get_shadowColor_tex() const { return getValue("shadowColor_tex"); }

	//! Shadow offset from the surface. Helps to prevent polygonal shadow artifacts on low-poly surfaces.
 	//! [UI Guides] displayName=Shadow bias, quantityType=distance
 	//! [Default value] 0
	bool set_shadowBias(float val) { return setValue("shadowBias", val); }
	//! Shadow offset from the surface. Helps to prevent polygonal shadow artifacts on low-poly surfaces.
 	//! [UI Guides] displayName=Shadow bias, quantityType=distance
 	//! [Default value] 0
	float get_shadowBias() const { return getFloat("shadowBias"); }

	//! Determines the number of photons emitted by this light when calculating the Global Photon Map. 1000 subdivs equal 1 million photons.
 	//! [UI Guides] displayName=Photon subdivs, minValue=0
 	//! [Default value] 500
	bool set_photonSubdivs(int val) { return setValue("photonSubdivs", val); }
	//! Determines the number of photons emitted by this light when calculating the Global Photon Map. 1000 subdivs equal 1 million photons.
 	//! [UI Guides] displayName=Photon subdivs, minValue=0
 	//! [Default value] 500
	int get_photonSubdivs() const { return getInt("photonSubdivs"); }

	//! Determines the number of photons emitted by this light when calculating the Caustics Photon Map. 1000 subdivs equal 1 million photons.
 	//! [UI Guides] displayName=Caustics subdivs, minValue=0
 	//! [Default value] 1000
	bool set_causticSubdivs(int val) { return setValue("causticSubdivs", val); }
	//! Determines the number of photons emitted by this light when calculating the Caustics Photon Map. 1000 subdivs equal 1 million photons.
 	//! [UI Guides] displayName=Caustics subdivs, minValue=0
 	//! [Default value] 1000
	int get_causticSubdivs() const { return getInt("causticSubdivs"); }

	//! Multiplier for the diffuse photons.
 	//! [UI Guides] displayName=Diffuse multiplier, minValue=0.0
 	//! [Default value] 1
	bool set_diffuseMult(float val) { return setValue("diffuseMult", val); }
	//! Multiplier for the diffuse photons.
 	//! [UI Guides] displayName=Diffuse multiplier, minValue=0.0
 	//! [Default value] 1
	float get_diffuseMult() const { return getFloat("diffuseMult"); }

	//! Multiplier for the caustics photons.
 	//! [UI Guides] displayName=Caustics multiplier, minValue=0.0
 	//! [Default value] 1
	bool set_causticMult(float val) { return setValue("causticMult", val); }
	//! Multiplier for the caustics photons.
 	//! [UI Guides] displayName=Caustics multiplier, minValue=0.0
 	//! [Default value] 1
	float get_causticMult() const { return getFloat("causticMult"); }

	//! Light cut-off threshold (speed optimization). If the light intensity for a point is below this threshold, the light will not be computed.
 	//! [UI Guides] displayName=Cut-off threshold, minValue=0.0
 	//! [Default value] 0.001
	bool set_cutoffThreshold(float val) { return setValue("cutoffThreshold", val); }
	//! Light cut-off threshold (speed optimization). If the light intensity for a point is below this threshold, the light will not be computed.
 	//! [UI Guides] displayName=Cut-off threshold, minValue=0.0
 	//! [Default value] 0.001
	float get_cutoffThreshold() const { return getFloat("cutoffThreshold"); }

	//! True if the light produces diffuse lighting and false otherwise.
 	//! [UI Guides] displayName=Affect diffuse
 	//! [Default value] true
	bool set_affectDiffuse(bool val) { return setValue("affectDiffuse", val); }
	//! True if the light produces diffuse lighting and false otherwise.
 	//! [UI Guides] displayName=Affect diffuse
 	//! [Default value] true
	bool get_affectDiffuse() const { return getBool("affectDiffuse"); }

	//! True if the light produces specular hilights and false otherwise.
 	//! [UI Guides] displayName=Affect specular
 	//! [Default value] true
	bool set_affectSpecular(bool val) { return setValue("affectSpecular", val); }
	//! True if the light produces specular hilights and false otherwise.
 	//! [UI Guides] displayName=Affect specular
 	//! [Default value] true
	bool get_affectSpecular() const { return getBool("affectSpecular"); }

	//! True if the bumped normal should be used to check if the light direction is below the surface.
 	//! [UI Guides] displayName=Bumped normal check
 	//! [Default value] false
	bool set_bumped_below_surface_check(bool val) { return setValue("bumped_below_surface_check", val); }
	//! True if the bumped normal should be used to check if the light direction is below the surface.
 	//! [UI Guides] displayName=Bumped normal check
 	//! [Default value] false
	bool get_bumped_below_surface_check() const { return getBool("bumped_below_surface_check"); }

	//! Number of parameter samples for motion blur.
 	//! [Default value] 0
	bool set_nsamples(int val) { return setValue("nsamples", val); }
	//! Number of parameter samples for motion blur.
 	//! [Default value] 0
	int get_nsamples() const { return getInt("nsamples"); }

	//! Diffuse contribution for the light.
 	//! [Default value] 1
	bool set_diffuse_contribution(float val) { return setValue("diffuse_contribution", val); }
	//! Diffuse contribution for the light.
 	//! [Default value] 1
	float get_diffuse_contribution() const { return getFloat("diffuse_contribution"); }

	//! Specular contribution for the light.
 	//! [Default value] 1
	bool set_specular_contribution(float val) { return setValue("specular_contribution", val); }
	//! Specular contribution for the light.
 	//! [Default value] 1
	float get_specular_contribution() const { return getFloat("specular_contribution"); }

	//! Render channels the result of this light will be written to
 	bool set_channels(const ValueList& pluginList) { return setValue("channels", pluginList); }
	//! Render channels the result of this light will be written to
 	ValueList get_channels() const { return getValueList("channels"); }

	//! Render channels the raw diffuse result of this light will be written to
 	bool set_channels_raw(const ValueList& pluginList) { return setValue("channels_raw", pluginList); }
	//! Render channels the raw diffuse result of this light will be written to
 	ValueList get_channels_raw() const { return getValueList("channels_raw"); }

	//! Render channels the diffuse result of this light will be written to
 	bool set_channels_diffuse(const ValueList& pluginList) { return setValue("channels_diffuse", pluginList); }
	//! Render channels the diffuse result of this light will be written to
 	ValueList get_channels_diffuse() const { return getValueList("channels_diffuse"); }

	//! Render channels the specular result of this light will be written to
 	bool set_channels_specular(const ValueList& pluginList) { return setValue("channels_specular", pluginList); }
	//! Render channels the specular result of this light will be written to
 	ValueList get_channels_specular() const { return getValueList("channels_specular"); }

	//! true if the light should use the global light level setting
 	//! [Default value] true
	bool set_use_global_light_level(bool val) { return setValue("use_global_light_level", val); }
	//! true if the light should use the global light level setting
 	//! [Default value] true
	bool get_use_global_light_level() const { return getBool("use_global_light_level"); }

	//! Units for the intensity (0 - default, 1 - lumens, 2 - lm/m/m/sr, 3 - watts, 4 - w/m/m/sr)
 	//! [UI Guides] enum=0:Default; 1:Lumens; 2:lm/m/m/sr; 3:Watts; 4:w/m/m/sr
 	//! [Default value] 0
	bool set_units(int val) { return setValue("units", val); }
	//! Units for the intensity (0 - default, 1 - lumens, 2 - lm/m/m/sr, 3 - watts, 4 - w/m/m/sr)
 	//! [UI Guides] enum=0:Default; 1:Lumens; 2:lm/m/m/sr; 3:Watts; 4:w/m/m/sr
 	//! [Default value] 0
	int get_units() const { return getInt("units"); }

	//! Light intensity
 	//! [UI Guides] overridenBy=intensity_tex
 	//! [Default value] 1
	bool set_intensity(float val) { return setValue("intensity", val); }
	//! Light intensity
 	//! [UI Guides] overridenBy=intensity_tex
 	//! [Default value] 1
	float get_intensity() const { return getFloat("intensity"); }

	//! A float texture that if present will override the intensity parameter
 	//! [UI Guides] overrides=intensity
 	bool set_intensity_tex(const Plugin& texturefloat) { return setValue("intensity_tex", texturefloat); }
	//! A float texture that if present will override the intensity parameter
 	//! [UI Guides] overrides=intensity
 	bool set_intensity_tex(float texturefloat) { return setValue("intensity_tex", texturefloat); }
	//! A float texture that if present will override the intensity parameter
 	//! [UI Guides] overrides=intensity
 	Value get_intensity_tex() const { return getValue("intensity_tex"); }

	//! The size of the light; 0.0 is a point light, larger values produces soft (area) shadows
 	//! [UI Guides] quantityType=distance, overridenBy=shadowRadius_tex
 	//! [Default value] 0
	bool set_shadowRadius(float val) { return setValue("shadowRadius", val); }
	//! The size of the light; 0.0 is a point light, larger values produces soft (area) shadows
 	//! [UI Guides] quantityType=distance, overridenBy=shadowRadius_tex
 	//! [Default value] 0
	float get_shadowRadius() const { return getFloat("shadowRadius"); }

	//! A float texture that if present will override the shadows radius parameter
 	//! [UI Guides] overrides=shadowRadius
 	bool set_shadowRadius_tex(const Plugin& texturefloat) { return setValue("shadowRadius_tex", texturefloat); }
	//! A float texture that if present will override the shadows radius parameter
 	//! [UI Guides] overrides=shadowRadius
 	bool set_shadowRadius_tex(float texturefloat) { return setValue("shadowRadius_tex", texturefloat); }
	//! A float texture that if present will override the shadows radius parameter
 	//! [UI Guides] overrides=shadowRadius
 	Value get_shadowRadius_tex() const { return getValue("shadowRadius_tex"); }

	//! If true, the hilights will match the shape of the light; if false, hilights will always be calculated as from a point light
 	//! [Default value] false
	bool set_areaSpeculars(bool val) { return setValue("areaSpeculars", val); }
	//! If true, the hilights will match the shape of the light; if false, hilights will always be calculated as from a point light
 	//! [Default value] false
	bool get_areaSpeculars() const { return getBool("areaSpeculars"); }

	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	bool set_shadowSubdivs(int val) { return setValue("shadowSubdivs", val); }
	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	int get_shadowSubdivs() const { return getInt("shadowSubdivs"); }

	//! When this option is on and GI calculation is set to Irradiance map V-Ray will calculate the effects of this light and store them in the irradiance map. The result is that the irradiance map is computed more slowly but the rendering takes less time. You can also save the irradiance map and reuse it later.
 	//! [UI Guides] displayName=Store with irradiance map
 	//! [Default value] false
	bool set_storeWithIrradianceMap(bool val) { return setValue("storeWithIrradianceMap", val); }
	//! When this option is on and GI calculation is set to Irradiance map V-Ray will calculate the effects of this light and store them in the irradiance map. The result is that the irradiance map is computed more slowly but the rendering takes less time. You can also save the irradiance map and reuse it later.
 	//! [UI Guides] displayName=Store with irradiance map
 	//! [Default value] false
	bool get_storeWithIrradianceMap() const { return getBool("storeWithIrradianceMap"); }

	//! 0.0 if the light has no beam radius
 	//! [Default value] 0
	bool set_beamRadius(float val) { return setValue("beamRadius", val); }
	//! 0.0 if the light has no beam radius
 	//! [Default value] 0
	float get_beamRadius() const { return getFloat("beamRadius"); }
};

class LightDirectMax : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "LightDirectMax"; }

	//! true if the light is casting light (turned on) and false otherwise; it only makes sense to use this parameter if it is animated, or if another object depends on this node but it must not be rendered
 	//! [Default value] true
	bool set_enabled(bool val) { return setValue("enabled", val); }
	//! true if the light is casting light (turned on) and false otherwise; it only makes sense to use this parameter if it is animated, or if another object depends on this node but it must not be rendered
 	//! [Default value] true
	bool get_enabled() const { return getBool("enabled"); }

	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	bool set_transform(const Transform& transform) { return setValue("transform", transform); }
	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	Transform get_transform() const { return getTransform("transform"); }

	//! Color of the light
 	//! [UI Guides] overridenBy=color_tex
 	//! [Default value] Color(1, 1, 1)
	bool set_color(const Color& color) { return setValue("color", color); }
	//! Color of the light
 	//! [UI Guides] overridenBy=color_tex
 	//! [Default value] Color(1, 1, 1)
	Color get_color() const { return getColor("color"); }

	//! A color texture that if present will override the color parameter
 	//! [UI Guides] overrides=color
 	bool set_color_tex(const Plugin& texture) { return setValue("color_tex", texture); }
	//! A color texture that if present will override the color parameter
 	//! [UI Guides] overrides=color
 	bool set_color_tex(const AColor& texture) { return setValue("color_tex", texture); }
	//! A color texture that if present will override the color parameter
 	//! [UI Guides] overrides=color
 	Value get_color_tex() const { return getValue("color_tex"); }

	//! true if the light casts shadows and false otherwise
 	//! [Default value] true
	bool set_shadows(bool val) { return setValue("shadows", val); }
	//! true if the light casts shadows and false otherwise
 	//! [Default value] true
	bool get_shadows() const { return getBool("shadows"); }

	//! The shadow color. Anything but black is not physically accurate.
 	//! [UI Guides] overridenBy=shadowColor_tex
 	//! [Default value] Color(0, 0, 0)
	bool set_shadowColor(const Color& color) { return setValue("shadowColor", color); }
	//! The shadow color. Anything but black is not physically accurate.
 	//! [UI Guides] overridenBy=shadowColor_tex
 	//! [Default value] Color(0, 0, 0)
	Color get_shadowColor() const { return getColor("shadowColor"); }

	//! A color texture that if present will override the shadowColor parameter
 	//! [UI Guides] overrides=shadowColor
 	bool set_shadowColor_tex(const Plugin& texture) { return setValue("shadowColor_tex", texture); }
	//! A color texture that if present will override the shadowColor parameter
 	//! [UI Guides] overrides=shadowColor
 	bool set_shadowColor_tex(const AColor& texture) { return setValue("shadowColor_tex", texture); }
	//! A color texture that if present will override the shadowColor parameter
 	//! [UI Guides] overrides=shadowColor
 	Value get_shadowColor_tex() const { return getValue("shadowColor_tex"); }

	//! Shadow offset from the surface. Helps to prevent polygonal shadow artifacts on low-poly surfaces.
 	//! [UI Guides] displayName=Shadow bias, quantityType=distance
 	//! [Default value] 0
	bool set_shadowBias(float val) { return setValue("shadowBias", val); }
	//! Shadow offset from the surface. Helps to prevent polygonal shadow artifacts on low-poly surfaces.
 	//! [UI Guides] displayName=Shadow bias, quantityType=distance
 	//! [Default value] 0
	float get_shadowBias() const { return getFloat("shadowBias"); }

	//! Determines the number of photons emitted by this light when calculating the Global Photon Map. 1000 subdivs equal 1 million photons.
 	//! [UI Guides] displayName=Photon subdivs, minValue=0
 	//! [Default value] 500
	bool set_photonSubdivs(int val) { return setValue("photonSubdivs", val); }
	//! Determines the number of photons emitted by this light when calculating the Global Photon Map. 1000 subdivs equal 1 million photons.
 	//! [UI Guides] displayName=Photon subdivs, minValue=0
 	//! [Default value] 500
	int get_photonSubdivs() const { return getInt("photonSubdivs"); }

	//! Determines the number of photons emitted by this light when calculating the Caustics Photon Map. 1000 subdivs equal 1 million photons.
 	//! [UI Guides] displayName=Caustics subdivs, minValue=0
 	//! [Default value] 1000
	bool set_causticSubdivs(int val) { return setValue("causticSubdivs", val); }
	//! Determines the number of photons emitted by this light when calculating the Caustics Photon Map. 1000 subdivs equal 1 million photons.
 	//! [UI Guides] displayName=Caustics subdivs, minValue=0
 	//! [Default value] 1000
	int get_causticSubdivs() const { return getInt("causticSubdivs"); }

	//! Multiplier for the diffuse photons.
 	//! [UI Guides] displayName=Diffuse multiplier, minValue=0.0
 	//! [Default value] 1
	bool set_diffuseMult(float val) { return setValue("diffuseMult", val); }
	//! Multiplier for the diffuse photons.
 	//! [UI Guides] displayName=Diffuse multiplier, minValue=0.0
 	//! [Default value] 1
	float get_diffuseMult() const { return getFloat("diffuseMult"); }

	//! Multiplier for the caustics photons.
 	//! [UI Guides] displayName=Caustics multiplier, minValue=0.0
 	//! [Default value] 1
	bool set_causticMult(float val) { return setValue("causticMult", val); }
	//! Multiplier for the caustics photons.
 	//! [UI Guides] displayName=Caustics multiplier, minValue=0.0
 	//! [Default value] 1
	float get_causticMult() const { return getFloat("causticMult"); }

	//! Light cut-off threshold (speed optimization). If the light intensity for a point is below this threshold, the light will not be computed.
 	//! [UI Guides] displayName=Cut-off threshold, minValue=0.0
 	//! [Default value] 0.001
	bool set_cutoffThreshold(float val) { return setValue("cutoffThreshold", val); }
	//! Light cut-off threshold (speed optimization). If the light intensity for a point is below this threshold, the light will not be computed.
 	//! [UI Guides] displayName=Cut-off threshold, minValue=0.0
 	//! [Default value] 0.001
	float get_cutoffThreshold() const { return getFloat("cutoffThreshold"); }

	//! True if the light produces diffuse lighting and false otherwise.
 	//! [UI Guides] displayName=Affect diffuse
 	//! [Default value] true
	bool set_affectDiffuse(bool val) { return setValue("affectDiffuse", val); }
	//! True if the light produces diffuse lighting and false otherwise.
 	//! [UI Guides] displayName=Affect diffuse
 	//! [Default value] true
	bool get_affectDiffuse() const { return getBool("affectDiffuse"); }

	//! True if the light produces specular hilights and false otherwise.
 	//! [UI Guides] displayName=Affect specular
 	//! [Default value] true
	bool set_affectSpecular(bool val) { return setValue("affectSpecular", val); }
	//! True if the light produces specular hilights and false otherwise.
 	//! [UI Guides] displayName=Affect specular
 	//! [Default value] true
	bool get_affectSpecular() const { return getBool("affectSpecular"); }

	//! True if the bumped normal should be used to check if the light direction is below the surface.
 	//! [UI Guides] displayName=Bumped normal check
 	//! [Default value] false
	bool set_bumped_below_surface_check(bool val) { return setValue("bumped_below_surface_check", val); }
	//! True if the bumped normal should be used to check if the light direction is below the surface.
 	//! [UI Guides] displayName=Bumped normal check
 	//! [Default value] false
	bool get_bumped_below_surface_check() const { return getBool("bumped_below_surface_check"); }

	//! Number of parameter samples for motion blur.
 	//! [Default value] 0
	bool set_nsamples(int val) { return setValue("nsamples", val); }
	//! Number of parameter samples for motion blur.
 	//! [Default value] 0
	int get_nsamples() const { return getInt("nsamples"); }

	//! Diffuse contribution for the light.
 	//! [Default value] 1
	bool set_diffuse_contribution(float val) { return setValue("diffuse_contribution", val); }
	//! Diffuse contribution for the light.
 	//! [Default value] 1
	float get_diffuse_contribution() const { return getFloat("diffuse_contribution"); }

	//! Specular contribution for the light.
 	//! [Default value] 1
	bool set_specular_contribution(float val) { return setValue("specular_contribution", val); }
	//! Specular contribution for the light.
 	//! [Default value] 1
	float get_specular_contribution() const { return getFloat("specular_contribution"); }

	//! Render channels the result of this light will be written to
 	bool set_channels(const ValueList& pluginList) { return setValue("channels", pluginList); }
	//! Render channels the result of this light will be written to
 	ValueList get_channels() const { return getValueList("channels"); }

	//! Render channels the raw diffuse result of this light will be written to
 	bool set_channels_raw(const ValueList& pluginList) { return setValue("channels_raw", pluginList); }
	//! Render channels the raw diffuse result of this light will be written to
 	ValueList get_channels_raw() const { return getValueList("channels_raw"); }

	//! Render channels the diffuse result of this light will be written to
 	bool set_channels_diffuse(const ValueList& pluginList) { return setValue("channels_diffuse", pluginList); }
	//! Render channels the diffuse result of this light will be written to
 	ValueList get_channels_diffuse() const { return getValueList("channels_diffuse"); }

	//! Render channels the specular result of this light will be written to
 	bool set_channels_specular(const ValueList& pluginList) { return setValue("channels_specular", pluginList); }
	//! Render channels the specular result of this light will be written to
 	ValueList get_channels_specular() const { return getValueList("channels_specular"); }

	//! true if the light should use the global light level setting
 	//! [Default value] true
	bool set_use_global_light_level(bool val) { return setValue("use_global_light_level", val); }
	//! true if the light should use the global light level setting
 	//! [Default value] true
	bool get_use_global_light_level() const { return getBool("use_global_light_level"); }

	//! Units for the intensity (0 - default, 1 - lumens, 2 - lm/m/m/sr, 3 - watts, 4 - w/m/m/sr)
 	//! [UI Guides] enum=0:Default; 1:Lumens; 2:lm/m/m/sr; 3:Watts; 4:w/m/m/sr
 	//! [Default value] 0
	bool set_units(int val) { return setValue("units", val); }
	//! Units for the intensity (0 - default, 1 - lumens, 2 - lm/m/m/sr, 3 - watts, 4 - w/m/m/sr)
 	//! [UI Guides] enum=0:Default; 1:Lumens; 2:lm/m/m/sr; 3:Watts; 4:w/m/m/sr
 	//! [Default value] 0
	int get_units() const { return getInt("units"); }

	//! Light intensity
 	//! [UI Guides] overridenBy=intensity_tex
 	//! [Default value] 1
	bool set_intensity(float val) { return setValue("intensity", val); }
	//! Light intensity
 	//! [UI Guides] overridenBy=intensity_tex
 	//! [Default value] 1
	float get_intensity() const { return getFloat("intensity"); }

	//! A float texture that if present will override the intensity parameter
 	//! [UI Guides] overrides=intensity
 	bool set_intensity_tex(const Plugin& texturefloat) { return setValue("intensity_tex", texturefloat); }
	//! A float texture that if present will override the intensity parameter
 	//! [UI Guides] overrides=intensity
 	bool set_intensity_tex(float texturefloat) { return setValue("intensity_tex", texturefloat); }
	//! A float texture that if present will override the intensity parameter
 	//! [UI Guides] overrides=intensity
 	Value get_intensity_tex() const { return getValue("intensity_tex"); }

	//! The size of the light; 0.0 is a point light, larger values produces soft (area) shadows
 	//! [UI Guides] quantityType=distance, overridenBy=shadowRadius_tex
 	//! [Default value] 0
	bool set_shadowRadius(float val) { return setValue("shadowRadius", val); }
	//! The size of the light; 0.0 is a point light, larger values produces soft (area) shadows
 	//! [UI Guides] quantityType=distance, overridenBy=shadowRadius_tex
 	//! [Default value] 0
	float get_shadowRadius() const { return getFloat("shadowRadius"); }

	//! A float texture that if present will override the shadows radius parameter
 	//! [UI Guides] overrides=shadowRadius
 	bool set_shadowRadius_tex(const Plugin& texturefloat) { return setValue("shadowRadius_tex", texturefloat); }
	//! A float texture that if present will override the shadows radius parameter
 	//! [UI Guides] overrides=shadowRadius
 	bool set_shadowRadius_tex(float texturefloat) { return setValue("shadowRadius_tex", texturefloat); }
	//! A float texture that if present will override the shadows radius parameter
 	//! [UI Guides] overrides=shadowRadius
 	Value get_shadowRadius_tex() const { return getValue("shadowRadius_tex"); }

	//! If true, the hilights will match the shape of the light; if false, hilights will always be calculated as from a point light
 	//! [Default value] false
	bool set_areaSpeculars(bool val) { return setValue("areaSpeculars", val); }
	//! If true, the hilights will match the shape of the light; if false, hilights will always be calculated as from a point light
 	//! [Default value] false
	bool get_areaSpeculars() const { return getBool("areaSpeculars"); }

	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	bool set_shadowSubdivs(int val) { return setValue("shadowSubdivs", val); }
	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	int get_shadowSubdivs() const { return getInt("shadowSubdivs"); }

	//! When this option is on and GI calculation is set to Irradiance map V-Ray will calculate the effects of this light and store them in the irradiance map. The result is that the irradiance map is computed more slowly but the rendering takes less time. You can also save the irradiance map and reuse it later.
 	//! [UI Guides] displayName=Store with irradiance map
 	//! [Default value] false
	bool set_storeWithIrradianceMap(bool val) { return setValue("storeWithIrradianceMap", val); }
	//! When this option is on and GI calculation is set to Irradiance map V-Ray will calculate the effects of this light and store them in the irradiance map. The result is that the irradiance map is computed more slowly but the rendering takes less time. You can also save the irradiance map and reuse it later.
 	//! [UI Guides] displayName=Store with irradiance map
 	//! [Default value] false
	bool get_storeWithIrradianceMap() const { return getBool("storeWithIrradianceMap"); }

	//! (description missing)
	bool set_projector_map(const Plugin& texture) { return setValue("projector_map", texture); }
	//! (description missing)
	bool set_projector_map(const AColor& texture) { return setValue("projector_map", texture); }
	//! (description missing)
	Value get_projector_map() const { return getValue("projector_map"); }

	//! Decay type (0 - no decay, 1 - linear, 2 - square)
 	//! [UI Guides] enum=0:No decay; 1:Linear; 2:Square
 	//! [Default value] 0
	bool set_decay_type(int val) { return setValue("decay_type", val); }
	//! Decay type (0 - no decay, 1 - linear, 2 - square)
 	//! [UI Guides] enum=0:No decay; 1:Linear; 2:Square
 	//! [Default value] 0
	int get_decay_type() const { return getInt("decay_type"); }

	//! (description missing)
	//! [Default value] 1
	bool set_decay_start(float val) { return setValue("decay_start", val); }
	//! (description missing)
	//! [Default value] 1
	float get_decay_start() const { return getFloat("decay_start"); }

	//! true to use near attenuation
 	//! [Default value] false
	bool set_near_attenuation(bool val) { return setValue("near_attenuation", val); }
	//! true to use near attenuation
 	//! [Default value] false
	bool get_near_attenuation() const { return getBool("near_attenuation"); }

	//! Near attenuation start
 	//! [Default value] 0
	bool set_near_attenuation_start(float val) { return setValue("near_attenuation_start", val); }
	//! Near attenuation start
 	//! [Default value] 0
	float get_near_attenuation_start() const { return getFloat("near_attenuation_start"); }

	//! Near attenuation end
 	//! [Default value] 0
	bool set_near_attenuation_end(float val) { return setValue("near_attenuation_end", val); }
	//! Near attenuation end
 	//! [Default value] 0
	float get_near_attenuation_end() const { return getFloat("near_attenuation_end"); }

	//! true to use far attenuation
 	//! [Default value] false
	bool set_far_attenuation(bool val) { return setValue("far_attenuation", val); }
	//! true to use far attenuation
 	//! [Default value] false
	bool get_far_attenuation() const { return getBool("far_attenuation"); }

	//! far attenuation start
 	//! [Default value] 0
	bool set_far_attenuation_start(float val) { return setValue("far_attenuation_start", val); }
	//! far attenuation start
 	//! [Default value] 0
	float get_far_attenuation_start() const { return getFloat("far_attenuation_start"); }

	//! far attenuation end
 	//! [Default value] 0
	bool set_far_attenuation_end(float val) { return setValue("far_attenuation_end", val); }
	//! far attenuation end
 	//! [Default value] 0
	float get_far_attenuation_end() const { return getFloat("far_attenuation_end"); }

	//! Shape for soft shadows (0 - box, 1 - sphere)
 	//! [UI Guides] enum=0:Box; 1:Sphere
 	//! [Default value] 0
	bool set_shadowShape(int val) { return setValue("shadowShape", val); }
	//! Shape for soft shadows (0 - box, 1 - sphere)
 	//! [UI Guides] enum=0:Box; 1:Sphere
 	//! [Default value] 0
	int get_shadowShape() const { return getInt("shadowShape"); }

	//! V-size for box shadows
 	//! [Default value] 0
	bool set_shadowRadius1(float val) { return setValue("shadowRadius1", val); }
	//! V-size for box shadows
 	//! [Default value] 0
	float get_shadowRadius1() const { return getFloat("shadowRadius1"); }

	//! W-size for box shadows
 	//! [Default value] 0
	bool set_shadowRadius2(float val) { return setValue("shadowRadius2", val); }
	//! W-size for box shadows
 	//! [Default value] 0
	float get_shadowRadius2() const { return getFloat("shadowRadius2"); }

	//! The entire spot cone, in radians
 	//! [UI Guides] minValue=0, maxValue=3.14159265359
 	//! [Default value] 1
	bool set_fallsize(float val) { return setValue("fallsize", val); }
	//! The entire spot cone, in radians
 	//! [UI Guides] minValue=0, maxValue=3.14159265359
 	//! [Default value] 1
	float get_fallsize() const { return getFloat("fallsize"); }

	//! The hotspot, in radians
 	//! [UI Guides] minValue=0, maxValue=3.14159265359
 	//! [Default value] 0
	bool set_hotspot(float val) { return setValue("hotspot", val); }
	//! The hotspot, in radians
 	//! [UI Guides] minValue=0, maxValue=3.14159265359
 	//! [Default value] 0
	float get_hotspot() const { return getFloat("hotspot"); }

	//! The shape of the beam (0 - circular, 1 - rectangular, 2 - smooth rectangular)
 	//! [UI Guides] enum=0:Circular; 1:Rectangular; 2:Smooth rectangular
 	//! [Default value] 0
	bool set_shape_type(int val) { return setValue("shape_type", val); }
	//! The shape of the beam (0 - circular, 1 - rectangular, 2 - smooth rectangular)
 	//! [UI Guides] enum=0:Circular; 1:Rectangular; 2:Smooth rectangular
 	//! [Default value] 0
	int get_shape_type() const { return getInt("shape_type"); }

	//! Aspect for the rectangle shape
 	//! [Default value] 1
	bool set_rect_aspect(float val) { return setValue("rect_aspect", val); }
	//! Aspect for the rectangle shape
 	//! [Default value] 1
	float get_rect_aspect() const { return getFloat("rect_aspect"); }

	//! true if the light is not limited in the beam
 	//! [Default value] false
	bool set_overshoot(bool val) { return setValue("overshoot", val); }
	//! true if the light is not limited in the beam
 	//! [Default value] false
	bool get_overshoot() const { return getBool("overshoot"); }
};

class LightDirectModo : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "LightDirectModo"; }

	//! true if the light is casting light (turned on) and false otherwise; it only makes sense to use this parameter if it is animated, or if another object depends on this node but it must not be rendered
 	//! [Default value] true
	bool set_enabled(bool val) { return setValue("enabled", val); }
	//! true if the light is casting light (turned on) and false otherwise; it only makes sense to use this parameter if it is animated, or if another object depends on this node but it must not be rendered
 	//! [Default value] true
	bool get_enabled() const { return getBool("enabled"); }

	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	bool set_transform(const Transform& transform) { return setValue("transform", transform); }
	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	Transform get_transform() const { return getTransform("transform"); }

	//! Color of the light
 	//! [UI Guides] overridenBy=color_tex
 	//! [Default value] Color(1, 1, 1)
	bool set_color(const Color& color) { return setValue("color", color); }
	//! Color of the light
 	//! [UI Guides] overridenBy=color_tex
 	//! [Default value] Color(1, 1, 1)
	Color get_color() const { return getColor("color"); }

	//! A color texture that if present will override the color parameter
 	//! [UI Guides] overrides=color
 	bool set_color_tex(const Plugin& texture) { return setValue("color_tex", texture); }
	//! A color texture that if present will override the color parameter
 	//! [UI Guides] overrides=color
 	bool set_color_tex(const AColor& texture) { return setValue("color_tex", texture); }
	//! A color texture that if present will override the color parameter
 	//! [UI Guides] overrides=color
 	Value get_color_tex() const { return getValue("color_tex"); }

	//! true if the light casts shadows and false otherwise
 	//! [Default value] true
	bool set_shadows(bool val) { return setValue("shadows", val); }
	//! true if the light casts shadows and false otherwise
 	//! [Default value] true
	bool get_shadows() const { return getBool("shadows"); }

	//! The shadow color. Anything but black is not physically accurate.
 	//! [UI Guides] overridenBy=shadowColor_tex
 	//! [Default value] Color(0, 0, 0)
	bool set_shadowColor(const Color& color) { return setValue("shadowColor", color); }
	//! The shadow color. Anything but black is not physically accurate.
 	//! [UI Guides] overridenBy=shadowColor_tex
 	//! [Default value] Color(0, 0, 0)
	Color get_shadowColor() const { return getColor("shadowColor"); }

	//! A color texture that if present will override the shadowColor parameter
 	//! [UI Guides] overrides=shadowColor
 	bool set_shadowColor_tex(const Plugin& texture) { return setValue("shadowColor_tex", texture); }
	//! A color texture that if present will override the shadowColor parameter
 	//! [UI Guides] overrides=shadowColor
 	bool set_shadowColor_tex(const AColor& texture) { return setValue("shadowColor_tex", texture); }
	//! A color texture that if present will override the shadowColor parameter
 	//! [UI Guides] overrides=shadowColor
 	Value get_shadowColor_tex() const { return getValue("shadowColor_tex"); }

	//! Shadow offset from the surface. Helps to prevent polygonal shadow artifacts on low-poly surfaces.
 	//! [UI Guides] displayName=Shadow bias, quantityType=distance
 	//! [Default value] 0
	bool set_shadowBias(float val) { return setValue("shadowBias", val); }
	//! Shadow offset from the surface. Helps to prevent polygonal shadow artifacts on low-poly surfaces.
 	//! [UI Guides] displayName=Shadow bias, quantityType=distance
 	//! [Default value] 0
	float get_shadowBias() const { return getFloat("shadowBias"); }

	//! Determines the number of photons emitted by this light when calculating the Global Photon Map. 1000 subdivs equal 1 million photons.
 	//! [UI Guides] displayName=Photon subdivs, minValue=0
 	//! [Default value] 500
	bool set_photonSubdivs(int val) { return setValue("photonSubdivs", val); }
	//! Determines the number of photons emitted by this light when calculating the Global Photon Map. 1000 subdivs equal 1 million photons.
 	//! [UI Guides] displayName=Photon subdivs, minValue=0
 	//! [Default value] 500
	int get_photonSubdivs() const { return getInt("photonSubdivs"); }

	//! Determines the number of photons emitted by this light when calculating the Caustics Photon Map. 1000 subdivs equal 1 million photons.
 	//! [UI Guides] displayName=Caustics subdivs, minValue=0
 	//! [Default value] 1000
	bool set_causticSubdivs(int val) { return setValue("causticSubdivs", val); }
	//! Determines the number of photons emitted by this light when calculating the Caustics Photon Map. 1000 subdivs equal 1 million photons.
 	//! [UI Guides] displayName=Caustics subdivs, minValue=0
 	//! [Default value] 1000
	int get_causticSubdivs() const { return getInt("causticSubdivs"); }

	//! Multiplier for the diffuse photons.
 	//! [UI Guides] displayName=Diffuse multiplier, minValue=0.0
 	//! [Default value] 1
	bool set_diffuseMult(float val) { return setValue("diffuseMult", val); }
	//! Multiplier for the diffuse photons.
 	//! [UI Guides] displayName=Diffuse multiplier, minValue=0.0
 	//! [Default value] 1
	float get_diffuseMult() const { return getFloat("diffuseMult"); }

	//! Multiplier for the caustics photons.
 	//! [UI Guides] displayName=Caustics multiplier, minValue=0.0
 	//! [Default value] 1
	bool set_causticMult(float val) { return setValue("causticMult", val); }
	//! Multiplier for the caustics photons.
 	//! [UI Guides] displayName=Caustics multiplier, minValue=0.0
 	//! [Default value] 1
	float get_causticMult() const { return getFloat("causticMult"); }

	//! Light cut-off threshold (speed optimization). If the light intensity for a point is below this threshold, the light will not be computed.
 	//! [UI Guides] displayName=Cut-off threshold, minValue=0.0
 	//! [Default value] 0.001
	bool set_cutoffThreshold(float val) { return setValue("cutoffThreshold", val); }
	//! Light cut-off threshold (speed optimization). If the light intensity for a point is below this threshold, the light will not be computed.
 	//! [UI Guides] displayName=Cut-off threshold, minValue=0.0
 	//! [Default value] 0.001
	float get_cutoffThreshold() const { return getFloat("cutoffThreshold"); }

	//! True if the light produces diffuse lighting and false otherwise.
 	//! [UI Guides] displayName=Affect diffuse
 	//! [Default value] true
	bool set_affectDiffuse(bool val) { return setValue("affectDiffuse", val); }
	//! True if the light produces diffuse lighting and false otherwise.
 	//! [UI Guides] displayName=Affect diffuse
 	//! [Default value] true
	bool get_affectDiffuse() const { return getBool("affectDiffuse"); }

	//! True if the light produces specular hilights and false otherwise.
 	//! [UI Guides] displayName=Affect specular
 	//! [Default value] true
	bool set_affectSpecular(bool val) { return setValue("affectSpecular", val); }
	//! True if the light produces specular hilights and false otherwise.
 	//! [UI Guides] displayName=Affect specular
 	//! [Default value] true
	bool get_affectSpecular() const { return getBool("affectSpecular"); }

	//! True if the bumped normal should be used to check if the light direction is below the surface.
 	//! [UI Guides] displayName=Bumped normal check
 	//! [Default value] false
	bool set_bumped_below_surface_check(bool val) { return setValue("bumped_below_surface_check", val); }
	//! True if the bumped normal should be used to check if the light direction is below the surface.
 	//! [UI Guides] displayName=Bumped normal check
 	//! [Default value] false
	bool get_bumped_below_surface_check() const { return getBool("bumped_below_surface_check"); }

	//! Number of parameter samples for motion blur.
 	//! [Default value] 0
	bool set_nsamples(int val) { return setValue("nsamples", val); }
	//! Number of parameter samples for motion blur.
 	//! [Default value] 0
	int get_nsamples() const { return getInt("nsamples"); }

	//! Diffuse contribution for the light.
 	//! [Default value] 1
	bool set_diffuse_contribution(float val) { return setValue("diffuse_contribution", val); }
	//! Diffuse contribution for the light.
 	//! [Default value] 1
	float get_diffuse_contribution() const { return getFloat("diffuse_contribution"); }

	//! Specular contribution for the light.
 	//! [Default value] 1
	bool set_specular_contribution(float val) { return setValue("specular_contribution", val); }
	//! Specular contribution for the light.
 	//! [Default value] 1
	float get_specular_contribution() const { return getFloat("specular_contribution"); }

	//! Render channels the result of this light will be written to
 	bool set_channels(const ValueList& pluginList) { return setValue("channels", pluginList); }
	//! Render channels the result of this light will be written to
 	ValueList get_channels() const { return getValueList("channels"); }

	//! Render channels the raw diffuse result of this light will be written to
 	bool set_channels_raw(const ValueList& pluginList) { return setValue("channels_raw", pluginList); }
	//! Render channels the raw diffuse result of this light will be written to
 	ValueList get_channels_raw() const { return getValueList("channels_raw"); }

	//! Render channels the diffuse result of this light will be written to
 	bool set_channels_diffuse(const ValueList& pluginList) { return setValue("channels_diffuse", pluginList); }
	//! Render channels the diffuse result of this light will be written to
 	ValueList get_channels_diffuse() const { return getValueList("channels_diffuse"); }

	//! Render channels the specular result of this light will be written to
 	bool set_channels_specular(const ValueList& pluginList) { return setValue("channels_specular", pluginList); }
	//! Render channels the specular result of this light will be written to
 	ValueList get_channels_specular() const { return getValueList("channels_specular"); }

	//! true if the light should use the global light level setting
 	//! [Default value] true
	bool set_use_global_light_level(bool val) { return setValue("use_global_light_level", val); }
	//! true if the light should use the global light level setting
 	//! [Default value] true
	bool get_use_global_light_level() const { return getBool("use_global_light_level"); }

	//! Units for the intensity (0 - default, 1 - lumens, 2 - lm/m/m/sr, 3 - watts, 4 - w/m/m/sr)
 	//! [UI Guides] enum=0:Default; 1:Lumens; 2:lm/m/m/sr; 3:Watts; 4:w/m/m/sr
 	//! [Default value] 0
	bool set_units(int val) { return setValue("units", val); }
	//! Units for the intensity (0 - default, 1 - lumens, 2 - lm/m/m/sr, 3 - watts, 4 - w/m/m/sr)
 	//! [UI Guides] enum=0:Default; 1:Lumens; 2:lm/m/m/sr; 3:Watts; 4:w/m/m/sr
 	//! [Default value] 0
	int get_units() const { return getInt("units"); }

	//! Light intensity
 	//! [UI Guides] overridenBy=intensity_tex
 	//! [Default value] 1
	bool set_intensity(float val) { return setValue("intensity", val); }
	//! Light intensity
 	//! [UI Guides] overridenBy=intensity_tex
 	//! [Default value] 1
	float get_intensity() const { return getFloat("intensity"); }

	//! A float texture that if present will override the intensity parameter
 	//! [UI Guides] overrides=intensity
 	bool set_intensity_tex(const Plugin& texturefloat) { return setValue("intensity_tex", texturefloat); }
	//! A float texture that if present will override the intensity parameter
 	//! [UI Guides] overrides=intensity
 	bool set_intensity_tex(float texturefloat) { return setValue("intensity_tex", texturefloat); }
	//! A float texture that if present will override the intensity parameter
 	//! [UI Guides] overrides=intensity
 	Value get_intensity_tex() const { return getValue("intensity_tex"); }

	//! The size of the light; 0.0 is a point light, larger values produces soft (area) shadows
 	//! [UI Guides] quantityType=distance, overridenBy=shadowRadius_tex
 	//! [Default value] 0
	bool set_shadowRadius(float val) { return setValue("shadowRadius", val); }
	//! The size of the light; 0.0 is a point light, larger values produces soft (area) shadows
 	//! [UI Guides] quantityType=distance, overridenBy=shadowRadius_tex
 	//! [Default value] 0
	float get_shadowRadius() const { return getFloat("shadowRadius"); }

	//! A float texture that if present will override the shadows radius parameter
 	//! [UI Guides] overrides=shadowRadius
 	bool set_shadowRadius_tex(const Plugin& texturefloat) { return setValue("shadowRadius_tex", texturefloat); }
	//! A float texture that if present will override the shadows radius parameter
 	//! [UI Guides] overrides=shadowRadius
 	bool set_shadowRadius_tex(float texturefloat) { return setValue("shadowRadius_tex", texturefloat); }
	//! A float texture that if present will override the shadows radius parameter
 	//! [UI Guides] overrides=shadowRadius
 	Value get_shadowRadius_tex() const { return getValue("shadowRadius_tex"); }

	//! If true, the hilights will match the shape of the light; if false, hilights will always be calculated as from a point light
 	//! [Default value] false
	bool set_areaSpeculars(bool val) { return setValue("areaSpeculars", val); }
	//! If true, the hilights will match the shape of the light; if false, hilights will always be calculated as from a point light
 	//! [Default value] false
	bool get_areaSpeculars() const { return getBool("areaSpeculars"); }

	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	bool set_shadowSubdivs(int val) { return setValue("shadowSubdivs", val); }
	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	int get_shadowSubdivs() const { return getInt("shadowSubdivs"); }

	//! When this option is on and GI calculation is set to Irradiance map V-Ray will calculate the effects of this light and store them in the irradiance map. The result is that the irradiance map is computed more slowly but the rendering takes less time. You can also save the irradiance map and reuse it later.
 	//! [UI Guides] displayName=Store with irradiance map
 	//! [Default value] false
	bool set_storeWithIrradianceMap(bool val) { return setValue("storeWithIrradianceMap", val); }
	//! When this option is on and GI calculation is set to Irradiance map V-Ray will calculate the effects of this light and store them in the irradiance map. The result is that the irradiance map is computed more slowly but the rendering takes less time. You can also save the irradiance map and reuse it later.
 	//! [UI Guides] displayName=Store with irradiance map
 	//! [Default value] false
	bool get_storeWithIrradianceMap() const { return getBool("storeWithIrradianceMap"); }

	//! 0.0 if the light has no beam radius
 	//! [Default value] 0
	bool set_beamRadius(float val) { return setValue("beamRadius", val); }
	//! 0.0 if the light has no beam radius
 	//! [Default value] 0
	float get_beamRadius() const { return getFloat("beamRadius"); }

	//! 0.0 if the light has no soft shadows; this value is in radians
 	//! [Default value] 0
	bool set_spreadAngle(float val) { return setValue("spreadAngle", val); }
	//! 0.0 if the light has no soft shadows; this value is in radians
 	//! [Default value] 0
	float get_spreadAngle() const { return getFloat("spreadAngle"); }
};

class LightDome : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "LightDome"; }

	//! true if the light is casting light (turned on) and false otherwise; it only makes sense to use this parameter if it is animated, or if another object depends on this node but it must not be rendered
 	//! [Default value] true
	bool set_enabled(bool val) { return setValue("enabled", val); }
	//! true if the light is casting light (turned on) and false otherwise; it only makes sense to use this parameter if it is animated, or if another object depends on this node but it must not be rendered
 	//! [Default value] true
	bool get_enabled() const { return getBool("enabled"); }

	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	bool set_transform(const Transform& transform) { return setValue("transform", transform); }
	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	Transform get_transform() const { return getTransform("transform"); }

	//! Color of the light
 	//! [UI Guides] overridenBy=color_tex
 	//! [Default value] Color(1, 1, 1)
	bool set_color(const Color& color) { return setValue("color", color); }
	//! Color of the light
 	//! [UI Guides] overridenBy=color_tex
 	//! [Default value] Color(1, 1, 1)
	Color get_color() const { return getColor("color"); }

	//! A color texture that if present will override the color parameter
 	//! [UI Guides] overrides=color
 	bool set_color_tex(const Plugin& texture) { return setValue("color_tex", texture); }
	//! A color texture that if present will override the color parameter
 	//! [UI Guides] overrides=color
 	bool set_color_tex(const AColor& texture) { return setValue("color_tex", texture); }
	//! A color texture that if present will override the color parameter
 	//! [UI Guides] overrides=color
 	Value get_color_tex() const { return getValue("color_tex"); }

	//! true if the light casts shadows and false otherwise
 	//! [Default value] true
	bool set_shadows(bool val) { return setValue("shadows", val); }
	//! true if the light casts shadows and false otherwise
 	//! [Default value] true
	bool get_shadows() const { return getBool("shadows"); }

	//! The shadow color. Anything but black is not physically accurate.
 	//! [UI Guides] overridenBy=shadowColor_tex
 	//! [Default value] Color(0, 0, 0)
	bool set_shadowColor(const Color& color) { return setValue("shadowColor", color); }
	//! The shadow color. Anything but black is not physically accurate.
 	//! [UI Guides] overridenBy=shadowColor_tex
 	//! [Default value] Color(0, 0, 0)
	Color get_shadowColor() const { return getColor("shadowColor"); }

	//! A color texture that if present will override the shadowColor parameter
 	//! [UI Guides] overrides=shadowColor
 	bool set_shadowColor_tex(const Plugin& texture) { return setValue("shadowColor_tex", texture); }
	//! A color texture that if present will override the shadowColor parameter
 	//! [UI Guides] overrides=shadowColor
 	bool set_shadowColor_tex(const AColor& texture) { return setValue("shadowColor_tex", texture); }
	//! A color texture that if present will override the shadowColor parameter
 	//! [UI Guides] overrides=shadowColor
 	Value get_shadowColor_tex() const { return getValue("shadowColor_tex"); }

	//! Shadow offset from the surface. Helps to prevent polygonal shadow artifacts on low-poly surfaces.
 	//! [UI Guides] displayName=Shadow bias, quantityType=distance
 	//! [Default value] 0
	bool set_shadowBias(float val) { return setValue("shadowBias", val); }
	//! Shadow offset from the surface. Helps to prevent polygonal shadow artifacts on low-poly surfaces.
 	//! [UI Guides] displayName=Shadow bias, quantityType=distance
 	//! [Default value] 0
	float get_shadowBias() const { return getFloat("shadowBias"); }

	//! Determines the number of photons emitted by this light when calculating the Global Photon Map. 1000 subdivs equal 1 million photons.
 	//! [UI Guides] displayName=Photon subdivs, minValue=0
 	//! [Default value] 500
	bool set_photonSubdivs(int val) { return setValue("photonSubdivs", val); }
	//! Determines the number of photons emitted by this light when calculating the Global Photon Map. 1000 subdivs equal 1 million photons.
 	//! [UI Guides] displayName=Photon subdivs, minValue=0
 	//! [Default value] 500
	int get_photonSubdivs() const { return getInt("photonSubdivs"); }

	//! Determines the number of photons emitted by this light when calculating the Caustics Photon Map. 1000 subdivs equal 1 million photons.
 	//! [UI Guides] displayName=Caustics subdivs, minValue=0
 	//! [Default value] 1000
	bool set_causticSubdivs(int val) { return setValue("causticSubdivs", val); }
	//! Determines the number of photons emitted by this light when calculating the Caustics Photon Map. 1000 subdivs equal 1 million photons.
 	//! [UI Guides] displayName=Caustics subdivs, minValue=0
 	//! [Default value] 1000
	int get_causticSubdivs() const { return getInt("causticSubdivs"); }

	//! Multiplier for the diffuse photons.
 	//! [UI Guides] displayName=Diffuse multiplier, minValue=0.0
 	//! [Default value] 1
	bool set_diffuseMult(float val) { return setValue("diffuseMult", val); }
	//! Multiplier for the diffuse photons.
 	//! [UI Guides] displayName=Diffuse multiplier, minValue=0.0
 	//! [Default value] 1
	float get_diffuseMult() const { return getFloat("diffuseMult"); }

	//! Multiplier for the caustics photons.
 	//! [UI Guides] displayName=Caustics multiplier, minValue=0.0
 	//! [Default value] 1
	bool set_causticMult(float val) { return setValue("causticMult", val); }
	//! Multiplier for the caustics photons.
 	//! [UI Guides] displayName=Caustics multiplier, minValue=0.0
 	//! [Default value] 1
	float get_causticMult() const { return getFloat("causticMult"); }

	//! Light cut-off threshold (speed optimization). If the light intensity for a point is below this threshold, the light will not be computed.
 	//! [UI Guides] displayName=Cut-off threshold, minValue=0.0
 	//! [Default value] 0.001
	bool set_cutoffThreshold(float val) { return setValue("cutoffThreshold", val); }
	//! Light cut-off threshold (speed optimization). If the light intensity for a point is below this threshold, the light will not be computed.
 	//! [UI Guides] displayName=Cut-off threshold, minValue=0.0
 	//! [Default value] 0.001
	float get_cutoffThreshold() const { return getFloat("cutoffThreshold"); }

	//! True if the light produces diffuse lighting and false otherwise.
 	//! [UI Guides] displayName=Affect diffuse
 	//! [Default value] true
	bool set_affectDiffuse(bool val) { return setValue("affectDiffuse", val); }
	//! True if the light produces diffuse lighting and false otherwise.
 	//! [UI Guides] displayName=Affect diffuse
 	//! [Default value] true
	bool get_affectDiffuse() const { return getBool("affectDiffuse"); }

	//! True if the light produces specular hilights and false otherwise.
 	//! [UI Guides] displayName=Affect specular
 	//! [Default value] true
	bool set_affectSpecular(bool val) { return setValue("affectSpecular", val); }
	//! True if the light produces specular hilights and false otherwise.
 	//! [UI Guides] displayName=Affect specular
 	//! [Default value] true
	bool get_affectSpecular() const { return getBool("affectSpecular"); }

	//! True if the bumped normal should be used to check if the light direction is below the surface.
 	//! [UI Guides] displayName=Bumped normal check
 	//! [Default value] false
	bool set_bumped_below_surface_check(bool val) { return setValue("bumped_below_surface_check", val); }
	//! True if the bumped normal should be used to check if the light direction is below the surface.
 	//! [UI Guides] displayName=Bumped normal check
 	//! [Default value] false
	bool get_bumped_below_surface_check() const { return getBool("bumped_below_surface_check"); }

	//! Number of parameter samples for motion blur.
 	//! [Default value] 0
	bool set_nsamples(int val) { return setValue("nsamples", val); }
	//! Number of parameter samples for motion blur.
 	//! [Default value] 0
	int get_nsamples() const { return getInt("nsamples"); }

	//! Diffuse contribution for the light.
 	//! [Default value] 1
	bool set_diffuse_contribution(float val) { return setValue("diffuse_contribution", val); }
	//! Diffuse contribution for the light.
 	//! [Default value] 1
	float get_diffuse_contribution() const { return getFloat("diffuse_contribution"); }

	//! Specular contribution for the light.
 	//! [Default value] 1
	bool set_specular_contribution(float val) { return setValue("specular_contribution", val); }
	//! Specular contribution for the light.
 	//! [Default value] 1
	float get_specular_contribution() const { return getFloat("specular_contribution"); }

	//! Render channels the result of this light will be written to
 	bool set_channels(const ValueList& pluginList) { return setValue("channels", pluginList); }
	//! Render channels the result of this light will be written to
 	ValueList get_channels() const { return getValueList("channels"); }

	//! Render channels the raw diffuse result of this light will be written to
 	bool set_channels_raw(const ValueList& pluginList) { return setValue("channels_raw", pluginList); }
	//! Render channels the raw diffuse result of this light will be written to
 	ValueList get_channels_raw() const { return getValueList("channels_raw"); }

	//! Render channels the diffuse result of this light will be written to
 	bool set_channels_diffuse(const ValueList& pluginList) { return setValue("channels_diffuse", pluginList); }
	//! Render channels the diffuse result of this light will be written to
 	ValueList get_channels_diffuse() const { return getValueList("channels_diffuse"); }

	//! Render channels the specular result of this light will be written to
 	bool set_channels_specular(const ValueList& pluginList) { return setValue("channels_specular", pluginList); }
	//! Render channels the specular result of this light will be written to
 	ValueList get_channels_specular() const { return getValueList("channels_specular"); }

	//! true if the light should use the global light level setting
 	//! [Default value] true
	bool set_use_global_light_level(bool val) { return setValue("use_global_light_level", val); }
	//! true if the light should use the global light level setting
 	//! [Default value] true
	bool get_use_global_light_level() const { return getBool("use_global_light_level"); }

	//! Units for the intensity (0 - default, 1 - lumens, 2 - lm/m/m/sr, 3 - watts, 4 - w/m/m/sr)
 	//! [UI Guides] enum=0:Default; 1:Lumens; 2:lm/m/m/sr; 3:Watts; 4:w/m/m/sr
 	//! [Default value] 0
	bool set_units(int val) { return setValue("units", val); }
	//! Units for the intensity (0 - default, 1 - lumens, 2 - lm/m/m/sr, 3 - watts, 4 - w/m/m/sr)
 	//! [UI Guides] enum=0:Default; 1:Lumens; 2:lm/m/m/sr; 3:Watts; 4:w/m/m/sr
 	//! [Default value] 0
	int get_units() const { return getInt("units"); }

	//! Light intensity
 	//! [UI Guides] overridenBy=intensity_tex
 	//! [Default value] 1
	bool set_intensity(float val) { return setValue("intensity", val); }
	//! Light intensity
 	//! [UI Guides] overridenBy=intensity_tex
 	//! [Default value] 1
	float get_intensity() const { return getFloat("intensity"); }

	//! A float texture that if present will override the intensity parameter
 	//! [UI Guides] overrides=intensity
 	bool set_intensity_tex(const Plugin& texturefloat) { return setValue("intensity_tex", texturefloat); }
	//! A float texture that if present will override the intensity parameter
 	//! [UI Guides] overrides=intensity
 	bool set_intensity_tex(float texturefloat) { return setValue("intensity_tex", texturefloat); }
	//! A float texture that if present will override the intensity parameter
 	//! [UI Guides] overrides=intensity
 	Value get_intensity_tex() const { return getValue("intensity_tex"); }

	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	bool set_subdivs(int val) { return setValue("subdivs", val); }
	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	int get_subdivs() const { return getInt("subdivs"); }

	//! When this option is on and GI calculation is set to Irradiance map V-Ray will calculate the effects of this light and store them in the irradiance map. The result is that the irradiance map is computed more slowly but the rendering takes less time. You can also save the irradiance map and reuse it later.
 	//! [UI Guides] displayName=Store with irradiance map
 	//! [Default value] false
	bool set_storeWithIrradianceMap(bool val) { return setValue("storeWithIrradianceMap", val); }
	//! When this option is on and GI calculation is set to Irradiance map V-Ray will calculate the effects of this light and store them in the irradiance map. The result is that the irradiance map is computed more slowly but the rendering takes less time. You can also save the irradiance map and reuse it later.
 	//! [UI Guides] displayName=Store with irradiance map
 	//! [Default value] false
	bool get_storeWithIrradianceMap() const { return getBool("storeWithIrradianceMap"); }

	//! True if the light is NOT directly visible from the camera and false otherwise.
 	//! [Default value] false
	bool set_invisible(bool val) { return setValue("invisible", val); }
	//! True if the light is NOT directly visible from the camera and false otherwise.
 	//! [Default value] false
	bool get_invisible() const { return getBool("invisible"); }

	//! True if the light appears in reflections and false otherwise.
 	//! [UI Guides] displayName=Affect reflections
 	//! [Default value] true
	bool set_affectReflections(bool val) { return setValue("affectReflections", val); }
	//! True if the light appears in reflections and false otherwise.
 	//! [UI Guides] displayName=Affect reflections
 	//! [Default value] true
	bool get_affectReflections() const { return getBool("affectReflections"); }

	//! (description missing)
	//! [Default value] 0
	bool set_objectID(int val) { return setValue("objectID", val); }
	//! (description missing)
	//! [Default value] 0
	int get_objectID() const { return getInt("objectID"); }

	//! This parameter is for debugging only. It should always be set to true in user scenes. When set to false, rendering quality is not optimal.
 	//! [UI Guides] displayName=Use multiple importance sampling
 	//! [Default value] true
	bool set_useMIS(bool val) { return setValue("useMIS", val); }
	//! This parameter is for debugging only. It should always be set to true in user scenes. When set to false, rendering quality is not optimal.
 	//! [UI Guides] displayName=Use multiple importance sampling
 	//! [Default value] true
	bool get_useMIS() const { return getBool("useMIS"); }

	//! (description missing)
	bool set_dome_tex(const Plugin& texture) { return setValue("dome_tex", texture); }
	//! (description missing)
	bool set_dome_tex(const AColor& texture) { return setValue("dome_tex", texture); }
	//! (description missing)
	Value get_dome_tex() const { return getValue("dome_tex"); }

	//! True if the texture should be used
 	//! [UI Guides] displayName=Use texture
 	//! [Default value] false
	bool set_use_dome_tex(bool val) { return setValue("use_dome_tex", val); }
	//! True if the texture should be used
 	//! [UI Guides] displayName=Use texture
 	//! [Default value] false
	bool get_use_dome_tex() const { return getBool("use_dome_tex"); }

	//! The texture presampling resolution
 	//! [UI Guides] displayName=Texture resolution, minValue=1, maxValue8192, enableIf: ?use_dome_tex=1
 	//! [Default value] 512
	bool set_tex_resolution(int val) { return setValue("tex_resolution", val); }
	//! The texture presampling resolution
 	//! [UI Guides] displayName=Texture resolution, minValue=1, maxValue8192, enableIf: ?use_dome_tex=1
 	//! [Default value] 512
	int get_tex_resolution() const { return getInt("tex_resolution"); }

	//! Defines a sphere around the center of the dome light TOWARD which photons are fired. This radius should encompass all glass and metal surfaces that you want to create caustics.
 	//! [UI Guides] displayName=Photon target radius, quantityType=distance, minValue=0.0
 	//! [Default value] 100
	bool set_dome_targetRadius(float val) { return setValue("dome_targetRadius", val); }
	//! Defines a sphere around the center of the dome light TOWARD which photons are fired. This radius should encompass all glass and metal surfaces that you want to create caustics.
 	//! [UI Guides] displayName=Photon target radius, quantityType=distance, minValue=0.0
 	//! [Default value] 100
	float get_dome_targetRadius() const { return getFloat("dome_targetRadius"); }

	//! Defines a sphere around the center of the dome light FROM which photons are fired. This radius should encompass all geometry in the scene.
 	//! [UI Guides] displayName=Photon emit radius, quantityType=distance, minValue=0.0
 	//! [Default value] 150
	bool set_dome_emitRadius(float val) { return setValue("dome_emitRadius", val); }
	//! Defines a sphere around the center of the dome light FROM which photons are fired. This radius should encompass all geometry in the scene.
 	//! [UI Guides] displayName=Photon emit radius, quantityType=distance, minValue=0.0
 	//! [Default value] 150
	float get_dome_emitRadius() const { return getFloat("dome_emitRadius"); }

	//! (description missing)
	//! [Default value] false
	bool set_dome_spherical(bool val) { return setValue("dome_spherical", val); }
	//! (description missing)
	//! [Default value] false
	bool get_dome_spherical() const { return getBool("dome_spherical"); }

	//! The adaptivity of the sampling to the texture brightness (0.0 - no adaptivity; 1.0 - full adaptivity
 	//! [UI Guides] displayName=Texture adaptivity, minValue=0.0, maxValue=1.0, enableIf: ?use_dome_tex=1
 	//! [Default value] 1
	bool set_tex_adaptive(float val) { return setValue("tex_adaptive", val); }
	//! The adaptivity of the sampling to the texture brightness (0.0 - no adaptivity; 1.0 - full adaptivity
 	//! [UI Guides] displayName=Texture adaptivity, minValue=0.0, maxValue=1.0, enableIf: ?use_dome_tex=1
 	//! [Default value] 1
	float get_tex_adaptive() const { return getFloat("tex_adaptive"); }

	//! [UI Guides] quantityType=distance
 	//! [Default value] 100000
	bool set_dome_rayDistance(float val) { return setValue("dome_rayDistance", val); }
	//! [UI Guides] quantityType=distance
 	//! [Default value] 100000
	float get_dome_rayDistance() const { return getFloat("dome_rayDistance"); }

	//! (description missing)
	//! [Default value] 0
	bool set_dome_rayDistanceMode(int val) { return setValue("dome_rayDistanceMode", val); }
	//! (description missing)
	//! [Default value] 0
	int get_dome_rayDistanceMode() const { return getInt("dome_rayDistanceMode"); }

	//! true if the light appears in the alpha and false otherwise
 	//! [Default value] true
	bool set_affect_alpha(bool val) { return setValue("affect_alpha", val); }
	//! true if the light appears in the alpha and false otherwise
 	//! [Default value] true
	bool get_affect_alpha() const { return getBool("affect_alpha"); }
};

class LightIES : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "LightIES"; }

	//! true if the light is casting light (turned on) and false otherwise; it only makes sense to use this parameter if it is animated, or if another object depends on this node but it must not be rendered
 	//! [Default value] true
	bool set_enabled(bool val) { return setValue("enabled", val); }
	//! true if the light is casting light (turned on) and false otherwise; it only makes sense to use this parameter if it is animated, or if another object depends on this node but it must not be rendered
 	//! [Default value] true
	bool get_enabled() const { return getBool("enabled"); }

	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	bool set_transform(const Transform& transform) { return setValue("transform", transform); }
	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	Transform get_transform() const { return getTransform("transform"); }

	//! Color of the light
 	//! [UI Guides] overridenBy=color_tex
 	//! [Default value] Color(1, 1, 1)
	bool set_color(const Color& color) { return setValue("color", color); }
	//! Color of the light
 	//! [UI Guides] overridenBy=color_tex
 	//! [Default value] Color(1, 1, 1)
	Color get_color() const { return getColor("color"); }

	//! A color texture that if present will override the color parameter
 	//! [UI Guides] overrides=color
 	bool set_color_tex(const Plugin& texture) { return setValue("color_tex", texture); }
	//! A color texture that if present will override the color parameter
 	//! [UI Guides] overrides=color
 	bool set_color_tex(const AColor& texture) { return setValue("color_tex", texture); }
	//! A color texture that if present will override the color parameter
 	//! [UI Guides] overrides=color
 	Value get_color_tex() const { return getValue("color_tex"); }

	//! true if the light casts shadows and false otherwise
 	//! [Default value] true
	bool set_shadows(bool val) { return setValue("shadows", val); }
	//! true if the light casts shadows and false otherwise
 	//! [Default value] true
	bool get_shadows() const { return getBool("shadows"); }

	//! The shadow color. Anything but black is not physically accurate.
 	//! [UI Guides] overridenBy=shadowColor_tex
 	//! [Default value] Color(0, 0, 0)
	bool set_shadowColor(const Color& color) { return setValue("shadowColor", color); }
	//! The shadow color. Anything but black is not physically accurate.
 	//! [UI Guides] overridenBy=shadowColor_tex
 	//! [Default value] Color(0, 0, 0)
	Color get_shadowColor() const { return getColor("shadowColor"); }

	//! A color texture that if present will override the shadowColor parameter
 	//! [UI Guides] overrides=shadowColor
 	bool set_shadowColor_tex(const Plugin& texture) { return setValue("shadowColor_tex", texture); }
	//! A color texture that if present will override the shadowColor parameter
 	//! [UI Guides] overrides=shadowColor
 	bool set_shadowColor_tex(const AColor& texture) { return setValue("shadowColor_tex", texture); }
	//! A color texture that if present will override the shadowColor parameter
 	//! [UI Guides] overrides=shadowColor
 	Value get_shadowColor_tex() const { return getValue("shadowColor_tex"); }

	//! Shadow offset from the surface. Helps to prevent polygonal shadow artifacts on low-poly surfaces.
 	//! [UI Guides] displayName=Shadow bias, quantityType=distance
 	//! [Default value] 0
	bool set_shadowBias(float val) { return setValue("shadowBias", val); }
	//! Shadow offset from the surface. Helps to prevent polygonal shadow artifacts on low-poly surfaces.
 	//! [UI Guides] displayName=Shadow bias, quantityType=distance
 	//! [Default value] 0
	float get_shadowBias() const { return getFloat("shadowBias"); }

	//! Determines the number of photons emitted by this light when calculating the Global Photon Map. 1000 subdivs equal 1 million photons.
 	//! [UI Guides] displayName=Photon subdivs, minValue=0
 	//! [Default value] 500
	bool set_photonSubdivs(int val) { return setValue("photonSubdivs", val); }
	//! Determines the number of photons emitted by this light when calculating the Global Photon Map. 1000 subdivs equal 1 million photons.
 	//! [UI Guides] displayName=Photon subdivs, minValue=0
 	//! [Default value] 500
	int get_photonSubdivs() const { return getInt("photonSubdivs"); }

	//! Determines the number of photons emitted by this light when calculating the Caustics Photon Map. 1000 subdivs equal 1 million photons.
 	//! [UI Guides] displayName=Caustics subdivs, minValue=0
 	//! [Default value] 1000
	bool set_causticSubdivs(int val) { return setValue("causticSubdivs", val); }
	//! Determines the number of photons emitted by this light when calculating the Caustics Photon Map. 1000 subdivs equal 1 million photons.
 	//! [UI Guides] displayName=Caustics subdivs, minValue=0
 	//! [Default value] 1000
	int get_causticSubdivs() const { return getInt("causticSubdivs"); }

	//! Multiplier for the diffuse photons.
 	//! [UI Guides] displayName=Diffuse multiplier, minValue=0.0
 	//! [Default value] 1
	bool set_diffuseMult(float val) { return setValue("diffuseMult", val); }
	//! Multiplier for the diffuse photons.
 	//! [UI Guides] displayName=Diffuse multiplier, minValue=0.0
 	//! [Default value] 1
	float get_diffuseMult() const { return getFloat("diffuseMult"); }

	//! Multiplier for the caustics photons.
 	//! [UI Guides] displayName=Caustics multiplier, minValue=0.0
 	//! [Default value] 1
	bool set_causticMult(float val) { return setValue("causticMult", val); }
	//! Multiplier for the caustics photons.
 	//! [UI Guides] displayName=Caustics multiplier, minValue=0.0
 	//! [Default value] 1
	float get_causticMult() const { return getFloat("causticMult"); }

	//! Light cut-off threshold (speed optimization). If the light intensity for a point is below this threshold, the light will not be computed.
 	//! [UI Guides] displayName=Cut-off threshold, minValue=0.0
 	//! [Default value] 0.001
	bool set_cutoffThreshold(float val) { return setValue("cutoffThreshold", val); }
	//! Light cut-off threshold (speed optimization). If the light intensity for a point is below this threshold, the light will not be computed.
 	//! [UI Guides] displayName=Cut-off threshold, minValue=0.0
 	//! [Default value] 0.001
	float get_cutoffThreshold() const { return getFloat("cutoffThreshold"); }

	//! True if the light produces diffuse lighting and false otherwise.
 	//! [UI Guides] displayName=Affect diffuse
 	//! [Default value] true
	bool set_affectDiffuse(bool val) { return setValue("affectDiffuse", val); }
	//! True if the light produces diffuse lighting and false otherwise.
 	//! [UI Guides] displayName=Affect diffuse
 	//! [Default value] true
	bool get_affectDiffuse() const { return getBool("affectDiffuse"); }

	//! True if the light produces specular hilights and false otherwise.
 	//! [UI Guides] displayName=Affect specular
 	//! [Default value] true
	bool set_affectSpecular(bool val) { return setValue("affectSpecular", val); }
	//! True if the light produces specular hilights and false otherwise.
 	//! [UI Guides] displayName=Affect specular
 	//! [Default value] true
	bool get_affectSpecular() const { return getBool("affectSpecular"); }

	//! True if the bumped normal should be used to check if the light direction is below the surface.
 	//! [UI Guides] displayName=Bumped normal check
 	//! [Default value] false
	bool set_bumped_below_surface_check(bool val) { return setValue("bumped_below_surface_check", val); }
	//! True if the bumped normal should be used to check if the light direction is below the surface.
 	//! [UI Guides] displayName=Bumped normal check
 	//! [Default value] false
	bool get_bumped_below_surface_check() const { return getBool("bumped_below_surface_check"); }

	//! Number of parameter samples for motion blur.
 	//! [Default value] 0
	bool set_nsamples(int val) { return setValue("nsamples", val); }
	//! Number of parameter samples for motion blur.
 	//! [Default value] 0
	int get_nsamples() const { return getInt("nsamples"); }

	//! Diffuse contribution for the light.
 	//! [Default value] 1
	bool set_diffuse_contribution(float val) { return setValue("diffuse_contribution", val); }
	//! Diffuse contribution for the light.
 	//! [Default value] 1
	float get_diffuse_contribution() const { return getFloat("diffuse_contribution"); }

	//! Specular contribution for the light.
 	//! [Default value] 1
	bool set_specular_contribution(float val) { return setValue("specular_contribution", val); }
	//! Specular contribution for the light.
 	//! [Default value] 1
	float get_specular_contribution() const { return getFloat("specular_contribution"); }

	//! Render channels the result of this light will be written to
 	bool set_channels(const ValueList& pluginList) { return setValue("channels", pluginList); }
	//! Render channels the result of this light will be written to
 	ValueList get_channels() const { return getValueList("channels"); }

	//! Render channels the raw diffuse result of this light will be written to
 	bool set_channels_raw(const ValueList& pluginList) { return setValue("channels_raw", pluginList); }
	//! Render channels the raw diffuse result of this light will be written to
 	ValueList get_channels_raw() const { return getValueList("channels_raw"); }

	//! Render channels the diffuse result of this light will be written to
 	bool set_channels_diffuse(const ValueList& pluginList) { return setValue("channels_diffuse", pluginList); }
	//! Render channels the diffuse result of this light will be written to
 	ValueList get_channels_diffuse() const { return getValueList("channels_diffuse"); }

	//! Render channels the specular result of this light will be written to
 	bool set_channels_specular(const ValueList& pluginList) { return setValue("channels_specular", pluginList); }
	//! Render channels the specular result of this light will be written to
 	ValueList get_channels_specular() const { return getValueList("channels_specular"); }

	//! true if the light should use the global light level setting
 	//! [Default value] true
	bool set_use_global_light_level(bool val) { return setValue("use_global_light_level", val); }
	//! true if the light should use the global light level setting
 	//! [Default value] true
	bool get_use_global_light_level() const { return getBool("use_global_light_level"); }

	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	bool set_shadowSubdivs(int val) { return setValue("shadowSubdivs", val); }
	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	int get_shadowSubdivs() const { return getInt("shadowSubdivs"); }

	//! When this option is on and GI calculation is set to Irradiance map V-Ray will calculate the effects of this light and store them in the irradiance map. The result is that the irradiance map is computed more slowly but the rendering takes less time. You can also save the irradiance map and reuse it later.
 	//! [UI Guides] displayName=Store with irradiance map
 	//! [Default value] false
	bool set_storeWithIrradianceMap(bool val) { return setValue("storeWithIrradianceMap", val); }
	//! When this option is on and GI calculation is set to Irradiance map V-Ray will calculate the effects of this light and store them in the irradiance map. The result is that the irradiance map is computed more slowly but the rendering takes less time. You can also save the irradiance map and reuse it later.
 	//! [UI Guides] displayName=Store with irradiance map
 	//! [Default value] false
	bool get_storeWithIrradianceMap() const { return getBool("storeWithIrradianceMap"); }

	//! IES file with luminaire description
 	//! [UI Guides] fileAsset=ies
 	bool set_ies_file(const char* str) { return setValue("ies_file", str); }
	//! IES file with luminaire description
 	//! [UI Guides] fileAsset=ies
 	bool set_ies_file(const std::string& str) { return setValue("ies_file", str); }
	//! IES file with luminaire description
 	//! [UI Guides] fileAsset=ies
 	std::string get_ies_file() const { return getString("ies_file"); }

	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	bool set_filter_color(const Color& color) { return setValue("filter_color", color); }
	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	Color get_filter_color() const { return getColor("filter_color"); }

	//! 0 works as point light; 1 to use the shape of the light for shadows; 2 to also use it for illumination
 	//! [Default value] 0
	bool set_soft_shadows(int val) { return setValue("soft_shadows", val); }
	//! 0 works as point light; 1 to use the shape of the light for shadows; 2 to also use it for illumination
 	//! [Default value] 0
	int get_soft_shadows() const { return getInt("soft_shadows"); }

	//! true to cause specular highlights produced by the light to match the light shape; false to always produce speculars as a point light
 	//! [Default value] true
	bool set_area_speculars(bool val) { return setValue("area_speculars", val); }
	//! true to cause specular highlights produced by the light to match the light shape; false to always produce speculars as a point light
 	//! [Default value] true
	bool get_area_speculars() const { return getBool("area_speculars"); }

	//! Limuous power (in lm); if zero, the default lumious power from the IES profile is used.
 	//! [Default value] 0
	bool set_power(float val) { return setValue("power", val); }
	//! Limuous power (in lm); if zero, the default lumious power from the IES profile is used.
 	//! [Default value] 0
	float get_power() const { return getFloat("power"); }

	//! IES light shape; if -1 the default light shape from IES profile is used.
 	//! [UI Guides] displayName=IES light shape, enum=-1:From IES File;0:Point;1:Rectangular;2:Circular;3:Sphere;4:Vertical Cylinder;5:Horizontal cylinder along lum. length;6:Horizontal cylinder along lum. width;7:Ellipse along lum. length;8:Ellipse along lum. width;9:Ellipsoid along lum. length;10:Ellipsoid along lum. width;11:Elliptic cylinder;12:Hor. elliptic cylinder along lum. length;13:Hor. elliptic cylinder along lum. width;14:Vertical Circle;15:Vectical Ellipse;16:Cuboid;
 	//! [Default value] -1
	bool set_ies_light_shape(int val) { return setValue("ies_light_shape", val); }
	//! IES light shape; if -1 the default light shape from IES profile is used.
 	//! [UI Guides] displayName=IES light shape, enum=-1:From IES File;0:Point;1:Rectangular;2:Circular;3:Sphere;4:Vertical Cylinder;5:Horizontal cylinder along lum. length;6:Horizontal cylinder along lum. width;7:Ellipse along lum. length;8:Ellipse along lum. width;9:Ellipsoid along lum. length;10:Ellipsoid along lum. width;11:Elliptic cylinder;12:Hor. elliptic cylinder along lum. length;13:Hor. elliptic cylinder along lum. width;14:Vertical Circle;15:Vectical Ellipse;16:Cuboid;
 	//! [Default value] -1
	int get_ies_light_shape() const { return getInt("ies_light_shape"); }

	//! Light shape width (in metres); if ies_light_shape is -1 the default light width from the IES profile is used.
 	//! [UI Guides] displayName=Width, quantityType=distance, units=meters, enableIf: ?ies_light_shape=1;?ies_light_shape=6;?ies_light_shape>=7,?ies_light_shape<=13;?ies_light_shape>=14
 	//! [Default value] 0
	bool set_ies_light_width(float val) { return setValue("ies_light_width", val); }
	//! Light shape width (in metres); if ies_light_shape is -1 the default light width from the IES profile is used.
 	//! [UI Guides] displayName=Width, quantityType=distance, units=meters, enableIf: ?ies_light_shape=1;?ies_light_shape=6;?ies_light_shape>=7,?ies_light_shape<=13;?ies_light_shape>=14
 	//! [Default value] 0
	float get_ies_light_width() const { return getFloat("ies_light_width"); }

	//! Light shape length (in metres); if ies_light_shape is -1 the default light length from the IES profile is used.
 	//! [UI Guides] displayName=Length, quantityType=distance, units=meters, enableIf: ?ies_light_shape=1;?ies_light_shape=5;?ies_light_shape>=7,?ies_light_shape<=13;?ies_light_shape>=16
 	//! [Default value] 0
	bool set_ies_light_length(float val) { return setValue("ies_light_length", val); }
	//! Light shape length (in metres); if ies_light_shape is -1 the default light length from the IES profile is used.
 	//! [UI Guides] displayName=Length, quantityType=distance, units=meters, enableIf: ?ies_light_shape=1;?ies_light_shape=5;?ies_light_shape>=7,?ies_light_shape<=13;?ies_light_shape>=16
 	//! [Default value] 0
	float get_ies_light_length() const { return getFloat("ies_light_length"); }

	//! Light shape height (in metres); if ies_light_shape is -1 the default light height from the IES profile is used.
 	//! [UI Guides] displayName=Height, quantityType=distance, units=meters, enableIf: ?ies_light_shape=4;?ies_light_shape>=9,?ies_light_shape<=13;?ies_light_shape>=15
 	//! [Default value] 0
	bool set_ies_light_height(float val) { return setValue("ies_light_height", val); }
	//! Light shape height (in metres); if ies_light_shape is -1 the default light height from the IES profile is used.
 	//! [UI Guides] displayName=Height, quantityType=distance, units=meters, enableIf: ?ies_light_shape=4;?ies_light_shape>=9,?ies_light_shape<=13;?ies_light_shape>=15
 	//! [Default value] 0
	float get_ies_light_height() const { return getFloat("ies_light_height"); }

	//! Light shape diameter (in metres); if ies_light_shape is -1 the default light diameter from the IES profile is used.
 	//! [UI Guides] displayName=Diameter, quantityType=distance, units=meters, enableIf: ?ies_light_shape>=2,?ies_light_shape<=6
 	//! [Default value] 0
	bool set_ies_light_diameter(float val) { return setValue("ies_light_diameter", val); }
	//! Light shape diameter (in metres); if ies_light_shape is -1 the default light diameter from the IES profile is used.
 	//! [UI Guides] displayName=Diameter, quantityType=distance, units=meters, enableIf: ?ies_light_shape>=2,?ies_light_shape<=6
 	//! [Default value] 0
	float get_ies_light_diameter() const { return getFloat("ies_light_diameter"); }

	//! If this is true, the intensity values of the IES file will be scaled, so the new maximum value is new_max_intensity.
 	//! [Default value] false
	bool set_rescale_max_intensty(bool val) { return setValue("rescale_max_intensty", val); }
	//! If this is true, the intensity values of the IES file will be scaled, so the new maximum value is new_max_intensity.
 	//! [Default value] false
	bool get_rescale_max_intensty() const { return getBool("rescale_max_intensty"); }

	//! The new maximum intensity after rescaling the intensities in the IES file, when rescale_max_intensty is true. This value is in cd(candelas).
 	//! [UI Guides] enableIf: ?rescale_max_intensty=1
 	//! [Default value] 1
	bool set_new_max_intensity(float val) { return setValue("new_max_intensity", val); }
	//! The new maximum intensity after rescaling the intensities in the IES file, when rescale_max_intensty is true. This value is in cd(candelas).
 	//! [UI Guides] enableIf: ?rescale_max_intensty=1
 	//! [Default value] 1
	float get_new_max_intensity() const { return getFloat("new_max_intensity"); }
};

class LightIESMax : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "LightIESMax"; }

	//! true if the light is casting light (turned on) and false otherwise; it only makes sense to use this parameter if it is animated, or if another object depends on this node but it must not be rendered
 	//! [Default value] true
	bool set_enabled(bool val) { return setValue("enabled", val); }
	//! true if the light is casting light (turned on) and false otherwise; it only makes sense to use this parameter if it is animated, or if another object depends on this node but it must not be rendered
 	//! [Default value] true
	bool get_enabled() const { return getBool("enabled"); }

	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	bool set_transform(const Transform& transform) { return setValue("transform", transform); }
	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	Transform get_transform() const { return getTransform("transform"); }

	//! Color of the light
 	//! [UI Guides] overridenBy=color_tex
 	//! [Default value] Color(1, 1, 1)
	bool set_color(const Color& color) { return setValue("color", color); }
	//! Color of the light
 	//! [UI Guides] overridenBy=color_tex
 	//! [Default value] Color(1, 1, 1)
	Color get_color() const { return getColor("color"); }

	//! A color texture that if present will override the color parameter
 	//! [UI Guides] overrides=color
 	bool set_color_tex(const Plugin& texture) { return setValue("color_tex", texture); }
	//! A color texture that if present will override the color parameter
 	//! [UI Guides] overrides=color
 	bool set_color_tex(const AColor& texture) { return setValue("color_tex", texture); }
	//! A color texture that if present will override the color parameter
 	//! [UI Guides] overrides=color
 	Value get_color_tex() const { return getValue("color_tex"); }

	//! true if the light casts shadows and false otherwise
 	//! [Default value] true
	bool set_shadows(bool val) { return setValue("shadows", val); }
	//! true if the light casts shadows and false otherwise
 	//! [Default value] true
	bool get_shadows() const { return getBool("shadows"); }

	//! The shadow color. Anything but black is not physically accurate.
 	//! [UI Guides] overridenBy=shadowColor_tex
 	//! [Default value] Color(0, 0, 0)
	bool set_shadowColor(const Color& color) { return setValue("shadowColor", color); }
	//! The shadow color. Anything but black is not physically accurate.
 	//! [UI Guides] overridenBy=shadowColor_tex
 	//! [Default value] Color(0, 0, 0)
	Color get_shadowColor() const { return getColor("shadowColor"); }

	//! A color texture that if present will override the shadowColor parameter
 	//! [UI Guides] overrides=shadowColor
 	bool set_shadowColor_tex(const Plugin& texture) { return setValue("shadowColor_tex", texture); }
	//! A color texture that if present will override the shadowColor parameter
 	//! [UI Guides] overrides=shadowColor
 	bool set_shadowColor_tex(const AColor& texture) { return setValue("shadowColor_tex", texture); }
	//! A color texture that if present will override the shadowColor parameter
 	//! [UI Guides] overrides=shadowColor
 	Value get_shadowColor_tex() const { return getValue("shadowColor_tex"); }

	//! Shadow offset from the surface. Helps to prevent polygonal shadow artifacts on low-poly surfaces.
 	//! [UI Guides] displayName=Shadow bias, quantityType=distance
 	//! [Default value] 0
	bool set_shadowBias(float val) { return setValue("shadowBias", val); }
	//! Shadow offset from the surface. Helps to prevent polygonal shadow artifacts on low-poly surfaces.
 	//! [UI Guides] displayName=Shadow bias, quantityType=distance
 	//! [Default value] 0
	float get_shadowBias() const { return getFloat("shadowBias"); }

	//! Determines the number of photons emitted by this light when calculating the Global Photon Map. 1000 subdivs equal 1 million photons.
 	//! [UI Guides] displayName=Photon subdivs, minValue=0
 	//! [Default value] 500
	bool set_photonSubdivs(int val) { return setValue("photonSubdivs", val); }
	//! Determines the number of photons emitted by this light when calculating the Global Photon Map. 1000 subdivs equal 1 million photons.
 	//! [UI Guides] displayName=Photon subdivs, minValue=0
 	//! [Default value] 500
	int get_photonSubdivs() const { return getInt("photonSubdivs"); }

	//! Determines the number of photons emitted by this light when calculating the Caustics Photon Map. 1000 subdivs equal 1 million photons.
 	//! [UI Guides] displayName=Caustics subdivs, minValue=0
 	//! [Default value] 1000
	bool set_causticSubdivs(int val) { return setValue("causticSubdivs", val); }
	//! Determines the number of photons emitted by this light when calculating the Caustics Photon Map. 1000 subdivs equal 1 million photons.
 	//! [UI Guides] displayName=Caustics subdivs, minValue=0
 	//! [Default value] 1000
	int get_causticSubdivs() const { return getInt("causticSubdivs"); }

	//! Multiplier for the diffuse photons.
 	//! [UI Guides] displayName=Diffuse multiplier, minValue=0.0
 	//! [Default value] 1
	bool set_diffuseMult(float val) { return setValue("diffuseMult", val); }
	//! Multiplier for the diffuse photons.
 	//! [UI Guides] displayName=Diffuse multiplier, minValue=0.0
 	//! [Default value] 1
	float get_diffuseMult() const { return getFloat("diffuseMult"); }

	//! Multiplier for the caustics photons.
 	//! [UI Guides] displayName=Caustics multiplier, minValue=0.0
 	//! [Default value] 1
	bool set_causticMult(float val) { return setValue("causticMult", val); }
	//! Multiplier for the caustics photons.
 	//! [UI Guides] displayName=Caustics multiplier, minValue=0.0
 	//! [Default value] 1
	float get_causticMult() const { return getFloat("causticMult"); }

	//! Light cut-off threshold (speed optimization). If the light intensity for a point is below this threshold, the light will not be computed.
 	//! [UI Guides] displayName=Cut-off threshold, minValue=0.0
 	//! [Default value] 0.001
	bool set_cutoffThreshold(float val) { return setValue("cutoffThreshold", val); }
	//! Light cut-off threshold (speed optimization). If the light intensity for a point is below this threshold, the light will not be computed.
 	//! [UI Guides] displayName=Cut-off threshold, minValue=0.0
 	//! [Default value] 0.001
	float get_cutoffThreshold() const { return getFloat("cutoffThreshold"); }

	//! True if the light produces diffuse lighting and false otherwise.
 	//! [UI Guides] displayName=Affect diffuse
 	//! [Default value] true
	bool set_affectDiffuse(bool val) { return setValue("affectDiffuse", val); }
	//! True if the light produces diffuse lighting and false otherwise.
 	//! [UI Guides] displayName=Affect diffuse
 	//! [Default value] true
	bool get_affectDiffuse() const { return getBool("affectDiffuse"); }

	//! True if the light produces specular hilights and false otherwise.
 	//! [UI Guides] displayName=Affect specular
 	//! [Default value] true
	bool set_affectSpecular(bool val) { return setValue("affectSpecular", val); }
	//! True if the light produces specular hilights and false otherwise.
 	//! [UI Guides] displayName=Affect specular
 	//! [Default value] true
	bool get_affectSpecular() const { return getBool("affectSpecular"); }

	//! True if the bumped normal should be used to check if the light direction is below the surface.
 	//! [UI Guides] displayName=Bumped normal check
 	//! [Default value] false
	bool set_bumped_below_surface_check(bool val) { return setValue("bumped_below_surface_check", val); }
	//! True if the bumped normal should be used to check if the light direction is below the surface.
 	//! [UI Guides] displayName=Bumped normal check
 	//! [Default value] false
	bool get_bumped_below_surface_check() const { return getBool("bumped_below_surface_check"); }

	//! Number of parameter samples for motion blur.
 	//! [Default value] 0
	bool set_nsamples(int val) { return setValue("nsamples", val); }
	//! Number of parameter samples for motion blur.
 	//! [Default value] 0
	int get_nsamples() const { return getInt("nsamples"); }

	//! Diffuse contribution for the light.
 	//! [Default value] 1
	bool set_diffuse_contribution(float val) { return setValue("diffuse_contribution", val); }
	//! Diffuse contribution for the light.
 	//! [Default value] 1
	float get_diffuse_contribution() const { return getFloat("diffuse_contribution"); }

	//! Specular contribution for the light.
 	//! [Default value] 1
	bool set_specular_contribution(float val) { return setValue("specular_contribution", val); }
	//! Specular contribution for the light.
 	//! [Default value] 1
	float get_specular_contribution() const { return getFloat("specular_contribution"); }

	//! Render channels the result of this light will be written to
 	bool set_channels(const ValueList& pluginList) { return setValue("channels", pluginList); }
	//! Render channels the result of this light will be written to
 	ValueList get_channels() const { return getValueList("channels"); }

	//! Render channels the raw diffuse result of this light will be written to
 	bool set_channels_raw(const ValueList& pluginList) { return setValue("channels_raw", pluginList); }
	//! Render channels the raw diffuse result of this light will be written to
 	ValueList get_channels_raw() const { return getValueList("channels_raw"); }

	//! Render channels the diffuse result of this light will be written to
 	bool set_channels_diffuse(const ValueList& pluginList) { return setValue("channels_diffuse", pluginList); }
	//! Render channels the diffuse result of this light will be written to
 	ValueList get_channels_diffuse() const { return getValueList("channels_diffuse"); }

	//! Render channels the specular result of this light will be written to
 	bool set_channels_specular(const ValueList& pluginList) { return setValue("channels_specular", pluginList); }
	//! Render channels the specular result of this light will be written to
 	ValueList get_channels_specular() const { return getValueList("channels_specular"); }

	//! true if the light should use the global light level setting
 	//! [Default value] true
	bool set_use_global_light_level(bool val) { return setValue("use_global_light_level", val); }
	//! true if the light should use the global light level setting
 	//! [Default value] true
	bool get_use_global_light_level() const { return getBool("use_global_light_level"); }

	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	bool set_shadowSubdivs(int val) { return setValue("shadowSubdivs", val); }
	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	int get_shadowSubdivs() const { return getInt("shadowSubdivs"); }

	//! When this option is on and GI calculation is set to Irradiance map V-Ray will calculate the effects of this light and store them in the irradiance map. The result is that the irradiance map is computed more slowly but the rendering takes less time. You can also save the irradiance map and reuse it later.
 	//! [UI Guides] displayName=Store with irradiance map
 	//! [Default value] false
	bool set_storeWithIrradianceMap(bool val) { return setValue("storeWithIrradianceMap", val); }
	//! When this option is on and GI calculation is set to Irradiance map V-Ray will calculate the effects of this light and store them in the irradiance map. The result is that the irradiance map is computed more slowly but the rendering takes less time. You can also save the irradiance map and reuse it later.
 	//! [UI Guides] displayName=Store with irradiance map
 	//! [Default value] false
	bool get_storeWithIrradianceMap() const { return getBool("storeWithIrradianceMap"); }

	//! IES file with luminaire description
 	//! [UI Guides] fileAsset=ies
 	bool set_ies_file(const char* str) { return setValue("ies_file", str); }
	//! IES file with luminaire description
 	//! [UI Guides] fileAsset=ies
 	bool set_ies_file(const std::string& str) { return setValue("ies_file", str); }
	//! IES file with luminaire description
 	//! [UI Guides] fileAsset=ies
 	std::string get_ies_file() const { return getString("ies_file"); }

	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	bool set_filter_color(const Color& color) { return setValue("filter_color", color); }
	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	Color get_filter_color() const { return getColor("filter_color"); }

	//! 0 works as point light; 1 to use the shape of the light for shadows; 2 to also use it for illumination
 	//! [Default value] 0
	bool set_soft_shadows(int val) { return setValue("soft_shadows", val); }
	//! 0 works as point light; 1 to use the shape of the light for shadows; 2 to also use it for illumination
 	//! [Default value] 0
	int get_soft_shadows() const { return getInt("soft_shadows"); }

	//! true to cause specular highlights produced by the light to match the light shape; false to always produce speculars as a point light
 	//! [Default value] true
	bool set_area_speculars(bool val) { return setValue("area_speculars", val); }
	//! true to cause specular highlights produced by the light to match the light shape; false to always produce speculars as a point light
 	//! [Default value] true
	bool get_area_speculars() const { return getBool("area_speculars"); }

	//! Limuous power (in lm); if zero, the default lumious power from the IES profile is used.
 	//! [Default value] 0
	bool set_power(float val) { return setValue("power", val); }
	//! Limuous power (in lm); if zero, the default lumious power from the IES profile is used.
 	//! [Default value] 0
	float get_power() const { return getFloat("power"); }

	//! IES light shape; if -1 the default light shape from IES profile is used.
 	//! [UI Guides] displayName=IES light shape, enum=-1:From IES File;0:Point;1:Rectangular;2:Circular;3:Sphere;4:Vertical Cylinder;5:Horizontal cylinder along lum. length;6:Horizontal cylinder along lum. width;7:Ellipse along lum. length;8:Ellipse along lum. width;9:Ellipsoid along lum. length;10:Ellipsoid along lum. width;11:Elliptic cylinder;12:Hor. elliptic cylinder along lum. length;13:Hor. elliptic cylinder along lum. width;14:Vertical Circle;15:Vectical Ellipse;16:Cuboid;
 	//! [Default value] -1
	bool set_ies_light_shape(int val) { return setValue("ies_light_shape", val); }
	//! IES light shape; if -1 the default light shape from IES profile is used.
 	//! [UI Guides] displayName=IES light shape, enum=-1:From IES File;0:Point;1:Rectangular;2:Circular;3:Sphere;4:Vertical Cylinder;5:Horizontal cylinder along lum. length;6:Horizontal cylinder along lum. width;7:Ellipse along lum. length;8:Ellipse along lum. width;9:Ellipsoid along lum. length;10:Ellipsoid along lum. width;11:Elliptic cylinder;12:Hor. elliptic cylinder along lum. length;13:Hor. elliptic cylinder along lum. width;14:Vertical Circle;15:Vectical Ellipse;16:Cuboid;
 	//! [Default value] -1
	int get_ies_light_shape() const { return getInt("ies_light_shape"); }

	//! Light shape width (in metres); if ies_light_shape is -1 the default light width from the IES profile is used.
 	//! [UI Guides] displayName=Width, quantityType=distance, units=meters, enableIf: ?ies_light_shape=1;?ies_light_shape=6;?ies_light_shape>=7,?ies_light_shape<=13;?ies_light_shape>=14
 	//! [Default value] 0
	bool set_ies_light_width(float val) { return setValue("ies_light_width", val); }
	//! Light shape width (in metres); if ies_light_shape is -1 the default light width from the IES profile is used.
 	//! [UI Guides] displayName=Width, quantityType=distance, units=meters, enableIf: ?ies_light_shape=1;?ies_light_shape=6;?ies_light_shape>=7,?ies_light_shape<=13;?ies_light_shape>=14
 	//! [Default value] 0
	float get_ies_light_width() const { return getFloat("ies_light_width"); }

	//! Light shape length (in metres); if ies_light_shape is -1 the default light length from the IES profile is used.
 	//! [UI Guides] displayName=Length, quantityType=distance, units=meters, enableIf: ?ies_light_shape=1;?ies_light_shape=5;?ies_light_shape>=7,?ies_light_shape<=13;?ies_light_shape>=16
 	//! [Default value] 0
	bool set_ies_light_length(float val) { return setValue("ies_light_length", val); }
	//! Light shape length (in metres); if ies_light_shape is -1 the default light length from the IES profile is used.
 	//! [UI Guides] displayName=Length, quantityType=distance, units=meters, enableIf: ?ies_light_shape=1;?ies_light_shape=5;?ies_light_shape>=7,?ies_light_shape<=13;?ies_light_shape>=16
 	//! [Default value] 0
	float get_ies_light_length() const { return getFloat("ies_light_length"); }

	//! Light shape height (in metres); if ies_light_shape is -1 the default light height from the IES profile is used.
 	//! [UI Guides] displayName=Height, quantityType=distance, units=meters, enableIf: ?ies_light_shape=4;?ies_light_shape>=9,?ies_light_shape<=13;?ies_light_shape>=15
 	//! [Default value] 0
	bool set_ies_light_height(float val) { return setValue("ies_light_height", val); }
	//! Light shape height (in metres); if ies_light_shape is -1 the default light height from the IES profile is used.
 	//! [UI Guides] displayName=Height, quantityType=distance, units=meters, enableIf: ?ies_light_shape=4;?ies_light_shape>=9,?ies_light_shape<=13;?ies_light_shape>=15
 	//! [Default value] 0
	float get_ies_light_height() const { return getFloat("ies_light_height"); }

	//! Light shape diameter (in metres); if ies_light_shape is -1 the default light diameter from the IES profile is used.
 	//! [UI Guides] displayName=Diameter, quantityType=distance, units=meters, enableIf: ?ies_light_shape>=2,?ies_light_shape<=6
 	//! [Default value] 0
	bool set_ies_light_diameter(float val) { return setValue("ies_light_diameter", val); }
	//! Light shape diameter (in metres); if ies_light_shape is -1 the default light diameter from the IES profile is used.
 	//! [UI Guides] displayName=Diameter, quantityType=distance, units=meters, enableIf: ?ies_light_shape>=2,?ies_light_shape<=6
 	//! [Default value] 0
	float get_ies_light_diameter() const { return getFloat("ies_light_diameter"); }

	//! If this is true, the intensity values of the IES file will be scaled, so the new maximum value is new_max_intensity.
 	//! [Default value] false
	bool set_rescale_max_intensty(bool val) { return setValue("rescale_max_intensty", val); }
	//! If this is true, the intensity values of the IES file will be scaled, so the new maximum value is new_max_intensity.
 	//! [Default value] false
	bool get_rescale_max_intensty() const { return getBool("rescale_max_intensty"); }

	//! The new maximum intensity after rescaling the intensities in the IES file, when rescale_max_intensty is true. This value is in cd(candelas).
 	//! [UI Guides] enableIf: ?rescale_max_intensty=1
 	//! [Default value] 1
	bool set_new_max_intensity(float val) { return setValue("new_max_intensity", val); }
	//! The new maximum intensity after rescaling the intensities in the IES file, when rescale_max_intensty is true. This value is in cd(candelas).
 	//! [UI Guides] enableIf: ?rescale_max_intensty=1
 	//! [Default value] 1
	float get_new_max_intensity() const { return getFloat("new_max_intensity"); }
};

class LightMesh : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "LightMesh"; }

	//! true if the light is casting light (turned on) and false otherwise; it only makes sense to use this parameter if it is animated, or if another object depends on this node but it must not be rendered
 	//! [Default value] true
	bool set_enabled(bool val) { return setValue("enabled", val); }
	//! true if the light is casting light (turned on) and false otherwise; it only makes sense to use this parameter if it is animated, or if another object depends on this node but it must not be rendered
 	//! [Default value] true
	bool get_enabled() const { return getBool("enabled"); }

	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	bool set_transform(const Transform& transform) { return setValue("transform", transform); }
	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	Transform get_transform() const { return getTransform("transform"); }

	//! Color of the light
 	//! [UI Guides] overridenBy=color_tex
 	//! [Default value] Color(1, 1, 1)
	bool set_color(const Color& color) { return setValue("color", color); }
	//! Color of the light
 	//! [UI Guides] overridenBy=color_tex
 	//! [Default value] Color(1, 1, 1)
	Color get_color() const { return getColor("color"); }

	//! A color texture that if present will override the color parameter
 	//! [UI Guides] overrides=color
 	bool set_color_tex(const Plugin& texture) { return setValue("color_tex", texture); }
	//! A color texture that if present will override the color parameter
 	//! [UI Guides] overrides=color
 	bool set_color_tex(const AColor& texture) { return setValue("color_tex", texture); }
	//! A color texture that if present will override the color parameter
 	//! [UI Guides] overrides=color
 	Value get_color_tex() const { return getValue("color_tex"); }

	//! true if the light casts shadows and false otherwise
 	//! [Default value] true
	bool set_shadows(bool val) { return setValue("shadows", val); }
	//! true if the light casts shadows and false otherwise
 	//! [Default value] true
	bool get_shadows() const { return getBool("shadows"); }

	//! The shadow color. Anything but black is not physically accurate.
 	//! [UI Guides] overridenBy=shadowColor_tex
 	//! [Default value] Color(0, 0, 0)
	bool set_shadowColor(const Color& color) { return setValue("shadowColor", color); }
	//! The shadow color. Anything but black is not physically accurate.
 	//! [UI Guides] overridenBy=shadowColor_tex
 	//! [Default value] Color(0, 0, 0)
	Color get_shadowColor() const { return getColor("shadowColor"); }

	//! A color texture that if present will override the shadowColor parameter
 	//! [UI Guides] overrides=shadowColor
 	bool set_shadowColor_tex(const Plugin& texture) { return setValue("shadowColor_tex", texture); }
	//! A color texture that if present will override the shadowColor parameter
 	//! [UI Guides] overrides=shadowColor
 	bool set_shadowColor_tex(const AColor& texture) { return setValue("shadowColor_tex", texture); }
	//! A color texture that if present will override the shadowColor parameter
 	//! [UI Guides] overrides=shadowColor
 	Value get_shadowColor_tex() const { return getValue("shadowColor_tex"); }

	//! Shadow offset from the surface. Helps to prevent polygonal shadow artifacts on low-poly surfaces.
 	//! [UI Guides] displayName=Shadow bias, quantityType=distance
 	//! [Default value] 0
	bool set_shadowBias(float val) { return setValue("shadowBias", val); }
	//! Shadow offset from the surface. Helps to prevent polygonal shadow artifacts on low-poly surfaces.
 	//! [UI Guides] displayName=Shadow bias, quantityType=distance
 	//! [Default value] 0
	float get_shadowBias() const { return getFloat("shadowBias"); }

	//! Determines the number of photons emitted by this light when calculating the Global Photon Map. 1000 subdivs equal 1 million photons.
 	//! [UI Guides] displayName=Photon subdivs, minValue=0
 	//! [Default value] 500
	bool set_photonSubdivs(int val) { return setValue("photonSubdivs", val); }
	//! Determines the number of photons emitted by this light when calculating the Global Photon Map. 1000 subdivs equal 1 million photons.
 	//! [UI Guides] displayName=Photon subdivs, minValue=0
 	//! [Default value] 500
	int get_photonSubdivs() const { return getInt("photonSubdivs"); }

	//! Determines the number of photons emitted by this light when calculating the Caustics Photon Map. 1000 subdivs equal 1 million photons.
 	//! [UI Guides] displayName=Caustics subdivs, minValue=0
 	//! [Default value] 1000
	bool set_causticSubdivs(int val) { return setValue("causticSubdivs", val); }
	//! Determines the number of photons emitted by this light when calculating the Caustics Photon Map. 1000 subdivs equal 1 million photons.
 	//! [UI Guides] displayName=Caustics subdivs, minValue=0
 	//! [Default value] 1000
	int get_causticSubdivs() const { return getInt("causticSubdivs"); }

	//! Multiplier for the diffuse photons.
 	//! [UI Guides] displayName=Diffuse multiplier, minValue=0.0
 	//! [Default value] 1
	bool set_diffuseMult(float val) { return setValue("diffuseMult", val); }
	//! Multiplier for the diffuse photons.
 	//! [UI Guides] displayName=Diffuse multiplier, minValue=0.0
 	//! [Default value] 1
	float get_diffuseMult() const { return getFloat("diffuseMult"); }

	//! Multiplier for the caustics photons.
 	//! [UI Guides] displayName=Caustics multiplier, minValue=0.0
 	//! [Default value] 1
	bool set_causticMult(float val) { return setValue("causticMult", val); }
	//! Multiplier for the caustics photons.
 	//! [UI Guides] displayName=Caustics multiplier, minValue=0.0
 	//! [Default value] 1
	float get_causticMult() const { return getFloat("causticMult"); }

	//! Light cut-off threshold (speed optimization). If the light intensity for a point is below this threshold, the light will not be computed.
 	//! [UI Guides] displayName=Cut-off threshold, minValue=0.0
 	//! [Default value] 0.001
	bool set_cutoffThreshold(float val) { return setValue("cutoffThreshold", val); }
	//! Light cut-off threshold (speed optimization). If the light intensity for a point is below this threshold, the light will not be computed.
 	//! [UI Guides] displayName=Cut-off threshold, minValue=0.0
 	//! [Default value] 0.001
	float get_cutoffThreshold() const { return getFloat("cutoffThreshold"); }

	//! True if the light produces diffuse lighting and false otherwise.
 	//! [UI Guides] displayName=Affect diffuse
 	//! [Default value] true
	bool set_affectDiffuse(bool val) { return setValue("affectDiffuse", val); }
	//! True if the light produces diffuse lighting and false otherwise.
 	//! [UI Guides] displayName=Affect diffuse
 	//! [Default value] true
	bool get_affectDiffuse() const { return getBool("affectDiffuse"); }

	//! True if the light produces specular hilights and false otherwise.
 	//! [UI Guides] displayName=Affect specular
 	//! [Default value] true
	bool set_affectSpecular(bool val) { return setValue("affectSpecular", val); }
	//! True if the light produces specular hilights and false otherwise.
 	//! [UI Guides] displayName=Affect specular
 	//! [Default value] true
	bool get_affectSpecular() const { return getBool("affectSpecular"); }

	//! True if the bumped normal should be used to check if the light direction is below the surface.
 	//! [UI Guides] displayName=Bumped normal check
 	//! [Default value] false
	bool set_bumped_below_surface_check(bool val) { return setValue("bumped_below_surface_check", val); }
	//! True if the bumped normal should be used to check if the light direction is below the surface.
 	//! [UI Guides] displayName=Bumped normal check
 	//! [Default value] false
	bool get_bumped_below_surface_check() const { return getBool("bumped_below_surface_check"); }

	//! Number of parameter samples for motion blur.
 	//! [Default value] 0
	bool set_nsamples(int val) { return setValue("nsamples", val); }
	//! Number of parameter samples for motion blur.
 	//! [Default value] 0
	int get_nsamples() const { return getInt("nsamples"); }

	//! Diffuse contribution for the light.
 	//! [Default value] 1
	bool set_diffuse_contribution(float val) { return setValue("diffuse_contribution", val); }
	//! Diffuse contribution for the light.
 	//! [Default value] 1
	float get_diffuse_contribution() const { return getFloat("diffuse_contribution"); }

	//! Specular contribution for the light.
 	//! [Default value] 1
	bool set_specular_contribution(float val) { return setValue("specular_contribution", val); }
	//! Specular contribution for the light.
 	//! [Default value] 1
	float get_specular_contribution() const { return getFloat("specular_contribution"); }

	//! Render channels the result of this light will be written to
 	bool set_channels(const ValueList& pluginList) { return setValue("channels", pluginList); }
	//! Render channels the result of this light will be written to
 	ValueList get_channels() const { return getValueList("channels"); }

	//! Render channels the raw diffuse result of this light will be written to
 	bool set_channels_raw(const ValueList& pluginList) { return setValue("channels_raw", pluginList); }
	//! Render channels the raw diffuse result of this light will be written to
 	ValueList get_channels_raw() const { return getValueList("channels_raw"); }

	//! Render channels the diffuse result of this light will be written to
 	bool set_channels_diffuse(const ValueList& pluginList) { return setValue("channels_diffuse", pluginList); }
	//! Render channels the diffuse result of this light will be written to
 	ValueList get_channels_diffuse() const { return getValueList("channels_diffuse"); }

	//! Render channels the specular result of this light will be written to
 	bool set_channels_specular(const ValueList& pluginList) { return setValue("channels_specular", pluginList); }
	//! Render channels the specular result of this light will be written to
 	ValueList get_channels_specular() const { return getValueList("channels_specular"); }

	//! true if the light should use the global light level setting
 	//! [Default value] true
	bool set_use_global_light_level(bool val) { return setValue("use_global_light_level", val); }
	//! true if the light should use the global light level setting
 	//! [Default value] true
	bool get_use_global_light_level() const { return getBool("use_global_light_level"); }

	//! Units for the intensity (0 - default, 1 - lumens, 2 - lm/m/m/sr, 3 - watts, 4 - w/m/m/sr)
 	//! [UI Guides] enum=0:Default; 1:Lumens; 2:lm/m/m/sr; 3:Watts; 4:w/m/m/sr
 	//! [Default value] 0
	bool set_units(int val) { return setValue("units", val); }
	//! Units for the intensity (0 - default, 1 - lumens, 2 - lm/m/m/sr, 3 - watts, 4 - w/m/m/sr)
 	//! [UI Guides] enum=0:Default; 1:Lumens; 2:lm/m/m/sr; 3:Watts; 4:w/m/m/sr
 	//! [Default value] 0
	int get_units() const { return getInt("units"); }

	//! Light intensity
 	//! [UI Guides] overridenBy=intensity_tex
 	//! [Default value] 1
	bool set_intensity(float val) { return setValue("intensity", val); }
	//! Light intensity
 	//! [UI Guides] overridenBy=intensity_tex
 	//! [Default value] 1
	float get_intensity() const { return getFloat("intensity"); }

	//! A float texture that if present will override the intensity parameter
 	//! [UI Guides] overrides=intensity
 	bool set_intensity_tex(const Plugin& texturefloat) { return setValue("intensity_tex", texturefloat); }
	//! A float texture that if present will override the intensity parameter
 	//! [UI Guides] overrides=intensity
 	bool set_intensity_tex(float texturefloat) { return setValue("intensity_tex", texturefloat); }
	//! A float texture that if present will override the intensity parameter
 	//! [UI Guides] overrides=intensity
 	Value get_intensity_tex() const { return getValue("intensity_tex"); }

	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	bool set_subdivs(int val) { return setValue("subdivs", val); }
	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	int get_subdivs() const { return getInt("subdivs"); }

	//! When this option is on and GI calculation is set to Irradiance map V-Ray will calculate the effects of this light and store them in the irradiance map. The result is that the irradiance map is computed more slowly but the rendering takes less time. You can also save the irradiance map and reuse it later.
 	//! [UI Guides] displayName=Store with irradiance map
 	//! [Default value] false
	bool set_storeWithIrradianceMap(bool val) { return setValue("storeWithIrradianceMap", val); }
	//! When this option is on and GI calculation is set to Irradiance map V-Ray will calculate the effects of this light and store them in the irradiance map. The result is that the irradiance map is computed more slowly but the rendering takes less time. You can also save the irradiance map and reuse it later.
 	//! [UI Guides] displayName=Store with irradiance map
 	//! [Default value] false
	bool get_storeWithIrradianceMap() const { return getBool("storeWithIrradianceMap"); }

	//! True if the light is NOT directly visible from the camera and false otherwise.
 	//! [Default value] false
	bool set_invisible(bool val) { return setValue("invisible", val); }
	//! True if the light is NOT directly visible from the camera and false otherwise.
 	//! [Default value] false
	bool get_invisible() const { return getBool("invisible"); }

	//! True if the light appears in reflections and false otherwise.
 	//! [UI Guides] displayName=Affect reflections
 	//! [Default value] true
	bool set_affectReflections(bool val) { return setValue("affectReflections", val); }
	//! True if the light appears in reflections and false otherwise.
 	//! [UI Guides] displayName=Affect reflections
 	//! [Default value] true
	bool get_affectReflections() const { return getBool("affectReflections"); }

	//! (description missing)
	//! [Default value] false
	bool set_noDecay(bool val) { return setValue("noDecay", val); }
	//! (description missing)
	//! [Default value] false
	bool get_noDecay() const { return getBool("noDecay"); }

	//! (description missing)
	//! [Default value] false
	bool set_doubleSided(bool val) { return setValue("doubleSided", val); }
	//! (description missing)
	//! [Default value] false
	bool get_doubleSided() const { return getBool("doubleSided"); }

	//! Specifies if the light is a portal light (0 - normal light, 1 - portal light, 2 - simple portal light)
 	//! [UI Guides] enum=0:Normal light; 1:Portal Light; 2:Simple portal light
 	//! [Default value] 0
	bool set_lightPortal(int val) { return setValue("lightPortal", val); }
	//! Specifies if the light is a portal light (0 - normal light, 1 - portal light, 2 - simple portal light)
 	//! [UI Guides] enum=0:Normal light; 1:Portal Light; 2:Simple portal light
 	//! [Default value] 0
	int get_lightPortal() const { return getInt("lightPortal"); }

	//! (description missing)
	//! [Default value] 0
	bool set_objectID(int val) { return setValue("objectID", val); }
	//! (description missing)
	//! [Default value] 0
	int get_objectID() const { return getInt("objectID"); }

	//! This parameter is for debugging only. It should always be set to true in user scenes. When set to false, rendering quality is not optimal.
 	//! [UI Guides] displayName=Use multiple importance sampling
 	//! [Default value] true
	bool set_useMIS(bool val) { return setValue("useMIS", val); }
	//! This parameter is for debugging only. It should always be set to true in user scenes. When set to false, rendering quality is not optimal.
 	//! [UI Guides] displayName=Use multiple importance sampling
 	//! [Default value] true
	bool get_useMIS() const { return getBool("useMIS"); }

	//! (description missing)
	bool set_geometry(const Plugin& plugin) { return setValue("geometry", plugin); }
	//! (description missing)
	Plugin get_geometry() const { return getPlugin("geometry"); }

	//! (description missing)
	//! [Default value] true
	bool set_ignoreLightNormals(bool val) { return setValue("ignoreLightNormals", val); }
	//! (description missing)
	//! [Default value] true
	bool get_ignoreLightNormals() const { return getBool("ignoreLightNormals"); }

	//! The light texture
 	bool set_tex(const Plugin& texture) { return setValue("tex", texture); }
	//! The light texture
 	bool set_tex(const AColor& texture) { return setValue("tex", texture); }
	//! The light texture
 	Value get_tex() const { return getValue("tex"); }

	//! True if the texture should be used
 	//! [UI Guides] displayName=Use texture
 	//! [Default value] false
	bool set_use_tex(bool val) { return setValue("use_tex", val); }
	//! True if the texture should be used
 	//! [UI Guides] displayName=Use texture
 	//! [Default value] false
	bool get_use_tex() const { return getBool("use_tex"); }

	//! The internal texture resolution
 	//! [UI Guides] displayName=Texture cache resolution, minValue=1, maxValue16384, enableIf: ?use_tex=1, ?cache_tex=1
 	//! [Default value] 256
	bool set_tex_resolution(int val) { return setValue("tex_resolution", val); }
	//! The internal texture resolution
 	//! [UI Guides] displayName=Texture cache resolution, minValue=1, maxValue16384, enableIf: ?use_tex=1, ?cache_tex=1
 	//! [Default value] 256
	int get_tex_resolution() const { return getInt("tex_resolution"); }

	//! When this is true the texture will be cached at tex_resolution x tex_resolution and this cached texture will be used to determine the texture color for shadows rays, speeding up light evaluation, especially for complex procedural textures
 	//! [UI Guides] displayName=Cache texture, enableIf: ?use_tex=1
 	//! [Default value] true
	bool set_cache_tex(bool val) { return setValue("cache_tex", val); }
	//! When this is true the texture will be cached at tex_resolution x tex_resolution and this cached texture will be used to determine the texture color for shadows rays, speeding up light evaluation, especially for complex procedural textures
 	//! [UI Guides] displayName=Cache texture, enableIf: ?use_tex=1
 	//! [Default value] true
	bool get_cache_tex() const { return getBool("cache_tex"); }

	//! A list of user defined attributes
 	bool set_user_attributes(const char* str) { return setValue("user_attributes", str); }
	//! A list of user defined attributes
 	bool set_user_attributes(const std::string& str) { return setValue("user_attributes", str); }
	//! A list of user defined attributes
 	std::string get_user_attributes() const { return getString("user_attributes"); }
};

class LightOmni : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "LightOmni"; }

	//! true if the light is casting light (turned on) and false otherwise; it only makes sense to use this parameter if it is animated, or if another object depends on this node but it must not be rendered
 	//! [Default value] true
	bool set_enabled(bool val) { return setValue("enabled", val); }
	//! true if the light is casting light (turned on) and false otherwise; it only makes sense to use this parameter if it is animated, or if another object depends on this node but it must not be rendered
 	//! [Default value] true
	bool get_enabled() const { return getBool("enabled"); }

	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	bool set_transform(const Transform& transform) { return setValue("transform", transform); }
	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	Transform get_transform() const { return getTransform("transform"); }

	//! Color of the light
 	//! [UI Guides] overridenBy=color_tex
 	//! [Default value] Color(1, 1, 1)
	bool set_color(const Color& color) { return setValue("color", color); }
	//! Color of the light
 	//! [UI Guides] overridenBy=color_tex
 	//! [Default value] Color(1, 1, 1)
	Color get_color() const { return getColor("color"); }

	//! A color texture that if present will override the color parameter
 	//! [UI Guides] overrides=color
 	bool set_color_tex(const Plugin& texture) { return setValue("color_tex", texture); }
	//! A color texture that if present will override the color parameter
 	//! [UI Guides] overrides=color
 	bool set_color_tex(const AColor& texture) { return setValue("color_tex", texture); }
	//! A color texture that if present will override the color parameter
 	//! [UI Guides] overrides=color
 	Value get_color_tex() const { return getValue("color_tex"); }

	//! true if the light casts shadows and false otherwise
 	//! [Default value] true
	bool set_shadows(bool val) { return setValue("shadows", val); }
	//! true if the light casts shadows and false otherwise
 	//! [Default value] true
	bool get_shadows() const { return getBool("shadows"); }

	//! The shadow color. Anything but black is not physically accurate.
 	//! [UI Guides] overridenBy=shadowColor_tex
 	//! [Default value] Color(0, 0, 0)
	bool set_shadowColor(const Color& color) { return setValue("shadowColor", color); }
	//! The shadow color. Anything but black is not physically accurate.
 	//! [UI Guides] overridenBy=shadowColor_tex
 	//! [Default value] Color(0, 0, 0)
	Color get_shadowColor() const { return getColor("shadowColor"); }

	//! A color texture that if present will override the shadowColor parameter
 	//! [UI Guides] overrides=shadowColor
 	bool set_shadowColor_tex(const Plugin& texture) { return setValue("shadowColor_tex", texture); }
	//! A color texture that if present will override the shadowColor parameter
 	//! [UI Guides] overrides=shadowColor
 	bool set_shadowColor_tex(const AColor& texture) { return setValue("shadowColor_tex", texture); }
	//! A color texture that if present will override the shadowColor parameter
 	//! [UI Guides] overrides=shadowColor
 	Value get_shadowColor_tex() const { return getValue("shadowColor_tex"); }

	//! Shadow offset from the surface. Helps to prevent polygonal shadow artifacts on low-poly surfaces.
 	//! [UI Guides] displayName=Shadow bias, quantityType=distance
 	//! [Default value] 0
	bool set_shadowBias(float val) { return setValue("shadowBias", val); }
	//! Shadow offset from the surface. Helps to prevent polygonal shadow artifacts on low-poly surfaces.
 	//! [UI Guides] displayName=Shadow bias, quantityType=distance
 	//! [Default value] 0
	float get_shadowBias() const { return getFloat("shadowBias"); }

	//! Determines the number of photons emitted by this light when calculating the Global Photon Map. 1000 subdivs equal 1 million photons.
 	//! [UI Guides] displayName=Photon subdivs, minValue=0
 	//! [Default value] 500
	bool set_photonSubdivs(int val) { return setValue("photonSubdivs", val); }
	//! Determines the number of photons emitted by this light when calculating the Global Photon Map. 1000 subdivs equal 1 million photons.
 	//! [UI Guides] displayName=Photon subdivs, minValue=0
 	//! [Default value] 500
	int get_photonSubdivs() const { return getInt("photonSubdivs"); }

	//! Determines the number of photons emitted by this light when calculating the Caustics Photon Map. 1000 subdivs equal 1 million photons.
 	//! [UI Guides] displayName=Caustics subdivs, minValue=0
 	//! [Default value] 1000
	bool set_causticSubdivs(int val) { return setValue("causticSubdivs", val); }
	//! Determines the number of photons emitted by this light when calculating the Caustics Photon Map. 1000 subdivs equal 1 million photons.
 	//! [UI Guides] displayName=Caustics subdivs, minValue=0
 	//! [Default value] 1000
	int get_causticSubdivs() const { return getInt("causticSubdivs"); }

	//! Multiplier for the diffuse photons.
 	//! [UI Guides] displayName=Diffuse multiplier, minValue=0.0
 	//! [Default value] 1
	bool set_diffuseMult(float val) { return setValue("diffuseMult", val); }
	//! Multiplier for the diffuse photons.
 	//! [UI Guides] displayName=Diffuse multiplier, minValue=0.0
 	//! [Default value] 1
	float get_diffuseMult() const { return getFloat("diffuseMult"); }

	//! Multiplier for the caustics photons.
 	//! [UI Guides] displayName=Caustics multiplier, minValue=0.0
 	//! [Default value] 1
	bool set_causticMult(float val) { return setValue("causticMult", val); }
	//! Multiplier for the caustics photons.
 	//! [UI Guides] displayName=Caustics multiplier, minValue=0.0
 	//! [Default value] 1
	float get_causticMult() const { return getFloat("causticMult"); }

	//! Light cut-off threshold (speed optimization). If the light intensity for a point is below this threshold, the light will not be computed.
 	//! [UI Guides] displayName=Cut-off threshold, minValue=0.0
 	//! [Default value] 0.001
	bool set_cutoffThreshold(float val) { return setValue("cutoffThreshold", val); }
	//! Light cut-off threshold (speed optimization). If the light intensity for a point is below this threshold, the light will not be computed.
 	//! [UI Guides] displayName=Cut-off threshold, minValue=0.0
 	//! [Default value] 0.001
	float get_cutoffThreshold() const { return getFloat("cutoffThreshold"); }

	//! True if the light produces diffuse lighting and false otherwise.
 	//! [UI Guides] displayName=Affect diffuse
 	//! [Default value] true
	bool set_affectDiffuse(bool val) { return setValue("affectDiffuse", val); }
	//! True if the light produces diffuse lighting and false otherwise.
 	//! [UI Guides] displayName=Affect diffuse
 	//! [Default value] true
	bool get_affectDiffuse() const { return getBool("affectDiffuse"); }

	//! True if the light produces specular hilights and false otherwise.
 	//! [UI Guides] displayName=Affect specular
 	//! [Default value] true
	bool set_affectSpecular(bool val) { return setValue("affectSpecular", val); }
	//! True if the light produces specular hilights and false otherwise.
 	//! [UI Guides] displayName=Affect specular
 	//! [Default value] true
	bool get_affectSpecular() const { return getBool("affectSpecular"); }

	//! True if the bumped normal should be used to check if the light direction is below the surface.
 	//! [UI Guides] displayName=Bumped normal check
 	//! [Default value] false
	bool set_bumped_below_surface_check(bool val) { return setValue("bumped_below_surface_check", val); }
	//! True if the bumped normal should be used to check if the light direction is below the surface.
 	//! [UI Guides] displayName=Bumped normal check
 	//! [Default value] false
	bool get_bumped_below_surface_check() const { return getBool("bumped_below_surface_check"); }

	//! Number of parameter samples for motion blur.
 	//! [Default value] 0
	bool set_nsamples(int val) { return setValue("nsamples", val); }
	//! Number of parameter samples for motion blur.
 	//! [Default value] 0
	int get_nsamples() const { return getInt("nsamples"); }

	//! Diffuse contribution for the light.
 	//! [Default value] 1
	bool set_diffuse_contribution(float val) { return setValue("diffuse_contribution", val); }
	//! Diffuse contribution for the light.
 	//! [Default value] 1
	float get_diffuse_contribution() const { return getFloat("diffuse_contribution"); }

	//! Specular contribution for the light.
 	//! [Default value] 1
	bool set_specular_contribution(float val) { return setValue("specular_contribution", val); }
	//! Specular contribution for the light.
 	//! [Default value] 1
	float get_specular_contribution() const { return getFloat("specular_contribution"); }

	//! Render channels the result of this light will be written to
 	bool set_channels(const ValueList& pluginList) { return setValue("channels", pluginList); }
	//! Render channels the result of this light will be written to
 	ValueList get_channels() const { return getValueList("channels"); }

	//! Render channels the raw diffuse result of this light will be written to
 	bool set_channels_raw(const ValueList& pluginList) { return setValue("channels_raw", pluginList); }
	//! Render channels the raw diffuse result of this light will be written to
 	ValueList get_channels_raw() const { return getValueList("channels_raw"); }

	//! Render channels the diffuse result of this light will be written to
 	bool set_channels_diffuse(const ValueList& pluginList) { return setValue("channels_diffuse", pluginList); }
	//! Render channels the diffuse result of this light will be written to
 	ValueList get_channels_diffuse() const { return getValueList("channels_diffuse"); }

	//! Render channels the specular result of this light will be written to
 	bool set_channels_specular(const ValueList& pluginList) { return setValue("channels_specular", pluginList); }
	//! Render channels the specular result of this light will be written to
 	ValueList get_channels_specular() const { return getValueList("channels_specular"); }

	//! true if the light should use the global light level setting
 	//! [Default value] true
	bool set_use_global_light_level(bool val) { return setValue("use_global_light_level", val); }
	//! true if the light should use the global light level setting
 	//! [Default value] true
	bool get_use_global_light_level() const { return getBool("use_global_light_level"); }

	//! Units for the intensity (0 - default, 1 - lumens, 2 - lm/m/m/sr, 3 - watts, 4 - w/m/m/sr)
 	//! [UI Guides] enum=0:Default; 1:Lumens; 2:lm/m/m/sr; 3:Watts; 4:w/m/m/sr
 	//! [Default value] 0
	bool set_units(int val) { return setValue("units", val); }
	//! Units for the intensity (0 - default, 1 - lumens, 2 - lm/m/m/sr, 3 - watts, 4 - w/m/m/sr)
 	//! [UI Guides] enum=0:Default; 1:Lumens; 2:lm/m/m/sr; 3:Watts; 4:w/m/m/sr
 	//! [Default value] 0
	int get_units() const { return getInt("units"); }

	//! Light intensity
 	//! [UI Guides] overridenBy=intensity_tex
 	//! [Default value] 1
	bool set_intensity(float val) { return setValue("intensity", val); }
	//! Light intensity
 	//! [UI Guides] overridenBy=intensity_tex
 	//! [Default value] 1
	float get_intensity() const { return getFloat("intensity"); }

	//! A float texture that if present will override the intensity parameter
 	//! [UI Guides] overrides=intensity
 	bool set_intensity_tex(const Plugin& texturefloat) { return setValue("intensity_tex", texturefloat); }
	//! A float texture that if present will override the intensity parameter
 	//! [UI Guides] overrides=intensity
 	bool set_intensity_tex(float texturefloat) { return setValue("intensity_tex", texturefloat); }
	//! A float texture that if present will override the intensity parameter
 	//! [UI Guides] overrides=intensity
 	Value get_intensity_tex() const { return getValue("intensity_tex"); }

	//! The size of the light; 0.0 is a point light, larger values produces soft (area) shadows
 	//! [UI Guides] quantityType=distance, overridenBy=shadowRadius_tex
 	//! [Default value] 0
	bool set_shadowRadius(float val) { return setValue("shadowRadius", val); }
	//! The size of the light; 0.0 is a point light, larger values produces soft (area) shadows
 	//! [UI Guides] quantityType=distance, overridenBy=shadowRadius_tex
 	//! [Default value] 0
	float get_shadowRadius() const { return getFloat("shadowRadius"); }

	//! A float texture that if present will override the shadows radius parameter
 	//! [UI Guides] overrides=shadowRadius
 	bool set_shadowRadius_tex(const Plugin& texturefloat) { return setValue("shadowRadius_tex", texturefloat); }
	//! A float texture that if present will override the shadows radius parameter
 	//! [UI Guides] overrides=shadowRadius
 	bool set_shadowRadius_tex(float texturefloat) { return setValue("shadowRadius_tex", texturefloat); }
	//! A float texture that if present will override the shadows radius parameter
 	//! [UI Guides] overrides=shadowRadius
 	Value get_shadowRadius_tex() const { return getValue("shadowRadius_tex"); }

	//! If true, the hilights will match the shape of the light; if false, hilights will always be calculated as from a point light
 	//! [Default value] false
	bool set_areaSpeculars(bool val) { return setValue("areaSpeculars", val); }
	//! If true, the hilights will match the shape of the light; if false, hilights will always be calculated as from a point light
 	//! [Default value] false
	bool get_areaSpeculars() const { return getBool("areaSpeculars"); }

	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	bool set_shadowSubdivs(int val) { return setValue("shadowSubdivs", val); }
	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	int get_shadowSubdivs() const { return getInt("shadowSubdivs"); }

	//! When this option is on and GI calculation is set to Irradiance map V-Ray will calculate the effects of this light and store them in the irradiance map. The result is that the irradiance map is computed more slowly but the rendering takes less time. You can also save the irradiance map and reuse it later.
 	//! [UI Guides] displayName=Store with irradiance map
 	//! [Default value] false
	bool set_storeWithIrradianceMap(bool val) { return setValue("storeWithIrradianceMap", val); }
	//! When this option is on and GI calculation is set to Irradiance map V-Ray will calculate the effects of this light and store them in the irradiance map. The result is that the irradiance map is computed more slowly but the rendering takes less time. You can also save the irradiance map and reuse it later.
 	//! [UI Guides] displayName=Store with irradiance map
 	//! [Default value] false
	bool get_storeWithIrradianceMap() const { return getBool("storeWithIrradianceMap"); }

	//! (description missing)
	//! [Default value] 2
	bool set_decay(float val) { return setValue("decay", val); }
	//! (description missing)
	//! [Default value] 2
	float get_decay() const { return getFloat("decay"); }
};

class LightOmniMax : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "LightOmniMax"; }

	//! true if the light is casting light (turned on) and false otherwise; it only makes sense to use this parameter if it is animated, or if another object depends on this node but it must not be rendered
 	//! [Default value] true
	bool set_enabled(bool val) { return setValue("enabled", val); }
	//! true if the light is casting light (turned on) and false otherwise; it only makes sense to use this parameter if it is animated, or if another object depends on this node but it must not be rendered
 	//! [Default value] true
	bool get_enabled() const { return getBool("enabled"); }

	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	bool set_transform(const Transform& transform) { return setValue("transform", transform); }
	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	Transform get_transform() const { return getTransform("transform"); }

	//! Color of the light
 	//! [UI Guides] overridenBy=color_tex
 	//! [Default value] Color(1, 1, 1)
	bool set_color(const Color& color) { return setValue("color", color); }
	//! Color of the light
 	//! [UI Guides] overridenBy=color_tex
 	//! [Default value] Color(1, 1, 1)
	Color get_color() const { return getColor("color"); }

	//! A color texture that if present will override the color parameter
 	//! [UI Guides] overrides=color
 	bool set_color_tex(const Plugin& texture) { return setValue("color_tex", texture); }
	//! A color texture that if present will override the color parameter
 	//! [UI Guides] overrides=color
 	bool set_color_tex(const AColor& texture) { return setValue("color_tex", texture); }
	//! A color texture that if present will override the color parameter
 	//! [UI Guides] overrides=color
 	Value get_color_tex() const { return getValue("color_tex"); }

	//! true if the light casts shadows and false otherwise
 	//! [Default value] true
	bool set_shadows(bool val) { return setValue("shadows", val); }
	//! true if the light casts shadows and false otherwise
 	//! [Default value] true
	bool get_shadows() const { return getBool("shadows"); }

	//! The shadow color. Anything but black is not physically accurate.
 	//! [UI Guides] overridenBy=shadowColor_tex
 	//! [Default value] Color(0, 0, 0)
	bool set_shadowColor(const Color& color) { return setValue("shadowColor", color); }
	//! The shadow color. Anything but black is not physically accurate.
 	//! [UI Guides] overridenBy=shadowColor_tex
 	//! [Default value] Color(0, 0, 0)
	Color get_shadowColor() const { return getColor("shadowColor"); }

	//! A color texture that if present will override the shadowColor parameter
 	//! [UI Guides] overrides=shadowColor
 	bool set_shadowColor_tex(const Plugin& texture) { return setValue("shadowColor_tex", texture); }
	//! A color texture that if present will override the shadowColor parameter
 	//! [UI Guides] overrides=shadowColor
 	bool set_shadowColor_tex(const AColor& texture) { return setValue("shadowColor_tex", texture); }
	//! A color texture that if present will override the shadowColor parameter
 	//! [UI Guides] overrides=shadowColor
 	Value get_shadowColor_tex() const { return getValue("shadowColor_tex"); }

	//! Shadow offset from the surface. Helps to prevent polygonal shadow artifacts on low-poly surfaces.
 	//! [UI Guides] displayName=Shadow bias, quantityType=distance
 	//! [Default value] 0
	bool set_shadowBias(float val) { return setValue("shadowBias", val); }
	//! Shadow offset from the surface. Helps to prevent polygonal shadow artifacts on low-poly surfaces.
 	//! [UI Guides] displayName=Shadow bias, quantityType=distance
 	//! [Default value] 0
	float get_shadowBias() const { return getFloat("shadowBias"); }

	//! Determines the number of photons emitted by this light when calculating the Global Photon Map. 1000 subdivs equal 1 million photons.
 	//! [UI Guides] displayName=Photon subdivs, minValue=0
 	//! [Default value] 500
	bool set_photonSubdivs(int val) { return setValue("photonSubdivs", val); }
	//! Determines the number of photons emitted by this light when calculating the Global Photon Map. 1000 subdivs equal 1 million photons.
 	//! [UI Guides] displayName=Photon subdivs, minValue=0
 	//! [Default value] 500
	int get_photonSubdivs() const { return getInt("photonSubdivs"); }

	//! Determines the number of photons emitted by this light when calculating the Caustics Photon Map. 1000 subdivs equal 1 million photons.
 	//! [UI Guides] displayName=Caustics subdivs, minValue=0
 	//! [Default value] 1000
	bool set_causticSubdivs(int val) { return setValue("causticSubdivs", val); }
	//! Determines the number of photons emitted by this light when calculating the Caustics Photon Map. 1000 subdivs equal 1 million photons.
 	//! [UI Guides] displayName=Caustics subdivs, minValue=0
 	//! [Default value] 1000
	int get_causticSubdivs() const { return getInt("causticSubdivs"); }

	//! Multiplier for the diffuse photons.
 	//! [UI Guides] displayName=Diffuse multiplier, minValue=0.0
 	//! [Default value] 1
	bool set_diffuseMult(float val) { return setValue("diffuseMult", val); }
	//! Multiplier for the diffuse photons.
 	//! [UI Guides] displayName=Diffuse multiplier, minValue=0.0
 	//! [Default value] 1
	float get_diffuseMult() const { return getFloat("diffuseMult"); }

	//! Multiplier for the caustics photons.
 	//! [UI Guides] displayName=Caustics multiplier, minValue=0.0
 	//! [Default value] 1
	bool set_causticMult(float val) { return setValue("causticMult", val); }
	//! Multiplier for the caustics photons.
 	//! [UI Guides] displayName=Caustics multiplier, minValue=0.0
 	//! [Default value] 1
	float get_causticMult() const { return getFloat("causticMult"); }

	//! Light cut-off threshold (speed optimization). If the light intensity for a point is below this threshold, the light will not be computed.
 	//! [UI Guides] displayName=Cut-off threshold, minValue=0.0
 	//! [Default value] 0.001
	bool set_cutoffThreshold(float val) { return setValue("cutoffThreshold", val); }
	//! Light cut-off threshold (speed optimization). If the light intensity for a point is below this threshold, the light will not be computed.
 	//! [UI Guides] displayName=Cut-off threshold, minValue=0.0
 	//! [Default value] 0.001
	float get_cutoffThreshold() const { return getFloat("cutoffThreshold"); }

	//! True if the light produces diffuse lighting and false otherwise.
 	//! [UI Guides] displayName=Affect diffuse
 	//! [Default value] true
	bool set_affectDiffuse(bool val) { return setValue("affectDiffuse", val); }
	//! True if the light produces diffuse lighting and false otherwise.
 	//! [UI Guides] displayName=Affect diffuse
 	//! [Default value] true
	bool get_affectDiffuse() const { return getBool("affectDiffuse"); }

	//! True if the light produces specular hilights and false otherwise.
 	//! [UI Guides] displayName=Affect specular
 	//! [Default value] true
	bool set_affectSpecular(bool val) { return setValue("affectSpecular", val); }
	//! True if the light produces specular hilights and false otherwise.
 	//! [UI Guides] displayName=Affect specular
 	//! [Default value] true
	bool get_affectSpecular() const { return getBool("affectSpecular"); }

	//! True if the bumped normal should be used to check if the light direction is below the surface.
 	//! [UI Guides] displayName=Bumped normal check
 	//! [Default value] false
	bool set_bumped_below_surface_check(bool val) { return setValue("bumped_below_surface_check", val); }
	//! True if the bumped normal should be used to check if the light direction is below the surface.
 	//! [UI Guides] displayName=Bumped normal check
 	//! [Default value] false
	bool get_bumped_below_surface_check() const { return getBool("bumped_below_surface_check"); }

	//! Number of parameter samples for motion blur.
 	//! [Default value] 0
	bool set_nsamples(int val) { return setValue("nsamples", val); }
	//! Number of parameter samples for motion blur.
 	//! [Default value] 0
	int get_nsamples() const { return getInt("nsamples"); }

	//! Diffuse contribution for the light.
 	//! [Default value] 1
	bool set_diffuse_contribution(float val) { return setValue("diffuse_contribution", val); }
	//! Diffuse contribution for the light.
 	//! [Default value] 1
	float get_diffuse_contribution() const { return getFloat("diffuse_contribution"); }

	//! Specular contribution for the light.
 	//! [Default value] 1
	bool set_specular_contribution(float val) { return setValue("specular_contribution", val); }
	//! Specular contribution for the light.
 	//! [Default value] 1
	float get_specular_contribution() const { return getFloat("specular_contribution"); }

	//! Render channels the result of this light will be written to
 	bool set_channels(const ValueList& pluginList) { return setValue("channels", pluginList); }
	//! Render channels the result of this light will be written to
 	ValueList get_channels() const { return getValueList("channels"); }

	//! Render channels the raw diffuse result of this light will be written to
 	bool set_channels_raw(const ValueList& pluginList) { return setValue("channels_raw", pluginList); }
	//! Render channels the raw diffuse result of this light will be written to
 	ValueList get_channels_raw() const { return getValueList("channels_raw"); }

	//! Render channels the diffuse result of this light will be written to
 	bool set_channels_diffuse(const ValueList& pluginList) { return setValue("channels_diffuse", pluginList); }
	//! Render channels the diffuse result of this light will be written to
 	ValueList get_channels_diffuse() const { return getValueList("channels_diffuse"); }

	//! Render channels the specular result of this light will be written to
 	bool set_channels_specular(const ValueList& pluginList) { return setValue("channels_specular", pluginList); }
	//! Render channels the specular result of this light will be written to
 	ValueList get_channels_specular() const { return getValueList("channels_specular"); }

	//! true if the light should use the global light level setting
 	//! [Default value] true
	bool set_use_global_light_level(bool val) { return setValue("use_global_light_level", val); }
	//! true if the light should use the global light level setting
 	//! [Default value] true
	bool get_use_global_light_level() const { return getBool("use_global_light_level"); }

	//! Units for the intensity (0 - default, 1 - lumens, 2 - lm/m/m/sr, 3 - watts, 4 - w/m/m/sr)
 	//! [UI Guides] enum=0:Default; 1:Lumens; 2:lm/m/m/sr; 3:Watts; 4:w/m/m/sr
 	//! [Default value] 0
	bool set_units(int val) { return setValue("units", val); }
	//! Units for the intensity (0 - default, 1 - lumens, 2 - lm/m/m/sr, 3 - watts, 4 - w/m/m/sr)
 	//! [UI Guides] enum=0:Default; 1:Lumens; 2:lm/m/m/sr; 3:Watts; 4:w/m/m/sr
 	//! [Default value] 0
	int get_units() const { return getInt("units"); }

	//! Light intensity
 	//! [UI Guides] overridenBy=intensity_tex
 	//! [Default value] 1
	bool set_intensity(float val) { return setValue("intensity", val); }
	//! Light intensity
 	//! [UI Guides] overridenBy=intensity_tex
 	//! [Default value] 1
	float get_intensity() const { return getFloat("intensity"); }

	//! A float texture that if present will override the intensity parameter
 	//! [UI Guides] overrides=intensity
 	bool set_intensity_tex(const Plugin& texturefloat) { return setValue("intensity_tex", texturefloat); }
	//! A float texture that if present will override the intensity parameter
 	//! [UI Guides] overrides=intensity
 	bool set_intensity_tex(float texturefloat) { return setValue("intensity_tex", texturefloat); }
	//! A float texture that if present will override the intensity parameter
 	//! [UI Guides] overrides=intensity
 	Value get_intensity_tex() const { return getValue("intensity_tex"); }

	//! The size of the light; 0.0 is a point light, larger values produces soft (area) shadows
 	//! [UI Guides] quantityType=distance, overridenBy=shadowRadius_tex
 	//! [Default value] 0
	bool set_shadowRadius(float val) { return setValue("shadowRadius", val); }
	//! The size of the light; 0.0 is a point light, larger values produces soft (area) shadows
 	//! [UI Guides] quantityType=distance, overridenBy=shadowRadius_tex
 	//! [Default value] 0
	float get_shadowRadius() const { return getFloat("shadowRadius"); }

	//! A float texture that if present will override the shadows radius parameter
 	//! [UI Guides] overrides=shadowRadius
 	bool set_shadowRadius_tex(const Plugin& texturefloat) { return setValue("shadowRadius_tex", texturefloat); }
	//! A float texture that if present will override the shadows radius parameter
 	//! [UI Guides] overrides=shadowRadius
 	bool set_shadowRadius_tex(float texturefloat) { return setValue("shadowRadius_tex", texturefloat); }
	//! A float texture that if present will override the shadows radius parameter
 	//! [UI Guides] overrides=shadowRadius
 	Value get_shadowRadius_tex() const { return getValue("shadowRadius_tex"); }

	//! If true, the hilights will match the shape of the light; if false, hilights will always be calculated as from a point light
 	//! [Default value] false
	bool set_areaSpeculars(bool val) { return setValue("areaSpeculars", val); }
	//! If true, the hilights will match the shape of the light; if false, hilights will always be calculated as from a point light
 	//! [Default value] false
	bool get_areaSpeculars() const { return getBool("areaSpeculars"); }

	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	bool set_shadowSubdivs(int val) { return setValue("shadowSubdivs", val); }
	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	int get_shadowSubdivs() const { return getInt("shadowSubdivs"); }

	//! When this option is on and GI calculation is set to Irradiance map V-Ray will calculate the effects of this light and store them in the irradiance map. The result is that the irradiance map is computed more slowly but the rendering takes less time. You can also save the irradiance map and reuse it later.
 	//! [UI Guides] displayName=Store with irradiance map
 	//! [Default value] false
	bool set_storeWithIrradianceMap(bool val) { return setValue("storeWithIrradianceMap", val); }
	//! When this option is on and GI calculation is set to Irradiance map V-Ray will calculate the effects of this light and store them in the irradiance map. The result is that the irradiance map is computed more slowly but the rendering takes less time. You can also save the irradiance map and reuse it later.
 	//! [UI Guides] displayName=Store with irradiance map
 	//! [Default value] false
	bool get_storeWithIrradianceMap() const { return getBool("storeWithIrradianceMap"); }

	//! (description missing)
	bool set_projector_map(const Plugin& texture) { return setValue("projector_map", texture); }
	//! (description missing)
	bool set_projector_map(const AColor& texture) { return setValue("projector_map", texture); }
	//! (description missing)
	Value get_projector_map() const { return getValue("projector_map"); }

	//! Decay type (0 - no decay, 1 - linear, 2 - square)
 	//! [UI Guides] enum=0:No decay; 1:Linear; 2:Square
 	//! [Default value] 0
	bool set_decay_type(int val) { return setValue("decay_type", val); }
	//! Decay type (0 - no decay, 1 - linear, 2 - square)
 	//! [UI Guides] enum=0:No decay; 1:Linear; 2:Square
 	//! [Default value] 0
	int get_decay_type() const { return getInt("decay_type"); }

	//! (description missing)
	//! [Default value] 1
	bool set_decay_start(float val) { return setValue("decay_start", val); }
	//! (description missing)
	//! [Default value] 1
	float get_decay_start() const { return getFloat("decay_start"); }

	//! true to use near attenuation
 	//! [Default value] false
	bool set_near_attenuation(bool val) { return setValue("near_attenuation", val); }
	//! true to use near attenuation
 	//! [Default value] false
	bool get_near_attenuation() const { return getBool("near_attenuation"); }

	//! Near attenuation start
 	//! [Default value] 0
	bool set_near_attenuation_start(float val) { return setValue("near_attenuation_start", val); }
	//! Near attenuation start
 	//! [Default value] 0
	float get_near_attenuation_start() const { return getFloat("near_attenuation_start"); }

	//! Near attenuation end
 	//! [Default value] 0
	bool set_near_attenuation_end(float val) { return setValue("near_attenuation_end", val); }
	//! Near attenuation end
 	//! [Default value] 0
	float get_near_attenuation_end() const { return getFloat("near_attenuation_end"); }

	//! true to use far attenuation
 	//! [Default value] false
	bool set_far_attenuation(bool val) { return setValue("far_attenuation", val); }
	//! true to use far attenuation
 	//! [Default value] false
	bool get_far_attenuation() const { return getBool("far_attenuation"); }

	//! far attenuation start
 	//! [Default value] 0
	bool set_far_attenuation_start(float val) { return setValue("far_attenuation_start", val); }
	//! far attenuation start
 	//! [Default value] 0
	float get_far_attenuation_start() const { return getFloat("far_attenuation_start"); }

	//! far attenuation end
 	//! [Default value] 0
	bool set_far_attenuation_end(float val) { return setValue("far_attenuation_end", val); }
	//! far attenuation end
 	//! [Default value] 0
	float get_far_attenuation_end() const { return getFloat("far_attenuation_end"); }

	//! Shape for soft shadows (0 - box, 1 - sphere)
 	//! [UI Guides] enum=0:Box; 1:Sphere
 	//! [Default value] 0
	bool set_shadowShape(int val) { return setValue("shadowShape", val); }
	//! Shape for soft shadows (0 - box, 1 - sphere)
 	//! [UI Guides] enum=0:Box; 1:Sphere
 	//! [Default value] 0
	int get_shadowShape() const { return getInt("shadowShape"); }

	//! V-size for box shadows
 	//! [Default value] 0
	bool set_shadowRadius1(float val) { return setValue("shadowRadius1", val); }
	//! V-size for box shadows
 	//! [Default value] 0
	float get_shadowRadius1() const { return getFloat("shadowRadius1"); }

	//! W-size for box shadows
 	//! [Default value] 0
	bool set_shadowRadius2(float val) { return setValue("shadowRadius2", val); }
	//! W-size for box shadows
 	//! [Default value] 0
	float get_shadowRadius2() const { return getFloat("shadowRadius2"); }
};

class LightRectangle : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "LightRectangle"; }

	//! true if the light is casting light (turned on) and false otherwise; it only makes sense to use this parameter if it is animated, or if another object depends on this node but it must not be rendered
 	//! [Default value] true
	bool set_enabled(bool val) { return setValue("enabled", val); }
	//! true if the light is casting light (turned on) and false otherwise; it only makes sense to use this parameter if it is animated, or if another object depends on this node but it must not be rendered
 	//! [Default value] true
	bool get_enabled() const { return getBool("enabled"); }

	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	bool set_transform(const Transform& transform) { return setValue("transform", transform); }
	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	Transform get_transform() const { return getTransform("transform"); }

	//! Color of the light
 	//! [UI Guides] overridenBy=color_tex
 	//! [Default value] Color(1, 1, 1)
	bool set_color(const Color& color) { return setValue("color", color); }
	//! Color of the light
 	//! [UI Guides] overridenBy=color_tex
 	//! [Default value] Color(1, 1, 1)
	Color get_color() const { return getColor("color"); }

	//! A color texture that if present will override the color parameter
 	//! [UI Guides] overrides=color
 	bool set_color_tex(const Plugin& texture) { return setValue("color_tex", texture); }
	//! A color texture that if present will override the color parameter
 	//! [UI Guides] overrides=color
 	bool set_color_tex(const AColor& texture) { return setValue("color_tex", texture); }
	//! A color texture that if present will override the color parameter
 	//! [UI Guides] overrides=color
 	Value get_color_tex() const { return getValue("color_tex"); }

	//! true if the light casts shadows and false otherwise
 	//! [Default value] true
	bool set_shadows(bool val) { return setValue("shadows", val); }
	//! true if the light casts shadows and false otherwise
 	//! [Default value] true
	bool get_shadows() const { return getBool("shadows"); }

	//! The shadow color. Anything but black is not physically accurate.
 	//! [UI Guides] overridenBy=shadowColor_tex
 	//! [Default value] Color(0, 0, 0)
	bool set_shadowColor(const Color& color) { return setValue("shadowColor", color); }
	//! The shadow color. Anything but black is not physically accurate.
 	//! [UI Guides] overridenBy=shadowColor_tex
 	//! [Default value] Color(0, 0, 0)
	Color get_shadowColor() const { return getColor("shadowColor"); }

	//! A color texture that if present will override the shadowColor parameter
 	//! [UI Guides] overrides=shadowColor
 	bool set_shadowColor_tex(const Plugin& texture) { return setValue("shadowColor_tex", texture); }
	//! A color texture that if present will override the shadowColor parameter
 	//! [UI Guides] overrides=shadowColor
 	bool set_shadowColor_tex(const AColor& texture) { return setValue("shadowColor_tex", texture); }
	//! A color texture that if present will override the shadowColor parameter
 	//! [UI Guides] overrides=shadowColor
 	Value get_shadowColor_tex() const { return getValue("shadowColor_tex"); }

	//! Shadow offset from the surface. Helps to prevent polygonal shadow artifacts on low-poly surfaces.
 	//! [UI Guides] displayName=Shadow bias, quantityType=distance
 	//! [Default value] 0
	bool set_shadowBias(float val) { return setValue("shadowBias", val); }
	//! Shadow offset from the surface. Helps to prevent polygonal shadow artifacts on low-poly surfaces.
 	//! [UI Guides] displayName=Shadow bias, quantityType=distance
 	//! [Default value] 0
	float get_shadowBias() const { return getFloat("shadowBias"); }

	//! Determines the number of photons emitted by this light when calculating the Global Photon Map. 1000 subdivs equal 1 million photons.
 	//! [UI Guides] displayName=Photon subdivs, minValue=0
 	//! [Default value] 500
	bool set_photonSubdivs(int val) { return setValue("photonSubdivs", val); }
	//! Determines the number of photons emitted by this light when calculating the Global Photon Map. 1000 subdivs equal 1 million photons.
 	//! [UI Guides] displayName=Photon subdivs, minValue=0
 	//! [Default value] 500
	int get_photonSubdivs() const { return getInt("photonSubdivs"); }

	//! Determines the number of photons emitted by this light when calculating the Caustics Photon Map. 1000 subdivs equal 1 million photons.
 	//! [UI Guides] displayName=Caustics subdivs, minValue=0
 	//! [Default value] 1000
	bool set_causticSubdivs(int val) { return setValue("causticSubdivs", val); }
	//! Determines the number of photons emitted by this light when calculating the Caustics Photon Map. 1000 subdivs equal 1 million photons.
 	//! [UI Guides] displayName=Caustics subdivs, minValue=0
 	//! [Default value] 1000
	int get_causticSubdivs() const { return getInt("causticSubdivs"); }

	//! Multiplier for the diffuse photons.
 	//! [UI Guides] displayName=Diffuse multiplier, minValue=0.0
 	//! [Default value] 1
	bool set_diffuseMult(float val) { return setValue("diffuseMult", val); }
	//! Multiplier for the diffuse photons.
 	//! [UI Guides] displayName=Diffuse multiplier, minValue=0.0
 	//! [Default value] 1
	float get_diffuseMult() const { return getFloat("diffuseMult"); }

	//! Multiplier for the caustics photons.
 	//! [UI Guides] displayName=Caustics multiplier, minValue=0.0
 	//! [Default value] 1
	bool set_causticMult(float val) { return setValue("causticMult", val); }
	//! Multiplier for the caustics photons.
 	//! [UI Guides] displayName=Caustics multiplier, minValue=0.0
 	//! [Default value] 1
	float get_causticMult() const { return getFloat("causticMult"); }

	//! Light cut-off threshold (speed optimization). If the light intensity for a point is below this threshold, the light will not be computed.
 	//! [UI Guides] displayName=Cut-off threshold, minValue=0.0
 	//! [Default value] 0.001
	bool set_cutoffThreshold(float val) { return setValue("cutoffThreshold", val); }
	//! Light cut-off threshold (speed optimization). If the light intensity for a point is below this threshold, the light will not be computed.
 	//! [UI Guides] displayName=Cut-off threshold, minValue=0.0
 	//! [Default value] 0.001
	float get_cutoffThreshold() const { return getFloat("cutoffThreshold"); }

	//! True if the light produces diffuse lighting and false otherwise.
 	//! [UI Guides] displayName=Affect diffuse
 	//! [Default value] true
	bool set_affectDiffuse(bool val) { return setValue("affectDiffuse", val); }
	//! True if the light produces diffuse lighting and false otherwise.
 	//! [UI Guides] displayName=Affect diffuse
 	//! [Default value] true
	bool get_affectDiffuse() const { return getBool("affectDiffuse"); }

	//! True if the light produces specular hilights and false otherwise.
 	//! [UI Guides] displayName=Affect specular
 	//! [Default value] true
	bool set_affectSpecular(bool val) { return setValue("affectSpecular", val); }
	//! True if the light produces specular hilights and false otherwise.
 	//! [UI Guides] displayName=Affect specular
 	//! [Default value] true
	bool get_affectSpecular() const { return getBool("affectSpecular"); }

	//! True if the bumped normal should be used to check if the light direction is below the surface.
 	//! [UI Guides] displayName=Bumped normal check
 	//! [Default value] false
	bool set_bumped_below_surface_check(bool val) { return setValue("bumped_below_surface_check", val); }
	//! True if the bumped normal should be used to check if the light direction is below the surface.
 	//! [UI Guides] displayName=Bumped normal check
 	//! [Default value] false
	bool get_bumped_below_surface_check() const { return getBool("bumped_below_surface_check"); }

	//! Number of parameter samples for motion blur.
 	//! [Default value] 0
	bool set_nsamples(int val) { return setValue("nsamples", val); }
	//! Number of parameter samples for motion blur.
 	//! [Default value] 0
	int get_nsamples() const { return getInt("nsamples"); }

	//! Diffuse contribution for the light.
 	//! [Default value] 1
	bool set_diffuse_contribution(float val) { return setValue("diffuse_contribution", val); }
	//! Diffuse contribution for the light.
 	//! [Default value] 1
	float get_diffuse_contribution() const { return getFloat("diffuse_contribution"); }

	//! Specular contribution for the light.
 	//! [Default value] 1
	bool set_specular_contribution(float val) { return setValue("specular_contribution", val); }
	//! Specular contribution for the light.
 	//! [Default value] 1
	float get_specular_contribution() const { return getFloat("specular_contribution"); }

	//! Render channels the result of this light will be written to
 	bool set_channels(const ValueList& pluginList) { return setValue("channels", pluginList); }
	//! Render channels the result of this light will be written to
 	ValueList get_channels() const { return getValueList("channels"); }

	//! Render channels the raw diffuse result of this light will be written to
 	bool set_channels_raw(const ValueList& pluginList) { return setValue("channels_raw", pluginList); }
	//! Render channels the raw diffuse result of this light will be written to
 	ValueList get_channels_raw() const { return getValueList("channels_raw"); }

	//! Render channels the diffuse result of this light will be written to
 	bool set_channels_diffuse(const ValueList& pluginList) { return setValue("channels_diffuse", pluginList); }
	//! Render channels the diffuse result of this light will be written to
 	ValueList get_channels_diffuse() const { return getValueList("channels_diffuse"); }

	//! Render channels the specular result of this light will be written to
 	bool set_channels_specular(const ValueList& pluginList) { return setValue("channels_specular", pluginList); }
	//! Render channels the specular result of this light will be written to
 	ValueList get_channels_specular() const { return getValueList("channels_specular"); }

	//! true if the light should use the global light level setting
 	//! [Default value] true
	bool set_use_global_light_level(bool val) { return setValue("use_global_light_level", val); }
	//! true if the light should use the global light level setting
 	//! [Default value] true
	bool get_use_global_light_level() const { return getBool("use_global_light_level"); }

	//! Units for the intensity (0 - default, 1 - lumens, 2 - lm/m/m/sr, 3 - watts, 4 - w/m/m/sr)
 	//! [UI Guides] enum=0:Default; 1:Lumens; 2:lm/m/m/sr; 3:Watts; 4:w/m/m/sr
 	//! [Default value] 0
	bool set_units(int val) { return setValue("units", val); }
	//! Units for the intensity (0 - default, 1 - lumens, 2 - lm/m/m/sr, 3 - watts, 4 - w/m/m/sr)
 	//! [UI Guides] enum=0:Default; 1:Lumens; 2:lm/m/m/sr; 3:Watts; 4:w/m/m/sr
 	//! [Default value] 0
	int get_units() const { return getInt("units"); }

	//! Light intensity
 	//! [UI Guides] overridenBy=intensity_tex
 	//! [Default value] 1
	bool set_intensity(float val) { return setValue("intensity", val); }
	//! Light intensity
 	//! [UI Guides] overridenBy=intensity_tex
 	//! [Default value] 1
	float get_intensity() const { return getFloat("intensity"); }

	//! A float texture that if present will override the intensity parameter
 	//! [UI Guides] overrides=intensity
 	bool set_intensity_tex(const Plugin& texturefloat) { return setValue("intensity_tex", texturefloat); }
	//! A float texture that if present will override the intensity parameter
 	//! [UI Guides] overrides=intensity
 	bool set_intensity_tex(float texturefloat) { return setValue("intensity_tex", texturefloat); }
	//! A float texture that if present will override the intensity parameter
 	//! [UI Guides] overrides=intensity
 	Value get_intensity_tex() const { return getValue("intensity_tex"); }

	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	bool set_subdivs(int val) { return setValue("subdivs", val); }
	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	int get_subdivs() const { return getInt("subdivs"); }

	//! When this option is on and GI calculation is set to Irradiance map V-Ray will calculate the effects of this light and store them in the irradiance map. The result is that the irradiance map is computed more slowly but the rendering takes less time. You can also save the irradiance map and reuse it later.
 	//! [UI Guides] displayName=Store with irradiance map
 	//! [Default value] false
	bool set_storeWithIrradianceMap(bool val) { return setValue("storeWithIrradianceMap", val); }
	//! When this option is on and GI calculation is set to Irradiance map V-Ray will calculate the effects of this light and store them in the irradiance map. The result is that the irradiance map is computed more slowly but the rendering takes less time. You can also save the irradiance map and reuse it later.
 	//! [UI Guides] displayName=Store with irradiance map
 	//! [Default value] false
	bool get_storeWithIrradianceMap() const { return getBool("storeWithIrradianceMap"); }

	//! True if the light is NOT directly visible from the camera and false otherwise.
 	//! [Default value] false
	bool set_invisible(bool val) { return setValue("invisible", val); }
	//! True if the light is NOT directly visible from the camera and false otherwise.
 	//! [Default value] false
	bool get_invisible() const { return getBool("invisible"); }

	//! True if the light appears in reflections and false otherwise.
 	//! [UI Guides] displayName=Affect reflections
 	//! [Default value] true
	bool set_affectReflections(bool val) { return setValue("affectReflections", val); }
	//! True if the light appears in reflections and false otherwise.
 	//! [UI Guides] displayName=Affect reflections
 	//! [Default value] true
	bool get_affectReflections() const { return getBool("affectReflections"); }

	//! (description missing)
	//! [Default value] false
	bool set_noDecay(bool val) { return setValue("noDecay", val); }
	//! (description missing)
	//! [Default value] false
	bool get_noDecay() const { return getBool("noDecay"); }

	//! (description missing)
	//! [Default value] false
	bool set_doubleSided(bool val) { return setValue("doubleSided", val); }
	//! (description missing)
	//! [Default value] false
	bool get_doubleSided() const { return getBool("doubleSided"); }

	//! Specifies if the light is a portal light (0 - normal light, 1 - portal light, 2 - simple portal light)
 	//! [UI Guides] enum=0:Normal light; 1:Portal Light; 2:Simple portal light
 	//! [Default value] 0
	bool set_lightPortal(int val) { return setValue("lightPortal", val); }
	//! Specifies if the light is a portal light (0 - normal light, 1 - portal light, 2 - simple portal light)
 	//! [UI Guides] enum=0:Normal light; 1:Portal Light; 2:Simple portal light
 	//! [Default value] 0
	int get_lightPortal() const { return getInt("lightPortal"); }

	//! (description missing)
	//! [Default value] 0
	bool set_objectID(int val) { return setValue("objectID", val); }
	//! (description missing)
	//! [Default value] 0
	int get_objectID() const { return getInt("objectID"); }

	//! This parameter is for debugging only. It should always be set to true in user scenes. When set to false, rendering quality is not optimal.
 	//! [UI Guides] displayName=Use multiple importance sampling
 	//! [Default value] true
	bool set_useMIS(bool val) { return setValue("useMIS", val); }
	//! This parameter is for debugging only. It should always be set to true in user scenes. When set to false, rendering quality is not optimal.
 	//! [UI Guides] displayName=Use multiple importance sampling
 	//! [Default value] true
	bool get_useMIS() const { return getBool("useMIS"); }

	//! The u dimension of the light (actually half-width)
 	//! [UI Guides] quantityType=distance
 	//! [Default value] 1
	bool set_u_size(float val) { return setValue("u_size", val); }
	//! The u dimension of the light (actually half-width)
 	//! [UI Guides] quantityType=distance
 	//! [Default value] 1
	float get_u_size() const { return getFloat("u_size"); }

	//! The v dimension of the light (actually half-height)
 	//! [UI Guides] quantityType=distance
 	//! [Default value] 1
	bool set_v_size(float val) { return setValue("v_size", val); }
	//! The v dimension of the light (actually half-height)
 	//! [UI Guides] quantityType=distance
 	//! [Default value] 1
	float get_v_size() const { return getFloat("v_size"); }

	//! Narrow the spread of the lighting and make the light directional
 	//! [UI Guides] minValue=0.0, maxValue=1.0
 	//! [Default value] 0
	bool set_directional(float val) { return setValue("directional", val); }
	//! Narrow the spread of the lighting and make the light directional
 	//! [UI Guides] minValue=0.0, maxValue=1.0
 	//! [Default value] 0
	float get_directional() const { return getFloat("directional"); }

	//! (description missing)
	//! [Default value] true
	bool set_ignoreLightNormals(bool val) { return setValue("ignoreLightNormals", val); }
	//! (description missing)
	//! [Default value] true
	bool get_ignoreLightNormals() const { return getBool("ignoreLightNormals"); }

	//! The light is disc shaped
 	//! [Default value] false
	bool set_is_disc(bool val) { return setValue("is_disc", val); }
	//! The light is disc shaped
 	//! [Default value] false
	bool get_is_disc() const { return getBool("is_disc"); }

	//! The light texture
 	bool set_rect_tex(const Plugin& texture) { return setValue("rect_tex", texture); }
	//! The light texture
 	bool set_rect_tex(const AColor& texture) { return setValue("rect_tex", texture); }
	//! The light texture
 	Value get_rect_tex() const { return getValue("rect_tex"); }

	//! True if the texture should be used
 	//! [UI Guides] displayName=Use texture
 	//! [Default value] false
	bool set_use_rect_tex(bool val) { return setValue("use_rect_tex", val); }
	//! True if the texture should be used
 	//! [UI Guides] displayName=Use texture
 	//! [Default value] false
	bool get_use_rect_tex() const { return getBool("use_rect_tex"); }

	//! The texture presampling resolution
 	//! [UI Guides] displayName=Texture resolution, minValue=1, maxValue8192, enableIf: ?use_rect_tex=1
 	//! [Default value] 512
	bool set_tex_resolution(int val) { return setValue("tex_resolution", val); }
	//! The texture presampling resolution
 	//! [UI Guides] displayName=Texture resolution, minValue=1, maxValue8192, enableIf: ?use_rect_tex=1
 	//! [Default value] 512
	int get_tex_resolution() const { return getInt("tex_resolution"); }

	//! The adaptivity of the sampling to the texture brightness (0.0 - no adaptivity; 1.0 - full adaptivity
 	//! [UI Guides] displayName=Texture adaptivity, minValue=0.0, maxValue=1.0, enableIf: ?use_rect_tex=1
 	//! [Default value] 1
	bool set_tex_adaptive(float val) { return setValue("tex_adaptive", val); }
	//! The adaptivity of the sampling to the texture brightness (0.0 - no adaptivity; 1.0 - full adaptivity
 	//! [UI Guides] displayName=Texture adaptivity, minValue=0.0, maxValue=1.0, enableIf: ?use_rect_tex=1
 	//! [Default value] 1
	float get_tex_adaptive() const { return getFloat("tex_adaptive"); }
};

class LightSphere : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "LightSphere"; }

	//! true if the light is casting light (turned on) and false otherwise; it only makes sense to use this parameter if it is animated, or if another object depends on this node but it must not be rendered
 	//! [Default value] true
	bool set_enabled(bool val) { return setValue("enabled", val); }
	//! true if the light is casting light (turned on) and false otherwise; it only makes sense to use this parameter if it is animated, or if another object depends on this node but it must not be rendered
 	//! [Default value] true
	bool get_enabled() const { return getBool("enabled"); }

	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	bool set_transform(const Transform& transform) { return setValue("transform", transform); }
	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	Transform get_transform() const { return getTransform("transform"); }

	//! Color of the light
 	//! [UI Guides] overridenBy=color_tex
 	//! [Default value] Color(1, 1, 1)
	bool set_color(const Color& color) { return setValue("color", color); }
	//! Color of the light
 	//! [UI Guides] overridenBy=color_tex
 	//! [Default value] Color(1, 1, 1)
	Color get_color() const { return getColor("color"); }

	//! A color texture that if present will override the color parameter
 	//! [UI Guides] overrides=color
 	bool set_color_tex(const Plugin& texture) { return setValue("color_tex", texture); }
	//! A color texture that if present will override the color parameter
 	//! [UI Guides] overrides=color
 	bool set_color_tex(const AColor& texture) { return setValue("color_tex", texture); }
	//! A color texture that if present will override the color parameter
 	//! [UI Guides] overrides=color
 	Value get_color_tex() const { return getValue("color_tex"); }

	//! true if the light casts shadows and false otherwise
 	//! [Default value] true
	bool set_shadows(bool val) { return setValue("shadows", val); }
	//! true if the light casts shadows and false otherwise
 	//! [Default value] true
	bool get_shadows() const { return getBool("shadows"); }

	//! The shadow color. Anything but black is not physically accurate.
 	//! [UI Guides] overridenBy=shadowColor_tex
 	//! [Default value] Color(0, 0, 0)
	bool set_shadowColor(const Color& color) { return setValue("shadowColor", color); }
	//! The shadow color. Anything but black is not physically accurate.
 	//! [UI Guides] overridenBy=shadowColor_tex
 	//! [Default value] Color(0, 0, 0)
	Color get_shadowColor() const { return getColor("shadowColor"); }

	//! A color texture that if present will override the shadowColor parameter
 	//! [UI Guides] overrides=shadowColor
 	bool set_shadowColor_tex(const Plugin& texture) { return setValue("shadowColor_tex", texture); }
	//! A color texture that if present will override the shadowColor parameter
 	//! [UI Guides] overrides=shadowColor
 	bool set_shadowColor_tex(const AColor& texture) { return setValue("shadowColor_tex", texture); }
	//! A color texture that if present will override the shadowColor parameter
 	//! [UI Guides] overrides=shadowColor
 	Value get_shadowColor_tex() const { return getValue("shadowColor_tex"); }

	//! Shadow offset from the surface. Helps to prevent polygonal shadow artifacts on low-poly surfaces.
 	//! [UI Guides] displayName=Shadow bias, quantityType=distance
 	//! [Default value] 0
	bool set_shadowBias(float val) { return setValue("shadowBias", val); }
	//! Shadow offset from the surface. Helps to prevent polygonal shadow artifacts on low-poly surfaces.
 	//! [UI Guides] displayName=Shadow bias, quantityType=distance
 	//! [Default value] 0
	float get_shadowBias() const { return getFloat("shadowBias"); }

	//! Determines the number of photons emitted by this light when calculating the Global Photon Map. 1000 subdivs equal 1 million photons.
 	//! [UI Guides] displayName=Photon subdivs, minValue=0
 	//! [Default value] 500
	bool set_photonSubdivs(int val) { return setValue("photonSubdivs", val); }
	//! Determines the number of photons emitted by this light when calculating the Global Photon Map. 1000 subdivs equal 1 million photons.
 	//! [UI Guides] displayName=Photon subdivs, minValue=0
 	//! [Default value] 500
	int get_photonSubdivs() const { return getInt("photonSubdivs"); }

	//! Determines the number of photons emitted by this light when calculating the Caustics Photon Map. 1000 subdivs equal 1 million photons.
 	//! [UI Guides] displayName=Caustics subdivs, minValue=0
 	//! [Default value] 1000
	bool set_causticSubdivs(int val) { return setValue("causticSubdivs", val); }
	//! Determines the number of photons emitted by this light when calculating the Caustics Photon Map. 1000 subdivs equal 1 million photons.
 	//! [UI Guides] displayName=Caustics subdivs, minValue=0
 	//! [Default value] 1000
	int get_causticSubdivs() const { return getInt("causticSubdivs"); }

	//! Multiplier for the diffuse photons.
 	//! [UI Guides] displayName=Diffuse multiplier, minValue=0.0
 	//! [Default value] 1
	bool set_diffuseMult(float val) { return setValue("diffuseMult", val); }
	//! Multiplier for the diffuse photons.
 	//! [UI Guides] displayName=Diffuse multiplier, minValue=0.0
 	//! [Default value] 1
	float get_diffuseMult() const { return getFloat("diffuseMult"); }

	//! Multiplier for the caustics photons.
 	//! [UI Guides] displayName=Caustics multiplier, minValue=0.0
 	//! [Default value] 1
	bool set_causticMult(float val) { return setValue("causticMult", val); }
	//! Multiplier for the caustics photons.
 	//! [UI Guides] displayName=Caustics multiplier, minValue=0.0
 	//! [Default value] 1
	float get_causticMult() const { return getFloat("causticMult"); }

	//! Light cut-off threshold (speed optimization). If the light intensity for a point is below this threshold, the light will not be computed.
 	//! [UI Guides] displayName=Cut-off threshold, minValue=0.0
 	//! [Default value] 0.001
	bool set_cutoffThreshold(float val) { return setValue("cutoffThreshold", val); }
	//! Light cut-off threshold (speed optimization). If the light intensity for a point is below this threshold, the light will not be computed.
 	//! [UI Guides] displayName=Cut-off threshold, minValue=0.0
 	//! [Default value] 0.001
	float get_cutoffThreshold() const { return getFloat("cutoffThreshold"); }

	//! True if the light produces diffuse lighting and false otherwise.
 	//! [UI Guides] displayName=Affect diffuse
 	//! [Default value] true
	bool set_affectDiffuse(bool val) { return setValue("affectDiffuse", val); }
	//! True if the light produces diffuse lighting and false otherwise.
 	//! [UI Guides] displayName=Affect diffuse
 	//! [Default value] true
	bool get_affectDiffuse() const { return getBool("affectDiffuse"); }

	//! True if the light produces specular hilights and false otherwise.
 	//! [UI Guides] displayName=Affect specular
 	//! [Default value] true
	bool set_affectSpecular(bool val) { return setValue("affectSpecular", val); }
	//! True if the light produces specular hilights and false otherwise.
 	//! [UI Guides] displayName=Affect specular
 	//! [Default value] true
	bool get_affectSpecular() const { return getBool("affectSpecular"); }

	//! True if the bumped normal should be used to check if the light direction is below the surface.
 	//! [UI Guides] displayName=Bumped normal check
 	//! [Default value] false
	bool set_bumped_below_surface_check(bool val) { return setValue("bumped_below_surface_check", val); }
	//! True if the bumped normal should be used to check if the light direction is below the surface.
 	//! [UI Guides] displayName=Bumped normal check
 	//! [Default value] false
	bool get_bumped_below_surface_check() const { return getBool("bumped_below_surface_check"); }

	//! Number of parameter samples for motion blur.
 	//! [Default value] 0
	bool set_nsamples(int val) { return setValue("nsamples", val); }
	//! Number of parameter samples for motion blur.
 	//! [Default value] 0
	int get_nsamples() const { return getInt("nsamples"); }

	//! Diffuse contribution for the light.
 	//! [Default value] 1
	bool set_diffuse_contribution(float val) { return setValue("diffuse_contribution", val); }
	//! Diffuse contribution for the light.
 	//! [Default value] 1
	float get_diffuse_contribution() const { return getFloat("diffuse_contribution"); }

	//! Specular contribution for the light.
 	//! [Default value] 1
	bool set_specular_contribution(float val) { return setValue("specular_contribution", val); }
	//! Specular contribution for the light.
 	//! [Default value] 1
	float get_specular_contribution() const { return getFloat("specular_contribution"); }

	//! Render channels the result of this light will be written to
 	bool set_channels(const ValueList& pluginList) { return setValue("channels", pluginList); }
	//! Render channels the result of this light will be written to
 	ValueList get_channels() const { return getValueList("channels"); }

	//! Render channels the raw diffuse result of this light will be written to
 	bool set_channels_raw(const ValueList& pluginList) { return setValue("channels_raw", pluginList); }
	//! Render channels the raw diffuse result of this light will be written to
 	ValueList get_channels_raw() const { return getValueList("channels_raw"); }

	//! Render channels the diffuse result of this light will be written to
 	bool set_channels_diffuse(const ValueList& pluginList) { return setValue("channels_diffuse", pluginList); }
	//! Render channels the diffuse result of this light will be written to
 	ValueList get_channels_diffuse() const { return getValueList("channels_diffuse"); }

	//! Render channels the specular result of this light will be written to
 	bool set_channels_specular(const ValueList& pluginList) { return setValue("channels_specular", pluginList); }
	//! Render channels the specular result of this light will be written to
 	ValueList get_channels_specular() const { return getValueList("channels_specular"); }

	//! true if the light should use the global light level setting
 	//! [Default value] true
	bool set_use_global_light_level(bool val) { return setValue("use_global_light_level", val); }
	//! true if the light should use the global light level setting
 	//! [Default value] true
	bool get_use_global_light_level() const { return getBool("use_global_light_level"); }

	//! Units for the intensity (0 - default, 1 - lumens, 2 - lm/m/m/sr, 3 - watts, 4 - w/m/m/sr)
 	//! [UI Guides] enum=0:Default; 1:Lumens; 2:lm/m/m/sr; 3:Watts; 4:w/m/m/sr
 	//! [Default value] 0
	bool set_units(int val) { return setValue("units", val); }
	//! Units for the intensity (0 - default, 1 - lumens, 2 - lm/m/m/sr, 3 - watts, 4 - w/m/m/sr)
 	//! [UI Guides] enum=0:Default; 1:Lumens; 2:lm/m/m/sr; 3:Watts; 4:w/m/m/sr
 	//! [Default value] 0
	int get_units() const { return getInt("units"); }

	//! Light intensity
 	//! [UI Guides] overridenBy=intensity_tex
 	//! [Default value] 1
	bool set_intensity(float val) { return setValue("intensity", val); }
	//! Light intensity
 	//! [UI Guides] overridenBy=intensity_tex
 	//! [Default value] 1
	float get_intensity() const { return getFloat("intensity"); }

	//! A float texture that if present will override the intensity parameter
 	//! [UI Guides] overrides=intensity
 	bool set_intensity_tex(const Plugin& texturefloat) { return setValue("intensity_tex", texturefloat); }
	//! A float texture that if present will override the intensity parameter
 	//! [UI Guides] overrides=intensity
 	bool set_intensity_tex(float texturefloat) { return setValue("intensity_tex", texturefloat); }
	//! A float texture that if present will override the intensity parameter
 	//! [UI Guides] overrides=intensity
 	Value get_intensity_tex() const { return getValue("intensity_tex"); }

	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	bool set_subdivs(int val) { return setValue("subdivs", val); }
	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	int get_subdivs() const { return getInt("subdivs"); }

	//! When this option is on and GI calculation is set to Irradiance map V-Ray will calculate the effects of this light and store them in the irradiance map. The result is that the irradiance map is computed more slowly but the rendering takes less time. You can also save the irradiance map and reuse it later.
 	//! [UI Guides] displayName=Store with irradiance map
 	//! [Default value] false
	bool set_storeWithIrradianceMap(bool val) { return setValue("storeWithIrradianceMap", val); }
	//! When this option is on and GI calculation is set to Irradiance map V-Ray will calculate the effects of this light and store them in the irradiance map. The result is that the irradiance map is computed more slowly but the rendering takes less time. You can also save the irradiance map and reuse it later.
 	//! [UI Guides] displayName=Store with irradiance map
 	//! [Default value] false
	bool get_storeWithIrradianceMap() const { return getBool("storeWithIrradianceMap"); }

	//! True if the light is NOT directly visible from the camera and false otherwise.
 	//! [Default value] false
	bool set_invisible(bool val) { return setValue("invisible", val); }
	//! True if the light is NOT directly visible from the camera and false otherwise.
 	//! [Default value] false
	bool get_invisible() const { return getBool("invisible"); }

	//! True if the light appears in reflections and false otherwise.
 	//! [UI Guides] displayName=Affect reflections
 	//! [Default value] true
	bool set_affectReflections(bool val) { return setValue("affectReflections", val); }
	//! True if the light appears in reflections and false otherwise.
 	//! [UI Guides] displayName=Affect reflections
 	//! [Default value] true
	bool get_affectReflections() const { return getBool("affectReflections"); }

	//! (description missing)
	//! [Default value] false
	bool set_noDecay(bool val) { return setValue("noDecay", val); }
	//! (description missing)
	//! [Default value] false
	bool get_noDecay() const { return getBool("noDecay"); }

	//! (description missing)
	//! [Default value] 0
	bool set_objectID(int val) { return setValue("objectID", val); }
	//! (description missing)
	//! [Default value] 0
	int get_objectID() const { return getInt("objectID"); }

	//! This parameter is for debugging only. It should always be set to true in user scenes. When set to false, rendering quality is not optimal.
 	//! [UI Guides] displayName=Use multiple importance sampling
 	//! [Default value] true
	bool set_useMIS(bool val) { return setValue("useMIS", val); }
	//! This parameter is for debugging only. It should always be set to true in user scenes. When set to false, rendering quality is not optimal.
 	//! [UI Guides] displayName=Use multiple importance sampling
 	//! [Default value] true
	bool get_useMIS() const { return getBool("useMIS"); }

	//! The radius of the sphere light.
 	//! [UI Guides] quantityType=distance, minValue=0.0
 	//! [Default value] 1
	bool set_radius(float val) { return setValue("radius", val); }
	//! The radius of the sphere light.
 	//! [UI Guides] quantityType=distance, minValue=0.0
 	//! [Default value] 1
	float get_radius() const { return getFloat("radius"); }

	//! Defines the smoothness of the sphere when visible in camera/reflection rays.
 	//! [UI Guides] minValue=3, maxValue=128
 	//! [Default value] 20
	bool set_sphere_segments(int val) { return setValue("sphere_segments", val); }
	//! Defines the smoothness of the sphere when visible in camera/reflection rays.
 	//! [UI Guides] minValue=3, maxValue=128
 	//! [Default value] 20
	int get_sphere_segments() const { return getInt("sphere_segments"); }
};

class LightSpot : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "LightSpot"; }

	//! true if the light is casting light (turned on) and false otherwise; it only makes sense to use this parameter if it is animated, or if another object depends on this node but it must not be rendered
 	//! [Default value] true
	bool set_enabled(bool val) { return setValue("enabled", val); }
	//! true if the light is casting light (turned on) and false otherwise; it only makes sense to use this parameter if it is animated, or if another object depends on this node but it must not be rendered
 	//! [Default value] true
	bool get_enabled() const { return getBool("enabled"); }

	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	bool set_transform(const Transform& transform) { return setValue("transform", transform); }
	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	Transform get_transform() const { return getTransform("transform"); }

	//! Color of the light
 	//! [UI Guides] overridenBy=color_tex
 	//! [Default value] Color(1, 1, 1)
	bool set_color(const Color& color) { return setValue("color", color); }
	//! Color of the light
 	//! [UI Guides] overridenBy=color_tex
 	//! [Default value] Color(1, 1, 1)
	Color get_color() const { return getColor("color"); }

	//! A color texture that if present will override the color parameter
 	//! [UI Guides] overrides=color
 	bool set_color_tex(const Plugin& texture) { return setValue("color_tex", texture); }
	//! A color texture that if present will override the color parameter
 	//! [UI Guides] overrides=color
 	bool set_color_tex(const AColor& texture) { return setValue("color_tex", texture); }
	//! A color texture that if present will override the color parameter
 	//! [UI Guides] overrides=color
 	Value get_color_tex() const { return getValue("color_tex"); }

	//! true if the light casts shadows and false otherwise
 	//! [Default value] true
	bool set_shadows(bool val) { return setValue("shadows", val); }
	//! true if the light casts shadows and false otherwise
 	//! [Default value] true
	bool get_shadows() const { return getBool("shadows"); }

	//! The shadow color. Anything but black is not physically accurate.
 	//! [UI Guides] overridenBy=shadowColor_tex
 	//! [Default value] Color(0, 0, 0)
	bool set_shadowColor(const Color& color) { return setValue("shadowColor", color); }
	//! The shadow color. Anything but black is not physically accurate.
 	//! [UI Guides] overridenBy=shadowColor_tex
 	//! [Default value] Color(0, 0, 0)
	Color get_shadowColor() const { return getColor("shadowColor"); }

	//! A color texture that if present will override the shadowColor parameter
 	//! [UI Guides] overrides=shadowColor
 	bool set_shadowColor_tex(const Plugin& texture) { return setValue("shadowColor_tex", texture); }
	//! A color texture that if present will override the shadowColor parameter
 	//! [UI Guides] overrides=shadowColor
 	bool set_shadowColor_tex(const AColor& texture) { return setValue("shadowColor_tex", texture); }
	//! A color texture that if present will override the shadowColor parameter
 	//! [UI Guides] overrides=shadowColor
 	Value get_shadowColor_tex() const { return getValue("shadowColor_tex"); }

	//! Shadow offset from the surface. Helps to prevent polygonal shadow artifacts on low-poly surfaces.
 	//! [UI Guides] displayName=Shadow bias, quantityType=distance
 	//! [Default value] 0
	bool set_shadowBias(float val) { return setValue("shadowBias", val); }
	//! Shadow offset from the surface. Helps to prevent polygonal shadow artifacts on low-poly surfaces.
 	//! [UI Guides] displayName=Shadow bias, quantityType=distance
 	//! [Default value] 0
	float get_shadowBias() const { return getFloat("shadowBias"); }

	//! Determines the number of photons emitted by this light when calculating the Global Photon Map. 1000 subdivs equal 1 million photons.
 	//! [UI Guides] displayName=Photon subdivs, minValue=0
 	//! [Default value] 500
	bool set_photonSubdivs(int val) { return setValue("photonSubdivs", val); }
	//! Determines the number of photons emitted by this light when calculating the Global Photon Map. 1000 subdivs equal 1 million photons.
 	//! [UI Guides] displayName=Photon subdivs, minValue=0
 	//! [Default value] 500
	int get_photonSubdivs() const { return getInt("photonSubdivs"); }

	//! Determines the number of photons emitted by this light when calculating the Caustics Photon Map. 1000 subdivs equal 1 million photons.
 	//! [UI Guides] displayName=Caustics subdivs, minValue=0
 	//! [Default value] 1000
	bool set_causticSubdivs(int val) { return setValue("causticSubdivs", val); }
	//! Determines the number of photons emitted by this light when calculating the Caustics Photon Map. 1000 subdivs equal 1 million photons.
 	//! [UI Guides] displayName=Caustics subdivs, minValue=0
 	//! [Default value] 1000
	int get_causticSubdivs() const { return getInt("causticSubdivs"); }

	//! Multiplier for the diffuse photons.
 	//! [UI Guides] displayName=Diffuse multiplier, minValue=0.0
 	//! [Default value] 1
	bool set_diffuseMult(float val) { return setValue("diffuseMult", val); }
	//! Multiplier for the diffuse photons.
 	//! [UI Guides] displayName=Diffuse multiplier, minValue=0.0
 	//! [Default value] 1
	float get_diffuseMult() const { return getFloat("diffuseMult"); }

	//! Multiplier for the caustics photons.
 	//! [UI Guides] displayName=Caustics multiplier, minValue=0.0
 	//! [Default value] 1
	bool set_causticMult(float val) { return setValue("causticMult", val); }
	//! Multiplier for the caustics photons.
 	//! [UI Guides] displayName=Caustics multiplier, minValue=0.0
 	//! [Default value] 1
	float get_causticMult() const { return getFloat("causticMult"); }

	//! Light cut-off threshold (speed optimization). If the light intensity for a point is below this threshold, the light will not be computed.
 	//! [UI Guides] displayName=Cut-off threshold, minValue=0.0
 	//! [Default value] 0.001
	bool set_cutoffThreshold(float val) { return setValue("cutoffThreshold", val); }
	//! Light cut-off threshold (speed optimization). If the light intensity for a point is below this threshold, the light will not be computed.
 	//! [UI Guides] displayName=Cut-off threshold, minValue=0.0
 	//! [Default value] 0.001
	float get_cutoffThreshold() const { return getFloat("cutoffThreshold"); }

	//! True if the light produces diffuse lighting and false otherwise.
 	//! [UI Guides] displayName=Affect diffuse
 	//! [Default value] true
	bool set_affectDiffuse(bool val) { return setValue("affectDiffuse", val); }
	//! True if the light produces diffuse lighting and false otherwise.
 	//! [UI Guides] displayName=Affect diffuse
 	//! [Default value] true
	bool get_affectDiffuse() const { return getBool("affectDiffuse"); }

	//! True if the light produces specular hilights and false otherwise.
 	//! [UI Guides] displayName=Affect specular
 	//! [Default value] true
	bool set_affectSpecular(bool val) { return setValue("affectSpecular", val); }
	//! True if the light produces specular hilights and false otherwise.
 	//! [UI Guides] displayName=Affect specular
 	//! [Default value] true
	bool get_affectSpecular() const { return getBool("affectSpecular"); }

	//! True if the bumped normal should be used to check if the light direction is below the surface.
 	//! [UI Guides] displayName=Bumped normal check
 	//! [Default value] false
	bool set_bumped_below_surface_check(bool val) { return setValue("bumped_below_surface_check", val); }
	//! True if the bumped normal should be used to check if the light direction is below the surface.
 	//! [UI Guides] displayName=Bumped normal check
 	//! [Default value] false
	bool get_bumped_below_surface_check() const { return getBool("bumped_below_surface_check"); }

	//! Number of parameter samples for motion blur.
 	//! [Default value] 0
	bool set_nsamples(int val) { return setValue("nsamples", val); }
	//! Number of parameter samples for motion blur.
 	//! [Default value] 0
	int get_nsamples() const { return getInt("nsamples"); }

	//! Diffuse contribution for the light.
 	//! [Default value] 1
	bool set_diffuse_contribution(float val) { return setValue("diffuse_contribution", val); }
	//! Diffuse contribution for the light.
 	//! [Default value] 1
	float get_diffuse_contribution() const { return getFloat("diffuse_contribution"); }

	//! Specular contribution for the light.
 	//! [Default value] 1
	bool set_specular_contribution(float val) { return setValue("specular_contribution", val); }
	//! Specular contribution for the light.
 	//! [Default value] 1
	float get_specular_contribution() const { return getFloat("specular_contribution"); }

	//! Render channels the result of this light will be written to
 	bool set_channels(const ValueList& pluginList) { return setValue("channels", pluginList); }
	//! Render channels the result of this light will be written to
 	ValueList get_channels() const { return getValueList("channels"); }

	//! Render channels the raw diffuse result of this light will be written to
 	bool set_channels_raw(const ValueList& pluginList) { return setValue("channels_raw", pluginList); }
	//! Render channels the raw diffuse result of this light will be written to
 	ValueList get_channels_raw() const { return getValueList("channels_raw"); }

	//! Render channels the diffuse result of this light will be written to
 	bool set_channels_diffuse(const ValueList& pluginList) { return setValue("channels_diffuse", pluginList); }
	//! Render channels the diffuse result of this light will be written to
 	ValueList get_channels_diffuse() const { return getValueList("channels_diffuse"); }

	//! Render channels the specular result of this light will be written to
 	bool set_channels_specular(const ValueList& pluginList) { return setValue("channels_specular", pluginList); }
	//! Render channels the specular result of this light will be written to
 	ValueList get_channels_specular() const { return getValueList("channels_specular"); }

	//! true if the light should use the global light level setting
 	//! [Default value] true
	bool set_use_global_light_level(bool val) { return setValue("use_global_light_level", val); }
	//! true if the light should use the global light level setting
 	//! [Default value] true
	bool get_use_global_light_level() const { return getBool("use_global_light_level"); }

	//! Units for the intensity (0 - default, 1 - lumens, 2 - lm/m/m/sr, 3 - watts, 4 - w/m/m/sr)
 	//! [UI Guides] enum=0:Default; 1:Lumens; 2:lm/m/m/sr; 3:Watts; 4:w/m/m/sr
 	//! [Default value] 0
	bool set_units(int val) { return setValue("units", val); }
	//! Units for the intensity (0 - default, 1 - lumens, 2 - lm/m/m/sr, 3 - watts, 4 - w/m/m/sr)
 	//! [UI Guides] enum=0:Default; 1:Lumens; 2:lm/m/m/sr; 3:Watts; 4:w/m/m/sr
 	//! [Default value] 0
	int get_units() const { return getInt("units"); }

	//! Light intensity
 	//! [UI Guides] overridenBy=intensity_tex
 	//! [Default value] 1
	bool set_intensity(float val) { return setValue("intensity", val); }
	//! Light intensity
 	//! [UI Guides] overridenBy=intensity_tex
 	//! [Default value] 1
	float get_intensity() const { return getFloat("intensity"); }

	//! A float texture that if present will override the intensity parameter
 	//! [UI Guides] overrides=intensity
 	bool set_intensity_tex(const Plugin& texturefloat) { return setValue("intensity_tex", texturefloat); }
	//! A float texture that if present will override the intensity parameter
 	//! [UI Guides] overrides=intensity
 	bool set_intensity_tex(float texturefloat) { return setValue("intensity_tex", texturefloat); }
	//! A float texture that if present will override the intensity parameter
 	//! [UI Guides] overrides=intensity
 	Value get_intensity_tex() const { return getValue("intensity_tex"); }

	//! The size of the light; 0.0 is a point light, larger values produces soft (area) shadows
 	//! [UI Guides] quantityType=distance, overridenBy=shadowRadius_tex
 	//! [Default value] 0
	bool set_shadowRadius(float val) { return setValue("shadowRadius", val); }
	//! The size of the light; 0.0 is a point light, larger values produces soft (area) shadows
 	//! [UI Guides] quantityType=distance, overridenBy=shadowRadius_tex
 	//! [Default value] 0
	float get_shadowRadius() const { return getFloat("shadowRadius"); }

	//! A float texture that if present will override the shadows radius parameter
 	//! [UI Guides] overrides=shadowRadius
 	bool set_shadowRadius_tex(const Plugin& texturefloat) { return setValue("shadowRadius_tex", texturefloat); }
	//! A float texture that if present will override the shadows radius parameter
 	//! [UI Guides] overrides=shadowRadius
 	bool set_shadowRadius_tex(float texturefloat) { return setValue("shadowRadius_tex", texturefloat); }
	//! A float texture that if present will override the shadows radius parameter
 	//! [UI Guides] overrides=shadowRadius
 	Value get_shadowRadius_tex() const { return getValue("shadowRadius_tex"); }

	//! If true, the hilights will match the shape of the light; if false, hilights will always be calculated as from a point light
 	//! [Default value] false
	bool set_areaSpeculars(bool val) { return setValue("areaSpeculars", val); }
	//! If true, the hilights will match the shape of the light; if false, hilights will always be calculated as from a point light
 	//! [Default value] false
	bool get_areaSpeculars() const { return getBool("areaSpeculars"); }

	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	bool set_shadowSubdivs(int val) { return setValue("shadowSubdivs", val); }
	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	int get_shadowSubdivs() const { return getInt("shadowSubdivs"); }

	//! When this option is on and GI calculation is set to Irradiance map V-Ray will calculate the effects of this light and store them in the irradiance map. The result is that the irradiance map is computed more slowly but the rendering takes less time. You can also save the irradiance map and reuse it later.
 	//! [UI Guides] displayName=Store with irradiance map
 	//! [Default value] false
	bool set_storeWithIrradianceMap(bool val) { return setValue("storeWithIrradianceMap", val); }
	//! When this option is on and GI calculation is set to Irradiance map V-Ray will calculate the effects of this light and store them in the irradiance map. The result is that the irradiance map is computed more slowly but the rendering takes less time. You can also save the irradiance map and reuse it later.
 	//! [UI Guides] displayName=Store with irradiance map
 	//! [Default value] false
	bool get_storeWithIrradianceMap() const { return getBool("storeWithIrradianceMap"); }

	//! The entire spot cone, in radians
 	//! [UI Guides] units=radians
 	//! [Default value] 1
	bool set_coneAngle(float val) { return setValue("coneAngle", val); }
	//! The entire spot cone, in radians
 	//! [UI Guides] units=radians
 	//! [Default value] 1
	float get_coneAngle() const { return getFloat("coneAngle"); }

	//! The penumbra region, in radians; positive is outside the spot cone; negative is inside
 	//! [UI Guides] units=radians
 	//! [Default value] 0
	bool set_penumbraAngle(float val) { return setValue("penumbraAngle", val); }
	//! The penumbra region, in radians; positive is outside the spot cone; negative is inside
 	//! [UI Guides] units=radians
 	//! [Default value] 0
	float get_penumbraAngle() const { return getFloat("penumbraAngle"); }

	//! The dropOff attribute
 	//! [Default value] 0
	bool set_dropOff(float val) { return setValue("dropOff", val); }
	//! The dropOff attribute
 	//! [Default value] 0
	float get_dropOff() const { return getFloat("dropOff"); }

	//! The type of transition in the penumbra region; 0 - linear; 1 - smooth cubic
 	//! [UI Guides] enum=0:Linear; 1:Smooth cubic
 	//! [Default value] 0
	bool set_falloffType(int val) { return setValue("falloffType", val); }
	//! The type of transition in the penumbra region; 0 - linear; 1 - smooth cubic
 	//! [UI Guides] enum=0:Linear; 1:Smooth cubic
 	//! [Default value] 0
	int get_falloffType() const { return getInt("falloffType"); }

	//! (description missing)
	//! [Default value] 2
	bool set_decay(float val) { return setValue("decay", val); }
	//! (description missing)
	//! [Default value] 2
	float get_decay() const { return getFloat("decay"); }

	//! true to produce a barn door effect.
 	//! [Default value] false
	bool set_barnDoor(bool val) { return setValue("barnDoor", val); }
	//! true to produce a barn door effect.
 	//! [Default value] false
	bool get_barnDoor() const { return getBool("barnDoor"); }

	//! angle between the light direction and the left barn door
 	//! [UI Guides] units=radians
 	//! [Default value] 0.349066
	bool set_barnDoorLeft(float val) { return setValue("barnDoorLeft", val); }
	//! angle between the light direction and the left barn door
 	//! [UI Guides] units=radians
 	//! [Default value] 0.349066
	float get_barnDoorLeft() const { return getFloat("barnDoorLeft"); }

	//! angle between the light direction and the right barn door
 	//! [UI Guides] units=radians
 	//! [Default value] 0.349066
	bool set_barnDoorRight(float val) { return setValue("barnDoorRight", val); }
	//! angle between the light direction and the right barn door
 	//! [UI Guides] units=radians
 	//! [Default value] 0.349066
	float get_barnDoorRight() const { return getFloat("barnDoorRight"); }

	//! angle between the light direction and the top barn door
 	//! [UI Guides] units=radians
 	//! [Default value] 0.349066
	bool set_barnDoorTop(float val) { return setValue("barnDoorTop", val); }
	//! angle between the light direction and the top barn door
 	//! [UI Guides] units=radians
 	//! [Default value] 0.349066
	float get_barnDoorTop() const { return getFloat("barnDoorTop"); }

	//! angle between the light direction and the bottom barn door
 	//! [UI Guides] units=radians
 	//! [Default value] 0.349066
	bool set_barnDoorBottom(float val) { return setValue("barnDoorBottom", val); }
	//! angle between the light direction and the bottom barn door
 	//! [UI Guides] units=radians
 	//! [Default value] 0.349066
	float get_barnDoorBottom() const { return getFloat("barnDoorBottom"); }

	//! True to use decay regions.
 	//! [Default value] false
	bool set_useDecayRegions(bool val) { return setValue("useDecayRegions", val); }
	//! True to use decay regions.
 	//! [Default value] false
	bool get_useDecayRegions() const { return getBool("useDecayRegions"); }

	//! Start of first decay region
 	//! [UI Guides] quantityType=distance
 	//! [Default value] 1
	bool set_startDistance1(float val) { return setValue("startDistance1", val); }
	//! Start of first decay region
 	//! [UI Guides] quantityType=distance
 	//! [Default value] 1
	float get_startDistance1() const { return getFloat("startDistance1"); }

	//! End of first decay region
 	//! [UI Guides] quantityType=distance
 	//! [Default value] 2
	bool set_endDistance1(float val) { return setValue("endDistance1", val); }
	//! End of first decay region
 	//! [UI Guides] quantityType=distance
 	//! [Default value] 2
	float get_endDistance1() const { return getFloat("endDistance1"); }

	//! Start of second decay region
 	//! [UI Guides] quantityType=distance
 	//! [Default value] 3
	bool set_startDistance2(float val) { return setValue("startDistance2", val); }
	//! Start of second decay region
 	//! [UI Guides] quantityType=distance
 	//! [Default value] 3
	float get_startDistance2() const { return getFloat("startDistance2"); }

	//! End of second decay region
 	//! [UI Guides] quantityType=distance
 	//! [Default value] 6
	bool set_endDistance2(float val) { return setValue("endDistance2", val); }
	//! End of second decay region
 	//! [UI Guides] quantityType=distance
 	//! [Default value] 6
	float get_endDistance2() const { return getFloat("endDistance2"); }

	//! Start of third decay region
 	//! [UI Guides] quantityType=distance
 	//! [Default value] 8
	bool set_startDistance3(float val) { return setValue("startDistance3", val); }
	//! Start of third decay region
 	//! [UI Guides] quantityType=distance
 	//! [Default value] 8
	float get_startDistance3() const { return getFloat("startDistance3"); }

	//! End of third decay region
 	//! [UI Guides] quantityType=distance
 	//! [Default value] 10
	bool set_endDistance3(float val) { return setValue("endDistance3", val); }
	//! End of third decay region
 	//! [UI Guides] quantityType=distance
 	//! [Default value] 10
	float get_endDistance3() const { return getFloat("endDistance3"); }
};

class LightSpotMax : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "LightSpotMax"; }

	//! true if the light is casting light (turned on) and false otherwise; it only makes sense to use this parameter if it is animated, or if another object depends on this node but it must not be rendered
 	//! [Default value] true
	bool set_enabled(bool val) { return setValue("enabled", val); }
	//! true if the light is casting light (turned on) and false otherwise; it only makes sense to use this parameter if it is animated, or if another object depends on this node but it must not be rendered
 	//! [Default value] true
	bool get_enabled() const { return getBool("enabled"); }

	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	bool set_transform(const Transform& transform) { return setValue("transform", transform); }
	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	Transform get_transform() const { return getTransform("transform"); }

	//! Color of the light
 	//! [UI Guides] overridenBy=color_tex
 	//! [Default value] Color(1, 1, 1)
	bool set_color(const Color& color) { return setValue("color", color); }
	//! Color of the light
 	//! [UI Guides] overridenBy=color_tex
 	//! [Default value] Color(1, 1, 1)
	Color get_color() const { return getColor("color"); }

	//! A color texture that if present will override the color parameter
 	//! [UI Guides] overrides=color
 	bool set_color_tex(const Plugin& texture) { return setValue("color_tex", texture); }
	//! A color texture that if present will override the color parameter
 	//! [UI Guides] overrides=color
 	bool set_color_tex(const AColor& texture) { return setValue("color_tex", texture); }
	//! A color texture that if present will override the color parameter
 	//! [UI Guides] overrides=color
 	Value get_color_tex() const { return getValue("color_tex"); }

	//! true if the light casts shadows and false otherwise
 	//! [Default value] true
	bool set_shadows(bool val) { return setValue("shadows", val); }
	//! true if the light casts shadows and false otherwise
 	//! [Default value] true
	bool get_shadows() const { return getBool("shadows"); }

	//! The shadow color. Anything but black is not physically accurate.
 	//! [UI Guides] overridenBy=shadowColor_tex
 	//! [Default value] Color(0, 0, 0)
	bool set_shadowColor(const Color& color) { return setValue("shadowColor", color); }
	//! The shadow color. Anything but black is not physically accurate.
 	//! [UI Guides] overridenBy=shadowColor_tex
 	//! [Default value] Color(0, 0, 0)
	Color get_shadowColor() const { return getColor("shadowColor"); }

	//! A color texture that if present will override the shadowColor parameter
 	//! [UI Guides] overrides=shadowColor
 	bool set_shadowColor_tex(const Plugin& texture) { return setValue("shadowColor_tex", texture); }
	//! A color texture that if present will override the shadowColor parameter
 	//! [UI Guides] overrides=shadowColor
 	bool set_shadowColor_tex(const AColor& texture) { return setValue("shadowColor_tex", texture); }
	//! A color texture that if present will override the shadowColor parameter
 	//! [UI Guides] overrides=shadowColor
 	Value get_shadowColor_tex() const { return getValue("shadowColor_tex"); }

	//! Shadow offset from the surface. Helps to prevent polygonal shadow artifacts on low-poly surfaces.
 	//! [UI Guides] displayName=Shadow bias, quantityType=distance
 	//! [Default value] 0
	bool set_shadowBias(float val) { return setValue("shadowBias", val); }
	//! Shadow offset from the surface. Helps to prevent polygonal shadow artifacts on low-poly surfaces.
 	//! [UI Guides] displayName=Shadow bias, quantityType=distance
 	//! [Default value] 0
	float get_shadowBias() const { return getFloat("shadowBias"); }

	//! Determines the number of photons emitted by this light when calculating the Global Photon Map. 1000 subdivs equal 1 million photons.
 	//! [UI Guides] displayName=Photon subdivs, minValue=0
 	//! [Default value] 500
	bool set_photonSubdivs(int val) { return setValue("photonSubdivs", val); }
	//! Determines the number of photons emitted by this light when calculating the Global Photon Map. 1000 subdivs equal 1 million photons.
 	//! [UI Guides] displayName=Photon subdivs, minValue=0
 	//! [Default value] 500
	int get_photonSubdivs() const { return getInt("photonSubdivs"); }

	//! Determines the number of photons emitted by this light when calculating the Caustics Photon Map. 1000 subdivs equal 1 million photons.
 	//! [UI Guides] displayName=Caustics subdivs, minValue=0
 	//! [Default value] 1000
	bool set_causticSubdivs(int val) { return setValue("causticSubdivs", val); }
	//! Determines the number of photons emitted by this light when calculating the Caustics Photon Map. 1000 subdivs equal 1 million photons.
 	//! [UI Guides] displayName=Caustics subdivs, minValue=0
 	//! [Default value] 1000
	int get_causticSubdivs() const { return getInt("causticSubdivs"); }

	//! Multiplier for the diffuse photons.
 	//! [UI Guides] displayName=Diffuse multiplier, minValue=0.0
 	//! [Default value] 1
	bool set_diffuseMult(float val) { return setValue("diffuseMult", val); }
	//! Multiplier for the diffuse photons.
 	//! [UI Guides] displayName=Diffuse multiplier, minValue=0.0
 	//! [Default value] 1
	float get_diffuseMult() const { return getFloat("diffuseMult"); }

	//! Multiplier for the caustics photons.
 	//! [UI Guides] displayName=Caustics multiplier, minValue=0.0
 	//! [Default value] 1
	bool set_causticMult(float val) { return setValue("causticMult", val); }
	//! Multiplier for the caustics photons.
 	//! [UI Guides] displayName=Caustics multiplier, minValue=0.0
 	//! [Default value] 1
	float get_causticMult() const { return getFloat("causticMult"); }

	//! Light cut-off threshold (speed optimization). If the light intensity for a point is below this threshold, the light will not be computed.
 	//! [UI Guides] displayName=Cut-off threshold, minValue=0.0
 	//! [Default value] 0.001
	bool set_cutoffThreshold(float val) { return setValue("cutoffThreshold", val); }
	//! Light cut-off threshold (speed optimization). If the light intensity for a point is below this threshold, the light will not be computed.
 	//! [UI Guides] displayName=Cut-off threshold, minValue=0.0
 	//! [Default value] 0.001
	float get_cutoffThreshold() const { return getFloat("cutoffThreshold"); }

	//! True if the light produces diffuse lighting and false otherwise.
 	//! [UI Guides] displayName=Affect diffuse
 	//! [Default value] true
	bool set_affectDiffuse(bool val) { return setValue("affectDiffuse", val); }
	//! True if the light produces diffuse lighting and false otherwise.
 	//! [UI Guides] displayName=Affect diffuse
 	//! [Default value] true
	bool get_affectDiffuse() const { return getBool("affectDiffuse"); }

	//! True if the light produces specular hilights and false otherwise.
 	//! [UI Guides] displayName=Affect specular
 	//! [Default value] true
	bool set_affectSpecular(bool val) { return setValue("affectSpecular", val); }
	//! True if the light produces specular hilights and false otherwise.
 	//! [UI Guides] displayName=Affect specular
 	//! [Default value] true
	bool get_affectSpecular() const { return getBool("affectSpecular"); }

	//! True if the bumped normal should be used to check if the light direction is below the surface.
 	//! [UI Guides] displayName=Bumped normal check
 	//! [Default value] false
	bool set_bumped_below_surface_check(bool val) { return setValue("bumped_below_surface_check", val); }
	//! True if the bumped normal should be used to check if the light direction is below the surface.
 	//! [UI Guides] displayName=Bumped normal check
 	//! [Default value] false
	bool get_bumped_below_surface_check() const { return getBool("bumped_below_surface_check"); }

	//! Number of parameter samples for motion blur.
 	//! [Default value] 0
	bool set_nsamples(int val) { return setValue("nsamples", val); }
	//! Number of parameter samples for motion blur.
 	//! [Default value] 0
	int get_nsamples() const { return getInt("nsamples"); }

	//! Diffuse contribution for the light.
 	//! [Default value] 1
	bool set_diffuse_contribution(float val) { return setValue("diffuse_contribution", val); }
	//! Diffuse contribution for the light.
 	//! [Default value] 1
	float get_diffuse_contribution() const { return getFloat("diffuse_contribution"); }

	//! Specular contribution for the light.
 	//! [Default value] 1
	bool set_specular_contribution(float val) { return setValue("specular_contribution", val); }
	//! Specular contribution for the light.
 	//! [Default value] 1
	float get_specular_contribution() const { return getFloat("specular_contribution"); }

	//! Render channels the result of this light will be written to
 	bool set_channels(const ValueList& pluginList) { return setValue("channels", pluginList); }
	//! Render channels the result of this light will be written to
 	ValueList get_channels() const { return getValueList("channels"); }

	//! Render channels the raw diffuse result of this light will be written to
 	bool set_channels_raw(const ValueList& pluginList) { return setValue("channels_raw", pluginList); }
	//! Render channels the raw diffuse result of this light will be written to
 	ValueList get_channels_raw() const { return getValueList("channels_raw"); }

	//! Render channels the diffuse result of this light will be written to
 	bool set_channels_diffuse(const ValueList& pluginList) { return setValue("channels_diffuse", pluginList); }
	//! Render channels the diffuse result of this light will be written to
 	ValueList get_channels_diffuse() const { return getValueList("channels_diffuse"); }

	//! Render channels the specular result of this light will be written to
 	bool set_channels_specular(const ValueList& pluginList) { return setValue("channels_specular", pluginList); }
	//! Render channels the specular result of this light will be written to
 	ValueList get_channels_specular() const { return getValueList("channels_specular"); }

	//! true if the light should use the global light level setting
 	//! [Default value] true
	bool set_use_global_light_level(bool val) { return setValue("use_global_light_level", val); }
	//! true if the light should use the global light level setting
 	//! [Default value] true
	bool get_use_global_light_level() const { return getBool("use_global_light_level"); }

	//! Units for the intensity (0 - default, 1 - lumens, 2 - lm/m/m/sr, 3 - watts, 4 - w/m/m/sr)
 	//! [UI Guides] enum=0:Default; 1:Lumens; 2:lm/m/m/sr; 3:Watts; 4:w/m/m/sr
 	//! [Default value] 0
	bool set_units(int val) { return setValue("units", val); }
	//! Units for the intensity (0 - default, 1 - lumens, 2 - lm/m/m/sr, 3 - watts, 4 - w/m/m/sr)
 	//! [UI Guides] enum=0:Default; 1:Lumens; 2:lm/m/m/sr; 3:Watts; 4:w/m/m/sr
 	//! [Default value] 0
	int get_units() const { return getInt("units"); }

	//! Light intensity
 	//! [UI Guides] overridenBy=intensity_tex
 	//! [Default value] 1
	bool set_intensity(float val) { return setValue("intensity", val); }
	//! Light intensity
 	//! [UI Guides] overridenBy=intensity_tex
 	//! [Default value] 1
	float get_intensity() const { return getFloat("intensity"); }

	//! A float texture that if present will override the intensity parameter
 	//! [UI Guides] overrides=intensity
 	bool set_intensity_tex(const Plugin& texturefloat) { return setValue("intensity_tex", texturefloat); }
	//! A float texture that if present will override the intensity parameter
 	//! [UI Guides] overrides=intensity
 	bool set_intensity_tex(float texturefloat) { return setValue("intensity_tex", texturefloat); }
	//! A float texture that if present will override the intensity parameter
 	//! [UI Guides] overrides=intensity
 	Value get_intensity_tex() const { return getValue("intensity_tex"); }

	//! The size of the light; 0.0 is a point light, larger values produces soft (area) shadows
 	//! [UI Guides] quantityType=distance, overridenBy=shadowRadius_tex
 	//! [Default value] 0
	bool set_shadowRadius(float val) { return setValue("shadowRadius", val); }
	//! The size of the light; 0.0 is a point light, larger values produces soft (area) shadows
 	//! [UI Guides] quantityType=distance, overridenBy=shadowRadius_tex
 	//! [Default value] 0
	float get_shadowRadius() const { return getFloat("shadowRadius"); }

	//! A float texture that if present will override the shadows radius parameter
 	//! [UI Guides] overrides=shadowRadius
 	bool set_shadowRadius_tex(const Plugin& texturefloat) { return setValue("shadowRadius_tex", texturefloat); }
	//! A float texture that if present will override the shadows radius parameter
 	//! [UI Guides] overrides=shadowRadius
 	bool set_shadowRadius_tex(float texturefloat) { return setValue("shadowRadius_tex", texturefloat); }
	//! A float texture that if present will override the shadows radius parameter
 	//! [UI Guides] overrides=shadowRadius
 	Value get_shadowRadius_tex() const { return getValue("shadowRadius_tex"); }

	//! If true, the hilights will match the shape of the light; if false, hilights will always be calculated as from a point light
 	//! [Default value] false
	bool set_areaSpeculars(bool val) { return setValue("areaSpeculars", val); }
	//! If true, the hilights will match the shape of the light; if false, hilights will always be calculated as from a point light
 	//! [Default value] false
	bool get_areaSpeculars() const { return getBool("areaSpeculars"); }

	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	bool set_shadowSubdivs(int val) { return setValue("shadowSubdivs", val); }
	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	int get_shadowSubdivs() const { return getInt("shadowSubdivs"); }

	//! When this option is on and GI calculation is set to Irradiance map V-Ray will calculate the effects of this light and store them in the irradiance map. The result is that the irradiance map is computed more slowly but the rendering takes less time. You can also save the irradiance map and reuse it later.
 	//! [UI Guides] displayName=Store with irradiance map
 	//! [Default value] false
	bool set_storeWithIrradianceMap(bool val) { return setValue("storeWithIrradianceMap", val); }
	//! When this option is on and GI calculation is set to Irradiance map V-Ray will calculate the effects of this light and store them in the irradiance map. The result is that the irradiance map is computed more slowly but the rendering takes less time. You can also save the irradiance map and reuse it later.
 	//! [UI Guides] displayName=Store with irradiance map
 	//! [Default value] false
	bool get_storeWithIrradianceMap() const { return getBool("storeWithIrradianceMap"); }

	//! (description missing)
	bool set_projector_map(const Plugin& texture) { return setValue("projector_map", texture); }
	//! (description missing)
	bool set_projector_map(const AColor& texture) { return setValue("projector_map", texture); }
	//! (description missing)
	Value get_projector_map() const { return getValue("projector_map"); }

	//! Decay type (0 - no decay, 1 - linear, 2 - square)
 	//! [UI Guides] enum=0:No decay; 1:Linear; 2:Square
 	//! [Default value] 0
	bool set_decay_type(int val) { return setValue("decay_type", val); }
	//! Decay type (0 - no decay, 1 - linear, 2 - square)
 	//! [UI Guides] enum=0:No decay; 1:Linear; 2:Square
 	//! [Default value] 0
	int get_decay_type() const { return getInt("decay_type"); }

	//! (description missing)
	//! [Default value] 1
	bool set_decay_start(float val) { return setValue("decay_start", val); }
	//! (description missing)
	//! [Default value] 1
	float get_decay_start() const { return getFloat("decay_start"); }

	//! true to use near attenuation
 	//! [Default value] false
	bool set_near_attenuation(bool val) { return setValue("near_attenuation", val); }
	//! true to use near attenuation
 	//! [Default value] false
	bool get_near_attenuation() const { return getBool("near_attenuation"); }

	//! Near attenuation start
 	//! [Default value] 0
	bool set_near_attenuation_start(float val) { return setValue("near_attenuation_start", val); }
	//! Near attenuation start
 	//! [Default value] 0
	float get_near_attenuation_start() const { return getFloat("near_attenuation_start"); }

	//! Near attenuation end
 	//! [Default value] 0
	bool set_near_attenuation_end(float val) { return setValue("near_attenuation_end", val); }
	//! Near attenuation end
 	//! [Default value] 0
	float get_near_attenuation_end() const { return getFloat("near_attenuation_end"); }

	//! true to use far attenuation
 	//! [Default value] false
	bool set_far_attenuation(bool val) { return setValue("far_attenuation", val); }
	//! true to use far attenuation
 	//! [Default value] false
	bool get_far_attenuation() const { return getBool("far_attenuation"); }

	//! far attenuation start
 	//! [Default value] 0
	bool set_far_attenuation_start(float val) { return setValue("far_attenuation_start", val); }
	//! far attenuation start
 	//! [Default value] 0
	float get_far_attenuation_start() const { return getFloat("far_attenuation_start"); }

	//! far attenuation end
 	//! [Default value] 0
	bool set_far_attenuation_end(float val) { return setValue("far_attenuation_end", val); }
	//! far attenuation end
 	//! [Default value] 0
	float get_far_attenuation_end() const { return getFloat("far_attenuation_end"); }

	//! Shape for soft shadows (0 - box, 1 - sphere)
 	//! [UI Guides] enum=0:Box; 1:Sphere
 	//! [Default value] 0
	bool set_shadowShape(int val) { return setValue("shadowShape", val); }
	//! Shape for soft shadows (0 - box, 1 - sphere)
 	//! [UI Guides] enum=0:Box; 1:Sphere
 	//! [Default value] 0
	int get_shadowShape() const { return getInt("shadowShape"); }

	//! V-size for box shadows
 	//! [Default value] 0
	bool set_shadowRadius1(float val) { return setValue("shadowRadius1", val); }
	//! V-size for box shadows
 	//! [Default value] 0
	float get_shadowRadius1() const { return getFloat("shadowRadius1"); }

	//! W-size for box shadows
 	//! [Default value] 0
	bool set_shadowRadius2(float val) { return setValue("shadowRadius2", val); }
	//! W-size for box shadows
 	//! [Default value] 0
	float get_shadowRadius2() const { return getFloat("shadowRadius2"); }

	//! The entire spot cone, in radians
 	//! [UI Guides] minValue=0, maxValue=3.14159265359
 	//! [Default value] 1
	bool set_fallsize(float val) { return setValue("fallsize", val); }
	//! The entire spot cone, in radians
 	//! [UI Guides] minValue=0, maxValue=3.14159265359
 	//! [Default value] 1
	float get_fallsize() const { return getFloat("fallsize"); }

	//! The hotspot, in radians
 	//! [UI Guides] minValue=0, maxValue=3.14159265359
 	//! [Default value] 0
	bool set_hotspot(float val) { return setValue("hotspot", val); }
	//! The hotspot, in radians
 	//! [UI Guides] minValue=0, maxValue=3.14159265359
 	//! [Default value] 0
	float get_hotspot() const { return getFloat("hotspot"); }

	//! The shape of the beam (0 - circular, 1 - rectangular, 2 - smooth rectangular)
 	//! [UI Guides] enum=0:Circular; 1:Rectangular; 2:Smooth rectangular
 	//! [Default value] 0
	bool set_shape_type(int val) { return setValue("shape_type", val); }
	//! The shape of the beam (0 - circular, 1 - rectangular, 2 - smooth rectangular)
 	//! [UI Guides] enum=0:Circular; 1:Rectangular; 2:Smooth rectangular
 	//! [Default value] 0
	int get_shape_type() const { return getInt("shape_type"); }

	//! Aspect for the rectangle shape
 	//! [Default value] 1
	bool set_rect_aspect(float val) { return setValue("rect_aspect", val); }
	//! Aspect for the rectangle shape
 	//! [Default value] 1
	float get_rect_aspect() const { return getFloat("rect_aspect"); }

	//! true if the light is not limited in the beam
 	//! [Default value] false
	bool set_overshoot(bool val) { return setValue("overshoot", val); }
	//! true if the light is not limited in the beam
 	//! [Default value] false
	bool get_overshoot() const { return getBool("overshoot"); }
};

class MayaGamma : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "MayaGamma"; }

	//! The input color
 	bool set_input(const Plugin& texture) { return setValue("input", texture); }
	//! The input color
 	bool set_input(const AColor& texture) { return setValue("input", texture); }
	//! The input color
 	Value get_input() const { return getValue("input"); }

	//! Gamma values
 	bool set_gamma(const Plugin& texture) { return setValue("gamma", texture); }
	//! Gamma values
 	bool set_gamma(const AColor& texture) { return setValue("gamma", texture); }
	//! Gamma values
 	Value get_gamma() const { return getValue("gamma"); }
};

class MayaLightDirect : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "MayaLightDirect"; }

	//! Color of the light
 	//! [Default value] Color(1, 1, 1)
	bool set_color(const Color& color) { return setValue("color", color); }
	//! Color of the light
 	//! [Default value] Color(1, 1, 1)
	Color get_color() const { return getColor("color"); }

	//! A color texture that if present will override the color parameter
 	bool set_color_tex(const Plugin& texture) { return setValue("color_tex", texture); }
	//! A color texture that if present will override the color parameter
 	bool set_color_tex(const AColor& texture) { return setValue("color_tex", texture); }
	//! A color texture that if present will override the color parameter
 	Value get_color_tex() const { return getValue("color_tex"); }

	//! Light intensity
 	//! [Default value] 1
	bool set_intensity(float val) { return setValue("intensity", val); }
	//! Light intensity
 	//! [Default value] 1
	float get_intensity() const { return getFloat("intensity"); }

	//! A float texture that if present will override the intensity parameter
 	bool set_intensity_tex(const Plugin& texturefloat) { return setValue("intensity_tex", texturefloat); }
	//! A float texture that if present will override the intensity parameter
 	bool set_intensity_tex(float texturefloat) { return setValue("intensity_tex", texturefloat); }
	//! A float texture that if present will override the intensity parameter
 	Value get_intensity_tex() const { return getValue("intensity_tex"); }

	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	bool set_transform(const Transform& transform) { return setValue("transform", transform); }
	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	Transform get_transform() const { return getTransform("transform"); }

	//! Shadow offset from the surface. Helps to prevent polygonal shadow artifacts on low-poly surfaces.
 	//! [UI Guides] quantityType=distance
 	//! [Default value] 0
	bool set_shadowBias(float val) { return setValue("shadowBias", val); }
	//! Shadow offset from the surface. Helps to prevent polygonal shadow artifacts on low-poly surfaces.
 	//! [UI Guides] quantityType=distance
 	//! [Default value] 0
	float get_shadowBias() const { return getFloat("shadowBias"); }

	//! (description missing)
	//! [Default value] 500
	bool set_photonSubdivs(int val) { return setValue("photonSubdivs", val); }
	//! (description missing)
	//! [Default value] 500
	int get_photonSubdivs() const { return getInt("photonSubdivs"); }

	//! (description missing)
	//! [Default value] 1000
	bool set_causticSubdivs(int val) { return setValue("causticSubdivs", val); }
	//! (description missing)
	//! [Default value] 1000
	int get_causticSubdivs() const { return getInt("causticSubdivs"); }

	//! (description missing)
	//! [Default value] true
	bool set_shadows(bool val) { return setValue("shadows", val); }
	//! (description missing)
	//! [Default value] true
	bool get_shadows() const { return getBool("shadows"); }

	//! The size of the light; 0.0 is a point light, larger values produces soft (area) shadows
 	//! [UI Guides] quantityType=distance
 	//! [Default value] 0
	bool set_shadowRadius(float val) { return setValue("shadowRadius", val); }
	//! The size of the light; 0.0 is a point light, larger values produces soft (area) shadows
 	//! [UI Guides] quantityType=distance
 	//! [Default value] 0
	float get_shadowRadius() const { return getFloat("shadowRadius"); }

	//! The units for the shadow radius (0 - radians; 1 - degrees)
 	//! [UI Guides] enum=0:Radians;1:Degrees
 	//! [Default value] 0
	bool set_shadowRadiusMode(int val) { return setValue("shadowRadiusMode", val); }
	//! The units for the shadow radius (0 - radians; 1 - degrees)
 	//! [UI Guides] enum=0:Radians;1:Degrees
 	//! [Default value] 0
	int get_shadowRadiusMode() const { return getInt("shadowRadiusMode"); }

	//! A float texture that if present will override the shadows radius parameter
 	bool set_shadowRadius_tex(const Plugin& texturefloat) { return setValue("shadowRadius_tex", texturefloat); }
	//! A float texture that if present will override the shadows radius parameter
 	bool set_shadowRadius_tex(float texturefloat) { return setValue("shadowRadius_tex", texturefloat); }
	//! A float texture that if present will override the shadows radius parameter
 	Value get_shadowRadius_tex() const { return getValue("shadowRadius_tex"); }

	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	bool set_shadowSubdivs(int val) { return setValue("shadowSubdivs", val); }
	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	int get_shadowSubdivs() const { return getInt("shadowSubdivs"); }

	//! (description missing)
	//! [Default value] false
	bool set_storeWithIrradianceMap(bool val) { return setValue("storeWithIrradianceMap", val); }
	//! (description missing)
	//! [Default value] false
	bool get_storeWithIrradianceMap() const { return getBool("storeWithIrradianceMap"); }

	//! The shadow color. Anything but black is not physically accurate.
 	//! [Default value] Color(0, 0, 0)
	bool set_shadowColor(const Color& color) { return setValue("shadowColor", color); }
	//! The shadow color. Anything but black is not physically accurate.
 	//! [Default value] Color(0, 0, 0)
	Color get_shadowColor() const { return getColor("shadowColor"); }

	//! A color texture that if present will override the shadowColor parameter
 	bool set_shadowColor_tex(const Plugin& texture) { return setValue("shadowColor_tex", texture); }
	//! A color texture that if present will override the shadowColor parameter
 	bool set_shadowColor_tex(const AColor& texture) { return setValue("shadowColor_tex", texture); }
	//! A color texture that if present will override the shadowColor parameter
 	Value get_shadowColor_tex() const { return getValue("shadowColor_tex"); }

	//! true if the light is casting light (turned on) and false otherwise; it only makes sense to use this parameter if it is animated, or if another object depends on this node but it must not be rendered
 	//! [Default value] true
	bool set_enabled(bool val) { return setValue("enabled", val); }
	//! true if the light is casting light (turned on) and false otherwise; it only makes sense to use this parameter if it is animated, or if another object depends on this node but it must not be rendered
 	//! [Default value] true
	bool get_enabled() const { return getBool("enabled"); }

	//! true if the light produces diffuse lighting and false otherwise
 	//! [Default value] true
	bool set_affectDiffuse(bool val) { return setValue("affectDiffuse", val); }
	//! true if the light produces diffuse lighting and false otherwise
 	//! [Default value] true
	bool get_affectDiffuse() const { return getBool("affectDiffuse"); }

	//! true if the light produces specular hilights and false otherwise
 	//! [Default value] true
	bool set_affectSpecular(bool val) { return setValue("affectSpecular", val); }
	//! true if the light produces specular hilights and false otherwise
 	//! [Default value] true
	bool get_affectSpecular() const { return getBool("affectSpecular"); }

	//! Number of parameter samples for motion blur.
 	//! [Default value] 0
	bool set_nsamples(int val) { return setValue("nsamples", val); }
	//! Number of parameter samples for motion blur.
 	//! [Default value] 0
	int get_nsamples() const { return getInt("nsamples"); }

	//! Diffuse contribution for the light
 	//! [Default value] 1
	bool set_diffuse_contribution(float val) { return setValue("diffuse_contribution", val); }
	//! Diffuse contribution for the light
 	//! [Default value] 1
	float get_diffuse_contribution() const { return getFloat("diffuse_contribution"); }

	//! Specular contribution for the light
 	//! [Default value] 1
	bool set_specular_contribution(float val) { return setValue("specular_contribution", val); }
	//! Specular contribution for the light
 	//! [Default value] 1
	float get_specular_contribution() const { return getFloat("specular_contribution"); }

	//! Render channels the result of this light will be written to
 	bool set_channels(const ValueList& pluginList) { return setValue("channels", pluginList); }
	//! Render channels the result of this light will be written to
 	ValueList get_channels() const { return getValueList("channels"); }

	//! Render channels the raw diffuse result of this light will be written to
 	bool set_channels_raw(const ValueList& pluginList) { return setValue("channels_raw", pluginList); }
	//! Render channels the raw diffuse result of this light will be written to
 	ValueList get_channels_raw() const { return getValueList("channels_raw"); }

	//! Render channels the diffuse result of this light will be written to
 	bool set_channels_diffuse(const ValueList& pluginList) { return setValue("channels_diffuse", pluginList); }
	//! Render channels the diffuse result of this light will be written to
 	ValueList get_channels_diffuse() const { return getValueList("channels_diffuse"); }

	//! Render channels the specular result of this light will be written to
 	bool set_channels_specular(const ValueList& pluginList) { return setValue("channels_specular", pluginList); }
	//! Render channels the specular result of this light will be written to
 	ValueList get_channels_specular() const { return getValueList("channels_specular"); }
};

class MayaMtlMatte : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "MayaMtlMatte"; }

	//! The matte mode (0 - black hole; 1 - solid matte; 2 - opacity gain; 3 - solid alpha)
 	//! [UI Guides] enum=0:Black hole; 1:Solid matte; 2:Opacity gain; 3:Solid alpha
 	//! [Default value] 2
	bool set_mode(int val) { return setValue("mode", val); }
	//! The matte mode (0 - black hole; 1 - solid matte; 2 - opacity gain; 3 - solid alpha)
 	//! [UI Guides] enum=0:Black hole; 1:Solid matte; 2:Opacity gain; 3:Solid alpha
 	//! [Default value] 2
	int get_mode() const { return getInt("mode"); }

	//! Base material
 	bool set_base_mtl(const Plugin& plugin) { return setValue("base_mtl", plugin); }
	//! Base material
 	Plugin get_base_mtl() const { return getPlugin("base_mtl"); }

	//! Matte opacity (0 is transparent; 1 is opaque or normal)
 	bool set_matte_opacity(const Plugin& texturefloat) { return setValue("matte_opacity", texturefloat); }
	//! Matte opacity (0 is transparent; 1 is opaque or normal)
 	bool set_matte_opacity(float texturefloat) { return setValue("matte_opacity", texturefloat); }
	//! Matte opacity (0 is transparent; 1 is opaque or normal)
 	Value get_matte_opacity() const { return getValue("matte_opacity"); }

	//! Alpha transparency (used only in mode 3)
 	bool set_alpha_transparency(const Plugin& texturefloat) { return setValue("alpha_transparency", texturefloat); }
	//! Alpha transparency (used only in mode 3)
 	bool set_alpha_transparency(float texturefloat) { return setValue("alpha_transparency", texturefloat); }
	//! Alpha transparency (used only in mode 3)
 	Value get_alpha_transparency() const { return getValue("alpha_transparency"); }
};

class MayaMultiplyDivide : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "MayaMultiplyDivide"; }

	//! First color
 	bool set_color1(const Plugin& texture) { return setValue("color1", texture); }
	//! First color
 	bool set_color1(const AColor& texture) { return setValue("color1", texture); }
	//! First color
 	Value get_color1() const { return getValue("color1"); }

	//! Second color
 	bool set_color2(const Plugin& texture) { return setValue("color2", texture); }
	//! Second color
 	bool set_color2(const AColor& texture) { return setValue("color2", texture); }
	//! Second color
 	Value get_color2() const { return getValue("color2"); }

	//! Operation (1 - multiply, 2 - divide, 3 - power)
 	//! [UI Guides] enum=1:Multiply; 2:Divide; 3:Power
 	//! [Default value] 1
	bool set_operation(int val) { return setValue("operation", val); }
	//! Operation (1 - multiply, 2 - divide, 3 - power)
 	//! [UI Guides] enum=1:Multiply; 2:Divide; 3:Power
 	//! [Default value] 1
	int get_operation() const { return getInt("operation"); }
};

class MayaProjectionTex : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "MayaProjectionTex"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! (description missing)
	//! [Default value] true
	bool set_wrap(bool val) { return setValue("wrap", val); }
	//! (description missing)
	//! [Default value] true
	bool get_wrap() const { return getBool("wrap"); }

	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	bool set_placement_type(int val) { return setValue("placement_type", val); }
	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	int get_placement_type() const { return getInt("placement_type"); }

	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_u(float val) { return setValue("u", val); }
	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_u() const { return getFloat("u"); }

	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_v(float val) { return setValue("v", val); }
	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_v() const { return getFloat("v"); }

	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_w(float val) { return setValue("w", val); }
	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_w() const { return getFloat("w"); }

	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_h(float val) { return setValue("h", val); }
	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_h() const { return getFloat("h"); }

	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	bool set_jitter(float val) { return setValue("jitter", val); }
	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	float get_jitter() const { return getFloat("jitter"); }

	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_u(bool val) { return setValue("tile_u", val); }
	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_u() const { return getBool("tile_u"); }

	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_v(bool val) { return setValue("tile_v", val); }
	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_v() const { return getBool("tile_v"); }

	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool set_uv_noise_on(bool val) { return setValue("uv_noise_on", val); }
	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool get_uv_noise_on() const { return getBool("uv_noise_on"); }

	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool set_uv_noise_animate(bool val) { return setValue("uv_noise_animate", val); }
	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool get_uv_noise_animate() const { return getBool("uv_noise_animate"); }

	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	bool set_uv_noise_amount(float val) { return setValue("uv_noise_amount", val); }
	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	float get_uv_noise_amount() const { return getFloat("uv_noise_amount"); }

	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	bool set_uv_noise_levels(float val) { return setValue("uv_noise_levels", val); }
	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	float get_uv_noise_levels() const { return getFloat("uv_noise_levels"); }

	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	bool set_uv_noise_size(float val) { return setValue("uv_noise_size", val); }
	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	float get_uv_noise_size() const { return getFloat("uv_noise_size"); }

	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	bool set_un_noise_phase(float val) { return setValue("un_noise_phase", val); }
	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	float get_un_noise_phase() const { return getFloat("un_noise_phase"); }

	//! (description missing)
	bool set_base_texture(const Plugin& texture) { return setValue("base_texture", texture); }
	//! (description missing)
	bool set_base_texture(const AColor& texture) { return setValue("base_texture", texture); }
	//! (description missing)
	Value get_base_texture() const { return getValue("base_texture"); }

	//! (description missing)
	bool set_nouvw_transparency(const Plugin& texture) { return setValue("nouvw_transparency", texture); }
	//! (description missing)
	bool set_nouvw_transparency(const AColor& texture) { return setValue("nouvw_transparency", texture); }
	//! (description missing)
	Value get_nouvw_transparency() const { return getValue("nouvw_transparency"); }

	//! (description missing)
	bool set_transparency_mult(const Plugin& texture) { return setValue("transparency_mult", texture); }
	//! (description missing)
	bool set_transparency_mult(const AColor& texture) { return setValue("transparency_mult", texture); }
	//! (description missing)
	Value get_transparency_mult() const { return getValue("transparency_mult"); }

	//! (description missing)
	bool set_transparency_offset(const Plugin& texture) { return setValue("transparency_offset", texture); }
	//! (description missing)
	bool set_transparency_offset(const AColor& texture) { return setValue("transparency_offset", texture); }
	//! (description missing)
	Value get_transparency_offset() const { return getValue("transparency_offset"); }
};

class Mtl2Sided : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "Mtl2Sided"; }

	//! The material for the surface on the same side as the normal.
 	//! [UI Guides] startTab=V-Ray 2-Sided Material, startRollout=Parameters
 	bool set_front(const Plugin& plugin) { return setValue("front", plugin); }
	//! The material for the surface on the same side as the normal.
 	//! [UI Guides] startTab=V-Ray 2-Sided Material, startRollout=Parameters
 	Plugin get_front() const { return getPlugin("front"); }

	//! The material for the side that is opposite the surface normal.
 	bool set_back(const Plugin& plugin) { return setValue("back", plugin); }
	//! The material for the side that is opposite the surface normal.
 	Plugin get_back() const { return getPlugin("back"); }

	//! Translucency between front and back.
 	//! [Default value] Color(0, 0, 0)
	bool set_translucency(const Color& color) { return setValue("translucency", color); }
	//! Translucency between front and back.
 	//! [Default value] Color(0, 0, 0)
	Color get_translucency() const { return getColor("translucency"); }

	//! Translucency texture.
 	//! [UI Guides] displayName=Translucency texture
 	bool set_translucency_tex(const Plugin& texture) { return setValue("translucency_tex", texture); }
	//! Translucency texture.
 	//! [UI Guides] displayName=Translucency texture
 	bool set_translucency_tex(const AColor& texture) { return setValue("translucency_tex", texture); }
	//! Translucency texture.
 	//! [UI Guides] displayName=Translucency texture
 	Value get_translucency_tex() const { return getValue("translucency_tex"); }

	//! Multiplier for the translucency texture.
 	//! [UI Guides] displayName=Translucency texture multiplier, minValue=0.0, maxValue=1.0
 	//! [Default value] 1
	bool set_translucency_tex_mult(float val) { return setValue("translucency_tex_mult", val); }
	//! Multiplier for the translucency texture.
 	//! [UI Guides] displayName=Translucency texture multiplier, minValue=0.0, maxValue=1.0
 	//! [Default value] 1
	float get_translucency_tex_mult() const { return getFloat("translucency_tex_mult"); }

	//! True to make the sub-materials one-sided.
 	//! [UI Guides] displayName=Force single-sided sub-materials
 	//! [Default value] true
	bool set_force_1sided(bool val) { return setValue("force_1sided", val); }
	//! True to make the sub-materials one-sided.
 	//! [UI Guides] displayName=Force single-sided sub-materials
 	//! [Default value] true
	bool get_force_1sided() const { return getBool("force_1sided"); }

	//! True to multiply the back side color by the cached diffuse color of the front BRDF.
 	//! [UI Guides] displayName=Multiply by front diffuse
 	//! [Default value] false
	bool set_mult_by_front_diffuse(bool val) { return setValue("mult_by_front_diffuse", val); }
	//! True to multiply the back side color by the cached diffuse color of the front BRDF.
 	//! [UI Guides] displayName=Multiply by front diffuse
 	//! [Default value] false
	bool get_mult_by_front_diffuse() const { return getBool("mult_by_front_diffuse"); }

	//! Render channels the result of this BRDF will be written to.
 	bool set_channels(const ValueList& pluginList) { return setValue("channels", pluginList); }
	//! Render channels the result of this BRDF will be written to.
 	ValueList get_channels() const { return getValueList("channels"); }
};

class MtlASGVIS : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "MtlASGVIS"; }

	//! (description missing)
	bool set_brdfs(const ValueList& pluginList) { return setValue("brdfs", pluginList); }
	//! (description missing)
	ValueList get_brdfs() const { return getValueList("brdfs"); }

	//! 1 to make the material double-sided
 	//! [Default value] true
	bool set_double_sided(bool val) { return setValue("double_sided", val); }
	//! 1 to make the material double-sided
 	//! [Default value] true
	bool get_double_sided() const { return getBool("double_sided"); }

	//! Set this flag to disable any volumetric effects that sub-brdfs might need
 	//! [Default value] false
	bool set_disable_volume_fog(bool val) { return setValue("disable_volume_fog", val); }
	//! Set this flag to disable any volumetric effects that sub-brdfs might need
 	//! [Default value] false
	bool get_disable_volume_fog() const { return getBool("disable_volume_fog"); }

	//! true if we want to turn on bump mapping
 	//! [Default value] false
	bool set_bump_on(bool val) { return setValue("bump_on", val); }
	//! true if we want to turn on bump mapping
 	//! [Default value] false
	bool get_bump_on() const { return getBool("bump_on"); }

	//! Bump texture, can be float or color
 	bool set_bump_tex(const Plugin& plugin) { return setValue("bump_tex", plugin); }
	//! Bump texture, can be float or color
 	Plugin get_bump_tex() const { return getPlugin("bump_tex"); }

	//! Bump amount
 	//! [Default value] 1
	bool set_bump_tex_mult(float val) { return setValue("bump_tex_mult", val); }
	//! Bump amount
 	//! [Default value] 1
	float get_bump_tex_mult() const { return getFloat("bump_tex_mult"); }

	//! true to offset the surface shading point, in addition to the normal
 	//! [Default value] false
	bool set_bump_shadows(bool val) { return setValue("bump_shadows", val); }
	//! true to offset the surface shading point, in addition to the normal
 	//! [Default value] false
	bool get_bump_shadows() const { return getBool("bump_shadows"); }

	//! Bump amount texture
 	bool set_bump_tex_mult_tex(const Plugin& texturefloat) { return setValue("bump_tex_mult_tex", texturefloat); }
	//! Bump amount texture
 	bool set_bump_tex_mult_tex(float texturefloat) { return setValue("bump_tex_mult_tex", texturefloat); }
	//! Bump amount texture
 	Value get_bump_tex_mult_tex() const { return getValue("bump_tex_mult_tex"); }

	//! Scale for sampling the bitmap when map_type is 0. Normally this is tied to the ray differentials, but can be changed if necessary.
 	//! [Default value] 1
	bool set_bump_delta_scale(float val) { return setValue("bump_delta_scale", val); }
	//! Scale for sampling the bitmap when map_type is 0. Normally this is tied to the ray differentials, but can be changed if necessary.
 	//! [Default value] 1
	float get_bump_delta_scale() const { return getFloat("bump_delta_scale"); }

	//! The type of the map (0 - from regular texture output, 1 - normal map in tangent space, 2 - normal map in object space, 3 - normal map in camera space, 4 - normal map in world space, 5 - from texture bump output, 6 - explicit normal)
 	//! [Default value] 0
	bool set_map_type(int val) { return setValue("map_type", val); }
	//! The type of the map (0 - from regular texture output, 1 - normal map in tangent space, 2 - normal map in object space, 3 - normal map in camera space, 4 - normal map in world space, 5 - from texture bump output, 6 - explicit normal)
 	//! [Default value] 0
	int get_map_type() const { return getInt("map_type"); }

	//! The uvw generator for the normal map texture when map_type is 1.
 	bool set_normal_uvwgen(const Plugin& plugin) { return setValue("normal_uvwgen", plugin); }
	//! The uvw generator for the normal map texture when map_type is 1.
 	Plugin get_normal_uvwgen() const { return getPlugin("normal_uvwgen"); }

	//! true to compute bump mapping for shadow rays in case the material is transparent; false to skip the bump map for shadow rays (faster rendering)
 	//! [Default value] true
	bool set_compute_bump_for_shadows(bool val) { return setValue("compute_bump_for_shadows", val); }
	//! true to compute bump mapping for shadow rays in case the material is transparent; false to skip the bump map for shadow rays (faster rendering)
 	//! [Default value] true
	bool get_compute_bump_for_shadows() const { return getBool("compute_bump_for_shadows"); }

	//! a float or color texture to be used to determine contribution multiplier
 	bool set_alpha_tex(const Plugin& texture) { return setValue("alpha_tex", texture); }
	//! a float or color texture to be used to determine contribution multiplier
 	bool set_alpha_tex(const AColor& texture) { return setValue("alpha_tex", texture); }
	//! a float or color texture to be used to determine contribution multiplier
 	Value get_alpha_tex() const { return getValue("alpha_tex"); }

	//! multiplier to be applied to alpha texture, if present
 	//! [Default value] 1
	bool set_alpha_tex_mult(float val) { return setValue("alpha_tex_mult", val); }
	//! multiplier to be applied to alpha texture, if present
 	//! [Default value] 1
	float get_alpha_tex_mult() const { return getFloat("alpha_tex_mult"); }

	//! the alpha multiplier to be used if no texture is provided
 	//! [Default value] 1
	bool set_alpha(float val) { return setValue("alpha", val); }
	//! the alpha multiplier to be used if no texture is provided
 	//! [Default value] 1
	float get_alpha() const { return getFloat("alpha"); }

	//! true if we want displacement turned on
 	//! [Default value] false
	bool set_displace_on(bool val) { return setValue("displace_on", val); }
	//! true if we want displacement turned on
 	//! [Default value] false
	bool get_displace_on() const { return getBool("displace_on"); }

	//! displacement texture, can be float or color
 	bool set_displace_tex(const Plugin& plugin) { return setValue("displace_tex", plugin); }
	//! displacement texture, can be float or color
 	Plugin get_displace_tex() const { return getPlugin("displace_tex"); }

	//! displacement multiplier ( displace amount )
 	//! [Default value] 1
	bool set_displace_tex_mult(float val) { return setValue("displace_tex_mult", val); }
	//! displacement multiplier ( displace amount )
 	//! [Default value] 1
	float get_displace_tex_mult() const { return getFloat("displace_tex_mult"); }

	//! a constant value added to the displacement
 	//! [Default value] 0
	bool set_displace_shift(float val) { return setValue("displace_shift", val); }
	//! a constant value added to the displacement
 	//! [Default value] 0
	float get_displace_shift() const { return getFloat("displace_shift"); }

	//! A cutoff point for displacement - can be used for a clipping effect
 	//! [Default value] 1e+030
	bool set_displace_water_level(float val) { return setValue("displace_water_level", val); }
	//! A cutoff point for displacement - can be used for a clipping effect
 	//! [Default value] 1e+030
	float get_displace_water_level() const { return getFloat("displace_water_level"); }

	//! Whether or not to use view-dependant tesselation
 	//! [Default value] true
	bool set_displace_view_dependent(bool val) { return setValue("displace_view_dependent", val); }
	//! Whether or not to use view-dependant tesselation
 	//! [Default value] true
	bool get_displace_view_dependent() const { return getBool("displace_view_dependent"); }

	//! Whether to use the global settings for our displacement
 	//! [Default value] true
	bool set_displace_use_globals(bool val) { return setValue("displace_use_globals", val); }
	//! Whether to use the global settings for our displacement
 	//! [Default value] true
	bool get_displace_use_globals() const { return getBool("displace_use_globals"); }

	//! The maximum number of subdivisions to use
 	//! [Default value] 256
	bool set_displace_max_subdivs(int val) { return setValue("displace_max_subdivs", val); }
	//! The maximum number of subdivisions to use
 	//! [Default value] 256
	int get_displace_max_subdivs() const { return getInt("displace_max_subdivs"); }

	//! The approximate edge length
 	//! [Default value] 4
	bool set_displace_edge_length(float val) { return setValue("displace_edge_length", val); }
	//! The approximate edge length
 	//! [Default value] 4
	float get_displace_edge_length() const { return getFloat("displace_edge_length"); }

	//! enable continuity feature of displacement
 	//! [Default value] true
	bool set_displace_continuity(bool val) { return setValue("displace_continuity", val); }
	//! enable continuity feature of displacement
 	//! [Default value] true
	bool get_displace_continuity() const { return getBool("displace_continuity"); }

	//! whether the global gi environment should be overridden
 	//! [Default value] false
	bool set_override_gi(bool val) { return setValue("override_gi", val); }
	//! whether the global gi environment should be overridden
 	//! [Default value] false
	bool get_override_gi() const { return getBool("override_gi"); }

	//! the gi color
 	//! [Default value] Color(0, 0, 0)
	bool set_gi_color(const Color& color) { return setValue("gi_color", color); }
	//! the gi color
 	//! [Default value] Color(0, 0, 0)
	Color get_gi_color() const { return getColor("gi_color"); }

	//! the texture to use for the gi environment
 	bool set_gi_tex(const Plugin& plugin) { return setValue("gi_tex", plugin); }
	//! the texture to use for the gi environment
 	Plugin get_gi_tex() const { return getPlugin("gi_tex"); }

	//! the multiplier for the gi environment texture
 	//! [Default value] 1
	bool set_gi_tex_mult(float val) { return setValue("gi_tex_mult", val); }
	//! the multiplier for the gi environment texture
 	//! [Default value] 1
	float get_gi_tex_mult() const { return getFloat("gi_tex_mult"); }

	//! whether the global bg environment should be overridden
 	//! [Default value] false
	bool set_override_bg(bool val) { return setValue("override_bg", val); }
	//! whether the global bg environment should be overridden
 	//! [Default value] false
	bool get_override_bg() const { return getBool("override_bg"); }

	//! the bg color
 	//! [Default value] Color(0, 0, 0)
	bool set_bg_color(const Color& color) { return setValue("bg_color", color); }
	//! the bg color
 	//! [Default value] Color(0, 0, 0)
	Color get_bg_color() const { return getColor("bg_color"); }

	//! the texture to use for the bg environment
 	bool set_bg_tex(const Plugin& plugin) { return setValue("bg_tex", plugin); }
	//! the texture to use for the bg environment
 	Plugin get_bg_tex() const { return getPlugin("bg_tex"); }

	//! the multiplier for the bg environment texture
 	//! [Default value] 1
	bool set_bg_tex_mult(float val) { return setValue("bg_tex_mult", val); }
	//! the multiplier for the bg environment texture
 	//! [Default value] 1
	float get_bg_tex_mult() const { return getFloat("bg_tex_mult"); }

	//! whether the global reflection environment should be overridden
 	//! [Default value] false
	bool set_override_reflect(bool val) { return setValue("override_reflect", val); }
	//! whether the global reflection environment should be overridden
 	//! [Default value] false
	bool get_override_reflect() const { return getBool("override_reflect"); }

	//! reflect color
 	//! [Default value] Color(0, 0, 0)
	bool set_reflect_color(const Color& color) { return setValue("reflect_color", color); }
	//! reflect color
 	//! [Default value] Color(0, 0, 0)
	Color get_reflect_color() const { return getColor("reflect_color"); }

	//! the reflection environment
 	bool set_reflect_tex(const Plugin& plugin) { return setValue("reflect_tex", plugin); }
	//! the reflection environment
 	Plugin get_reflect_tex() const { return getPlugin("reflect_tex"); }

	//! the reflection environment texture multiplier
 	//! [Default value] 1
	bool set_reflect_tex_mult(float val) { return setValue("reflect_tex_mult", val); }
	//! the reflection environment texture multiplier
 	//! [Default value] 1
	float get_reflect_tex_mult() const { return getFloat("reflect_tex_mult"); }

	//! whether the global refraction environment should be overridden
 	//! [Default value] false
	bool set_override_refract(bool val) { return setValue("override_refract", val); }
	//! whether the global refraction environment should be overridden
 	//! [Default value] false
	bool get_override_refract() const { return getBool("override_refract"); }

	//! refract color
 	//! [Default value] Color(0, 0, 0)
	bool set_refract_color(const Color& color) { return setValue("refract_color", color); }
	//! refract color
 	//! [Default value] Color(0, 0, 0)
	Color get_refract_color() const { return getColor("refract_color"); }

	//! the refraction environment
 	bool set_refract_tex(const Plugin& plugin) { return setValue("refract_tex", plugin); }
	//! the refraction environment
 	Plugin get_refract_tex() const { return getPlugin("refract_tex"); }

	//! the refraction environment texture multiplier
 	//! [Default value] 1
	bool set_refract_tex_mult(float val) { return setValue("refract_tex_mult", val); }
	//! the refraction environment texture multiplier
 	//! [Default value] 1
	float get_refract_tex_mult() const { return getFloat("refract_tex_mult"); }

	//! Whether we should ignore all objects in the scene when tracing ourself
 	//! [Default value] false
	bool set_ignore_objects(bool val) { return setValue("ignore_objects", val); }
	//! Whether we should ignore all objects in the scene when tracing ourself
 	//! [Default value] false
	bool get_ignore_objects() const { return getBool("ignore_objects"); }

	//! Whether we should do the cheating version of object exclusion-  may cause artifacts
 	//! [Default value] false
	bool set_short_circuit(bool val) { return setValue("short_circuit", val); }
	//! Whether we should do the cheating version of object exclusion-  may cause artifacts
 	//! [Default value] false
	bool get_short_circuit() const { return getBool("short_circuit"); }

	//! This will be used to represent the material in the material id channel if specified
 	//! [Default value] Color(0, 0, 0)
	bool set_material_id_color(const Color& color) { return setValue("material_id_color", color); }
	//! This will be used to represent the material in the material id channel if specified
 	//! [Default value] Color(0, 0, 0)
	Color get_material_id_color() const { return getColor("material_id_color"); }

	//! Whether or not we want objects with this material to cast a shadow
 	//! [Default value] true
	bool set_cast_shadow(bool val) { return setValue("cast_shadow", val); }
	//! Whether or not we want objects with this material to cast a shadow
 	//! [Default value] true
	bool get_cast_shadow() const { return getBool("cast_shadow"); }

	//! Whether or not this object should only be visible in reflects/refractions
 	//! [Default value] false
	bool set_only_visible_in_secondary(bool val) { return setValue("only_visible_in_secondary", val); }
	//! Whether or not this object should only be visible in reflects/refractions
 	//! [Default value] false
	bool get_only_visible_in_secondary() const { return getBool("only_visible_in_secondary"); }
};

class MtlAngleBlend : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "MtlAngleBlend"; }

	//! the first material to be blended
 	bool set_mtl_one(const Plugin& plugin) { return setValue("mtl_one", plugin); }
	//! the first material to be blended
 	Plugin get_mtl_one() const { return getPlugin("mtl_one"); }

	//! the second material to be blended
 	bool set_mtl_two(const Plugin& plugin) { return setValue("mtl_two", plugin); }
	//! the second material to be blended
 	Plugin get_mtl_two() const { return getPlugin("mtl_two"); }

	//! angle where blending begins ( degrees ) - anything before this will be material one only
 	//! [Default value] 25
	bool set_start_angle(float val) { return setValue("start_angle", val); }
	//! angle where blending begins ( degrees ) - anything before this will be material one only
 	//! [Default value] 25
	float get_start_angle() const { return getFloat("start_angle"); }

	//! angle where blending ends ( degrees ) - anything after this will be material two only
 	//! [Default value] 75
	bool set_stop_angle(float val) { return setValue("stop_angle", val); }
	//! angle where blending ends ( degrees ) - anything after this will be material two only
 	//! [Default value] 75
	float get_stop_angle() const { return getFloat("stop_angle"); }

	//! The function to use to blend the materials. 0:Linear 1:Normal Distribution 2:Sigmoid 3:Gompertz 4:Cube Root 5:Cubic 6: Cubic Polynomial
 	//! [Default value] 0
	bool set_blend_function(int val) { return setValue("blend_function", val); }
	//! The function to use to blend the materials. 0:Linear 1:Normal Distribution 2:Sigmoid 3:Gompertz 4:Cube Root 5:Cubic 6: Cubic Polynomial
 	//! [Default value] 0
	int get_blend_function() const { return getInt("blend_function"); }

	//! If this is true we will flip the view direction prior to doing calculations on it
 	//! [Default value] false
	bool set_flip_view_dir(bool val) { return setValue("flip_view_dir", val); }
	//! If this is true we will flip the view direction prior to doing calculations on it
 	//! [Default value] false
	bool get_flip_view_dir() const { return getBool("flip_view_dir"); }
};

class MtlBump : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "MtlBump"; }

	//! Base material
 	bool set_base_mtl(const Plugin& plugin) { return setValue("base_mtl", plugin); }
	//! Base material
 	Plugin get_base_mtl() const { return getPlugin("base_mtl"); }

	//! Bump texture
 	bool set_bump_tex_color(const Plugin& texture) { return setValue("bump_tex_color", texture); }
	//! Bump texture
 	bool set_bump_tex_color(const AColor& texture) { return setValue("bump_tex_color", texture); }
	//! Bump texture
 	Value get_bump_tex_color() const { return getValue("bump_tex_color"); }

	//! Bump texture
 	bool set_bump_tex_float(const Plugin& texturefloat) { return setValue("bump_tex_float", texturefloat); }
	//! Bump texture
 	bool set_bump_tex_float(float texturefloat) { return setValue("bump_tex_float", texturefloat); }
	//! Bump texture
 	Value get_bump_tex_float() const { return getValue("bump_tex_float"); }

	//! Bump amount
 	//! [Default value] 1
	bool set_bump_tex_mult(float val) { return setValue("bump_tex_mult", val); }
	//! Bump amount
 	//! [Default value] 1
	float get_bump_tex_mult() const { return getFloat("bump_tex_mult"); }

	//! Bump amount texture
 	bool set_bump_tex_mult_tex(const Plugin& texturefloat) { return setValue("bump_tex_mult_tex", texturefloat); }
	//! Bump amount texture
 	bool set_bump_tex_mult_tex(float texturefloat) { return setValue("bump_tex_mult_tex", texturefloat); }
	//! Bump amount texture
 	Value get_bump_tex_mult_tex() const { return getValue("bump_tex_mult_tex"); }

	//! Bump texture; this is deprecated, use bump_tex_color or bump_tex_float instead
 	bool set_bump_tex(const Plugin& plugin) { return setValue("bump_tex", plugin); }
	//! Bump texture; this is deprecated, use bump_tex_color or bump_tex_float instead
 	Plugin get_bump_tex() const { return getPlugin("bump_tex"); }

	//! true to offset the surface shading point, in addition to the normal
 	//! [Default value] false
	bool set_bump_shadows(bool val) { return setValue("bump_shadows", val); }
	//! true to offset the surface shading point, in addition to the normal
 	//! [Default value] false
	bool get_bump_shadows() const { return getBool("bump_shadows"); }

	//! Scale for sampling the bitmap when map_type is 0. Normally this is tied to the ray differentials, but can be changed if necessary.
 	//! [Default value] 1
	bool set_bump_delta_scale(float val) { return setValue("bump_delta_scale", val); }
	//! Scale for sampling the bitmap when map_type is 0. Normally this is tied to the ray differentials, but can be changed if necessary.
 	//! [Default value] 1
	float get_bump_delta_scale() const { return getFloat("bump_delta_scale"); }

	//! When this is true the BRDFBump will try to match the Maya bump/normal mapping
 	//! [Default value] false
	bool set_maya_compatible(bool val) { return setValue("maya_compatible", val); }
	//! When this is true the BRDFBump will try to match the Maya bump/normal mapping
 	//! [Default value] false
	bool get_maya_compatible() const { return getBool("maya_compatible"); }

	//! The type of the map (0 - from regular texture output, 1 - normal map in tangent space, 2 - normal map in object space, 3 - normal map in camera space, 4 - normal map in world space, 5 - from texture bump output, 6 - explicit normal)
 	//! [UI Guides] enum=0:Regular texture output;1:Normal map in tangent space;2:Normal map in object space;3:Normal map in camera space;4:Normal map in world space;5:From texture bump output;6:Explicit normal
 	//! [Default value] 0
	bool set_map_type(int val) { return setValue("map_type", val); }
	//! The type of the map (0 - from regular texture output, 1 - normal map in tangent space, 2 - normal map in object space, 3 - normal map in camera space, 4 - normal map in world space, 5 - from texture bump output, 6 - explicit normal)
 	//! [UI Guides] enum=0:Regular texture output;1:Normal map in tangent space;2:Normal map in object space;3:Normal map in camera space;4:Normal map in world space;5:From texture bump output;6:Explicit normal
 	//! [Default value] 0
	int get_map_type() const { return getInt("map_type"); }

	//! The uvw generator for the normal map texture when map_type is 1.
 	bool set_normal_uvwgen(const Plugin& plugin) { return setValue("normal_uvwgen", plugin); }
	//! The uvw generator for the normal map texture when map_type is 1.
 	Plugin get_normal_uvwgen() const { return getPlugin("normal_uvwgen"); }

	//! true to compute bump mapping for shadow rays in case the material is transparent; false to skip the bump map for shadow rays (faster rendering)
 	//! [Default value] true
	bool set_compute_bump_for_shadows(bool val) { return setValue("compute_bump_for_shadows", val); }
	//! true to compute bump mapping for shadow rays in case the material is transparent; false to skip the bump map for shadow rays (faster rendering)
 	//! [Default value] true
	bool get_compute_bump_for_shadows() const { return getBool("compute_bump_for_shadows"); }
};

class MtlDiffuse : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "MtlDiffuse"; }

	//! (description missing)
	//! [Default value] Color(0.5, 0.5, 0.5)
	bool set_diffuse(const Color& color) { return setValue("diffuse", color); }
	//! (description missing)
	//! [Default value] Color(0.5, 0.5, 0.5)
	Color get_diffuse() const { return getColor("diffuse"); }

	//! (description missing)
	bool set_diffuse_tex(const Plugin& texture) { return setValue("diffuse_tex", texture); }
	//! (description missing)
	bool set_diffuse_tex(const AColor& texture) { return setValue("diffuse_tex", texture); }
	//! (description missing)
	Value get_diffuse_tex() const { return getValue("diffuse_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_diffuse_tex_mult(float val) { return setValue("diffuse_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_diffuse_tex_mult() const { return getFloat("diffuse_tex_mult"); }

	//! (description missing)
	//! [Default value] Color(0, 0, 0)
	bool set_reflection(const Color& color) { return setValue("reflection", color); }
	//! (description missing)
	//! [Default value] Color(0, 0, 0)
	Color get_reflection() const { return getColor("reflection"); }

	//! (description missing)
	//! [Default value] Color(0, 0, 0)
	bool set_transparency(const Color& color) { return setValue("transparency", color); }
	//! (description missing)
	//! [Default value] Color(0, 0, 0)
	Color get_transparency() const { return getColor("transparency"); }

	//! (description missing)
	bool set_render_channel_color(const Plugin& plugin) { return setValue("render_channel_color", plugin); }
	//! (description missing)
	Plugin get_render_channel_color() const { return getPlugin("render_channel_color"); }

	//! (description missing)
	bool set_render_channel_alpha(const Plugin& plugin) { return setValue("render_channel_alpha", plugin); }
	//! (description missing)
	Plugin get_render_channel_alpha() const { return getPlugin("render_channel_alpha"); }
};

class MtlDoubleSided : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "MtlDoubleSided"; }

	//! Base material
 	bool set_base_mtl(const Plugin& plugin) { return setValue("base_mtl", plugin); }
	//! Base material
 	Plugin get_base_mtl() const { return getPlugin("base_mtl"); }
};

class MtlGLSL : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "MtlGLSL"; }

	//! [UI Guides] fileAsset=glsl
 	bool set_shader_file(const char* str) { return setValue("shader_file", str); }
	//! [UI Guides] fileAsset=glsl
 	bool set_shader_file(const std::string& str) { return setValue("shader_file", str); }
	//! [UI Guides] fileAsset=glsl
 	std::string get_shader_file() const { return getString("shader_file"); }

	//! Name of the target graph node if XMSL file is specified
 	bool set_shader_node(const char* str) { return setValue("shader_node", str); }
	//! Name of the target graph node if XMSL file is specified
 	bool set_shader_node(const std::string& str) { return setValue("shader_node", str); }
	//! Name of the target graph node if XMSL file is specified
 	std::string get_shader_node() const { return getString("shader_node"); }

	//! (description missing)
	bool set_textures(const ValueList& pluginList) { return setValue("textures", pluginList); }
	//! (description missing)
	ValueList get_textures() const { return getValueList("textures"); }

	//! (description missing)
	bool set_uvw_generators(const ValueList& pluginList) { return setValue("uvw_generators", pluginList); }
	//! (description missing)
	ValueList get_uvw_generators() const { return getValueList("uvw_generators"); }

	//! (description missing)
	//! [Default value] Color(0, 0, 0)
	bool set_transparency(const Color& color) { return setValue("transparency", color); }
	//! (description missing)
	//! [Default value] Color(0, 0, 0)
	Color get_transparency() const { return getColor("transparency"); }

	//! (description missing)
	bool set_transparency_tex(const Plugin& texture) { return setValue("transparency_tex", texture); }
	//! (description missing)
	bool set_transparency_tex(const AColor& texture) { return setValue("transparency_tex", texture); }
	//! (description missing)
	Value get_transparency_tex() const { return getValue("transparency_tex"); }

	//! (description missing)
	//! [Default value] 0
	bool set_transparency_tex_mult(float val) { return setValue("transparency_tex_mult", val); }
	//! (description missing)
	//! [Default value] 0
	float get_transparency_tex_mult() const { return getFloat("transparency_tex_mult"); }

	//! Switch for using either the transparency parameters or the shader alpha result
 	//! [Default value] false
	bool set_use_shader_alpha(bool val) { return setValue("use_shader_alpha", val); }
	//! Switch for using either the transparency parameters or the shader alpha result
 	//! [Default value] false
	bool get_use_shader_alpha() const { return getBool("use_shader_alpha"); }

	//! Non-varying state variables referenced by the shader
 	bool set_uniforms(const ValueList& list) { return setValue("uniforms", list); }
	//! Non-varying state variables referenced by the shader
 	ValueList get_uniforms() const { return getValueList("uniforms"); }

	//! (description missing)
	//! [Default value] -1
	bool set_max_ray_depth(int val) { return setValue("max_ray_depth", val); }
	//! (description missing)
	//! [Default value] -1
	int get_max_ray_depth() const { return getInt("max_ray_depth"); }

	//! Flag that shows whether to clamp final result or not
 	//! [Default value] true
	bool set_clamp_result(bool val) { return setValue("clamp_result", val); }
	//! Flag that shows whether to clamp final result or not
 	//! [Default value] true
	bool get_clamp_result() const { return getBool("clamp_result"); }

	//! The upper clamp limit for the result color should the clamp_result flag is true
 	//! [Default value] 1
	bool set_clamp_value(float val) { return setValue("clamp_value", val); }
	//! The upper clamp limit for the result color should the clamp_result flag is true
 	//! [Default value] 1
	float get_clamp_value() const { return getFloat("clamp_value"); }
};

class MtlLayeredBRDF : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "MtlLayeredBRDF"; }

	//! (description missing)
	bool set_brdfs(const ValueList& pluginList) { return setValue("brdfs", pluginList); }
	//! (description missing)
	ValueList get_brdfs() const { return getValueList("brdfs"); }

	//! 1 to make the material double-sided
 	//! [Default value] true
	bool set_double_sided(bool val) { return setValue("double_sided", val); }
	//! 1 to make the material double-sided
 	//! [Default value] true
	bool get_double_sided() const { return getBool("double_sided"); }
};

class MtlMDL : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "MtlMDL"; }

	//!  The fully-qualified MDL name of the MDL module (including package names, starting with "::")
 	bool set_mdl_module(const char* str) { return setValue("mdl_module", str); }
	//!  The fully-qualified MDL name of the MDL module (including package names, starting with "::")
 	bool set_mdl_module(const std::string& str) { return setValue("mdl_module", str); }
	//!  The fully-qualified MDL name of the MDL module (including package names, starting with "::")
 	std::string get_mdl_module() const { return getString("mdl_module"); }

	//! The fully-qualified name of the MDL material to be loaded from the specified module
 	bool set_mdl_material(const char* str) { return setValue("mdl_material", str); }
	//! The fully-qualified name of the MDL material to be loaded from the specified module
 	bool set_mdl_material(const std::string& str) { return setValue("mdl_material", str); }
	//! The fully-qualified name of the MDL material to be loaded from the specified module
 	std::string get_mdl_material() const { return getString("mdl_material"); }

	//! Input parameter values in the order and type declared by the MDL shader
 	bool set_input_parameters(const ValueList& list) { return setValue("input_parameters", list); }
	//! Input parameter values in the order and type declared by the MDL shader
 	ValueList get_input_parameters() const { return getValueList("input_parameters"); }

	//! (description missing)
	bool set_uvw_generators(const ValueList& pluginList) { return setValue("uvw_generators", pluginList); }
	//! (description missing)
	ValueList get_uvw_generators() const { return getValueList("uvw_generators"); }

	//! Maximum trace depth allowed for material evaluation
 	//! [Default value] 5
	bool set_max_ray_depth(int val) { return setValue("max_ray_depth", val); }
	//! Maximum trace depth allowed for material evaluation
 	//! [Default value] 5
	int get_max_ray_depth() const { return getInt("max_ray_depth"); }

	//! Semicolon-separated list of MDL search directories
 	bool set_mdl_path_list(const char* str) { return setValue("mdl_path_list", str); }
	//! Semicolon-separated list of MDL search directories
 	bool set_mdl_path_list(const std::string& str) { return setValue("mdl_path_list", str); }
	//! Semicolon-separated list of MDL search directories
 	std::string get_mdl_path_list() const { return getString("mdl_path_list"); }

	//! List of import declarations to be inserted inside the temporary module
 	bool set_imports_list(const ValueList& list) { return setValue("imports_list", list); }
	//! List of import declarations to be inserted inside the temporary module
 	ValueList get_imports_list() const { return getValueList("imports_list"); }

	//! Expect squared roughness for GGX (on by default)
 	//! [Default value] 1
	bool set_remap_roughness(int val) { return setValue("remap_roughness", val); }
	//! Expect squared roughness for GGX (on by default)
 	//! [Default value] 1
	int get_remap_roughness() const { return getInt("remap_roughness"); }
};

class MtlMaterialID : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "MtlMaterialID"; }

	//! The base material
 	bool set_base_mtl(const Plugin& plugin) { return setValue("base_mtl", plugin); }
	//! The base material
 	Plugin get_base_mtl() const { return getPlugin("base_mtl"); }

	//! The material id color
 	bool set_material_id_color(const Plugin& texture) { return setValue("material_id_color", texture); }
	//! The material id color
 	bool set_material_id_color(const AColor& texture) { return setValue("material_id_color", texture); }
	//! The material id color
 	Value get_material_id_color() const { return getValue("material_id_color"); }

	//! (description missing)
	//! [Default value] 0
	bool set_material_id_number(int val) { return setValue("material_id_number", val); }
	//! (description missing)
	//! [Default value] 0
	int get_material_id_number() const { return getInt("material_id_number"); }
};

class MtlMayaRamp : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "MtlMayaRamp"; }

	//! positions of the color ramp
 	bool set_color_positions(const ValueList& list) { return setValue("color_positions", list); }
	//! positions of the color ramp
 	ValueList get_color_positions() const { return getValueList("color_positions"); }

	//! colors of the color ramp
 	bool set_color_colors(const ValueList& textureList) { return setValue("color_colors", textureList); }
	//! colors of the color ramp
 	ValueList get_color_colors() const { return getValueList("color_colors"); }

	//! 0: none, 1: linear, 2: smooth, 3: spline
 	//! [Default value] 0
	bool set_color_interpolations(const IntList& intList) { return setValue("color_interpolations", intList); }
	//! 0: none, 1: linear, 2: smooth, 3: spline
 	//! [Default value] 0
	bool set_color_interpolations(const int* ints, size_t count) { return setArray("color_interpolations", ints, count); }
	//! 0: none, 1: linear, 2: smooth, 3: spline
 	//! [Default value] 0
	template<size_t count> bool set_color_interpolations(const int (&ints)[count]) { return setArray("color_interpolations", ints, count); }
	//! 0: none, 1: linear, 2: smooth, 3: spline
 	//! [Default value] 0
	IntList get_color_interpolations() const { return getIntList("color_interpolations"); }

	//! 0: light angle, 1: facing angle, 2: brightness, 3: normalized brightness
 	//! [Default value] 0
	bool set_color_input(int val) { return setValue("color_input", val); }
	//! 0: light angle, 1: facing angle, 2: brightness, 3: normalized brightness
 	//! [Default value] 0
	int get_color_input() const { return getInt("color_input"); }

	//! positions of the transparency ramp
 	bool set_transp_positions(const ValueList& list) { return setValue("transp_positions", list); }
	//! positions of the transparency ramp
 	ValueList get_transp_positions() const { return getValueList("transp_positions"); }

	//! colors of the transparency ramp
 	bool set_transp_colors(const ValueList& textureList) { return setValue("transp_colors", textureList); }
	//! colors of the transparency ramp
 	ValueList get_transp_colors() const { return getValueList("transp_colors"); }

	//! 0: none, 1: linear, 2: smooth, 3: spline
 	//! [Default value] 0
	bool set_transp_interpolations(const IntList& intList) { return setValue("transp_interpolations", intList); }
	//! 0: none, 1: linear, 2: smooth, 3: spline
 	//! [Default value] 0
	bool set_transp_interpolations(const int* ints, size_t count) { return setArray("transp_interpolations", ints, count); }
	//! 0: none, 1: linear, 2: smooth, 3: spline
 	//! [Default value] 0
	template<size_t count> bool set_transp_interpolations(const int (&ints)[count]) { return setArray("transp_interpolations", ints, count); }
	//! 0: none, 1: linear, 2: smooth, 3: spline
 	//! [Default value] 0
	IntList get_transp_interpolations() const { return getIntList("transp_interpolations"); }

	//! positions of the incandescence ramp
 	bool set_incan_positions(const ValueList& list) { return setValue("incan_positions", list); }
	//! positions of the incandescence ramp
 	ValueList get_incan_positions() const { return getValueList("incan_positions"); }

	//! colors of the incandescence ramp
 	bool set_incan_colors(const ValueList& textureList) { return setValue("incan_colors", textureList); }
	//! colors of the incandescence ramp
 	ValueList get_incan_colors() const { return getValueList("incan_colors"); }

	//! 0: none, 1: linear, 2: smooth, 3: spline
 	//! [Default value] 0
	bool set_incan_interpolations(const IntList& intList) { return setValue("incan_interpolations", intList); }
	//! 0: none, 1: linear, 2: smooth, 3: spline
 	//! [Default value] 0
	bool set_incan_interpolations(const int* ints, size_t count) { return setArray("incan_interpolations", ints, count); }
	//! 0: none, 1: linear, 2: smooth, 3: spline
 	//! [Default value] 0
	template<size_t count> bool set_incan_interpolations(const int (&ints)[count]) { return setArray("incan_interpolations", ints, count); }
	//! 0: none, 1: linear, 2: smooth, 3: spline
 	//! [Default value] 0
	IntList get_incan_interpolations() const { return getIntList("incan_interpolations"); }

	//! positions of the specular ramp
 	bool set_specular_positions(const ValueList& list) { return setValue("specular_positions", list); }
	//! positions of the specular ramp
 	ValueList get_specular_positions() const { return getValueList("specular_positions"); }

	//! colors of the specular ramp
 	bool set_specular_colors(const ValueList& textureList) { return setValue("specular_colors", textureList); }
	//! colors of the specular ramp
 	ValueList get_specular_colors() const { return getValueList("specular_colors"); }

	//! 0: none, 1: linear, 2: smooth, 3: spline
 	//! [Default value] 0
	bool set_specular_interpolations(const IntList& intList) { return setValue("specular_interpolations", intList); }
	//! 0: none, 1: linear, 2: smooth, 3: spline
 	//! [Default value] 0
	bool set_specular_interpolations(const int* ints, size_t count) { return setArray("specular_interpolations", ints, count); }
	//! 0: none, 1: linear, 2: smooth, 3: spline
 	//! [Default value] 0
	template<size_t count> bool set_specular_interpolations(const int (&ints)[count]) { return setArray("specular_interpolations", ints, count); }
	//! 0: none, 1: linear, 2: smooth, 3: spline
 	//! [Default value] 0
	IntList get_specular_interpolations() const { return getIntList("specular_interpolations"); }

	//! positions of the environment ramp
 	bool set_environm_positions(const ValueList& list) { return setValue("environm_positions", list); }
	//! positions of the environment ramp
 	ValueList get_environm_positions() const { return getValueList("environm_positions"); }

	//! colors of the environment ramp
 	bool set_environm_colors(const ValueList& textureList) { return setValue("environm_colors", textureList); }
	//! colors of the environment ramp
 	ValueList get_environm_colors() const { return getValueList("environm_colors"); }

	//! 0: none, 1: linear, 2: smooth, 3: spline
 	//! [Default value] 0
	bool set_environm_interpolations(const IntList& intList) { return setValue("environm_interpolations", intList); }
	//! 0: none, 1: linear, 2: smooth, 3: spline
 	//! [Default value] 0
	bool set_environm_interpolations(const int* ints, size_t count) { return setArray("environm_interpolations", ints, count); }
	//! 0: none, 1: linear, 2: smooth, 3: spline
 	//! [Default value] 0
	template<size_t count> bool set_environm_interpolations(const int (&ints)[count]) { return setArray("environm_interpolations", ints, count); }
	//! 0: none, 1: linear, 2: smooth, 3: spline
 	//! [Default value] 0
	IntList get_environm_interpolations() const { return getIntList("environm_interpolations"); }

	//! positions of the specular roll off ramp
 	bool set_specularRollOff_positions(const ValueList& list) { return setValue("specularRollOff_positions", list); }
	//! positions of the specular roll off ramp
 	ValueList get_specularRollOff_positions() const { return getValueList("specularRollOff_positions"); }

	//! values of the specular roll off ramp
 	bool set_specularRollOff_values(const ValueList& texturefloatList) { return setValue("specularRollOff_values", texturefloatList); }
	//! values of the specular roll off ramp
 	ValueList get_specularRollOff_values() const { return getValueList("specularRollOff_values"); }

	//! 0: none, 1: linear, 2: smooth, 3: spline
 	//! [Default value] 0
	bool set_specularRollOff_interpolations(const IntList& intList) { return setValue("specularRollOff_interpolations", intList); }
	//! 0: none, 1: linear, 2: smooth, 3: spline
 	//! [Default value] 0
	bool set_specularRollOff_interpolations(const int* ints, size_t count) { return setArray("specularRollOff_interpolations", ints, count); }
	//! 0: none, 1: linear, 2: smooth, 3: spline
 	//! [Default value] 0
	template<size_t count> bool set_specularRollOff_interpolations(const int (&ints)[count]) { return setArray("specularRollOff_interpolations", ints, count); }
	//! 0: none, 1: linear, 2: smooth, 3: spline
 	//! [Default value] 0
	IntList get_specularRollOff_interpolations() const { return getIntList("specularRollOff_interpolations"); }

	//! positions of the reflectivity ramp
 	bool set_reflectivity_positions(const ValueList& list) { return setValue("reflectivity_positions", list); }
	//! positions of the reflectivity ramp
 	ValueList get_reflectivity_positions() const { return getValueList("reflectivity_positions"); }

	//! values of the reflectivity ramp
 	bool set_reflectivity_values(const ValueList& texturefloatList) { return setValue("reflectivity_values", texturefloatList); }
	//! values of the reflectivity ramp
 	ValueList get_reflectivity_values() const { return getValueList("reflectivity_values"); }

	//! 0: none, 1: linear, 2: smooth, 3: spline
 	//! [Default value] 0
	bool set_reflectivity_interpolations(const IntList& intList) { return setValue("reflectivity_interpolations", intList); }
	//! 0: none, 1: linear, 2: smooth, 3: spline
 	//! [Default value] 0
	bool set_reflectivity_interpolations(const int* ints, size_t count) { return setArray("reflectivity_interpolations", ints, count); }
	//! 0: none, 1: linear, 2: smooth, 3: spline
 	//! [Default value] 0
	template<size_t count> bool set_reflectivity_interpolations(const int (&ints)[count]) { return setArray("reflectivity_interpolations", ints, count); }
	//! 0: none, 1: linear, 2: smooth, 3: spline
 	//! [Default value] 0
	IntList get_reflectivity_interpolations() const { return getIntList("reflectivity_interpolations"); }

	//! ambient texture
 	bool set_ambient_tex(const Plugin& texture) { return setValue("ambient_tex", texture); }
	//! ambient texture
 	bool set_ambient_tex(const AColor& texture) { return setValue("ambient_tex", texture); }
	//! ambient texture
 	Value get_ambient_tex() const { return getValue("ambient_tex"); }

	//! eccentricity float texture
 	bool set_eccentricity_tex(const Plugin& texturefloat) { return setValue("eccentricity_tex", texturefloat); }
	//! eccentricity float texture
 	bool set_eccentricity_tex(float texturefloat) { return setValue("eccentricity_tex", texturefloat); }
	//! eccentricity float texture
 	Value get_eccentricity_tex() const { return getValue("eccentricity_tex"); }

	//! specularity float texture
 	bool set_specularity_tex(const Plugin& texturefloat) { return setValue("specularity_tex", texturefloat); }
	//! specularity float texture
 	bool set_specularity_tex(float texturefloat) { return setValue("specularity_tex", texturefloat); }
	//! specularity float texture
 	Value get_specularity_tex() const { return getValue("specularity_tex"); }

	//! diffuse float texture
 	bool set_diffuse_tex(const Plugin& texturefloat) { return setValue("diffuse_tex", texturefloat); }
	//! diffuse float texture
 	bool set_diffuse_tex(float texturefloat) { return setValue("diffuse_tex", texturefloat); }
	//! diffuse float texture
 	Value get_diffuse_tex() const { return getValue("diffuse_tex"); }

	//! forward scatter float texture
 	bool set_fscatter_tex(const Plugin& texturefloat) { return setValue("fscatter_tex", texturefloat); }
	//! forward scatter float texture
 	bool set_fscatter_tex(float texturefloat) { return setValue("fscatter_tex", texturefloat); }
	//! forward scatter float texture
 	Value get_fscatter_tex() const { return getValue("fscatter_tex"); }

	//! reflection limit
 	//! [Default value] 0
	bool set_reflection_limit(int val) { return setValue("reflection_limit", val); }
	//! reflection limit
 	//! [Default value] 0
	int get_reflection_limit() const { return getInt("reflection_limit"); }

	//! (description missing)
	//! [Default value] false
	bool set_refractions(bool val) { return setValue("refractions", val); }
	//! (description missing)
	//! [Default value] false
	bool get_refractions() const { return getBool("refractions"); }

	//! IOR for the material; this is ignored if the surface has a volume shader (the volume IOR is used).
 	//! [Default value] 1.55
	bool set_ior(float val) { return setValue("ior", val); }
	//! IOR for the material; this is ignored if the surface has a volume shader (the volume IOR is used).
 	//! [Default value] 1.55
	float get_ior() const { return getFloat("ior"); }

	//! The maximum refraction bounces
 	//! [Default value] -1
	bool set_refraction_limit(int val) { return setValue("refraction_limit", val); }
	//! The maximum refraction bounces
 	//! [Default value] -1
	int get_refraction_limit() const { return getInt("refraction_limit"); }

	//! (description missing)
	bool set_volume(const Plugin& plugin) { return setValue("volume", plugin); }
	//! (description missing)
	Plugin get_volume() const { return getPlugin("volume"); }

	//! bump BRDF used internally for bump mapping
 	bool set_bump_brdf(const Plugin& plugin) { return setValue("bump_brdf", plugin); }
	//! bump BRDF used internally for bump mapping
 	Plugin get_bump_brdf() const { return getPlugin("bump_brdf"); }

	//! Render channels the result will be written to
 	bool set_channels(const ValueList& pluginList) { return setValue("channels", pluginList); }
	//! Render channels the result will be written to
 	ValueList get_channels() const { return getValueList("channels"); }
};

class MtlMulti : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "MtlMulti"; }

	//! (Deprecated; use mtls_list/ids_list instead). A list of two-element lists with the material id and the material plugin.
 	bool set_mtls(const ValueList& pluginList) { return setValue("mtls", pluginList); }
	//! (Deprecated; use mtls_list/ids_list instead). A list of two-element lists with the material id and the material plugin.
 	ValueList get_mtls() const { return getValueList("mtls"); }

	//! A list of the materials.
 	bool set_mtls_list(const ValueList& pluginList) { return setValue("mtls_list", pluginList); }
	//! A list of the materials.
 	ValueList get_mtls_list() const { return getValueList("mtls_list"); }

	//! A list of material IDs
 	//! [Default value] 0
	bool set_ids_list(const IntList& intList) { return setValue("ids_list", intList); }
	//! A list of material IDs
 	//! [Default value] 0
	bool set_ids_list(const int* ints, size_t count) { return setArray("ids_list", ints, count); }
	//! A list of material IDs
 	//! [Default value] 0
	template<size_t count> bool set_ids_list(const int (&ints)[count]) { return setArray("ids_list", ints, count); }
	//! A list of material IDs
 	//! [Default value] 0
	IntList get_ids_list() const { return getIntList("ids_list"); }

	//! A list of shader set names to be matched to the materials.
 	bool set_shader_sets_list(const ValueList& stringList) { return setValue("shader_sets_list", stringList); }
	//! A list of shader set names to be matched to the materials.
 	ValueList get_shader_sets_list() const { return getValueList("shader_sets_list"); }

	//! An integer texture that generates material ids; if not present, neither mtlid_gen_float is present then surface material id will be used.
 	bool set_mtlid_gen(const Plugin& textureint) { return setValue("mtlid_gen", textureint); }
	//! An integer texture that generates material ids; if not present, neither mtlid_gen_float is present then surface material id will be used.
 	bool set_mtlid_gen(int textureint) { return setValue("mtlid_gen", textureint); }
	//! An integer texture that generates material ids; if not present, neither mtlid_gen_float is present then surface material id will be used.
 	Value get_mtlid_gen() const { return getValue("mtlid_gen"); }

	//! A float texture that generates material ids; if not present, neither mtlid_gen is present then surface material id will be used.
 	bool set_mtlid_gen_float(const Plugin& texturefloat) { return setValue("mtlid_gen_float", texturefloat); }
	//! A float texture that generates material ids; if not present, neither mtlid_gen is present then surface material id will be used.
 	bool set_mtlid_gen_float(float texturefloat) { return setValue("mtlid_gen_float", texturefloat); }
	//! A float texture that generates material ids; if not present, neither mtlid_gen is present then surface material id will be used.
 	Value get_mtlid_gen_float() const { return getValue("mtlid_gen_float"); }

	//! true to wrap the material ID's to the largest specified ID for the material
 	//! [Default value] false
	bool set_wrap_id(bool val) { return setValue("wrap_id", val); }
	//! true to wrap the material ID's to the largest specified ID for the material
 	//! [Default value] false
	bool get_wrap_id() const { return getBool("wrap_id"); }
};

class MtlOSL : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "MtlOSL"; }

	//! Path to a *.oso file
 	//! [UI Guides] fileAsset=oso
 	bool set_shader_file(const char* str) { return setValue("shader_file", str); }
	//! Path to a *.oso file
 	//! [UI Guides] fileAsset=oso
 	bool set_shader_file(const std::string& str) { return setValue("shader_file", str); }
	//! Path to a *.oso file
 	//! [UI Guides] fileAsset=oso
 	std::string get_shader_file() const { return getString("shader_file"); }

	//! Input parameter values in the order and type declared by the osl shader
 	bool set_input_parameters(const ValueList& list) { return setValue("input_parameters", list); }
	//! Input parameter values in the order and type declared by the osl shader
 	ValueList get_input_parameters() const { return getValueList("input_parameters"); }

	//! Name of the output closure color as declared in the osl shader
 	bool set_output_closure(const char* str) { return setValue("output_closure", str); }
	//! Name of the output closure color as declared in the osl shader
 	bool set_output_closure(const std::string& str) { return setValue("output_closure", str); }
	//! Name of the output closure color as declared in the osl shader
 	std::string get_output_closure() const { return getString("output_closure"); }

	//! The uvw generator for the material
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw generator for the material
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! Maximum trace depth allowed for material evaluation
 	//! [Default value] 5
	bool set_max_ray_depth(int val) { return setValue("max_ray_depth", val); }
	//! Maximum trace depth allowed for material evaluation
 	//! [Default value] 5
	int get_max_ray_depth() const { return getInt("max_ray_depth"); }
};

class MtlObjBBox : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "MtlObjBBox"; }

	//! Base material
 	bool set_base_mtl(const Plugin& plugin) { return setValue("base_mtl", plugin); }
	//! Base material
 	Plugin get_base_mtl() const { return getPlugin("base_mtl"); }

	//! Min. coordinates for object bounding box
 	//! [Default value] Vector(0, 0, 0)
	bool set_bbox_min(const Vector& vector) { return setValue("bbox_min", vector); }
	//! Min. coordinates for object bounding box
 	//! [Default value] Vector(0, 0, 0)
	Vector get_bbox_min() const { return getVector("bbox_min"); }

	//! Max. coordinates for object bounding box
 	//! [Default value] Vector(0, 0, 0)
	bool set_bbox_max(const Vector& vector) { return setValue("bbox_max", vector); }
	//! Max. coordinates for object bounding box
 	//! [Default value] Vector(0, 0, 0)
	Vector get_bbox_max() const { return getVector("bbox_max"); }
};

class MtlOverride : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "MtlOverride"; }

	//! The normal material (visible to the camera)
 	//! [UI Guides] startTab=V-Ray Override Material, startRollout=Material override, displayName=Base Material
 	bool set_base_mtl(const Plugin& plugin) { return setValue("base_mtl", plugin); }
	//! The normal material (visible to the camera)
 	//! [UI Guides] startTab=V-Ray Override Material, startRollout=Material override, displayName=Base Material
 	Plugin get_base_mtl() const { return getPlugin("base_mtl"); }

	//! Enable the GI material.
 	//! [UI Guides] startRollout=, displayName=Enable GI Material
 	//! [Default value] true
	bool set_enable_gi_mtl(bool val) { return setValue("enable_gi_mtl", val); }
	//! Enable the GI material.
 	//! [UI Guides] startRollout=, displayName=Enable GI Material
 	//! [Default value] true
	bool get_enable_gi_mtl() const { return getBool("enable_gi_mtl"); }

	//! The GI material.
 	//! [UI Guides] displayName=GI Material, enableIf: ?enable_gi_mtl=1
 	bool set_gi_mtl(const Plugin& plugin) { return setValue("gi_mtl", plugin); }
	//! The GI material.
 	//! [UI Guides] displayName=GI Material, enableIf: ?enable_gi_mtl=1
 	Plugin get_gi_mtl() const { return getPlugin("gi_mtl"); }

	//! Enable the reflection material.
 	//! [UI Guides] startRollout=, displayName=Enable Reflection Material
 	//! [Default value] true
	bool set_enable_reflect_mtl(bool val) { return setValue("enable_reflect_mtl", val); }
	//! Enable the reflection material.
 	//! [UI Guides] startRollout=, displayName=Enable Reflection Material
 	//! [Default value] true
	bool get_enable_reflect_mtl() const { return getBool("enable_reflect_mtl"); }

	//! The reflection material.
 	//! [UI Guides] displayName=Reflection Material, enableIf: ?enable_reflect_mtl=1
 	bool set_reflect_mtl(const Plugin& plugin) { return setValue("reflect_mtl", plugin); }
	//! The reflection material.
 	//! [UI Guides] displayName=Reflection Material, enableIf: ?enable_reflect_mtl=1
 	Plugin get_reflect_mtl() const { return getPlugin("reflect_mtl"); }

	//! Enable the refraction material.
 	//! [UI Guides] startRollout=, displayName=Enable Refraction Material
 	//! [Default value] true
	bool set_enable_refract_mtl(bool val) { return setValue("enable_refract_mtl", val); }
	//! Enable the refraction material.
 	//! [UI Guides] startRollout=, displayName=Enable Refraction Material
 	//! [Default value] true
	bool get_enable_refract_mtl() const { return getBool("enable_refract_mtl"); }

	//! The refraction material.
 	//! [UI Guides] displayName=Refraction Material, enableIf: ?enable_refract_mtl=1
 	bool set_refract_mtl(const Plugin& plugin) { return setValue("refract_mtl", plugin); }
	//! The refraction material.
 	//! [UI Guides] displayName=Refraction Material, enableIf: ?enable_refract_mtl=1
 	Plugin get_refract_mtl() const { return getPlugin("refract_mtl"); }

	//! Enable the shadow material.
 	//! [UI Guides] startRollout=, displayName=Enable Shadow Material
 	//! [Default value] true
	bool set_enable_shadow_mtl(bool val) { return setValue("enable_shadow_mtl", val); }
	//! Enable the shadow material.
 	//! [UI Guides] startRollout=, displayName=Enable Shadow Material
 	//! [Default value] true
	bool get_enable_shadow_mtl() const { return getBool("enable_shadow_mtl"); }

	//! The shadow material.
 	//! [UI Guides] displayName=Shadow Material, enableIf: ?enable_shadow_mtl=1
 	bool set_shadow_mtl(const Plugin& plugin) { return setValue("shadow_mtl", plugin); }
	//! The shadow material.
 	//! [UI Guides] displayName=Shadow Material, enableIf: ?enable_shadow_mtl=1
 	Plugin get_shadow_mtl() const { return getPlugin("shadow_mtl"); }

	//! True to use the 'environment override' texture.
 	//! [UI Guides] startRollout=Environment override
 	//! [Default value] false
	bool set_use_environment_override(bool val) { return setValue("use_environment_override", val); }
	//! True to use the 'environment override' texture.
 	//! [UI Guides] startRollout=Environment override
 	//! [Default value] false
	bool get_use_environment_override() const { return getBool("use_environment_override"); }

	//! Environment override texture
 	//! [UI Guides] enableIf: ?use_environment_override=1
 	bool set_environment_override(const Plugin& texture) { return setValue("environment_override", texture); }
	//! Environment override texture
 	//! [UI Guides] enableIf: ?use_environment_override=1
 	bool set_environment_override(const AColor& texture) { return setValue("environment_override", texture); }
	//! Environment override texture
 	//! [UI Guides] enableIf: ?use_environment_override=1
 	Value get_environment_override() const { return getValue("environment_override"); }

	//! Environment override priority (used when several materials override it along a ray path)
 	//! [UI Guides] enableIf: ?use_environment_override=1, minValue=-1000, maxValue=1000
 	//! [Default value] 0
	bool set_environment_priority(int val) { return setValue("environment_priority", val); }
	//! Environment override priority (used when several materials override it along a ray path)
 	//! [UI Guides] enableIf: ?use_environment_override=1, minValue=-1000, maxValue=1000
 	//! [Default value] 0
	int get_environment_priority() const { return getInt("environment_priority"); }
};

class MtlRenderStats : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "MtlRenderStats"; }

	//! Base material
 	bool set_base_mtl(const Plugin& plugin) { return setValue("base_mtl", plugin); }
	//! Base material
 	Plugin get_base_mtl() const { return getPlugin("base_mtl"); }

	//! Whether the object is visible from the camera (camera rays)
 	//! [Default value] true
	bool set_camera_visibility(bool val) { return setValue("camera_visibility", val); }
	//! Whether the object is visible from the camera (camera rays)
 	//! [Default value] true
	bool get_camera_visibility() const { return getBool("camera_visibility"); }

	//! Whether the object is visible in reflections
 	//! [Default value] true
	bool set_reflections_visibility(bool val) { return setValue("reflections_visibility", val); }
	//! Whether the object is visible in reflections
 	//! [Default value] true
	bool get_reflections_visibility() const { return getBool("reflections_visibility"); }

	//! Whether the object is visible in refractions
 	//! [Default value] true
	bool set_refractions_visibility(bool val) { return setValue("refractions_visibility", val); }
	//! Whether the object is visible in refractions
 	//! [Default value] true
	bool get_refractions_visibility() const { return getBool("refractions_visibility"); }

	//! Whether the object is visible to GI (generating and receiving)
 	//! [Default value] true
	bool set_gi_visibility(bool val) { return setValue("gi_visibility", val); }
	//! Whether the object is visible to GI (generating and receiving)
 	//! [Default value] true
	bool get_gi_visibility() const { return getBool("gi_visibility"); }

	//! Whether the object casts shadows (visible to lights for shadow rays)
 	//! [Default value] true
	bool set_shadows_visibility(bool val) { return setValue("shadows_visibility", val); }
	//! Whether the object casts shadows (visible to lights for shadow rays)
 	//! [Default value] true
	bool get_shadows_visibility() const { return getBool("shadows_visibility"); }

	//! Whether the object receives shadows
 	//! [Default value] true
	bool set_shadows_receive(bool val) { return setValue("shadows_receive", val); }
	//! Whether the object receives shadows
 	//! [Default value] true
	bool get_shadows_receive() const { return getBool("shadows_receive"); }

	//! Overall visibility
 	//! [Default value] 1
	bool set_visibility(float val) { return setValue("visibility", val); }
	//! Overall visibility
 	//! [Default value] 1
	float get_visibility() const { return getFloat("visibility"); }
};

class MtlRoundEdges : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "MtlRoundEdges"; }

	//! Base material
 	bool set_base_mtl(const Plugin& plugin) { return setValue("base_mtl", plugin); }
	//! Base material
 	Plugin get_base_mtl() const { return getPlugin("base_mtl"); }

	//! Rounding radius
 	//! [UI Guides] quantityType=distance
 	bool set_radius(const Plugin& texturefloat) { return setValue("radius", texturefloat); }
	//! Rounding radius
 	//! [UI Guides] quantityType=distance
 	bool set_radius(float texturefloat) { return setValue("radius", texturefloat); }
	//! Rounding radius
 	//! [UI Guides] quantityType=distance
 	Value get_radius() const { return getValue("radius"); }

	//! 0 - the radius parameter is in object space, 1 - the radius parameter is in world space.
 	//! [Default value] 0
	bool set_radius_mode(int val) { return setValue("radius_mode", val); }
	//! 0 - the radius parameter is in object space, 1 - the radius parameter is in world space.
 	//! [Default value] 0
	int get_radius_mode() const { return getInt("radius_mode"); }

	//! true to use raytracing to compute the rounded corners and false to use static mesh analysis.
 	//! [Default value] true
	bool set_raytraced(bool val) { return setValue("raytraced", val); }
	//! true to use raytracing to compute the rounded corners and false to use static mesh analysis.
 	//! [Default value] true
	bool get_raytraced() const { return getBool("raytraced"); }

	//! true to consider only corners on the same object, and false to consider other intersecting objects.
 	//! [UI Guides] displayName=Consider same object only, enableIf: ?raytraced=1
 	//! [Default value] true
	bool set_raytraced_consider_same_object_only(bool val) { return setValue("raytraced_consider_same_object_only", val); }
	//! true to consider only corners on the same object, and false to consider other intersecting objects.
 	//! [UI Guides] displayName=Consider same object only, enableIf: ?raytraced=1
 	//! [Default value] true
	bool get_raytraced_consider_same_object_only() const { return getBool("raytraced_consider_same_object_only"); }

	//! Which corners to smooth: 0 - both convex and concave; 1 - convex only; 2 - concave only.
 	//! [UI Guides] displayName=Mode, enableIf: ?raytraced=1, enum=0:Convex and Concave;1:Convex only;2:Concave only
 	//! [Default value] 0
	bool set_raytraced_mode(int val) { return setValue("raytraced_mode", val); }
	//! Which corners to smooth: 0 - both convex and concave; 1 - convex only; 2 - concave only.
 	//! [UI Guides] displayName=Mode, enableIf: ?raytraced=1, enum=0:Convex and Concave;1:Convex only;2:Concave only
 	//! [Default value] 0
	int get_raytraced_mode() const { return getInt("raytraced_mode"); }
};

class MtlSelectRE : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "MtlSelectRE"; }

	//! The base material. The alpha result of this material will be written to all alpha channels specified in the 'alpha_elements' parameter.
 	bool set_base_mtl(const Plugin& plugin) { return setValue("base_mtl", plugin); }
	//! The base material. The alpha result of this material will be written to all alpha channels specified in the 'alpha_elements' parameter.
 	Plugin get_base_mtl() const { return getPlugin("base_mtl"); }

	//! A list of alpha render elements.
 	bool set_alpha_elements(const ValueList& pluginList) { return setValue("alpha_elements", pluginList); }
	//! A list of alpha render elements.
 	ValueList get_alpha_elements() const { return getValueList("alpha_elements"); }
};

class MtlSingleBRDF : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "MtlSingleBRDF"; }

	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	bool set_filter(const Color& color) { return setValue("filter", color); }
	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	Color get_filter() const { return getColor("filter"); }

	//! (description missing)
	bool set_brdf(const Plugin& plugin) { return setValue("brdf", plugin); }
	//! (description missing)
	Plugin get_brdf() const { return getPlugin("brdf"); }

	//! 0 - single sided, 1 - to make the material double-sided, 2 - make back faces pointing at camera transparent for camera rays, 3 - make back faces transparent for all ray types except shadow rays, 4 - same as 3 but back faces are also visible to rays that have been refracted(and are not GI or reflection rays
 	//! [Default value] 1
	bool set_double_sided(int val) { return setValue("double_sided", val); }
	//! 0 - single sided, 1 - to make the material double-sided, 2 - make back faces pointing at camera transparent for camera rays, 3 - make back faces transparent for all ray types except shadow rays, 4 - same as 3 but back faces are also visible to rays that have been refracted(and are not GI or reflection rays
 	//! [Default value] 1
	int get_double_sided() const { return getInt("double_sided"); }

	//! true to allow negative color components; otherwise they will be clamped to 0
 	//! [Default value] false
	bool set_allow_negative_colors(bool val) { return setValue("allow_negative_colors", val); }
	//! true to allow negative color components; otherwise they will be clamped to 0
 	//! [Default value] false
	bool get_allow_negative_colors() const { return getBool("allow_negative_colors"); }
};

class MtlSkp2Sided : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "MtlSkp2Sided"; }

	//! the material for the surface on the same side as the normal
 	bool set_front(const Plugin& plugin) { return setValue("front", plugin); }
	//! the material for the surface on the same side as the normal
 	Plugin get_front() const { return getPlugin("front"); }

	//! the material for the side that is opposite the surface normal
 	bool set_back(const Plugin& plugin) { return setValue("back", plugin); }
	//! the material for the side that is opposite the surface normal
 	Plugin get_back() const { return getPlugin("back"); }

	//! 1 to make the sub-materials one-sided
 	//! [Default value] false
	bool set_force_1sided(bool val) { return setValue("force_1sided", val); }
	//! 1 to make the sub-materials one-sided
 	//! [Default value] false
	bool get_force_1sided() const { return getBool("force_1sided"); }
};

class MtlStreakFade : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "MtlStreakFade"; }

	//! Base material
 	bool set_base_mtl(const Plugin& plugin) { return setValue("base_mtl", plugin); }
	//! Base material
 	Plugin get_base_mtl() const { return getPlugin("base_mtl"); }

	//! 1.0f - no fade, < 1.0f - fade
 	//! [Default value] 1
	bool set_fade(float val) { return setValue("fade", val); }
	//! 1.0f - no fade, < 1.0f - fade
 	//! [Default value] 1
	float get_fade() const { return getFloat("fade"); }
};

class MtlToon : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "MtlToon"; }

	//! The material that should have toon lines added to it
 	bool set_base_mtl(const Plugin& plugin) { return setValue("base_mtl", plugin); }
	//! The material that should have toon lines added to it
 	Plugin get_base_mtl() const { return getPlugin("base_mtl"); }

	//! (description missing)
	//! [Default value] 1
	bool set_lineWidth(float val) { return setValue("lineWidth", val); }
	//! (description missing)
	//! [Default value] 1
	float get_lineWidth() const { return getFloat("lineWidth"); }

	//! (description missing)
	bool set_lineWidthTex(const Plugin& texturefloat) { return setValue("lineWidthTex", texturefloat); }
	//! (description missing)
	bool set_lineWidthTex(float texturefloat) { return setValue("lineWidthTex", texturefloat); }
	//! (description missing)
	Value get_lineWidthTex() const { return getValue("lineWidthTex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_lineWidthTexMult(float val) { return setValue("lineWidthTexMult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_lineWidthTexMult() const { return getFloat("lineWidthTexMult"); }

	//! (description missing)
	//! [Default value] 1
	bool set_opacity(float val) { return setValue("opacity", val); }
	//! (description missing)
	//! [Default value] 1
	float get_opacity() const { return getFloat("opacity"); }

	//! (description missing)
	bool set_opacityTex(const Plugin& texturefloat) { return setValue("opacityTex", texturefloat); }
	//! (description missing)
	bool set_opacityTex(float texturefloat) { return setValue("opacityTex", texturefloat); }
	//! (description missing)
	Value get_opacityTex() const { return getValue("opacityTex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_opacityTexMult(float val) { return setValue("opacityTexMult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_opacityTexMult() const { return getFloat("opacityTexMult"); }

	//! (description missing)
	//! [Default value] 0
	bool set_distort(float val) { return setValue("distort", val); }
	//! (description missing)
	//! [Default value] 0
	float get_distort() const { return getFloat("distort"); }

	//! (description missing)
	bool set_distortTex(const Plugin& texturefloat) { return setValue("distortTex", texturefloat); }
	//! (description missing)
	bool set_distortTex(float texturefloat) { return setValue("distortTex", texturefloat); }
	//! (description missing)
	Value get_distortTex() const { return getValue("distortTex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_distortTexMult(float val) { return setValue("distortTexMult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_distortTexMult() const { return getFloat("distortTexMult"); }

	//! (description missing)
	//! [Default value] Color(0, 0, 0)
	bool set_lineColor(const Color& color) { return setValue("lineColor", color); }
	//! (description missing)
	//! [Default value] Color(0, 0, 0)
	Color get_lineColor() const { return getColor("lineColor"); }

	//! (description missing)
	bool set_lineColorTex(const Plugin& texture) { return setValue("lineColorTex", texture); }
	//! (description missing)
	bool set_lineColorTex(const AColor& texture) { return setValue("lineColorTex", texture); }
	//! (description missing)
	Value get_lineColorTex() const { return getValue("lineColorTex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_lineColorTexMult(float val) { return setValue("lineColorTexMult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_lineColorTexMult() const { return getFloat("lineColorTexMult"); }

	//! (description missing)
	//! [Default value] 0.01
	bool set_zThreshold(float val) { return setValue("zThreshold", val); }
	//! (description missing)
	//! [Default value] 0.01
	float get_zThreshold() const { return getFloat("zThreshold"); }

	//! (description missing)
	//! [Default value] 0.01
	bool set_traceBias(float val) { return setValue("traceBias", val); }
	//! (description missing)
	//! [Default value] 0.01
	float get_traceBias() const { return getFloat("traceBias"); }

	//! (description missing)
	//! [Default value] 0.01
	bool set_normalThreshold(float val) { return setValue("normalThreshold", val); }
	//! (description missing)
	//! [Default value] 0.01
	float get_normalThreshold() const { return getFloat("normalThreshold"); }

	//! (description missing)
	//! [Default value] true
	bool set_doSecondary(bool val) { return setValue("doSecondary", val); }
	//! (description missing)
	//! [Default value] true
	bool get_doSecondary() const { return getBool("doSecondary"); }

	//! (description missing)
	//! [Default value] false
	bool set_divideByDist(bool val) { return setValue("divideByDist", val); }
	//! (description missing)
	//! [Default value] false
	bool get_divideByDist() const { return getBool("divideByDist"); }

	//! (description missing)
	//! [Default value] false
	bool set_doSilhouetteMult(bool val) { return setValue("doSilhouetteMult", val); }
	//! (description missing)
	//! [Default value] false
	bool get_doSilhouetteMult() const { return getBool("doSilhouetteMult"); }

	//! (description missing)
	//! [Default value] 1.5
	bool set_silhouetteMult(float val) { return setValue("silhouetteMult", val); }
	//! (description missing)
	//! [Default value] 1.5
	float get_silhouetteMult() const { return getFloat("silhouetteMult"); }

	//! Compensate for V-Ray physical camera exposure
 	//! [Default value] false
	bool set_compensateExposure(bool val) { return setValue("compensateExposure", val); }
	//! Compensate for V-Ray physical camera exposure
 	//! [Default value] false
	bool get_compensateExposure() const { return getBool("compensateExposure"); }
};

class MtlVRmat : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "MtlVRmat"; }

	//! [UI Guides] fileAsset=vrmat;vismat;vrscene, displayName=Material File, startTab=V-Ray VRmat, startRollout=Parameters
 	bool set_filename(const char* str) { return setValue("filename", str); }
	//! [UI Guides] fileAsset=vrmat;vismat;vrscene, displayName=Material File, startTab=V-Ray VRmat, startRollout=Parameters
 	bool set_filename(const std::string& str) { return setValue("filename", str); }
	//! [UI Guides] fileAsset=vrmat;vismat;vrscene, displayName=Material File, startTab=V-Ray VRmat, startRollout=Parameters
 	std::string get_filename() const { return getString("filename"); }

	//! [UI Guides] displayName=Material Name
 	bool set_mtlname(const char* str) { return setValue("mtlname", str); }
	//! [UI Guides] displayName=Material Name
 	bool set_mtlname(const std::string& str) { return setValue("mtlname", str); }
	//! [UI Guides] displayName=Material Name
 	std::string get_mtlname() const { return getString("mtlname"); }
};

class MtlWrapper : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "MtlWrapper"; }

	//! The base material
 	bool set_base_material(const Plugin& plugin) { return setValue("base_material", plugin); }
	//! The base material
 	Plugin get_base_material() const { return getPlugin("base_material"); }

	//! Allow enable/disable of irradiance map per surface.
 	//! [UI Guides] displayName=Use irradiance map, startRollout=Additional surface properties
 	//! [Default value] true
	bool set_use_irrad_map(bool val) { return setValue("use_irrad_map", val); }
	//! Allow enable/disable of irradiance map per surface.
 	//! [UI Guides] displayName=Use irradiance map, startRollout=Additional surface properties
 	//! [Default value] true
	bool get_use_irrad_map() const { return getBool("use_irrad_map"); }

	//! Controls the GI generated by the material.
 	//! [UI Guides] displayName=Generated GI mult., minValue=0.0
 	//! [Default value] 1
	bool set_generate_gi(float val) { return setValue("generate_gi", val); }
	//! Controls the GI generated by the material.
 	//! [UI Guides] displayName=Generated GI mult., minValue=0.0
 	//! [Default value] 1
	float get_generate_gi() const { return getFloat("generate_gi"); }

	//! Controls the GI received by the material.
 	//! [UI Guides] displayName=Received GI mult., minValue=0.0
 	//! [Default value] 1
	bool set_receive_gi(float val) { return setValue("receive_gi", val); }
	//! Controls the GI received by the material.
 	//! [UI Guides] displayName=Received GI mult., minValue=0.0
 	//! [Default value] 1
	float get_receive_gi() const { return getFloat("receive_gi"); }

	//! Controls the caustics generated by the material.
 	//! [UI Guides] displayName=Generated caustics mult., minValue=0.0
 	//! [Default value] 1
	bool set_generate_caustics(float val) { return setValue("generate_caustics", val); }
	//! Controls the caustics generated by the material.
 	//! [UI Guides] displayName=Generated caustics mult., minValue=0.0
 	//! [Default value] 1
	float get_generate_caustics() const { return getFloat("generate_caustics"); }

	//! Controls the caustics received by the material.
 	//! [UI Guides] displayName=Received caustics mult., minValue=0.0
 	//! [Default value] 1
	bool set_receive_caustics(float val) { return setValue("receive_caustics", val); }
	//! Controls the caustics received by the material.
 	//! [UI Guides] displayName=Received caustics mult., minValue=0.0
 	//! [Default value] 1
	float get_receive_caustics() const { return getFloat("receive_caustics"); }

	//! The contribution of the resulting color to the alpha channel.
 	//! [UI Guides] startRollout=Matte properties, minValue=-1, maxValue=1
 	//! [Default value] 1
	bool set_alpha_contribution(float val) { return setValue("alpha_contribution", val); }
	//! The contribution of the resulting color to the alpha channel.
 	//! [UI Guides] startRollout=Matte properties, minValue=-1, maxValue=1
 	//! [Default value] 1
	float get_alpha_contribution() const { return getFloat("alpha_contribution"); }

	//! Makes the material appear as a matte material, which shows the background, instead of the base material, when viewed directly.
 	//! [Default value] false
	bool set_matte_surface(bool val) { return setValue("matte_surface", val); }
	//! Makes the material appear as a matte material, which shows the background, instead of the base material, when viewed directly.
 	//! [Default value] false
	bool get_matte_surface() const { return getBool("matte_surface"); }

	//! Turn this on to make shadows visible on the matte surface.
 	//! [UI Guides] enableIf: ?matte_surface=1
 	//! [Default value] false
	bool set_shadows(bool val) { return setValue("shadows", val); }
	//! Turn this on to make shadows visible on the matte surface.
 	//! [UI Guides] enableIf: ?matte_surface=1
 	//! [Default value] false
	bool get_shadows() const { return getBool("shadows"); }

	//! Turn this on to make shadows affect the alpha contribution of the matte surface.
 	//! [UI Guides] enableIf: ?matte_surface=1
 	//! [Default value] false
	bool set_affect_alpha(bool val) { return setValue("affect_alpha", val); }
	//! Turn this on to make shadows affect the alpha contribution of the matte surface.
 	//! [UI Guides] enableIf: ?matte_surface=1
 	//! [Default value] false
	bool get_affect_alpha() const { return getBool("affect_alpha"); }

	//! Tint for the shadows on the matte surface.
 	//! [UI Guides] enableIf: ?matte_surface=1
 	//! [Default value] Color(0, 0, 0)
	bool set_shadow_tint_color(const Color& color) { return setValue("shadow_tint_color", color); }
	//! Tint for the shadows on the matte surface.
 	//! [UI Guides] enableIf: ?matte_surface=1
 	//! [Default value] Color(0, 0, 0)
	Color get_shadow_tint_color() const { return getColor("shadow_tint_color"); }

	//! An optional brightness parameter for the shadows on the matte surface.A value of 0.0 will make the shadows completely invisible, while a value of 1.0 will show the full shadows.
 	//! [UI Guides] enableIf: ?matte_surface=1, minValue=0, maxValue=1
 	//! [Default value] 1
	bool set_shadow_brightness(float val) { return setValue("shadow_brightness", val); }
	//! An optional brightness parameter for the shadows on the matte surface.A value of 0.0 will make the shadows completely invisible, while a value of 1.0 will show the full shadows.
 	//! [UI Guides] enableIf: ?matte_surface=1, minValue=0, maxValue=1
 	//! [Default value] 1
	float get_shadow_brightness() const { return getFloat("shadow_brightness"); }

	//! Shows the reflections of the base material.
 	//! [UI Guides] enableIf: ?matte_surface=1, minValue=0, maxValue=1
 	//! [Default value] 1
	bool set_reflection_amount(float val) { return setValue("reflection_amount", val); }
	//! Shows the reflections of the base material.
 	//! [UI Guides] enableIf: ?matte_surface=1, minValue=0, maxValue=1
 	//! [Default value] 1
	float get_reflection_amount() const { return getFloat("reflection_amount"); }

	//! Shows the refractions of the base material.
 	//! [UI Guides] enableIf: ?matte_surface=1, minValue=0, maxValue=1
 	//! [Default value] 1
	bool set_refraction_amount(float val) { return setValue("refraction_amount", val); }
	//! Shows the refractions of the base material.
 	//! [UI Guides] enableIf: ?matte_surface=1, minValue=0, maxValue=1
 	//! [Default value] 1
	float get_refraction_amount() const { return getFloat("refraction_amount"); }

	//! Determines the amount of gi shadows.
 	//! [UI Guides] displayName=GI amount, enableIf: ?matte_surface=1, minValue=0, maxValue=1
 	//! [Default value] 1
	bool set_gi_amount(float val) { return setValue("gi_amount", val); }
	//! Determines the amount of gi shadows.
 	//! [UI Guides] displayName=GI amount, enableIf: ?matte_surface=1, minValue=0, maxValue=1
 	//! [Default value] 1
	float get_gi_amount() const { return getFloat("gi_amount"); }

	//! This will cause the material to appear as a matte object in reflections, refractions, GI etc for other matte objects.
 	//! [UI Guides] displayName=No GI on other mattes, enableIf: ?matte_surface=1
 	//! [Default value] true
	bool set_no_gi_on_other_mattes(bool val) { return setValue("no_gi_on_other_mattes", val); }
	//! This will cause the material to appear as a matte object in reflections, refractions, GI etc for other matte objects.
 	//! [UI Guides] displayName=No GI on other mattes, enableIf: ?matte_surface=1
 	//! [Default value] true
	bool get_no_gi_on_other_mattes() const { return getBool("no_gi_on_other_mattes"); }

	//! Set this to 1 to make the material act as matte for all secondary rays (reflections and refractions); if set to 2, the material will perform automatic projection mapping of the environment map on the matte geometry
 	//! [UI Guides] displayName=Matte for sec. rays, enum=0:Disable;1:Without Projection Mapping;2:With Projection Mapping, enableIf: ?matte_surface=1
 	//! [Default value] 0
	bool set_matte_for_secondary_rays(int val) { return setValue("matte_for_secondary_rays", val); }
	//! Set this to 1 to make the material act as matte for all secondary rays (reflections and refractions); if set to 2, the material will perform automatic projection mapping of the environment map on the matte geometry
 	//! [UI Guides] displayName=Matte for sec. rays, enum=0:Disable;1:Without Projection Mapping;2:With Projection Mapping, enableIf: ?matte_surface=1
 	//! [Default value] 0
	int get_matte_for_secondary_rays() const { return getInt("matte_for_secondary_rays"); }

	//! If two objects have different GI surface ids, the light cache samples of the two objects will not be blended.
 	//! [UI Guides] displayName=GI surface ID, minValue0, startRollout=Miscellaneous
 	//! [Default value] 0
	bool set_gi_surface_id(int val) { return setValue("gi_surface_id", val); }
	//! If two objects have different GI surface ids, the light cache samples of the two objects will not be blended.
 	//! [UI Guides] displayName=GI surface ID, minValue0, startRollout=Miscellaneous
 	//! [Default value] 0
	int get_gi_surface_id() const { return getInt("gi_surface_id"); }

	//! This is a multiplier for the subdivisions of all secondary ray tracing done for the particular surface.
 	//! [UI Guides] displayName=Subdivs multiplier, minValue0.0
 	//! [Default value] 1
	bool set_gi_quality_multiplier(float val) { return setValue("gi_quality_multiplier", val); }
	//! This is a multiplier for the subdivisions of all secondary ray tracing done for the particular surface.
 	//! [UI Guides] displayName=Subdivs multiplier, minValue0.0
 	//! [Default value] 1
	float get_gi_quality_multiplier() const { return getFloat("gi_quality_multiplier"); }

	//! Setting this to true will make the matte alpha opaque so that the alpha of objects behind the matte won't be seen.
 	//! [Default value] false
	bool set_maya_background_shader_compatibility(bool val) { return setValue("maya_background_shader_compatibility", val); }
	//! Setting this to true will make the matte alpha opaque so that the alpha of objects behind the matte won't be seen.
 	//! [Default value] false
	bool get_maya_background_shader_compatibility() const { return getBool("maya_background_shader_compatibility"); }

	//! Same as alpha_contribution but used for the Maya's useBackground shader which supports textures as alpha contribution
 	bool set_alpha_contribution_tex(const Plugin& texturefloat) { return setValue("alpha_contribution_tex", texturefloat); }
	//! Same as alpha_contribution but used for the Maya's useBackground shader which supports textures as alpha contribution
 	bool set_alpha_contribution_tex(float texturefloat) { return setValue("alpha_contribution_tex", texturefloat); }
	//! Same as alpha_contribution but used for the Maya's useBackground shader which supports textures as alpha contribution
 	Value get_alpha_contribution_tex() const { return getValue("alpha_contribution_tex"); }

	//! Same as shadow_brightness but used for the Maya's useBackground shader which supports textures as shadow brightness
 	bool set_shadow_brightness_tex(const Plugin& texturefloat) { return setValue("shadow_brightness_tex", texturefloat); }
	//! Same as shadow_brightness but used for the Maya's useBackground shader which supports textures as shadow brightness
 	bool set_shadow_brightness_tex(float texturefloat) { return setValue("shadow_brightness_tex", texturefloat); }
	//! Same as shadow_brightness but used for the Maya's useBackground shader which supports textures as shadow brightness
 	Value get_shadow_brightness_tex() const { return getValue("shadow_brightness_tex"); }

	//! (description missing)
	bool set_reflection_filter_tex(const Plugin& texture) { return setValue("reflection_filter_tex", texture); }
	//! (description missing)
	bool set_reflection_filter_tex(const AColor& texture) { return setValue("reflection_filter_tex", texture); }
	//! (description missing)
	Value get_reflection_filter_tex() const { return getValue("reflection_filter_tex"); }

	//! The maximum reflection depth (-1 is controlled by the global options)
 	//! [Default value] -1
	bool set_trace_depth(int val) { return setValue("trace_depth", val); }
	//! The maximum reflection depth (-1 is controlled by the global options)
 	//! [Default value] -1
	int get_trace_depth() const { return getInt("trace_depth"); }

	//! Render channels the result of this BRDF will be written to
 	bool set_channels(const ValueList& pluginList) { return setValue("channels", pluginList); }
	//! Render channels the result of this BRDF will be written to
 	ValueList get_channels() const { return getValueList("channels"); }

	//! Setting this to false makes objects to not affect the render elements.
 	//! [Default value] true
	bool set_generate_render_elements(bool val) { return setValue("generate_render_elements", val); }
	//! Setting this to false makes objects to not affect the render elements.
 	//! [Default value] true
	bool get_generate_render_elements() const { return getBool("generate_render_elements"); }

	//! A list of plugins that will be excluded from reflections.
 	//! [UI Guides] attributes=objectSet, startRollout=
 	bool set_reflection_exclude(const ValueList& pluginList) { return setValue("reflection_exclude", pluginList); }
	//! A list of plugins that will be excluded from reflections.
 	//! [UI Guides] attributes=objectSet, startRollout=
 	ValueList get_reflection_exclude() const { return getValueList("reflection_exclude"); }

	//! Setting this to true will turn the reflection exclude list into inclusive (inverted).
 	//! [Default value] false
	bool set_reflection_list_is_inclusive(bool val) { return setValue("reflection_list_is_inclusive", val); }
	//! Setting this to true will turn the reflection exclude list into inclusive (inverted).
 	//! [Default value] false
	bool get_reflection_list_is_inclusive() const { return getBool("reflection_list_is_inclusive"); }

	//! A list of plugins that will be excluded from refractions.
 	//! [UI Guides] attributes=objectSet, startRollout=
 	bool set_refraction_exclude(const ValueList& pluginList) { return setValue("refraction_exclude", pluginList); }
	//! A list of plugins that will be excluded from refractions.
 	//! [UI Guides] attributes=objectSet, startRollout=
 	ValueList get_refraction_exclude() const { return getValueList("refraction_exclude"); }

	//! Setting this to true will turn the refraction exclude list into inclusive (inverted).
 	//! [Default value] false
	bool set_refraction_list_is_inclusive(bool val) { return setValue("refraction_list_is_inclusive", val); }
	//! Setting this to true will turn the refraction exclude list into inclusive (inverted).
 	//! [Default value] false
	bool get_refraction_list_is_inclusive() const { return getBool("refraction_list_is_inclusive"); }
};

class MtlWrapperMaya : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "MtlWrapperMaya"; }

	//! The base material
 	bool set_base_material(const Plugin& plugin) { return setValue("base_material", plugin); }
	//! The base material
 	Plugin get_base_material() const { return getPlugin("base_material"); }

	//! Allow enable/disable of irradiance map per surface.
 	//! [UI Guides] displayName=Use irradiance map, startRollout=Additional surface properties
 	//! [Default value] true
	bool set_use_irrad_map(bool val) { return setValue("use_irrad_map", val); }
	//! Allow enable/disable of irradiance map per surface.
 	//! [UI Guides] displayName=Use irradiance map, startRollout=Additional surface properties
 	//! [Default value] true
	bool get_use_irrad_map() const { return getBool("use_irrad_map"); }

	//! Controls the GI generated by the material.
 	//! [UI Guides] displayName=Generated GI mult., minValue=0.0
 	//! [Default value] 1
	bool set_generate_gi(float val) { return setValue("generate_gi", val); }
	//! Controls the GI generated by the material.
 	//! [UI Guides] displayName=Generated GI mult., minValue=0.0
 	//! [Default value] 1
	float get_generate_gi() const { return getFloat("generate_gi"); }

	//! Controls the GI received by the material.
 	//! [UI Guides] displayName=Received GI mult., minValue=0.0
 	//! [Default value] 1
	bool set_receive_gi(float val) { return setValue("receive_gi", val); }
	//! Controls the GI received by the material.
 	//! [UI Guides] displayName=Received GI mult., minValue=0.0
 	//! [Default value] 1
	float get_receive_gi() const { return getFloat("receive_gi"); }

	//! Controls the caustics generated by the material.
 	//! [UI Guides] displayName=Generated caustics mult., minValue=0.0
 	//! [Default value] 1
	bool set_generate_caustics(float val) { return setValue("generate_caustics", val); }
	//! Controls the caustics generated by the material.
 	//! [UI Guides] displayName=Generated caustics mult., minValue=0.0
 	//! [Default value] 1
	float get_generate_caustics() const { return getFloat("generate_caustics"); }

	//! Controls the caustics received by the material.
 	//! [UI Guides] displayName=Received caustics mult., minValue=0.0
 	//! [Default value] 1
	bool set_receive_caustics(float val) { return setValue("receive_caustics", val); }
	//! Controls the caustics received by the material.
 	//! [UI Guides] displayName=Received caustics mult., minValue=0.0
 	//! [Default value] 1
	float get_receive_caustics() const { return getFloat("receive_caustics"); }

	//! The contribution of the resulting color to the alpha channel.
 	//! [UI Guides] startRollout=Matte properties, minValue=-1, maxValue=1
 	//! [Default value] 1
	bool set_alpha_contribution(float val) { return setValue("alpha_contribution", val); }
	//! The contribution of the resulting color to the alpha channel.
 	//! [UI Guides] startRollout=Matte properties, minValue=-1, maxValue=1
 	//! [Default value] 1
	float get_alpha_contribution() const { return getFloat("alpha_contribution"); }

	//! Makes the material appear as a matte material, which shows the background, instead of the base material, when viewed directly.
 	//! [Default value] false
	bool set_matte_surface(bool val) { return setValue("matte_surface", val); }
	//! Makes the material appear as a matte material, which shows the background, instead of the base material, when viewed directly.
 	//! [Default value] false
	bool get_matte_surface() const { return getBool("matte_surface"); }

	//! Turn this on to make shadows visible on the matte surface.
 	//! [UI Guides] enableIf: ?matte_surface=1
 	//! [Default value] false
	bool set_shadows(bool val) { return setValue("shadows", val); }
	//! Turn this on to make shadows visible on the matte surface.
 	//! [UI Guides] enableIf: ?matte_surface=1
 	//! [Default value] false
	bool get_shadows() const { return getBool("shadows"); }

	//! Turn this on to make shadows affect the alpha contribution of the matte surface.
 	//! [UI Guides] enableIf: ?matte_surface=1
 	//! [Default value] false
	bool set_affect_alpha(bool val) { return setValue("affect_alpha", val); }
	//! Turn this on to make shadows affect the alpha contribution of the matte surface.
 	//! [UI Guides] enableIf: ?matte_surface=1
 	//! [Default value] false
	bool get_affect_alpha() const { return getBool("affect_alpha"); }

	//! Tint for the shadows on the matte surface.
 	//! [UI Guides] enableIf: ?matte_surface=1
 	//! [Default value] Color(0, 0, 0)
	bool set_shadow_tint_color(const Color& color) { return setValue("shadow_tint_color", color); }
	//! Tint for the shadows on the matte surface.
 	//! [UI Guides] enableIf: ?matte_surface=1
 	//! [Default value] Color(0, 0, 0)
	Color get_shadow_tint_color() const { return getColor("shadow_tint_color"); }

	//! An optional brightness parameter for the shadows on the matte surface.A value of 0.0 will make the shadows completely invisible, while a value of 1.0 will show the full shadows.
 	//! [UI Guides] enableIf: ?matte_surface=1, minValue=0, maxValue=1
 	//! [Default value] 1
	bool set_shadow_brightness(float val) { return setValue("shadow_brightness", val); }
	//! An optional brightness parameter for the shadows on the matte surface.A value of 0.0 will make the shadows completely invisible, while a value of 1.0 will show the full shadows.
 	//! [UI Guides] enableIf: ?matte_surface=1, minValue=0, maxValue=1
 	//! [Default value] 1
	float get_shadow_brightness() const { return getFloat("shadow_brightness"); }

	//! Shows the reflections of the base material.
 	//! [UI Guides] enableIf: ?matte_surface=1, minValue=0, maxValue=1
 	//! [Default value] 1
	bool set_reflection_amount(float val) { return setValue("reflection_amount", val); }
	//! Shows the reflections of the base material.
 	//! [UI Guides] enableIf: ?matte_surface=1, minValue=0, maxValue=1
 	//! [Default value] 1
	float get_reflection_amount() const { return getFloat("reflection_amount"); }

	//! Shows the refractions of the base material.
 	//! [UI Guides] enableIf: ?matte_surface=1, minValue=0, maxValue=1
 	//! [Default value] 1
	bool set_refraction_amount(float val) { return setValue("refraction_amount", val); }
	//! Shows the refractions of the base material.
 	//! [UI Guides] enableIf: ?matte_surface=1, minValue=0, maxValue=1
 	//! [Default value] 1
	float get_refraction_amount() const { return getFloat("refraction_amount"); }

	//! Determines the amount of gi shadows.
 	//! [UI Guides] displayName=GI amount, enableIf: ?matte_surface=1, minValue=0, maxValue=1
 	//! [Default value] 1
	bool set_gi_amount(float val) { return setValue("gi_amount", val); }
	//! Determines the amount of gi shadows.
 	//! [UI Guides] displayName=GI amount, enableIf: ?matte_surface=1, minValue=0, maxValue=1
 	//! [Default value] 1
	float get_gi_amount() const { return getFloat("gi_amount"); }

	//! This will cause the material to appear as a matte object in reflections, refractions, GI etc for other matte objects.
 	//! [UI Guides] displayName=No GI on other mattes, enableIf: ?matte_surface=1
 	//! [Default value] true
	bool set_no_gi_on_other_mattes(bool val) { return setValue("no_gi_on_other_mattes", val); }
	//! This will cause the material to appear as a matte object in reflections, refractions, GI etc for other matte objects.
 	//! [UI Guides] displayName=No GI on other mattes, enableIf: ?matte_surface=1
 	//! [Default value] true
	bool get_no_gi_on_other_mattes() const { return getBool("no_gi_on_other_mattes"); }

	//! Set this to 1 to make the material act as matte for all secondary rays (reflections and refractions); if set to 2, the material will perform automatic projection mapping of the environment map on the matte geometry
 	//! [UI Guides] displayName=Matte for sec. rays, enum=0:Disable;1:Without Projection Mapping;2:With Projection Mapping, enableIf: ?matte_surface=1
 	//! [Default value] 0
	bool set_matte_for_secondary_rays(int val) { return setValue("matte_for_secondary_rays", val); }
	//! Set this to 1 to make the material act as matte for all secondary rays (reflections and refractions); if set to 2, the material will perform automatic projection mapping of the environment map on the matte geometry
 	//! [UI Guides] displayName=Matte for sec. rays, enum=0:Disable;1:Without Projection Mapping;2:With Projection Mapping, enableIf: ?matte_surface=1
 	//! [Default value] 0
	int get_matte_for_secondary_rays() const { return getInt("matte_for_secondary_rays"); }

	//! If two objects have different GI surface ids, the light cache samples of the two objects will not be blended.
 	//! [UI Guides] displayName=GI surface ID, minValue0, startRollout=Miscellaneous
 	//! [Default value] 0
	bool set_gi_surface_id(int val) { return setValue("gi_surface_id", val); }
	//! If two objects have different GI surface ids, the light cache samples of the two objects will not be blended.
 	//! [UI Guides] displayName=GI surface ID, minValue0, startRollout=Miscellaneous
 	//! [Default value] 0
	int get_gi_surface_id() const { return getInt("gi_surface_id"); }

	//! This is a multiplier for the subdivisions of all secondary ray tracing done for the particular surface.
 	//! [UI Guides] displayName=Subdivs multiplier, minValue0.0
 	//! [Default value] 1
	bool set_gi_quality_multiplier(float val) { return setValue("gi_quality_multiplier", val); }
	//! This is a multiplier for the subdivisions of all secondary ray tracing done for the particular surface.
 	//! [UI Guides] displayName=Subdivs multiplier, minValue0.0
 	//! [Default value] 1
	float get_gi_quality_multiplier() const { return getFloat("gi_quality_multiplier"); }

	//! Setting this to true will make the matte alpha opaque so that the alpha of objects behind the matte won't be seen.
 	//! [Default value] false
	bool set_maya_background_shader_compatibility(bool val) { return setValue("maya_background_shader_compatibility", val); }
	//! Setting this to true will make the matte alpha opaque so that the alpha of objects behind the matte won't be seen.
 	//! [Default value] false
	bool get_maya_background_shader_compatibility() const { return getBool("maya_background_shader_compatibility"); }

	//! Same as alpha_contribution but used for the Maya's useBackground shader which supports textures as alpha contribution
 	bool set_alpha_contribution_tex(const Plugin& texturefloat) { return setValue("alpha_contribution_tex", texturefloat); }
	//! Same as alpha_contribution but used for the Maya's useBackground shader which supports textures as alpha contribution
 	bool set_alpha_contribution_tex(float texturefloat) { return setValue("alpha_contribution_tex", texturefloat); }
	//! Same as alpha_contribution but used for the Maya's useBackground shader which supports textures as alpha contribution
 	Value get_alpha_contribution_tex() const { return getValue("alpha_contribution_tex"); }

	//! Same as shadow_brightness but used for the Maya's useBackground shader which supports textures as shadow brightness
 	bool set_shadow_brightness_tex(const Plugin& texturefloat) { return setValue("shadow_brightness_tex", texturefloat); }
	//! Same as shadow_brightness but used for the Maya's useBackground shader which supports textures as shadow brightness
 	bool set_shadow_brightness_tex(float texturefloat) { return setValue("shadow_brightness_tex", texturefloat); }
	//! Same as shadow_brightness but used for the Maya's useBackground shader which supports textures as shadow brightness
 	Value get_shadow_brightness_tex() const { return getValue("shadow_brightness_tex"); }

	//! (description missing)
	bool set_reflection_filter_tex(const Plugin& texture) { return setValue("reflection_filter_tex", texture); }
	//! (description missing)
	bool set_reflection_filter_tex(const AColor& texture) { return setValue("reflection_filter_tex", texture); }
	//! (description missing)
	Value get_reflection_filter_tex() const { return getValue("reflection_filter_tex"); }

	//! The maximum reflection depth (-1 is controlled by the global options)
 	//! [Default value] -1
	bool set_trace_depth(int val) { return setValue("trace_depth", val); }
	//! The maximum reflection depth (-1 is controlled by the global options)
 	//! [Default value] -1
	int get_trace_depth() const { return getInt("trace_depth"); }

	//! Render channels the result of this BRDF will be written to
 	bool set_channels(const ValueList& pluginList) { return setValue("channels", pluginList); }
	//! Render channels the result of this BRDF will be written to
 	ValueList get_channels() const { return getValueList("channels"); }

	//! Setting this to false makes objects to not affect the render elements.
 	//! [Default value] true
	bool set_generate_render_elements(bool val) { return setValue("generate_render_elements", val); }
	//! Setting this to false makes objects to not affect the render elements.
 	//! [Default value] true
	bool get_generate_render_elements() const { return getBool("generate_render_elements"); }

	//! A list of plugins that will be excluded from reflections.
 	//! [UI Guides] attributes=objectSet, startRollout=
 	bool set_reflection_exclude(const ValueList& pluginList) { return setValue("reflection_exclude", pluginList); }
	//! A list of plugins that will be excluded from reflections.
 	//! [UI Guides] attributes=objectSet, startRollout=
 	ValueList get_reflection_exclude() const { return getValueList("reflection_exclude"); }

	//! Setting this to true will turn the reflection exclude list into inclusive (inverted).
 	//! [Default value] false
	bool set_reflection_list_is_inclusive(bool val) { return setValue("reflection_list_is_inclusive", val); }
	//! Setting this to true will turn the reflection exclude list into inclusive (inverted).
 	//! [Default value] false
	bool get_reflection_list_is_inclusive() const { return getBool("reflection_list_is_inclusive"); }

	//! A list of plugins that will be excluded from refractions.
 	//! [UI Guides] attributes=objectSet, startRollout=
 	bool set_refraction_exclude(const ValueList& pluginList) { return setValue("refraction_exclude", pluginList); }
	//! A list of plugins that will be excluded from refractions.
 	//! [UI Guides] attributes=objectSet, startRollout=
 	ValueList get_refraction_exclude() const { return getValueList("refraction_exclude"); }

	//! Setting this to true will turn the refraction exclude list into inclusive (inverted).
 	//! [Default value] false
	bool set_refraction_list_is_inclusive(bool val) { return setValue("refraction_list_is_inclusive", val); }
	//! Setting this to true will turn the refraction exclude list into inclusive (inverted).
 	//! [Default value] false
	bool get_refraction_list_is_inclusive() const { return getBool("refraction_list_is_inclusive"); }
};

class NURBSCurve : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "NURBSCurve"; }

	//! Degree of the curve
 	//! [Default value] 3
	bool set_degree(int val) { return setValue("degree", val); }
	//! Degree of the curve
 	//! [Default value] 3
	int get_degree() const { return getInt("degree"); }

	//! The control vertices of the curve
 	//! [Default value] Vector(0, 0, 0)
	bool set_cvs(const VectorList& vectorList) { return setValue("cvs", vectorList); }
	//! The control vertices of the curve
 	//! [Default value] Vector(0, 0, 0)
	bool set_cvs(const Vector* vectors, size_t count) { return setArray("cvs", vectors, count); }
	//! The control vertices of the curve
 	//! [Default value] Vector(0, 0, 0)
	template<size_t count> bool set_cvs(const Vector (&vectors)[count]) { return setArray("cvs", vectors, count); }
	//! The control vertices of the curve
 	//! [Default value] Vector(0, 0, 0)
	VectorList get_cvs() const { return getVectorList("cvs"); }

	//! The knots vector for the curve
 	//! [Default value] 0
	bool set_knotVector(const FloatList& floatList) { return setValue("knotVector", floatList); }
	//! The knots vector for the curve
 	//! [Default value] 0
	bool set_knotVector(const float* floats, size_t count) { return setArray("knotVector", floats, count); }
	//! The knots vector for the curve
 	//! [Default value] 0
	template<size_t count> bool set_knotVector(const float (&floats)[count]) { return setArray("knotVector", floats, count); }
	//! The knots vector for the curve
 	//! [Default value] 0
	FloatList get_knotVector() const { return getFloatList("knotVector"); }

	//! Mark curve as island or hole
 	//! [Default value] true
	bool set_boundary(const Value& boolList) { return setValue("boundary", boolList); }
	//! Mark curve as island or hole
 	//! [Default value] true
	Value get_boundary() const { return getValue("boundary"); }
};

class Node : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "Node"; }

	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	bool set_transform(const Transform& transform) { return setValue("transform", transform); }
	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	Transform get_transform() const { return getTransform("transform"); }

	//! (description missing)
	bool set_geometry(const Plugin& plugin) { return setValue("geometry", plugin); }
	//! (description missing)
	Plugin get_geometry() const { return getPlugin("geometry"); }

	//! (description missing)
	bool set_material(const Plugin& plugin) { return setValue("material", plugin); }
	//! (description missing)
	Plugin get_material() const { return getPlugin("material"); }

	//! (description missing)
	bool set_volume(const Plugin& plugin) { return setValue("volume", plugin); }
	//! (description missing)
	Plugin get_volume() const { return getPlugin("volume"); }

	//! Number of transform samples
 	//! [Default value] 0
	bool set_nsamples(int val) { return setValue("nsamples", val); }
	//! Number of transform samples
 	//! [Default value] 0
	int get_nsamples() const { return getInt("nsamples"); }

	//! (description missing)
	bool set_lights(const ValueList& pluginList) { return setValue("lights", pluginList); }
	//! (description missing)
	ValueList get_lights() const { return getValueList("lights"); }

	//! true if the object is renderable (visible) and false otherwise; it only makes sense to use this parameter if it is animated, or if another object depends on this node but it must not be rendered
 	//! [Default value] true
	bool set_visible(bool val) { return setValue("visible", val); }
	//! true if the object is renderable (visible) and false otherwise; it only makes sense to use this parameter if it is animated, or if another object depends on this node but it must not be rendered
 	//! [Default value] true
	bool get_visible() const { return getBool("visible"); }

	//! A list of user defined attributes
 	bool set_user_attributes(const char* str) { return setValue("user_attributes", str); }
	//! A list of user defined attributes
 	bool set_user_attributes(const std::string& str) { return setValue("user_attributes", str); }
	//! A list of user defined attributes
 	std::string get_user_attributes() const { return getString("user_attributes"); }

	//! Object ID for the rendering
 	//! [Default value] 0
	bool set_objectID(int val) { return setValue("objectID", val); }
	//! Object ID for the rendering
 	//! [Default value] 0
	int get_objectID() const { return getInt("objectID"); }

	//! If off shading an intersection with this mesh will not generate a gbuffer.
 	//! [Default value] true
	bool set_primary_visibility(bool val) { return setValue("primary_visibility", val); }
	//! If off shading an intersection with this mesh will not generate a gbuffer.
 	//! [Default value] true
	bool get_primary_visibility() const { return getBool("primary_visibility"); }

	//! If this is used (controlled by 'use_time_for_geometry') it will be given as the time for which the instance should be created and the geometry should be compiled for geometry that supports the StaticGeomSourceForTimeInterface interface. Note that this time will not be used for the transform of the node - the current frame time will be used for that
 	//! [Default value] 0
	bool set_time_for_geometry(float val) { return setValue("time_for_geometry", val); }
	//! If this is used (controlled by 'use_time_for_geometry') it will be given as the time for which the instance should be created and the geometry should be compiled for geometry that supports the StaticGeomSourceForTimeInterface interface. Note that this time will not be used for the transform of the node - the current frame time will be used for that
 	//! [Default value] 0
	float get_time_for_geometry() const { return getFloat("time_for_geometry"); }

	//! If true the 'time_for_geometry' parameter will be used
 	//! [Default value] false
	bool set_use_time_for_geometry(bool val) { return setValue("use_time_for_geometry", val); }
	//! If true the 'time_for_geometry' parameter will be used
 	//! [Default value] false
	bool get_use_time_for_geometry() const { return getBool("use_time_for_geometry"); }
};

class OutputDeepWriter : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "OutputDeepWriter"; }

	//! The name of the file in which the shade map information is stored.
 	//! [UI Guides] fileAsset=vrst
 	bool set_file(const char* str) { return setValue("file", str); }
	//! The name of the file in which the shade map information is stored.
 	//! [UI Guides] fileAsset=vrst
 	bool set_file(const std::string& str) { return setValue("file", str); }
	//! The name of the file in which the shade map information is stored.
 	//! [UI Guides] fileAsset=vrst
 	std::string get_file() const { return getString("file"); }

	//! Store 32 bit (single precision) color channels in the shade map. When off 16 bit (half precision) values are stored.
 	//! [Default value] false
	bool set_float_colors_mode(bool val) { return setValue("float_colors_mode", val); }
	//! Store 32 bit (single precision) color channels in the shade map. When off 16 bit (half precision) values are stored.
 	//! [Default value] false
	bool get_float_colors_mode() const { return getBool("float_colors_mode"); }

	//! Compression type for the .vrst files (0 - no compression, 1 - ZLIB compression)
 	//! [UI Guides] enum=0:None;1:ZLIB
 	//! [Default value] 1
	bool set_vrst_compression(int val) { return setValue("vrst_compression", val); }
	//! Compression type for the .vrst files (0 - no compression, 1 - ZLIB compression)
 	//! [UI Guides] enum=0:None;1:ZLIB
 	//! [Default value] 1
	int get_vrst_compression() const { return getInt("vrst_compression"); }

	//! Compression type for the .exr files (0 - no compression, 1 - RLE compression, 2 - ZIPS compression)
 	//! [UI Guides] enum=0:None;1:RLE;2:ZIPS
 	//! [Default value] 2
	bool set_exr_compression(int val) { return setValue("exr_compression", val); }
	//! Compression type for the .exr files (0 - no compression, 1 - RLE compression, 2 - ZIPS compression)
 	//! [UI Guides] enum=0:None;1:RLE;2:ZIPS
 	//! [Default value] 2
	int get_exr_compression() const { return getInt("exr_compression"); }
};

class OutputTest : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "OutputTest"; }
};

class ParticleTex : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "ParticleTex"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! (description missing)
	//! [Default value] false
	bool set_use_3d_mapping(bool val) { return setValue("use_3d_mapping", val); }
	//! (description missing)
	//! [Default value] false
	bool get_use_3d_mapping() const { return getBool("use_3d_mapping"); }

	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	bool set_placement_type(int val) { return setValue("placement_type", val); }
	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	int get_placement_type() const { return getInt("placement_type"); }

	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_u(float val) { return setValue("u", val); }
	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_u() const { return getFloat("u"); }

	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_v(float val) { return setValue("v", val); }
	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_v() const { return getFloat("v"); }

	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_w(float val) { return setValue("w", val); }
	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_w() const { return getFloat("w"); }

	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_h(float val) { return setValue("h", val); }
	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_h() const { return getFloat("h"); }

	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	bool set_jitter(float val) { return setValue("jitter", val); }
	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	float get_jitter() const { return getFloat("jitter"); }

	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_u(bool val) { return setValue("tile_u", val); }
	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_u() const { return getBool("tile_u"); }

	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_v(bool val) { return setValue("tile_v", val); }
	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_v() const { return getBool("tile_v"); }

	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool set_uv_noise_on(bool val) { return setValue("uv_noise_on", val); }
	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool get_uv_noise_on() const { return getBool("uv_noise_on"); }

	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool set_uv_noise_animate(bool val) { return setValue("uv_noise_animate", val); }
	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool get_uv_noise_animate() const { return getBool("uv_noise_animate"); }

	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	bool set_uv_noise_amount(float val) { return setValue("uv_noise_amount", val); }
	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	float get_uv_noise_amount() const { return getFloat("uv_noise_amount"); }

	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	bool set_uv_noise_levels(float val) { return setValue("uv_noise_levels", val); }
	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	float get_uv_noise_levels() const { return getFloat("uv_noise_levels"); }

	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	bool set_uv_noise_size(float val) { return setValue("uv_noise_size", val); }
	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	float get_uv_noise_size() const { return getFloat("uv_noise_size"); }

	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	bool set_un_noise_phase(float val) { return setValue("un_noise_phase", val); }
	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	float get_un_noise_phase() const { return getFloat("un_noise_phase"); }

	//! (description missing)
	//! [Default value] false
	bool set_blend_alpha(bool val) { return setValue("blend_alpha", val); }
	//! (description missing)
	//! [Default value] false
	bool get_blend_alpha() const { return getBool("blend_alpha"); }

	//! 0: Equal; 1: Proportional; 2: Biggest
 	//! [UI Guides] enum=0: Equal; 1: Proportional; 2: Biggest
 	//! [Default value] 1
	bool set_blend_method(int val) { return setValue("blend_method", val); }
	//! 0: Equal; 1: Proportional; 2: Biggest
 	//! [UI Guides] enum=0: Equal; 1: Proportional; 2: Biggest
 	//! [Default value] 1
	int get_blend_method() const { return getInt("blend_method"); }

	//! 0: not per particle; 1: pp color; 2: pp emission 1; 3: pp user color 1; etc...
 	//! [Default value] 1
	bool set_color_mode(int val) { return setValue("color_mode", val); }
	//! 0: not per particle; 1: pp color; 2: pp emission 1; 3: pp user color 1; etc...
 	//! [Default value] 1
	int get_color_mode() const { return getInt("color_mode"); }

	//! (description missing)
	bool set_map(const Plugin& texture) { return setValue("map", texture); }
	//! (description missing)
	bool set_map(const AColor& texture) { return setValue("map", texture); }
	//! (description missing)
	Value get_map() const { return getValue("map"); }

	//! 0: not per particle; 1: pp radius; 2: pp user scalar 1; etc...
 	//! [Default value] 1
	bool set_radius_mode(int val) { return setValue("radius_mode", val); }
	//! 0: not per particle; 1: pp radius; 2: pp user scalar 1; etc...
 	//! [Default value] 1
	int get_radius_mode() const { return getInt("radius_mode"); }

	//! (description missing)
	//! [Default value] 1
	bool set_radius(float val) { return setValue("radius", val); }
	//! (description missing)
	//! [Default value] 1
	float get_radius() const { return getFloat("radius"); }

	//! (description missing)
	//! [Default value] 1
	bool set_amplitude(float val) { return setValue("amplitude", val); }
	//! (description missing)
	//! [Default value] 1
	float get_amplitude() const { return getFloat("amplitude"); }

	//! (description missing)
	//! [Default value] false
	bool set_shift_mode(bool val) { return setValue("shift_mode", val); }
	//! (description missing)
	//! [Default value] false
	bool get_shift_mode() const { return getBool("shift_mode"); }

	//! (description missing)
	//! [Default value] 1
	bool set_shift(float val) { return setValue("shift", val); }
	//! (description missing)
	//! [Default value] 1
	float get_shift() const { return getFloat("shift"); }

	//! (description missing)
	//! [Default value] true
	bool set_radius_scale(bool val) { return setValue("radius_scale", val); }
	//! (description missing)
	//! [Default value] true
	bool get_radius_scale() const { return getBool("radius_scale"); }

	//! (description missing)
	//! [Default value] false
	bool set_pa_color(bool val) { return setValue("pa_color", val); }
	//! (description missing)
	//! [Default value] false
	bool get_pa_color() const { return getBool("pa_color"); }

	//! (description missing)
	//! [Default value] false
	bool set_pa_radius(bool val) { return setValue("pa_radius", val); }
	//! (description missing)
	//! [Default value] false
	bool get_pa_radius() const { return getBool("pa_radius"); }

	//! (description missing)
	//! [Default value] false
	bool set_pa_amplitude(bool val) { return setValue("pa_amplitude", val); }
	//! (description missing)
	//! [Default value] false
	bool get_pa_amplitude() const { return getBool("pa_amplitude"); }

	//! (description missing)
	//! [Default value] false
	bool set_pa_shift(bool val) { return setValue("pa_shift", val); }
	//! (description missing)
	//! [Default value] false
	bool get_pa_shift() const { return getBool("pa_shift"); }

	//! List of particle systems to get the particle data from
 	bool set_particle_systems(const ValueList& pluginList) { return setValue("particle_systems", pluginList); }
	//! List of particle systems to get the particle data from
 	ValueList get_particle_systems() const { return getValueList("particle_systems"); }

	//! world to 'object' transformation of the source
 	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	bool set_source_transform(const Transform& transform) { return setValue("source_transform", transform); }
	//! world to 'object' transformation of the source
 	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	Transform get_source_transform() const { return getTransform("source_transform"); }
};

class PhxShaderCache : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "PhxShaderCache"; }

	//! Input Cache Path
 	//! [UI Guides] displayName=Input Cache File, fileAsset=vdb;f3d;aur, fileAssetNames=OpenVDB;Field3D;Phoenix FD, fileAssetOp=load, startRollout=Input
 	bool set_cache_path(const char* str) { return setValue("cache_path", str); }
	//! Input Cache Path
 	//! [UI Guides] displayName=Input Cache File, fileAsset=vdb;f3d;aur, fileAssetNames=OpenVDB;Field3D;Phoenix FD, fileAssetOp=load, startRollout=Input
 	bool set_cache_path(const std::string& str) { return setValue("cache_path", str); }
	//! Input Cache Path
 	//! [UI Guides] displayName=Input Cache File, fileAsset=vdb;f3d;aur, fileAssetNames=OpenVDB;Field3D;Phoenix FD, fileAssetOp=load, startRollout=Input
 	std::string get_cache_path() const { return getString("cache_path"); }

	//! Whether to actually load the cache or use it just to figure out the grid and cell size.
 	//! [Default value] true
	bool set_cache_load(bool val) { return setValue("cache_load", val); }
	//! Whether to actually load the cache or use it just to figure out the grid and cell size.
 	//! [Default value] true
	bool get_cache_load() const { return getBool("cache_load"); }

	//! Create velocity channel from the uvw movement channel.
 	//! [Default value] false
	bool set_velocities_from_uvw(bool val) { return setValue("velocities_from_uvw", val); }
	//! Create velocity channel from the uvw movement channel.
 	//! [Default value] false
	bool get_velocities_from_uvw() const { return getBool("velocities_from_uvw"); }

	//! Number of cells in x dimension if no cache file is specified; internally truncated to the nearest integer
 	//! [Default value] 1
	bool set_grid_size_x(float val) { return setValue("grid_size_x", val); }
	//! Number of cells in x dimension if no cache file is specified; internally truncated to the nearest integer
 	//! [Default value] 1
	float get_grid_size_x() const { return getFloat("grid_size_x"); }

	//! Number of cells in y dimension if no cache file is specified; internally truncated to the nearest integer
 	//! [Default value] 1
	bool set_grid_size_y(float val) { return setValue("grid_size_y", val); }
	//! Number of cells in y dimension if no cache file is specified; internally truncated to the nearest integer
 	//! [Default value] 1
	float get_grid_size_y() const { return getFloat("grid_size_y"); }

	//! Number of cells in z dimension if no cache file is specified; internally truncated to the nearest integer
 	//! [Default value] 1
	bool set_grid_size_z(float val) { return setValue("grid_size_z", val); }
	//! Number of cells in z dimension if no cache file is specified; internally truncated to the nearest integer
 	//! [Default value] 1
	float get_grid_size_z() const { return getFloat("grid_size_z"); }

	//! Size of a single grid cell
 	//! [Default value] 1
	bool set_cell_size(float val) { return setValue("cell_size", val); }
	//! Size of a single grid cell
 	//! [Default value] 1
	float get_cell_size() const { return getFloat("cell_size"); }

	//! Animation mode, 0 - standard, 1 - direct frame index, 2 - loop
 	//! [UI Guides] displayName=Animation Control, enum=0:Linear; 1:Frame Index; 2:Loop, startRollout=Time Bend Controls
 	//! [Default value] 0
	bool set_anim_mode(int val) { return setValue("anim_mode", val); }
	//! Animation mode, 0 - standard, 1 - direct frame index, 2 - loop
 	//! [UI Guides] displayName=Animation Control, enum=0:Linear; 1:Frame Index; 2:Loop, startRollout=Time Bend Controls
 	//! [Default value] 0
	int get_anim_mode() const { return getInt("anim_mode"); }

	//! Number of overlapped frame in the looped animation mode.
 	//! [UI Guides] displayName=Loop Overlap, minValue=0, maxValue=100, enableIf: ?anim_mode=2
 	//! [Default value] 0
	bool set_loop_overlap(int val) { return setValue("loop_overlap", val); }
	//! Number of overlapped frame in the looped animation mode.
 	//! [UI Guides] displayName=Loop Overlap, minValue=0, maxValue=100, enableIf: ?anim_mode=2
 	//! [Default value] 0
	int get_loop_overlap() const { return getInt("loop_overlap"); }

	//! Frame Blending
 	//! [UI Guides] displayName=Frame Blending, enum=0:Interpolation; 1:Velocity
 	//! [Default value] 0
	bool set_blend_method(int val) { return setValue("blend_method", val); }
	//! Frame Blending
 	//! [UI Guides] displayName=Frame Blending, enum=0:Interpolation; 1:Velocity
 	//! [Default value] 0
	int get_blend_method() const { return getInt("blend_method"); }

	//! Cache Start
 	//! [UI Guides] displayName=Cache Start, minValue=-10000, maxValue=10000, enableIf: ?anim_mode!=1
 	//! [Default value] 0
	bool set_read_offset(int val) { return setValue("read_offset", val); }
	//! Cache Start
 	//! [UI Guides] displayName=Cache Start, minValue=-10000, maxValue=10000, enableIf: ?anim_mode!=1
 	//! [Default value] 0
	int get_read_offset() const { return getInt("read_offset"); }

	//! Play Start
 	//! [UI Guides] displayName=Play Start, minValue=-10000, maxValue=10000, enableIf: ?anim_mode!=1
 	//! [Default value] 0
	bool set_play_at(int val) { return setValue("play_at", val); }
	//! Play Start
 	//! [UI Guides] displayName=Play Start, minValue=-10000, maxValue=10000, enableIf: ?anim_mode!=1
 	//! [Default value] 0
	int get_play_at() const { return getInt("play_at"); }

	//! Play Length
 	//! [UI Guides] displayName=Play Length, minValue=-10000, maxValue=10000, enableIf: ?anim_mode!=1
 	//! [Default value] 0
	bool set_max_length(int val) { return setValue("max_length", val); }
	//! Play Length
 	//! [UI Guides] displayName=Play Length, minValue=-10000, maxValue=10000, enableIf: ?anim_mode!=1
 	//! [Default value] 0
	int get_max_length() const { return getInt("max_length"); }

	//! Play Speed
 	//! [UI Guides] displayName=Play Speed, minValue=-10, maxValue=10, enableIf: ?anim_mode!=1
 	//! [Default value] 1
	bool set_play_speed(float val) { return setValue("play_speed", val); }
	//! Play Speed
 	//! [UI Guides] displayName=Play Speed, minValue=-10, maxValue=10, enableIf: ?anim_mode!=1
 	//! [Default value] 1
	float get_play_speed() const { return getFloat("play_speed"); }

	//! Direct time to frame transformation.
 	//! [UI Guides] displayName=Frame Index, minValue=0, maxValue=1000, enableIf: ?anim_mode=1
 	//! [Default value] 0
	bool set_t2f(float val) { return setValue("t2f", val); }
	//! Direct time to frame transformation.
 	//! [UI Guides] displayName=Frame Index, minValue=0, maxValue=1000, enableIf: ?anim_mode=1
 	//! [Default value] 0
	float get_t2f() const { return getFloat("t2f"); }

	//! ticks per frame
 	//! [Default value] 1000
	bool set_TPF(int val) { return setValue("TPF", val); }
	//! ticks per frame
 	//! [Default value] 1000
	int get_TPF() const { return getInt("TPF"); }

	//! If true, the yz axis of the cache will be flipped.
 	//! [UI Guides] displayName=Flip Up axis
 	//! [Default value] false
	bool set_flip_yz(bool val) { return setValue("flip_yz", val); }
	//! If true, the yz axis of the cache will be flipped.
 	//! [UI Guides] displayName=Flip Up axis
 	//! [Default value] false
	bool get_flip_yz() const { return getBool("flip_yz"); }

	//! used in RT to determine the frame loading flags
 	//! [Default value] 0
	bool set_load_flags(int val) { return setValue("load_flags", val); }
	//! used in RT to determine the frame loading flags
 	//! [Default value] 0
	int get_load_flags() const { return getInt("load_flags"); }

	//! If there is no cache file with the desired frame number, the nearest cache is found and loaded.
 	//! [UI Guides] displayName=Load Nearest if Missing
 	//! [Default value] false
	bool set_load_nearest(bool val) { return setValue("load_nearest", val); }
	//! If there is no cache file with the desired frame number, the nearest cache is found and loaded.
 	//! [UI Guides] displayName=Load Nearest if Missing
 	//! [Default value] false
	bool get_load_nearest() const { return getBool("load_nearest"); }

	//! (description missing)
	//! [Default value] 0
	bool set_smooth_mask(int val) { return setValue("smooth_mask", val); }
	//! (description missing)
	//! [Default value] 0
	int get_smooth_mask() const { return getInt("smooth_mask"); }

	//! (description missing)
	//! [Default value] 0
	bool set_smooth_threshold(const FloatList& floatList) { return setValue("smooth_threshold", floatList); }
	//! (description missing)
	//! [Default value] 0
	bool set_smooth_threshold(const float* floats, size_t count) { return setArray("smooth_threshold", floats, count); }
	//! (description missing)
	//! [Default value] 0
	template<size_t count> bool set_smooth_threshold(const float (&floats)[count]) { return setArray("smooth_threshold", floats, count); }
	//! (description missing)
	//! [Default value] 0
	FloatList get_smooth_threshold() const { return getFloatList("smooth_threshold"); }

	//! (description missing)
	//! [Default value] 0
	bool set_smooth_similarity(const FloatList& floatList) { return setValue("smooth_similarity", floatList); }
	//! (description missing)
	//! [Default value] 0
	bool set_smooth_similarity(const float* floats, size_t count) { return setArray("smooth_similarity", floats, count); }
	//! (description missing)
	//! [Default value] 0
	template<size_t count> bool set_smooth_similarity(const float (&floats)[count]) { return setArray("smooth_similarity", floats, count); }
	//! (description missing)
	//! [Default value] 0
	FloatList get_smooth_similarity() const { return getFloatList("smooth_similarity"); }

	//! (description missing)
	//! [Default value] 0
	bool set_smooth_randomize(const FloatList& floatList) { return setValue("smooth_randomize", floatList); }
	//! (description missing)
	//! [Default value] 0
	bool set_smooth_randomize(const float* floats, size_t count) { return setArray("smooth_randomize", floats, count); }
	//! (description missing)
	//! [Default value] 0
	template<size_t count> bool set_smooth_randomize(const float (&floats)[count]) { return setArray("smooth_randomize", floats, count); }
	//! (description missing)
	//! [Default value] 0
	FloatList get_smooth_randomize() const { return getFloatList("smooth_randomize"); }

	//! internally used
 	//! [Default value] 0
	bool set_free_mem_detect(int val) { return setValue("free_mem_detect", val); }
	//! internally used
 	//! [Default value] 0
	int get_free_mem_detect() const { return getInt("free_mem_detect"); }

	//! 3rd party caches channels mappings.
 	bool set_usrchmap(const char* str) { return setValue("usrchmap", str); }
	//! 3rd party caches channels mappings.
 	bool set_usrchmap(const std::string& str) { return setValue("usrchmap", str); }
	//! 3rd party caches channels mappings.
 	std::string get_usrchmap() const { return getString("usrchmap"); }
};

class PhxShaderFoam : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "PhxShaderFoam"; }

	//! enable rendeirng
 	//! [Default value] true
	bool set_enabled(bool val) { return setValue("enabled", val); }
	//! enable rendeirng
 	//! [Default value] true
	bool get_enabled() const { return getBool("enabled"); }

	//! (description missing)
	//! [Default value] 0
	bool set_geommode(int val) { return setValue("geommode", val); }
	//! (description missing)
	//! [Default value] 0
	int get_geommode() const { return getInt("geommode"); }

	//! A list of particles source
 	bool set_particle_source(const ValueList& pluginList) { return setValue("particle_source", pluginList); }
	//! A list of particles source
 	ValueList get_particle_source() const { return getValueList("particle_source"); }

	//! A list of transformations per particles source
 	bool set_particle_tm(const ValueList& list) { return setValue("particle_tm", list); }
	//! A list of transformations per particles source
 	ValueList get_particle_tm() const { return getValueList("particle_tm"); }

	//! foam color
 	//! [Default value] Color(1, 1, 1)
	bool set_color(const Color& color) { return setValue("color", color); }
	//! foam color
 	//! [Default value] Color(1, 1, 1)
	Color get_color() const { return getColor("color"); }

	//! max bounces
 	//! [Default value] 0
	bool set_bounces(int val) { return setValue("bounces", val); }
	//! max bounces
 	//! [Default value] 0
	int get_bounces() const { return getInt("bounces"); }

	//! reflection cut off
 	//! [Default value] 0.01
	bool set_minw(float val) { return setValue("minw", val); }
	//! reflection cut off
 	//! [Default value] 0.01
	float get_minw() const { return getFloat("minw"); }

	//! refraction index
 	//! [Default value] 2
	bool set_ri(float val) { return setValue("ri", val); }
	//! refraction index
 	//! [Default value] 2
	float get_ri() const { return getFloat("ri"); }

	//! diffuse multiplier
 	//! [Default value] 1
	bool set_difmul(float val) { return setValue("difmul", val); }
	//! diffuse multiplier
 	//! [Default value] 1
	float get_difmul() const { return getFloat("difmul"); }

	//! highlights width
 	//! [Default value] 0.5
	bool set_hlwidth(float val) { return setValue("hlwidth", val); }
	//! highlights width
 	//! [Default value] 0.5
	float get_hlwidth() const { return getFloat("hlwidth"); }

	//! highlights multiplier
 	//! [Default value] 1
	bool set_hlmult(float val) { return setValue("hlmult", val); }
	//! highlights multiplier
 	//! [Default value] 1
	float get_hlmult() const { return getFloat("hlmult"); }

	//! particle reduction
 	//! [Default value] 0
	bool set_reduction(float val) { return setValue("reduction", val); }
	//! particle reduction
 	//! [Default value] 0
	float get_reduction() const { return getFloat("reduction"); }

	//! pressure variation
 	//! [Default value] 0.5
	bool set_pvar(float val) { return setValue("pvar", val); }
	//! pressure variation
 	//! [Default value] 0.5
	float get_pvar() const { return getFloat("pvar"); }

	//! size multiplier
 	//! [Default value] 1
	bool set_szmul(float val) { return setValue("szmul", val); }
	//! size multiplier
 	//! [Default value] 1
	float get_szmul() const { return getFloat("szmul"); }

	//! size multiplier by particle age
 	//! [Default value] false
	bool set_szmul_pa(bool val) { return setValue("szmul_pa", val); }
	//! size multiplier by particle age
 	//! [Default value] false
	bool get_szmul_pa() const { return getBool("szmul_pa"); }

	//! A list of particle size multipliers per particle age
 	bool set_szmul_anim(const ValueList& list) { return setValue("szmul_anim", list); }
	//! A list of particle size multipliers per particle age
 	ValueList get_szmul_anim() const { return getValueList("szmul_anim"); }

	//! size addend
 	//! [Default value] 0
	bool set_szadd(float val) { return setValue("szadd", val); }
	//! size addend
 	//! [Default value] 0
	float get_szadd() const { return getFloat("szadd"); }

	//! size variation
 	//! [Default value] 0
	bool set_szvar(float val) { return setValue("szvar", val); }
	//! size variation
 	//! [Default value] 0
	float get_szvar() const { return getFloat("szvar"); }

	//! size distribution
 	//! [Default value] 1
	bool set_szdist(float val) { return setValue("szdist", val); }
	//! size distribution
 	//! [Default value] 1
	float get_szdist() const { return getFloat("szdist"); }

	//! scattering method - 0:enabled, 1:disabled, 2:approximate, 3:approximate+shadows
 	//! [Default value] 2
	bool set_scattering(int val) { return setValue("scattering", val); }
	//! scattering method - 0:enabled, 1:disabled, 2:approximate, 3:approximate+shadows
 	//! [Default value] 2
	int get_scattering() const { return getInt("scattering"); }

	//! rendering mode - 0:bubble, 1:cellular, 2:splashes, 3:point, 4:fog
 	//! [Default value] 1
	bool set_mode(int val) { return setValue("mode", val); }
	//! rendering mode - 0:bubble, 1:cellular, 2:splashes, 3:point, 4:fog
 	//! [Default value] 1
	int get_mode() const { return getInt("mode"); }

	//! optimize bad systems
 	//! [Default value] true
	bool set_optimize(bool val) { return setValue("optimize", val); }
	//! optimize bad systems
 	//! [Default value] true
	bool get_optimize() const { return getBool("optimize"); }

	//! motion blur - 0:from renderer, 1:force on, 2:force off
 	//! [Default value] 0
	bool set_moblur(int val) { return setValue("moblur", val); }
	//! motion blur - 0:from renderer, 1:force on, 2:force off
 	//! [Default value] 0
	int get_moblur() const { return getInt("moblur"); }

	//! motion blur step
 	//! [Default value] 1
	bool set_mbstep(float val) { return setValue("mbstep", val); }
	//! motion blur step
 	//! [Default value] 1
	float get_mbstep() const { return getFloat("mbstep"); }

	//! maximum point expansion with motion blur
 	//! [Default value] 100
	bool set_mblimit(int val) { return setValue("mblimit", val); }
	//! maximum point expansion with motion blur
 	//! [Default value] 100
	int get_mblimit() const { return getInt("mblimit"); }

	//! point opacity in point mode
 	//! [Default value] 0.111
	bool set_ptAlpha(float val) { return setValue("ptAlpha", val); }
	//! point opacity in point mode
 	//! [Default value] 0.111
	float get_ptAlpha() const { return getFloat("ptAlpha"); }

	//! point radius in point mode
 	//! [Default value] 1
	bool set_ptSize(float val) { return setValue("ptSize", val); }
	//! point radius in point mode
 	//! [Default value] 1
	float get_ptSize() const { return getFloat("ptSize"); }

	//! point shadow strength in point mode
 	//! [Default value] 1
	bool set_ptShadStren(float val) { return setValue("ptShadStren", val); }
	//! point shadow strength in point mode
 	//! [Default value] 1
	float get_ptShadStren() const { return getFloat("ptShadStren"); }

	//! particle velocity multiplier
 	//! [Default value] 1
	bool set_velmult(float val) { return setValue("velmult", val); }
	//! particle velocity multiplier
 	//! [Default value] 1
	float get_velmult() const { return getFloat("velmult"); }

	//! render subgroup - 0:all, 1:under water, 2:above water, 3:above the size limit, 4:below the size limit
 	//! [Default value] 0
	bool set_subgroup(int val) { return setValue("subgroup", val); }
	//! render subgroup - 0:all, 1:under water, 2:above water, 3:above the size limit, 4:below the size limit
 	//! [Default value] 0
	int get_subgroup() const { return getInt("subgroup"); }

	//! disable liquid shadows
 	//! [Default value] false
	bool set_nolqshadows(bool val) { return setValue("nolqshadows", val); }
	//! disable liquid shadows
 	//! [Default value] false
	bool get_nolqshadows() const { return getBool("nolqshadows"); }

	//! ignores the particle size
 	//! [Default value] false
	bool set_ignoresize(bool val) { return setValue("ignoresize", val); }
	//! ignores the particle size
 	//! [Default value] false
	bool get_ignoresize() const { return getBool("ignoresize"); }

	//! size limit. Particle below/above this limit will not be shaded
 	//! [Default value] 1
	bool set_szlimit(float val) { return setValue("szlimit", val); }
	//! size limit. Particle below/above this limit will not be shaded
 	//! [Default value] 1
	float get_szlimit() const { return getFloat("szlimit"); }

	//! fog resolution
 	//! [Default value] 1
	bool set_fogres(float val) { return setValue("fogres", val); }
	//! fog resolution
 	//! [Default value] 1
	float get_fogres() const { return getFloat("fogres"); }

	//! fog multiplier
 	//! [Default value] 1
	bool set_fogmult(float val) { return setValue("fogmult", val); }
	//! fog multiplier
 	//! [Default value] 1
	float get_fogmult() const { return getFloat("fogmult"); }

	//! (description missing)
	//! [Default value] 90
	bool set_rendstep(int val) { return setValue("rendstep", val); }
	//! (description missing)
	//! [Default value] 90
	int get_rendstep() const { return getInt("rendstep"); }

	//! (description missing)
	//! [Default value] 200
	bool set_rendshadstep(int val) { return setValue("rendshadstep", val); }
	//! (description missing)
	//! [Default value] 200
	int get_rendshadstep() const { return getInt("rendshadstep"); }

	//! enable the reflection map
 	//! [Default value] false
	bool set_usereflmap(bool val) { return setValue("usereflmap", val); }
	//! enable the reflection map
 	//! [Default value] false
	bool get_usereflmap() const { return getBool("usereflmap"); }

	//! enable the environment map
 	//! [Default value] false
	bool set_useenvmap(bool val) { return setValue("useenvmap", val); }
	//! enable the environment map
 	//! [Default value] false
	bool get_useenvmap() const { return getBool("useenvmap"); }

	//! reflection texture
 	bool set_reflmap(const Plugin& texture) { return setValue("reflmap", texture); }
	//! reflection texture
 	bool set_reflmap(const AColor& texture) { return setValue("reflmap", texture); }
	//! reflection texture
 	Value get_reflmap() const { return getValue("reflmap"); }

	//! environment texture
 	bool set_envmap(const Plugin& texture) { return setValue("envmap", texture); }
	//! environment texture
 	bool set_envmap(const AColor& texture) { return setValue("envmap", texture); }
	//! environment texture
 	Value get_envmap() const { return getValue("envmap"); }

	//! enable using of render cutter
 	//! [Default value] 0
	bool set_usegizmo(int val) { return setValue("usegizmo", val); }
	//! enable using of render cutter
 	//! [Default value] 0
	int get_usegizmo() const { return getInt("usegizmo"); }

	//! invert the volume of the render cutter
 	//! [Default value] 0
	bool set_invgizmo(int val) { return setValue("invgizmo", val); }
	//! invert the volume of the render cutter
 	//! [Default value] 0
	int get_invgizmo() const { return getInt("invgizmo"); }

	//! geometry to define the rendering volume
 	bool set_gizmo(const Plugin& plugin) { return setValue("gizmo", plugin); }
	//! geometry to define the rendering volume
 	Plugin get_gizmo() const { return getPlugin("gizmo"); }

	//! world transformation of the gizmo
 	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	bool set_gizmo_transform(const Transform& transform) { return setValue("gizmo_transform", transform); }
	//! world transformation of the gizmo
 	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	Transform get_gizmo_transform() const { return getTransform("gizmo_transform"); }

	//! enable the liquid_sim
 	//! [Default value] 0
	bool set_useliquid(int val) { return setValue("useliquid", val); }
	//! enable the liquid_sim
 	//! [Default value] 0
	int get_useliquid() const { return getInt("useliquid"); }

	//! liquid Phoenix simulator used to determine above/under water flag
 	bool set_liquid_sim(const Plugin& plugin) { return setValue("liquid_sim", plugin); }
	//! liquid Phoenix simulator used to determine above/under water flag
 	Plugin get_liquid_sim() const { return getPlugin("liquid_sim"); }

	//! enable using of glass geometry
 	//! [Default value] 0
	bool set_useglass(int val) { return setValue("useglass", val); }
	//! enable using of glass geometry
 	//! [Default value] 0
	int get_useglass() const { return getInt("useglass"); }

	//! glass geometry
 	bool set_glass(const Plugin& plugin) { return setValue("glass", plugin); }
	//! glass geometry
 	Plugin get_glass() const { return getPlugin("glass"); }

	//! world transformation of the glass
 	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	bool set_glass_transform(const Transform& transform) { return setValue("glass_transform", transform); }
	//! world transformation of the glass
 	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	Transform get_glass_transform() const { return getTransform("glass_transform"); }

	//! light linking list used in volumetric mode
 	bool set_lightlinks(const ValueList& pluginList) { return setValue("lightlinks", pluginList); }
	//! light linking list used in volumetric mode
 	ValueList get_lightlinks() const { return getValueList("lightlinks"); }

	//! if true, a light cache will be used for diffuse lighting
 	//! [Default value] 1
	bool set_lightcache(int val) { return setValue("lightcache", val); }
	//! if true, a light cache will be used for diffuse lighting
 	//! [Default value] 1
	int get_lightcache() const { return getInt("lightcache"); }

	//! speedup of the light cache
 	//! [Default value] 0
	bool set_lightcachesr(float val) { return setValue("lightcachesr", val); }
	//! speedup of the light cache
 	//! [Default value] 0
	float get_lightcachesr() const { return getFloat("lightcachesr"); }

	//! enable/disable particle mode of primary rays
 	//! [Default value] false
	bool set_pmprimary(bool val) { return setValue("pmprimary", val); }
	//! enable/disable particle mode of primary rays
 	//! [Default value] false
	bool get_pmprimary() const { return getBool("pmprimary"); }

	//! Mesh 'ocean' level
 	//! [Default value] 50
	bool set_oceanlevel(float val) { return setValue("oceanlevel", val); }
	//! Mesh 'ocean' level
 	//! [Default value] 50
	float get_oceanlevel() const { return getFloat("oceanlevel"); }

	//! (description missing)
	//! [Default value] 1
	bool set_generate_gi(int val) { return setValue("generate_gi", val); }
	//! (description missing)
	//! [Default value] 1
	int get_generate_gi() const { return getInt("generate_gi"); }

	//! (description missing)
	//! [Default value] 1
	bool set_receive_gi(int val) { return setValue("receive_gi", val); }
	//! (description missing)
	//! [Default value] 1
	int get_receive_gi() const { return getInt("receive_gi"); }

	//! (description missing)
	//! [Default value] 1
	bool set_gen_gi_mult(float val) { return setValue("gen_gi_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_gen_gi_mult() const { return getFloat("gen_gi_mult"); }

	//! (description missing)
	//! [Default value] 1
	bool set_rec_gi_mult(float val) { return setValue("rec_gi_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_rec_gi_mult() const { return getFloat("rec_gi_mult"); }

	//! (description missing)
	//! [Default value] 1
	bool set_generate_caust(int val) { return setValue("generate_caust", val); }
	//! (description missing)
	//! [Default value] 1
	int get_generate_caust() const { return getInt("generate_caust"); }

	//! (description missing)
	//! [Default value] 1
	bool set_receive_caust(int val) { return setValue("receive_caust", val); }
	//! (description missing)
	//! [Default value] 1
	int get_receive_caust() const { return getInt("receive_caust"); }

	//! (description missing)
	//! [Default value] 1
	bool set_caust_mult(float val) { return setValue("caust_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_caust_mult() const { return getFloat("caust_mult"); }

	//! (description missing)
	//! [Default value] true
	bool set_camera_visibility(bool val) { return setValue("camera_visibility", val); }
	//! (description missing)
	//! [Default value] true
	bool get_camera_visibility() const { return getBool("camera_visibility"); }

	//! (description missing)
	//! [Default value] true
	bool set_reflections_visibility(bool val) { return setValue("reflections_visibility", val); }
	//! (description missing)
	//! [Default value] true
	bool get_reflections_visibility() const { return getBool("reflections_visibility"); }

	//! (description missing)
	//! [Default value] true
	bool set_refractions_visibility(bool val) { return setValue("refractions_visibility", val); }
	//! (description missing)
	//! [Default value] true
	bool get_refractions_visibility() const { return getBool("refractions_visibility"); }

	//! (description missing)
	//! [Default value] true
	bool set_gi_visibility(bool val) { return setValue("gi_visibility", val); }
	//! (description missing)
	//! [Default value] true
	bool get_gi_visibility() const { return getBool("gi_visibility"); }

	//! (description missing)
	//! [Default value] true
	bool set_shadows_visibility(bool val) { return setValue("shadows_visibility", val); }
	//! (description missing)
	//! [Default value] true
	bool get_shadows_visibility() const { return getBool("shadows_visibility"); }

	//! Use probabilistic sampling {0: disabled; 1:Only RT; 2:Always}.
 	//! [Default value] 1
	bool set_probabilistic(int val) { return setValue("probabilistic", val); }
	//! Use probabilistic sampling {0: disabled; 1:Only RT; 2:Always}.
 	//! [Default value] 1
	int get_probabilistic() const { return getInt("probabilistic"); }

	//! Material ID
 	//! [Default value] Color(0, 0, 0)
	bool set_material_id(const Color& color) { return setValue("material_id", color); }
	//! Material ID
 	//! [Default value] Color(0, 0, 0)
	Color get_material_id() const { return getColor("material_id"); }

	//! if true, write to the z-depth render element
 	//! [Default value] 0
	bool set_volzdepth(int val) { return setValue("volzdepth", val); }
	//! if true, write to the z-depth render element
 	//! [Default value] 0
	int get_volzdepth() const { return getInt("volzdepth"); }

	//! if true, write to the particle age render element
 	//! [Default value] 0
	bool set_part_age(int val) { return setValue("part_age", val); }
	//! if true, write to the particle age render element
 	//! [Default value] 0
	int get_part_age() const { return getInt("part_age"); }
};

class PhxShaderOceanTex : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "PhxShaderOceanTex"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! (description missing)
	//! [Default value] false
	bool set_use_3d_mapping(bool val) { return setValue("use_3d_mapping", val); }
	//! (description missing)
	//! [Default value] false
	bool get_use_3d_mapping() const { return getBool("use_3d_mapping"); }

	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	bool set_placement_type(int val) { return setValue("placement_type", val); }
	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	int get_placement_type() const { return getInt("placement_type"); }

	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_u(float val) { return setValue("u", val); }
	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_u() const { return getFloat("u"); }

	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_v(float val) { return setValue("v", val); }
	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_v() const { return getFloat("v"); }

	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_w(float val) { return setValue("w", val); }
	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_w() const { return getFloat("w"); }

	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_h(float val) { return setValue("h", val); }
	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_h() const { return getFloat("h"); }

	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	bool set_jitter(float val) { return setValue("jitter", val); }
	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	float get_jitter() const { return getFloat("jitter"); }

	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_u(bool val) { return setValue("tile_u", val); }
	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_u() const { return getBool("tile_u"); }

	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_v(bool val) { return setValue("tile_v", val); }
	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_v() const { return getBool("tile_v"); }

	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool set_uv_noise_on(bool val) { return setValue("uv_noise_on", val); }
	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool get_uv_noise_on() const { return getBool("uv_noise_on"); }

	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool set_uv_noise_animate(bool val) { return setValue("uv_noise_animate", val); }
	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool get_uv_noise_animate() const { return getBool("uv_noise_animate"); }

	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	bool set_uv_noise_amount(float val) { return setValue("uv_noise_amount", val); }
	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	float get_uv_noise_amount() const { return getFloat("uv_noise_amount"); }

	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	bool set_uv_noise_levels(float val) { return setValue("uv_noise_levels", val); }
	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	float get_uv_noise_levels() const { return getFloat("uv_noise_levels"); }

	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	bool set_uv_noise_size(float val) { return setValue("uv_noise_size", val); }
	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	float get_uv_noise_size() const { return getFloat("uv_noise_size"); }

	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	bool set_un_noise_phase(float val) { return setValue("un_noise_phase", val); }
	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	float get_un_noise_phase() const { return getFloat("un_noise_phase"); }

	//! (description missing)
	//! [Default value] true
	bool set_vector(bool val) { return setValue("vector", val); }
	//! (description missing)
	//! [Default value] true
	bool get_vector() const { return getBool("vector"); }

	//! (description missing)
	//! [Default value] true
	bool set_usewind(bool val) { return setValue("usewind", val); }
	//! (description missing)
	//! [Default value] true
	bool get_usewind() const { return getBool("usewind"); }

	//! (description missing)
	//! [Default value] 3
	bool set_wind(float val) { return setValue("wind", val); }
	//! (description missing)
	//! [Default value] 3
	float get_wind() const { return getFloat("wind"); }

	//! (description missing)
	//! [Default value] 10
	bool set_lod(int val) { return setValue("lod", val); }
	//! (description missing)
	//! [Default value] 10
	int get_lod() const { return getInt("lod"); }

	//! (description missing)
	//! [Default value] 0.9
	bool set_sharpness(float val) { return setValue("sharpness", val); }
	//! (description missing)
	//! [Default value] 0.9
	float get_sharpness() const { return getFloat("sharpness"); }

	//! (description missing)
	//! [Default value] 1
	bool set_velmult(float val) { return setValue("velmult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_velmult() const { return getFloat("velmult"); }

	//! (description missing)
	//! [Default value] 0.2
	bool set_velcoh(float val) { return setValue("velcoh", val); }
	//! (description missing)
	//! [Default value] 0.2
	float get_velcoh() const { return getFloat("velcoh"); }

	//! (description missing)
	//! [Default value] 1
	bool set_rgbmult(float val) { return setValue("rgbmult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_rgbmult() const { return getFloat("rgbmult"); }

	//! (description missing)
	//! [Default value] 0
	bool set_rgboffset(float val) { return setValue("rgboffset", val); }
	//! (description missing)
	//! [Default value] 0
	float get_rgboffset() const { return getFloat("rgboffset"); }

	//! (description missing)
	//! [Default value] 1
	bool set_meter_scale(float val) { return setValue("meter_scale", val); }
	//! (description missing)
	//! [Default value] 1
	float get_meter_scale() const { return getFloat("meter_scale"); }

	//! (description missing)
	//! [Default value] 1
	bool set_up_vector(int val) { return setValue("up_vector", val); }
	//! (description missing)
	//! [Default value] 1
	int get_up_vector() const { return getInt("up_vector"); }

	//! (description missing)
	//! [Default value] 345344
	bool set_seed(int val) { return setValue("seed", val); }
	//! (description missing)
	//! [Default value] 345344
	int get_seed() const { return getInt("seed"); }

	//! (description missing)
	//! [Default value] 0.2
	bool set_bell(float val) { return setValue("bell", val); }
	//! (description missing)
	//! [Default value] 0.2
	float get_bell() const { return getFloat("bell"); }

	//! Displacement Scale
 	bool set_scaletex(const Plugin& texture) { return setValue("scaletex", texture); }
	//! Displacement Scale
 	bool set_scaletex(const AColor& texture) { return setValue("scaletex", texture); }
	//! Displacement Scale
 	Value get_scaletex() const { return getValue("scaletex"); }
};

class PhxShaderPGroup : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "PhxShaderPGroup"; }

	//! The Phoenix simulator that exports the particle group
 	bool set_phoenix_sim(const Plugin& plugin) { return setValue("phoenix_sim", plugin); }
	//! The Phoenix simulator that exports the particle group
 	Plugin get_phoenix_sim() const { return getPlugin("phoenix_sim"); }

	//! the name of the particle group that will be used as a source
 	bool set_pgroup(const char* str) { return setValue("pgroup", str); }
	//! the name of the particle group that will be used as a source
 	bool set_pgroup(const std::string& str) { return setValue("pgroup", str); }
	//! the name of the particle group that will be used as a source
 	std::string get_pgroup() const { return getString("pgroup"); }

	//! lifespan mode: 0-default, 1-constant, 2-random
 	//! [Default value] 0
	bool set_lifespan_mode(int val) { return setValue("lifespan_mode", val); }
	//! lifespan mode: 0-default, 1-constant, 2-random
 	//! [Default value] 0
	int get_lifespan_mode() const { return getInt("lifespan_mode"); }

	//! lifespan randomization seed
 	//! [Default value] 0
	bool set_lifespan_seed(int val) { return setValue("lifespan_seed", val); }
	//! lifespan randomization seed
 	//! [Default value] 0
	int get_lifespan_seed() const { return getInt("lifespan_seed"); }

	//! lifespan base
 	//! [Default value] 0
	bool set_lifespan(float val) { return setValue("lifespan", val); }
	//! lifespan base
 	//! [Default value] 0
	float get_lifespan() const { return getFloat("lifespan"); }

	//! lifespan randomization
 	//! [Default value] 0
	bool set_lifespan_random(float val) { return setValue("lifespan_random", val); }
	//! lifespan randomization
 	//! [Default value] 0
	float get_lifespan_random() const { return getFloat("lifespan_random"); }
};

class PhxShaderParticleTex : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "PhxShaderParticleTex"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! (description missing)
	//! [Default value] false
	bool set_use_3d_mapping(bool val) { return setValue("use_3d_mapping", val); }
	//! (description missing)
	//! [Default value] false
	bool get_use_3d_mapping() const { return getBool("use_3d_mapping"); }

	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	bool set_placement_type(int val) { return setValue("placement_type", val); }
	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	int get_placement_type() const { return getInt("placement_type"); }

	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_u(float val) { return setValue("u", val); }
	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_u() const { return getFloat("u"); }

	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_v(float val) { return setValue("v", val); }
	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_v() const { return getFloat("v"); }

	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_w(float val) { return setValue("w", val); }
	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_w() const { return getFloat("w"); }

	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_h(float val) { return setValue("h", val); }
	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_h() const { return getFloat("h"); }

	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	bool set_jitter(float val) { return setValue("jitter", val); }
	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	float get_jitter() const { return getFloat("jitter"); }

	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_u(bool val) { return setValue("tile_u", val); }
	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_u() const { return getBool("tile_u"); }

	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_v(bool val) { return setValue("tile_v", val); }
	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_v() const { return getBool("tile_v"); }

	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool set_uv_noise_on(bool val) { return setValue("uv_noise_on", val); }
	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool get_uv_noise_on() const { return getBool("uv_noise_on"); }

	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool set_uv_noise_animate(bool val) { return setValue("uv_noise_animate", val); }
	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool get_uv_noise_animate() const { return getBool("uv_noise_animate"); }

	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	bool set_uv_noise_amount(float val) { return setValue("uv_noise_amount", val); }
	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	float get_uv_noise_amount() const { return getFloat("uv_noise_amount"); }

	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	bool set_uv_noise_levels(float val) { return setValue("uv_noise_levels", val); }
	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	float get_uv_noise_levels() const { return getFloat("uv_noise_levels"); }

	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	bool set_uv_noise_size(float val) { return setValue("uv_noise_size", val); }
	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	float get_uv_noise_size() const { return getFloat("uv_noise_size"); }

	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	bool set_un_noise_phase(float val) { return setValue("un_noise_phase", val); }
	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	float get_un_noise_phase() const { return getFloat("un_noise_phase"); }

	//! (description missing)
	bool set_system(const ValueList& pluginList) { return setValue("system", pluginList); }
	//! (description missing)
	ValueList get_system() const { return getValueList("system"); }

	//! (description missing)
	bool set_system_tm(const ValueList& list) { return setValue("system_tm", list); }
	//! (description missing)
	ValueList get_system_tm() const { return getValueList("system_tm"); }

	//! (description missing)
	bool set_map(const Plugin& texture) { return setValue("map", texture); }
	//! (description missing)
	bool set_map(const AColor& texture) { return setValue("map", texture); }
	//! (description missing)
	Value get_map() const { return getValue("map"); }

	//! (description missing)
	//! [Default value] 1
	bool set_radius(float val) { return setValue("radius", val); }
	//! (description missing)
	//! [Default value] 1
	float get_radius() const { return getFloat("radius"); }

	//! (description missing)
	bool set_radius_anim(const ValueList& list) { return setValue("radius_anim", list); }
	//! (description missing)
	ValueList get_radius_anim() const { return getValueList("radius_anim"); }

	//! (description missing)
	//! [Default value] false
	bool set_radius_time(bool val) { return setValue("radius_time", val); }
	//! (description missing)
	//! [Default value] false
	bool get_radius_time() const { return getBool("radius_time"); }

	//! (description missing)
	//! [Default value] true
	bool set_mulbysz(bool val) { return setValue("mulbysz", val); }
	//! (description missing)
	//! [Default value] true
	bool get_mulbysz() const { return getBool("mulbysz"); }

	//! (description missing)
	//! [Default value] 1
	bool set_amplitude(float val) { return setValue("amplitude", val); }
	//! (description missing)
	//! [Default value] 1
	float get_amplitude() const { return getFloat("amplitude"); }

	//! (description missing)
	bool set_amplitude_anim(const ValueList& list) { return setValue("amplitude_anim", list); }
	//! (description missing)
	ValueList get_amplitude_anim() const { return getValueList("amplitude_anim"); }

	//! (description missing)
	//! [Default value] false
	bool set_amplitude_time(bool val) { return setValue("amplitude_time", val); }
	//! (description missing)
	//! [Default value] false
	bool get_amplitude_time() const { return getBool("amplitude_time"); }

	//! (description missing)
	//! [Default value] false
	bool set_shift_mode(bool val) { return setValue("shift_mode", val); }
	//! (description missing)
	//! [Default value] false
	bool get_shift_mode() const { return getBool("shift_mode"); }

	//! (description missing)
	//! [Default value] 1
	bool set_shift(float val) { return setValue("shift", val); }
	//! (description missing)
	//! [Default value] 1
	float get_shift() const { return getFloat("shift"); }

	//! (description missing)
	bool set_shift_anim(const ValueList& list) { return setValue("shift_anim", list); }
	//! (description missing)
	ValueList get_shift_anim() const { return getValueList("shift_anim"); }

	//! (description missing)
	//! [Default value] false
	bool set_shift_time(bool val) { return setValue("shift_time", val); }
	//! (description missing)
	//! [Default value] false
	bool get_shift_time() const { return getBool("shift_time"); }

	//! (description missing)
	//! [Default value] 1
	bool set_blending(int val) { return setValue("blending", val); }
	//! (description missing)
	//! [Default value] 1
	int get_blending() const { return getInt("blending"); }

	//! (description missing)
	//! [Default value] false
	bool set_blend_alpha(bool val) { return setValue("blend_alpha", val); }
	//! (description missing)
	//! [Default value] false
	bool get_blend_alpha() const { return getBool("blend_alpha"); }

	//! (description missing)
	//! [Default value] false
	bool set_local_space_particles(bool val) { return setValue("local_space_particles", val); }
	//! (description missing)
	//! [Default value] false
	bool get_local_space_particles() const { return getBool("local_space_particles"); }
};

class PhxShaderPrtLoader : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "PhxShaderPrtLoader"; }

	//! Path to the prt cache file
 	bool set_filesrc(const char* str) { return setValue("filesrc", str); }
	//! Path to the prt cache file
 	bool set_filesrc(const std::string& str) { return setValue("filesrc", str); }
	//! Path to the prt cache file
 	std::string get_filesrc() const { return getString("filesrc"); }

	//! The particles are transformed relative to the position of the prt loader icon
 	//! [Default value] true
	bool set_usetm(bool val) { return setValue("usetm", val); }
	//! The particles are transformed relative to the position of the prt loader icon
 	//! [Default value] true
	bool get_usetm() const { return getBool("usetm"); }

	//! Velocity multiplier for the particles
 	//! [Default value] 1
	bool set_velmult(float val) { return setValue("velmult", val); }
	//! Velocity multiplier for the particles
 	//! [Default value] 1
	float get_velmult() const { return getFloat("velmult"); }
};

class PhxShaderSim : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "PhxShaderSim"; }

	//! The Phoenix cache that will be used with this simulator
 	bool set_cache(const Plugin& plugin) { return setValue("cache", plugin); }
	//! The Phoenix cache that will be used with this simulator
 	Plugin get_cache() const { return getPlugin("cache"); }

	//! (description missing)
	//! [Default value] 1
	bool set_play_speed(float val) { return setValue("play_speed", val); }
	//! (description missing)
	//! [Default value] 1
	float get_play_speed() const { return getFloat("play_speed"); }

	//! set to false to disable.
 	//! [Default value] true
	bool set_enabled(bool val) { return setValue("enabled", val); }
	//! set to false to disable.
 	//! [Default value] true
	bool get_enabled() const { return getBool("enabled"); }

	//! set to false to disable rendering. The data is still loaded and Phoenix textures and emissive lights will still work.
 	//! [UI Guides] displayName=Enable Rendering
 	//! [Default value] true
	bool set_render(bool val) { return setValue("render", val); }
	//! set to false to disable rendering. The data is still loaded and Phoenix textures and emissive lights will still work.
 	//! [UI Guides] displayName=Enable Rendering
 	//! [Default value] true
	bool get_render() const { return getBool("render"); }

	//! force using an externally set content time
 	//! [Default value] -1
	bool set_contentTime(int val) { return setValue("contentTime", val); }
	//! force using an externally set content time
 	//! [Default value] -1
	int get_contentTime() const { return getInt("contentTime"); }

	//! The transformation matrix for the instance that uses this simulator
 	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	bool set_node_transform(const Transform& transform) { return setValue("node_transform", transform); }
	//! The transformation matrix for the instance that uses this simulator
 	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	Transform get_node_transform() const { return getTransform("node_transform"); }

	//! (description missing)
	//! [Default value] false
	bool set_wind_from_movement(bool val) { return setValue("wind_from_movement", val); }
	//! (description missing)
	//! [Default value] false
	bool get_wind_from_movement() const { return getBool("wind_from_movement"); }

	//! The scaling between simulation and scene time units
 	//! [Default value] 1
	bool set_unit_scale(float val) { return setValue("unit_scale", val); }
	//! The scaling between simulation and scene time units
 	//! [Default value] 1
	float get_unit_scale() const { return getFloat("unit_scale"); }

	//! Override the frame duration in the cache
 	//! [Default value] 0
	bool set_frame_duration(float val) { return setValue("frame_duration", val); }
	//! Override the frame duration in the cache
 	//! [Default value] 0
	float get_frame_duration() const { return getFloat("frame_duration"); }

	//! 0-texture; 1-T; 2-Sm; 3-V; 10-fuel
 	//! [UI Guides] displayName=Surface from, enum=0:Texture; 1:Temperature; 2:Smoke; 3:Speed; 10:Fuel, startRollout=Surface
 	//! [Default value] 2
	bool set_sarg(int val) { return setValue("sarg", val); }
	//! 0-texture; 1-T; 2-Sm; 3-V; 10-fuel
 	//! [UI Guides] displayName=Surface from, enum=0:Texture; 1:Temperature; 2:Smoke; 3:Speed; 10:Fuel, startRollout=Surface
 	//! [Default value] 2
	int get_sarg() const { return getInt("sarg"); }

	//! Surface Texture
 	//! [UI Guides] displayName=Surface Texture, attributes=textureSlot, enableIf: ?sarg=0
 	bool set_stex(const Plugin& texture) { return setValue("stex", texture); }
	//! Surface Texture
 	//! [UI Guides] displayName=Surface Texture, attributes=textureSlot, enableIf: ?sarg=0
 	bool set_stex(const AColor& texture) { return setValue("stex", texture); }
	//! Surface Texture
 	//! [UI Guides] displayName=Surface Texture, attributes=textureSlot, enableIf: ?sarg=0
 	Value get_stex() const { return getValue("stex"); }

	//! Isosurface Level
 	//! [UI Guides] displayName=Isosurface Level, minValue=-10000, maxValue=10000
 	//! [Default value] 0.1
	bool set_surflevel(float val) { return setValue("surflevel", val); }
	//! Isosurface Level
 	//! [UI Guides] displayName=Isosurface Level, minValue=-10000, maxValue=10000
 	//! [Default value] 0.1
	float get_surflevel() const { return getFloat("surflevel"); }

	//! Invert Volume
 	//! [UI Guides] displayName=Invert Volume
 	//! [Default value] false
	bool set_solidbelow(bool val) { return setValue("solidbelow", val); }
	//! Invert Volume
 	//! [UI Guides] displayName=Invert Volume
 	//! [Default value] false
	bool get_solidbelow() const { return getBool("solidbelow"); }

	//! Enable Displacement
 	//! [UI Guides] displayName=Enable Displacement, startRollout=Displacement
 	//! [Default value] false
	bool set_displacement(bool val) { return setValue("displacement", val); }
	//! Enable Displacement
 	//! [UI Guides] displayName=Enable Displacement, startRollout=Displacement
 	//! [Default value] false
	bool get_displacement() const { return getBool("displacement"); }

	//! [UI Guides] displayName=Type, enum=0:Gradient Driven;1:Surface Driven;2:Vector;3:Advection, enableIf: ?displacement=1
 	//! [Default value] 1
	bool set_displ2d(int val) { return setValue("displ2d", val); }
	//! [UI Guides] displayName=Type, enum=0:Gradient Driven;1:Surface Driven;2:Vector;3:Advection, enableIf: ?displacement=1
 	//! [Default value] 1
	int get_displ2d() const { return getInt("displ2d"); }

	//! [UI Guides] displayName=Multiplier, minValue=-1000, maxValue=1000, enableIf: ?displacement=1
 	//! [Default value] 1
	bool set_displmul(float val) { return setValue("displmul", val); }
	//! [UI Guides] displayName=Multiplier, minValue=-1000, maxValue=1000, enableIf: ?displacement=1
 	//! [Default value] 1
	float get_displmul() const { return getFloat("displmul"); }

	//! [UI Guides] displayName=Fade Out Zone, minValue=0, maxValue=100, enableIf: ?displacement=1
 	//! [Default value] 20
	bool set_displfade(float val) { return setValue("displfade", val); }
	//! [UI Guides] displayName=Fade Out Zone, minValue=0, maxValue=100, enableIf: ?displacement=1
 	//! [Default value] 20
	float get_displfade() const { return getFloat("displfade"); }

	//! [UI Guides] displayName=Velocity Based Fade Out
 	//! [Default value] false
	bool set_fadebyvel(bool val) { return setValue("fadebyvel", val); }
	//! [UI Guides] displayName=Velocity Based Fade Out
 	//! [Default value] false
	bool get_fadebyvel() const { return getBool("fadebyvel"); }

	//! [UI Guides] enableIf: ?displacement=1, attributes=textureSlot
 	bool set_displ0(const Plugin& texture) { return setValue("displ0", texture); }
	//! [UI Guides] enableIf: ?displacement=1, attributes=textureSlot
 	bool set_displ0(const AColor& texture) { return setValue("displ0", texture); }
	//! [UI Guides] enableIf: ?displacement=1, attributes=textureSlot
 	Value get_displ0() const { return getValue("displ0"); }

	//! [UI Guides] enableIf: ?displacement=1, attributes=textureSlot
 	bool set_displ1(const Plugin& texture) { return setValue("displ1", texture); }
	//! [UI Guides] enableIf: ?displacement=1, attributes=textureSlot
 	bool set_displ1(const AColor& texture) { return setValue("displ1", texture); }
	//! [UI Guides] enableIf: ?displacement=1, attributes=textureSlot
 	Value get_displ1() const { return getValue("displ1"); }

	//! [UI Guides] displayName=Displacement Texture, enableIf: ?displacement=1, attributes=textureSlot
 	bool set_displ2(const Plugin& texture) { return setValue("displ2", texture); }
	//! [UI Guides] displayName=Displacement Texture, enableIf: ?displacement=1, attributes=textureSlot
 	bool set_displ2(const AColor& texture) { return setValue("displ2", texture); }
	//! [UI Guides] displayName=Displacement Texture, enableIf: ?displacement=1, attributes=textureSlot
 	Value get_displ2() const { return getValue("displ2"); }

	//! Percentage of the cell size. Lower values take longer to render.
 	//! [UI Guides] displayName=Rend. Step %, minValue=1, maxValue=10000, enableIf: ?render=1
 	//! [Default value] 90
	bool set_rendstep(int val) { return setValue("rendstep", val); }
	//! Percentage of the cell size. Lower values take longer to render.
 	//! [UI Guides] displayName=Rend. Step %, minValue=1, maxValue=10000, enableIf: ?render=1
 	//! [Default value] 90
	int get_rendstep() const { return getInt("rendstep"); }

	//! Percentage of the cell size. Lower values take longer to render.
 	//! [UI Guides] displayName=Shadow Step %, minValue=1, maxValue=10000, enableIf: ?render=1
 	//! [Default value] 200
	bool set_rendshadstep(int val) { return setValue("rendshadstep", val); }
	//! Percentage of the cell size. Lower values take longer to render.
 	//! [UI Guides] displayName=Shadow Step %, minValue=1, maxValue=10000, enableIf: ?render=1
 	//! [Default value] 200
	int get_rendshadstep() const { return getInt("rendshadstep"); }

	//! if true, a light cache will be used for diffuse lighting
 	//! [UI Guides] displayName=Use Light Cache
 	//! [Default value] true
	bool set_lightcache(bool val) { return setValue("lightcache", val); }
	//! if true, a light cache will be used for diffuse lighting
 	//! [UI Guides] displayName=Use Light Cache
 	//! [Default value] true
	bool get_lightcache() const { return getBool("lightcache"); }

	//! [UI Guides] displayName=Light Cache Speedup, minValue=0, maxValue=0.999, enableIf: ?lightcache=1
 	//! [Default value] 0.9
	bool set_lightcachesr(float val) { return setValue("lightcachesr", val); }
	//! [UI Guides] displayName=Light Cache Speedup, minValue=0, maxValue=0.999, enableIf: ?lightcache=1
 	//! [Default value] 0.9
	float get_lightcachesr() const { return getFloat("lightcachesr"); }

	//! enable/disable particle mode of primary rays. Used as a boolean, even though it's exported as an int
 	//! [Default value] 0
	bool set_pmprimary(int val) { return setValue("pmprimary", val); }
	//! enable/disable particle mode of primary rays. Used as a boolean, even though it's exported as an int
 	//! [Default value] 0
	int get_pmprimary() const { return getInt("pmprimary"); }

	//! enable/disable particle mode of secondary rays. Used as a boolean, even though it's exported as an int
 	//! [Default value] 1
	bool set_pmbounces(int val) { return setValue("pmbounces", val); }
	//! enable/disable particle mode of secondary rays. Used as a boolean, even though it's exported as an int
 	//! [Default value] 1
	int get_pmbounces() const { return getInt("pmbounces"); }

	//! Render mode: Heat Haze
 	//! [Default value] 0
	bool set_heathaze(int val) { return setValue("heathaze", val); }
	//! Render mode: Heat Haze
 	//! [Default value] 0
	int get_heathaze() const { return getInt("heathaze"); }

	//! Heat Haze
 	//! [UI Guides] displayName=Heat Haze, minValue=-1000.0, maxValue=1000.0
 	//! [Default value] 1
	bool set_hhfactor(float val) { return setValue("hhfactor", val); }
	//! Heat Haze
 	//! [UI Guides] displayName=Heat Haze, minValue=-1000.0, maxValue=1000.0
 	//! [Default value] 1
	float get_hhfactor() const { return getFloat("hhfactor"); }

	//! Render mode: Isosurface
 	//! [Default value] 0
	bool set_rendsolid(int val) { return setValue("rendsolid", val); }
	//! Render mode: Isosurface
 	//! [Default value] 0
	int get_rendsolid() const { return getInt("rendsolid"); }

	//! (description missing)
	//! [Default value] 0
	bool set_geommode(int val) { return setValue("geommode", val); }
	//! (description missing)
	//! [Default value] 0
	int get_geommode() const { return getInt("geommode"); }

	//! Render mode enum, one of the PhxRenderSets::RendMode enum values
 	//! [Default value] -1
	bool set_rendMode(int val) { return setValue("rendMode", val); }
	//! Render mode enum, one of the PhxRenderSets::RendMode enum values
 	//! [Default value] -1
	int get_rendMode() const { return getInt("rendMode"); }

	//! deprecated, don't use
 	//! [Default value] false
	bool set_left_handed_coord(bool val) { return setValue("left_handed_coord", val); }
	//! deprecated, don't use
 	//! [Default value] false
	bool get_left_handed_coord() const { return getBool("left_handed_coord"); }

	//! (description missing)
	//! [Default value] true
	bool set_mbself(bool val) { return setValue("mbself", val); }
	//! (description missing)
	//! [Default value] true
	bool get_mbself() const { return getBool("mbself"); }

	//! jitter
 	//! [UI Guides] displayName=Jittering, enableIf: ?render=1
 	//! [Default value] true
	bool set_jitter(bool val) { return setValue("jitter", val); }
	//! jitter
 	//! [UI Guides] displayName=Jittering, enableIf: ?render=1
 	//! [Default value] true
	bool get_jitter() const { return getBool("jitter"); }

	//! Fade Out
 	//! [UI Guides] displayName=Fade Out, minValue=0.0, maxValue=40.0, enableIf: ?render=1
 	//! [Default value] 0
	bool set_softb(float val) { return setValue("softb", val); }
	//! Fade Out
 	//! [UI Guides] displayName=Fade Out, minValue=0.0, maxValue=40.0, enableIf: ?render=1
 	//! [Default value] 0
	float get_softb() const { return getFloat("softb"); }

	//! [UI Guides] displayName=Diffuse Multiplier, minValue=0.0, maxValue=4.0, enableIf: ?noscatter!=0
 	//! [Default value] 1
	bool set_difmul(float val) { return setValue("difmul", val); }
	//! [UI Guides] displayName=Diffuse Multiplier, minValue=0.0, maxValue=4.0, enableIf: ?noscatter!=0
 	//! [Default value] 1
	float get_difmul() const { return getFloat("difmul"); }

	//! Sampler type: 0-box; 1-linear; 2-spherical
 	//! [UI Guides] displayName=Sampler Type, enum=0:Box; 1:Linear; 2:Spherical, enableIf: ?render=1
 	//! [Default value] 1
	bool set_sampler(int val) { return setValue("sampler", val); }
	//! Sampler type: 0-box; 1-linear; 2-spherical
 	//! [UI Guides] displayName=Sampler Type, enum=0:Box; 1:Linear; 2:Spherical, enableIf: ?render=1
 	//! [Default value] 1
	int get_sampler() const { return getInt("sampler"); }

	//! Simple Smoke Factor
 	//! [UI Guides] displayName=Simple Smoke Opacity, minValue=0.0, maxValue=1.0, enableIf: ?targ=0
 	//! [Default value] 0.5
	bool set_smoketransp(float val) { return setValue("smoketransp", val); }
	//! Simple Smoke Factor
 	//! [UI Guides] displayName=Simple Smoke Opacity, minValue=0.0, maxValue=1.0, enableIf: ?targ=0
 	//! [Default value] 0.5
	float get_smoketransp() const { return getFloat("smoketransp"); }

	//! (description missing)
	//! [Default value] false
	bool set_alphaunitscale(bool val) { return setValue("alphaunitscale", val); }
	//! (description missing)
	//! [Default value] false
	bool get_alphaunitscale() const { return getBool("alphaunitscale"); }

	//! (description missing)
	//! [Default value] 1
	bool set_basedensityscale(float val) { return setValue("basedensityscale", val); }
	//! (description missing)
	//! [Default value] 1
	float get_basedensityscale() const { return getFloat("basedensityscale"); }

	//! Enables the "Optimizing Volumetrics" prepass for grids over 15 million voxels which speeds up their sampling during rendering.
 	//! [Default value] true
	bool set_optvolpass(bool val) { return setValue("optvolpass", val); }
	//! Enables the "Optimizing Volumetrics" prepass for grids over 15 million voxels which speeds up their sampling during rendering.
 	//! [Default value] true
	bool get_optvolpass() const { return getBool("optvolpass"); }

	//! (description missing)
	//! [Default value] 0.999
	bool set_stoptransp(float val) { return setValue("stoptransp", val); }
	//! (description missing)
	//! [Default value] 0.999
	float get_stoptransp() const { return getFloat("stoptransp"); }

	//! (description missing)
	//! [Default value] 0.001
	bool set_skiptransp(float val) { return setValue("skiptransp", val); }
	//! (description missing)
	//! [Default value] 0.001
	float get_skiptransp() const { return getFloat("skiptransp"); }

	//! 0-ray-traced; 1-disabled; 2-approximate; 3-approximate+shadows
 	//! [UI Guides] displayName=Scattering, enum=0:Ray-Traced GI Only;1:Disabled;2:Approximate;3:Approximate+Shadows
 	//! [Default value] 3
	bool set_noscatter(int val) { return setValue("noscatter", val); }
	//! 0-ray-traced; 1-disabled; 2-approximate; 3-approximate+shadows
 	//! [UI Guides] displayName=Scattering, enum=0:Ray-Traced GI Only;1:Disabled;2:Approximate;3:Approximate+Shadows
 	//! [Default value] 3
	int get_noscatter() const { return getInt("noscatter"); }

	//! [UI Guides] displayName=Own Light Scatter Mult, minValue=0.0, maxValue=10.0, enableIf: ?noscatter=2;?noscatter=3
 	//! [Default value] 1
	bool set_transfown(float val) { return setValue("transfown", val); }
	//! [UI Guides] displayName=Own Light Scatter Mult, minValue=0.0, maxValue=10.0, enableIf: ?noscatter=2;?noscatter=3
 	//! [Default value] 1
	float get_transfown() const { return getFloat("transfown"); }

	//! [UI Guides] displayName=External Scatter Mult, minValue=0.0, maxValue=10.0, enableIf: ?noscatter=2;?noscatter=3
 	//! [Default value] 1
	bool set_transfext(float val) { return setValue("transfext", val); }
	//! [UI Guides] displayName=External Scatter Mult, minValue=0.0, maxValue=10.0, enableIf: ?noscatter=2;?noscatter=3
 	//! [Default value] 1
	float get_transfext() const { return getFloat("transfext"); }

	//! if 1, the values are interpreted as opacity instead of transparency.
 	//! [Default value] 1
	bool set_transpmode(int val) { return setValue("transpmode", val); }
	//! if 1, the values are interpreted as opacity instead of transparency.
 	//! [Default value] 1
	int get_transpmode() const { return getInt("transpmode"); }

	//! (description missing)
	//! [Default value] 1
	bool set_bias(float val) { return setValue("bias", val); }
	//! (description missing)
	//! [Default value] 1
	float get_bias() const { return getFloat("bias"); }

	//! (description missing)
	//! [Default value] 0
	bool set_usebias(int val) { return setValue("usebias", val); }
	//! (description missing)
	//! [Default value] 0
	int get_usebias() const { return getInt("usebias"); }

	//! (description missing)
	//! [Default value] false
	bool set_wrapx(bool val) { return setValue("wrapx", val); }
	//! (description missing)
	//! [Default value] false
	bool get_wrapx() const { return getBool("wrapx"); }

	//! (description missing)
	//! [Default value] false
	bool set_wrapy(bool val) { return setValue("wrapy", val); }
	//! (description missing)
	//! [Default value] false
	bool get_wrapy() const { return getBool("wrapy"); }

	//! (description missing)
	//! [Default value] false
	bool set_wrapz(bool val) { return setValue("wrapz", val); }
	//! (description missing)
	//! [Default value] false
	bool get_wrapz() const { return getBool("wrapz"); }

	//! light linking list used in volumetric mode
 	bool set_lightlinks(const ValueList& pluginList) { return setValue("lightlinks", pluginList); }
	//! light linking list used in volumetric mode
 	ValueList get_lightlinks() const { return getValueList("lightlinks"); }

	//! max GI bounces
 	//! [UI Guides] displayName=Scatter Depth, enableIf: ?noscatter=0
 	//! [Default value] 10
	bool set_bounces(int val) { return setValue("bounces", val); }
	//! max GI bounces
 	//! [UI Guides] displayName=Scatter Depth, enableIf: ?noscatter=0
 	//! [Default value] 10
	int get_bounces() const { return getInt("bounces"); }

	//! Velocity multiplier for the volume renderer.
 	//! [UI Guides] displayName=Velocity Multiplier, minValue=0, maxValue=1000, enableIf: ?render=1
 	//! [Default value] 1
	bool set_velocity_mult(float val) { return setValue("velocity_mult", val); }
	//! Velocity multiplier for the volume renderer.
 	//! [UI Guides] displayName=Velocity Multiplier, minValue=0, maxValue=1000, enableIf: ?render=1
 	//! [Default value] 1
	float get_velocity_mult() const { return getFloat("velocity_mult"); }

	//! Create velocity channel from uvw movement
 	//! [Default value] false
	bool set_velocities_from_uvw(bool val) { return setValue("velocities_from_uvw", val); }
	//! Create velocity channel from uvw movement
 	//! [Default value] false
	bool get_velocities_from_uvw() const { return getBool("velocities_from_uvw"); }

	//! The strength of the shadow.
 	//! [UI Guides] displayName=Shadow Strength, minValue=0.0, maxValue=100
 	//! [Default value] 1
	bool set_shad_strength(float val) { return setValue("shad_strength", val); }
	//! The strength of the shadow.
 	//! [UI Guides] displayName=Shadow Strength, minValue=0.0, maxValue=100
 	//! [Default value] 1
	float get_shad_strength() const { return getFloat("shad_strength"); }

	//! The texture coordinates generation method.
 	//! [UI Guides] displayName=Coordinate Method, enum=0:Fixed; 1:Grid
 	//! [Default value] 0
	bool set_coord_method(int val) { return setValue("coord_method", val); }
	//! The texture coordinates generation method.
 	//! [UI Guides] displayName=Coordinate Method, enum=0:Fixed; 1:Grid
 	//! [Default value] 0
	int get_coord_method() const { return getInt("coord_method"); }

	//! Gamma multiplier for Phoenix's render output.
 	//! [Default value] 1
	bool set_gamma_mult(float val) { return setValue("gamma_mult", val); }
	//! Gamma multiplier for Phoenix's render output.
 	//! [Default value] 1
	float get_gamma_mult() const { return getFloat("gamma_mult"); }

	//! Number of Gaussian passes to smooth out the motion blur.
 	//! [Default value] 3
	bool set_mbsmooth(int val) { return setValue("mbsmooth", val); }
	//! Number of Gaussian passes to smooth out the motion blur.
 	//! [Default value] 3
	int get_mbsmooth() const { return getInt("mbsmooth"); }

	//! Use 1 to enable the displacement fading around an object
 	//! [Default value] 0
	bool set_usefadeobj(int val) { return setValue("usefadeobj", val); }
	//! Use 1 to enable the displacement fading around an object
 	//! [Default value] 0
	int get_usefadeobj() const { return getInt("usefadeobj"); }

	//! The distance around the object where the displacement is going to be reduced.
 	//! [Default value] 20
	bool set_displgeomfade(float val) { return setValue("displgeomfade", val); }
	//! The distance around the object where the displacement is going to be reduced.
 	//! [Default value] 20
	float get_displgeomfade() const { return getFloat("displgeomfade"); }

	//! The object that is going to be used for displacement fade
 	bool set_fadeobj(const Plugin& plugin) { return setValue("fadeobj", plugin); }
	//! The object that is going to be used for displacement fade
 	Plugin get_fadeobj() const { return getPlugin("fadeobj"); }

	//! world transformation of the gizmo
 	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	bool set_fadeobj_transform(const Transform& transform) { return setValue("fadeobj_transform", transform); }
	//! world transformation of the gizmo
 	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	Transform get_fadeobj_transform() const { return getTransform("fadeobj_transform"); }

	//! If true, use mesher to generate runtime V-Ray static mesh
 	//! [Default value] false
	bool set_mesher(bool val) { return setValue("mesher", val); }
	//! If true, use mesher to generate runtime V-Ray static mesh
 	//! [Default value] false
	bool get_mesher() const { return getBool("mesher"); }

	//! Mesh smoothing iterations
 	//! [UI Guides] displayName=Mesh Smoothing Level, minValue=0, maxValue=20
 	//! [Default value] 0
	bool set_smoothmesh(int val) { return setValue("smoothmesh", val); }
	//! Mesh smoothing iterations
 	//! [UI Guides] displayName=Mesh Smoothing Level, minValue=0, maxValue=20
 	//! [Default value] 0
	int get_smoothmesh() const { return getInt("smoothmesh"); }

	//! Use FLIP Liquid particles for smoothing the mesh
 	//! [Default value] false
	bool set_useprt(bool val) { return setValue("useprt", val); }
	//! Use FLIP Liquid particles for smoothing the mesh
 	//! [Default value] false
	bool get_useprt() const { return getBool("useprt"); }

	//! Size of the particles used for mesh smoothing
 	//! [Default value] 0.5
	bool set_prtsz(float val) { return setValue("prtsz", val); }
	//! Size of the particles used for mesh smoothing
 	//! [Default value] 0.5
	float get_prtsz() const { return getFloat("prtsz"); }

	//! Mesh skyline subdivisions
 	//! [Default value] 5
	bool set_meshsubdiv(float val) { return setValue("meshsubdiv", val); }
	//! Mesh skyline subdivisions
 	//! [Default value] 5
	float get_meshsubdiv() const { return getFloat("meshsubdiv"); }

	//! In Ocean Mesh or Cap Mesh mode, the cache files will not be used and the ocean will be built without cache files for each frame
 	//! [Default value] false
	bool set_pureocean(bool val) { return setValue("pureocean", val); }
	//! In Ocean Mesh or Cap Mesh mode, the cache files will not be used and the ocean will be built without cache files for each frame
 	//! [Default value] false
	bool get_pureocean() const { return getBool("pureocean"); }

	//! Mesh skyline darkening
 	//! [Default value] 0.5
	bool set_darksky(float val) { return setValue("darksky", val); }
	//! Mesh skyline darkening
 	//! [Default value] 0.5
	float get_darksky() const { return getFloat("darksky"); }

	//! If true, generate 'ocean' geometry outside the simulator.
 	//! [Default value] false
	bool set_ocean(bool val) { return setValue("ocean", val); }
	//! If true, generate 'ocean' geometry outside the simulator.
 	//! [Default value] false
	bool get_ocean() const { return getBool("ocean"); }

	//! Mesh 'ocean' level
 	//! [UI Guides] displayName=Ocean Level, minValue=0, maxValue=100
 	//! [Default value] 50
	bool set_oceanlevel(float val) { return setValue("oceanlevel", val); }
	//! Mesh 'ocean' level
 	//! [UI Guides] displayName=Ocean Level, minValue=0, maxValue=100
 	//! [Default value] 50
	float get_oceanlevel() const { return getFloat("oceanlevel"); }

	//! If true, ecolor_position, dcolor_positions and transp_positions are normalized between offset and scale.
 	//! [Default value] 0
	bool set_normalized_positions(int val) { return setValue("normalized_positions", val); }
	//! If true, ecolor_position, dcolor_positions and transp_positions are normalized between offset and scale.
 	//! [Default value] 0
	int get_normalized_positions() const { return getInt("normalized_positions"); }

	//! [UI Guides] displayName=Modulate with Texture, enableIf: ?earg!=0,?earg!=4
 	//! [Default value] false
	bool set_mod_e(bool val) { return setValue("mod_e", val); }
	//! [UI Guides] displayName=Modulate with Texture, enableIf: ?earg!=0,?earg!=4
 	//! [Default value] false
	bool get_mod_e() const { return getBool("mod_e"); }

	//! 0-disabled; 1-T; 2-Sm; 3-V; 4-texture; 5-RGB; 10-fuel
 	//! [UI Guides] displayName=Based On, enum=0:Disabled; 1:Temperature; 2:Smoke; 3:Speed; 4:Texture; 5:RGB; 10:Fuel, startRollout=Incandescence
 	//! [Default value] 1
	bool set_earg(int val) { return setValue("earg", val); }
	//! 0-disabled; 1-T; 2-Sm; 3-V; 4-texture; 5-RGB; 10-fuel
 	//! [UI Guides] displayName=Based On, enum=0:Disabled; 1:Temperature; 2:Smoke; 3:Speed; 4:Texture; 5:RGB; 10:Fuel, startRollout=Incandescence
 	//! [Default value] 1
	int get_earg() const { return getInt("earg"); }

	//! [UI Guides] displayName=Emissive Texture, attributes=textureSlot
 	bool set_etex(const Plugin& texture) { return setValue("etex", texture); }
	//! [UI Guides] displayName=Emissive Texture, attributes=textureSlot
 	bool set_etex(const AColor& texture) { return setValue("etex", texture); }
	//! [UI Guides] displayName=Emissive Texture, attributes=textureSlot
 	Value get_etex() const { return getValue("etex"); }

	//! raw emissive table
 	//! [Default value] Color(0, 0, 0)
	bool set_ecolor(const Color& color) { return setValue("ecolor", color); }
	//! raw emissive table
 	//! [Default value] Color(0, 0, 0)
	Color get_ecolor() const { return getColor("ecolor"); }

	//! positions of the emission color ramp
 	//! [Default value] 0
	bool set_ecolor_positions(const FloatList& floatList) { return setValue("ecolor_positions", floatList); }
	//! positions of the emission color ramp
 	//! [Default value] 0
	bool set_ecolor_positions(const float* floats, size_t count) { return setArray("ecolor_positions", floats, count); }
	//! positions of the emission color ramp
 	//! [Default value] 0
	template<size_t count> bool set_ecolor_positions(const float (&floats)[count]) { return setArray("ecolor_positions", floats, count); }
	//! positions of the emission color ramp
 	//! [Default value] 0
	FloatList get_ecolor_positions() const { return getFloatList("ecolor_positions"); }

	//! colors of the emission color ramp
 	//! [Default value] Color(0, 0, 0)
	bool set_ecolor_colors(const ColorList& colorList) { return setValue("ecolor_colors", colorList); }
	//! colors of the emission color ramp
 	//! [Default value] Color(0, 0, 0)
	bool set_ecolor_colors(const Color* colors, size_t count) { return setArray("ecolor_colors", colors, count); }
	//! colors of the emission color ramp
 	//! [Default value] Color(0, 0, 0)
	template<size_t count> bool set_ecolor_colors(const Color (&colors)[count]) { return setArray("ecolor_colors", colors, count); }
	//! colors of the emission color ramp
 	//! [Default value] Color(0, 0, 0)
	ColorList get_ecolor_colors() const { return getColorList("ecolor_colors"); }

	//! Currently not used!
 	//! [Default value] 3
	bool set_ecolor_interpolations(const IntList& intList) { return setValue("ecolor_interpolations", intList); }
	//! Currently not used!
 	//! [Default value] 3
	bool set_ecolor_interpolations(const int* ints, size_t count) { return setArray("ecolor_interpolations", ints, count); }
	//! Currently not used!
 	//! [Default value] 3
	template<size_t count> bool set_ecolor_interpolations(const int (&ints)[count]) { return setArray("ecolor_interpolations", ints, count); }
	//! Currently not used!
 	//! [Default value] 3
	IntList get_ecolor_interpolations() const { return getIntList("ecolor_interpolations"); }

	//! The gradient for remapping the Fire base channel to self-illumination color.
 	//! [UI Guides] displayName=Fire Color Gradient, enableIf: ?earg!=0,?earg!=4,?earg!=5
 	bool set_ecolor_remap(const Plugin& plugin) { return setValue("ecolor_remap", plugin); }
	//! The gradient for remapping the Fire base channel to self-illumination color.
 	//! [UI Guides] displayName=Fire Color Gradient, enableIf: ?earg!=0,?earg!=4,?earg!=5
 	Plugin get_ecolor_remap() const { return getPlugin("ecolor_remap"); }

	//! positions of the luminance ramp
 	//! [Default value] 1
	bool set_elum_positions(const FloatList& floatList) { return setValue("elum_positions", floatList); }
	//! positions of the luminance ramp
 	//! [Default value] 1
	bool set_elum_positions(const float* floats, size_t count) { return setArray("elum_positions", floats, count); }
	//! positions of the luminance ramp
 	//! [Default value] 1
	template<size_t count> bool set_elum_positions(const float (&floats)[count]) { return setArray("elum_positions", floats, count); }
	//! positions of the luminance ramp
 	//! [Default value] 1
	FloatList get_elum_positions() const { return getFloatList("elum_positions"); }

	//! values of the luminance ramp
 	//! [Default value] 0
	bool set_elum_values(const FloatList& floatList) { return setValue("elum_values", floatList); }
	//! values of the luminance ramp
 	//! [Default value] 0
	bool set_elum_values(const float* floats, size_t count) { return setArray("elum_values", floats, count); }
	//! values of the luminance ramp
 	//! [Default value] 0
	template<size_t count> bool set_elum_values(const float (&floats)[count]) { return setArray("elum_values", floats, count); }
	//! values of the luminance ramp
 	//! [Default value] 0
	FloatList get_elum_values() const { return getFloatList("elum_values"); }

	//! 0: none, 1: linear, 2: smooth, 3: spline, 4: bezier, 5: logarithmic+bezier
 	//! [Default value] 0
	bool set_elum_interpolations(const IntList& intList) { return setValue("elum_interpolations", intList); }
	//! 0: none, 1: linear, 2: smooth, 3: spline, 4: bezier, 5: logarithmic+bezier
 	//! [Default value] 0
	bool set_elum_interpolations(const int* ints, size_t count) { return setArray("elum_interpolations", ints, count); }
	//! 0: none, 1: linear, 2: smooth, 3: spline, 4: bezier, 5: logarithmic+bezier
 	//! [Default value] 0
	template<size_t count> bool set_elum_interpolations(const int (&ints)[count]) { return setArray("elum_interpolations", ints, count); }
	//! 0: none, 1: linear, 2: smooth, 3: spline, 4: bezier, 5: logarithmic+bezier
 	//! [Default value] 0
	IntList get_elum_interpolations() const { return getIntList("elum_interpolations"); }

	//! The gradient for remapping the Fire base channel to self-illumination intensity.
 	//! [UI Guides] displayName=Fire Luminance Gradient, enableIf: ?earg!=0,?earg!=4,?earg!=5
 	bool set_elum_remap(const Plugin& plugin) { return setValue("elum_remap", plugin); }
	//! The gradient for remapping the Fire base channel to self-illumination intensity.
 	//! [UI Guides] displayName=Fire Luminance Gradient, enableIf: ?earg!=0,?earg!=4,?earg!=5
 	Plugin get_elum_remap() const { return getPlugin("elum_remap"); }

	//! [UI Guides] displayName=Input Offset, enableIf: ?earg!=0,?earg!=4,?earg!=5
 	//! [Default value] 0
	bool set_ecolor_offset(float val) { return setValue("ecolor_offset", val); }
	//! [UI Guides] displayName=Input Offset, enableIf: ?earg!=0,?earg!=4,?earg!=5
 	//! [Default value] 0
	float get_ecolor_offset() const { return getFloat("ecolor_offset"); }

	//! [UI Guides] displayName=Input Scale, minValue=0, enableIf: ?earg!=0,?earg!=4,?earg!=5
 	//! [Default value] 1
	bool set_ecolor_scale(float val) { return setValue("ecolor_scale", val); }
	//! [UI Guides] displayName=Input Scale, minValue=0, enableIf: ?earg!=0,?earg!=4,?earg!=5
 	//! [Default value] 1
	float get_ecolor_scale() const { return getFloat("ecolor_scale"); }

	//! multiplier for the emission color
 	//! [UI Guides] displayName=Luminance Scale, minValue=0, enableIf: ?earg!=0,?earg!=5
 	//! [Default value] 1
	bool set_emult(float val) { return setValue("emult", val); }
	//! multiplier for the emission color
 	//! [UI Guides] displayName=Luminance Scale, minValue=0, enableIf: ?earg!=0,?earg!=5
 	//! [Default value] 1
	float get_emult() const { return getFloat("emult"); }

	//! multiplier for the emission alpha if Fire Opacity Mode is set to Use Own Opacity.
 	//! [UI Guides] displayName=Opacity Multiplier, minValue=0, maxValue=100, enableIf: ?earg!=0,?earg!=5,?fire_opacity_mode!=0
 	//! [Default value] 1
	bool set_etmult(float val) { return setValue("etmult", val); }
	//! multiplier for the emission alpha if Fire Opacity Mode is set to Use Own Opacity.
 	//! [UI Guides] displayName=Opacity Multiplier, minValue=0, maxValue=100, enableIf: ?earg!=0,?earg!=5,?fire_opacity_mode!=0
 	//! [Default value] 1
	float get_etmult() const { return getFloat("etmult"); }

	//! Implicitly multiply the emissive diagram with a black body exponent
 	//! [Default value] -1
	bool set_blackbody(float val) { return setValue("blackbody", val); }
	//! Implicitly multiply the emissive diagram with a black body exponent
 	//! [Default value] -1
	float get_blackbody() const { return getFloat("blackbody"); }

	//! 0 - Use Smoke Opacity - fire will use the same opacity that is set in the 'Smoke Opacity' rollout. This way there will be no emission in cells where there is no smoke.
 	//! 1 - Fully Visible - fire will always use 'Opacity Multiplier', regardless of the smoke opacity.
 	//! 2 - Use Own Opacity - the Fire Luminance Gradient is used to determine the opacity.
 	//! [UI Guides] displayName=Opacity Mode, enum=0:Use Diffuse Opacity;1:Fully Visible;2:Use Own Opacity, enableIf: ?earg!=0
 	//! [Default value] 0
	bool set_fire_opacity_mode(int val) { return setValue("fire_opacity_mode", val); }
	//! 0 - Use Smoke Opacity - fire will use the same opacity that is set in the 'Smoke Opacity' rollout. This way there will be no emission in cells where there is no smoke.
 	//! 1 - Fully Visible - fire will always use 'Opacity Multiplier', regardless of the smoke opacity.
 	//! 2 - Use Own Opacity - the Fire Luminance Gradient is used to determine the opacity.
 	//! [UI Guides] displayName=Opacity Mode, enum=0:Use Diffuse Opacity;1:Fully Visible;2:Use Own Opacity, enableIf: ?earg!=0
 	//! [Default value] 0
	int get_fire_opacity_mode() const { return getInt("fire_opacity_mode"); }

	//! [UI Guides] displayName=Modulate with Texture, enableIf: ?darg!=0,?darg!=4
 	//! [Default value] false
	bool set_mod_d(bool val) { return setValue("mod_d", val); }
	//! [UI Guides] displayName=Modulate with Texture, enableIf: ?darg!=0,?darg!=4
 	//! [Default value] false
	bool get_mod_d() const { return getBool("mod_d"); }

	//! 0-disabled; 1-T; 2-Sm; 3-V; 4-texture; 5-simple color; 6-RGB; 10-fuel
 	//! [UI Guides] displayName=Based On, enum=0:Disabled; 1:Temperature; 2:Smoke; 3:Speed; 4:Texture; 5:Simple Color; 6:RGB; 10:Fuel, startRollout=Diffuse Color
 	//! [Default value] 5
	bool set_darg(int val) { return setValue("darg", val); }
	//! 0-disabled; 1-T; 2-Sm; 3-V; 4-texture; 5-simple color; 6-RGB; 10-fuel
 	//! [UI Guides] displayName=Based On, enum=0:Disabled; 1:Temperature; 2:Smoke; 3:Speed; 4:Texture; 5:Simple Color; 6:RGB; 10:Fuel, startRollout=Diffuse Color
 	//! [Default value] 5
	int get_darg() const { return getInt("darg"); }

	//! [UI Guides] displayName=Diffuse Texture, attributes=textureSlot
 	bool set_dtex(const Plugin& texture) { return setValue("dtex", texture); }
	//! [UI Guides] displayName=Diffuse Texture, attributes=textureSlot
 	bool set_dtex(const AColor& texture) { return setValue("dtex", texture); }
	//! [UI Guides] displayName=Diffuse Texture, attributes=textureSlot
 	Value get_dtex() const { return getValue("dtex"); }

	//! raw diffuse table
 	//! [Default value] Color(0, 0, 0)
	bool set_dcolor(const Color& color) { return setValue("dcolor", color); }
	//! raw diffuse table
 	//! [Default value] Color(0, 0, 0)
	Color get_dcolor() const { return getColor("dcolor"); }

	//! positions of the diffuse color ramp
 	//! [Default value] 0
	bool set_dcolor_positions(const FloatList& floatList) { return setValue("dcolor_positions", floatList); }
	//! positions of the diffuse color ramp
 	//! [Default value] 0
	bool set_dcolor_positions(const float* floats, size_t count) { return setArray("dcolor_positions", floats, count); }
	//! positions of the diffuse color ramp
 	//! [Default value] 0
	template<size_t count> bool set_dcolor_positions(const float (&floats)[count]) { return setArray("dcolor_positions", floats, count); }
	//! positions of the diffuse color ramp
 	//! [Default value] 0
	FloatList get_dcolor_positions() const { return getFloatList("dcolor_positions"); }

	//! colors of the diffuse color ramp
 	//! [Default value] Color(0, 0, 0)
	bool set_dcolor_colors(const ColorList& colorList) { return setValue("dcolor_colors", colorList); }
	//! colors of the diffuse color ramp
 	//! [Default value] Color(0, 0, 0)
	bool set_dcolor_colors(const Color* colors, size_t count) { return setArray("dcolor_colors", colors, count); }
	//! colors of the diffuse color ramp
 	//! [Default value] Color(0, 0, 0)
	template<size_t count> bool set_dcolor_colors(const Color (&colors)[count]) { return setArray("dcolor_colors", colors, count); }
	//! colors of the diffuse color ramp
 	//! [Default value] Color(0, 0, 0)
	ColorList get_dcolor_colors() const { return getColorList("dcolor_colors"); }

	//! Currently not used!
 	//! [Default value] 3
	bool set_dcolor_interpolations(const IntList& intList) { return setValue("dcolor_interpolations", intList); }
	//! Currently not used!
 	//! [Default value] 3
	bool set_dcolor_interpolations(const int* ints, size_t count) { return setArray("dcolor_interpolations", ints, count); }
	//! Currently not used!
 	//! [Default value] 3
	template<size_t count> bool set_dcolor_interpolations(const int (&ints)[count]) { return setArray("dcolor_interpolations", ints, count); }
	//! Currently not used!
 	//! [Default value] 3
	IntList get_dcolor_interpolations() const { return getIntList("dcolor_interpolations"); }

	//! The gradient for remapping the Diffuse input to a diffuse color.
 	//! [UI Guides] displayName=Diffuse Color Gradient, enableIf: ?darg!=0,?darg!=4,?darg!=5,?darg!=6
 	bool set_dcolor_remap(const Plugin& plugin) { return setValue("dcolor_remap", plugin); }
	//! The gradient for remapping the Diffuse input to a diffuse color.
 	//! [UI Guides] displayName=Diffuse Color Gradient, enableIf: ?darg!=0,?darg!=4,?darg!=5,?darg!=6
 	Plugin get_dcolor_remap() const { return getPlugin("dcolor_remap"); }

	//! [UI Guides] displayName=Input Offset, enableIf: ?darg!=0,?darg!=4,?darg!=5,?darg!=6
 	//! [Default value] 0
	bool set_dcolor_offset(float val) { return setValue("dcolor_offset", val); }
	//! [UI Guides] displayName=Input Offset, enableIf: ?darg!=0,?darg!=4,?darg!=5,?darg!=6
 	//! [Default value] 0
	float get_dcolor_offset() const { return getFloat("dcolor_offset"); }

	//! [UI Guides] displayName=Input Scale, minValue=0, enableIf: ?darg!=0,?darg!=4,?darg!=5,?darg!=6
 	//! [Default value] 1
	bool set_dcolor_scale(float val) { return setValue("dcolor_scale", val); }
	//! [UI Guides] displayName=Input Scale, minValue=0, enableIf: ?darg!=0,?darg!=4,?darg!=5,?darg!=6
 	//! [Default value] 1
	float get_dcolor_scale() const { return getFloat("dcolor_scale"); }

	//! Simple Color
 	//! [UI Guides] displayName=Simple Color, enableIf: ?darg=5
 	//! [Default value] AColor(0.2, 0.2, 0.2, 1)
	bool set_simple_color(const AColor& acolor) { return setValue("simple_color", acolor); }
	//! Simple Color
 	//! [UI Guides] displayName=Simple Color, enableIf: ?darg=5
 	//! [Default value] AColor(0.2, 0.2, 0.2, 1)
	AColor get_simple_color() const { return getAColor("simple_color"); }

	//! [UI Guides] displayName=Modulate with Texture, enableIf: ?targ!=4
 	//! [Default value] false
	bool set_mod_t(bool val) { return setValue("mod_t", val); }
	//! [UI Guides] displayName=Modulate with Texture, enableIf: ?targ!=4
 	//! [Default value] false
	bool get_mod_t() const { return getBool("mod_t"); }

	//! 0-simple smoke; 1-T; 2-Sm; 3-V; 4-texture; 10-fuel
 	//! [UI Guides] displayName=Based On, enum=0:Simple Smoke; 1:Temperature; 2:Smoke; 3:Speed; 4:Texture; 10:Fuel, startRollout=Diffuse Opacity
 	//! [Default value] 0
	bool set_targ(int val) { return setValue("targ", val); }
	//! 0-simple smoke; 1-T; 2-Sm; 3-V; 4-texture; 10-fuel
 	//! [UI Guides] displayName=Based On, enum=0:Simple Smoke; 1:Temperature; 2:Smoke; 3:Speed; 4:Texture; 10:Fuel, startRollout=Diffuse Opacity
 	//! [Default value] 0
	int get_targ() const { return getInt("targ"); }

	//! [UI Guides] displayName=Opacity Texture, attributes=textureSlot
 	bool set_ttex(const Plugin& texture) { return setValue("ttex", texture); }
	//! [UI Guides] displayName=Opacity Texture, attributes=textureSlot
 	bool set_ttex(const AColor& texture) { return setValue("ttex", texture); }
	//! [UI Guides] displayName=Opacity Texture, attributes=textureSlot
 	Value get_ttex() const { return getValue("ttex"); }

	//! raw transparency table
 	//! [Default value] 0
	bool set_transp(float val) { return setValue("transp", val); }
	//! raw transparency table
 	//! [Default value] 0
	float get_transp() const { return getFloat("transp"); }

	//! positions of the transparency ramp
 	//! [Default value] 0
	bool set_transp_positions(const FloatList& floatList) { return setValue("transp_positions", floatList); }
	//! positions of the transparency ramp
 	//! [Default value] 0
	bool set_transp_positions(const float* floats, size_t count) { return setArray("transp_positions", floats, count); }
	//! positions of the transparency ramp
 	//! [Default value] 0
	template<size_t count> bool set_transp_positions(const float (&floats)[count]) { return setArray("transp_positions", floats, count); }
	//! positions of the transparency ramp
 	//! [Default value] 0
	FloatList get_transp_positions() const { return getFloatList("transp_positions"); }

	//! values of the transparency ramp
 	//! [Default value] 0
	bool set_transp_values(const FloatList& floatList) { return setValue("transp_values", floatList); }
	//! values of the transparency ramp
 	//! [Default value] 0
	bool set_transp_values(const float* floats, size_t count) { return setArray("transp_values", floats, count); }
	//! values of the transparency ramp
 	//! [Default value] 0
	template<size_t count> bool set_transp_values(const float (&floats)[count]) { return setArray("transp_values", floats, count); }
	//! values of the transparency ramp
 	//! [Default value] 0
	FloatList get_transp_values() const { return getFloatList("transp_values"); }

	//! 0: none, 1: linear, 2: smooth, 3: spline
 	//! [Default value] 0
	bool set_transp_interpolations(const IntList& intList) { return setValue("transp_interpolations", intList); }
	//! 0: none, 1: linear, 2: smooth, 3: spline
 	//! [Default value] 0
	bool set_transp_interpolations(const int* ints, size_t count) { return setArray("transp_interpolations", ints, count); }
	//! 0: none, 1: linear, 2: smooth, 3: spline
 	//! [Default value] 0
	template<size_t count> bool set_transp_interpolations(const int (&ints)[count]) { return setArray("transp_interpolations", ints, count); }
	//! 0: none, 1: linear, 2: smooth, 3: spline
 	//! [Default value] 0
	IntList get_transp_interpolations() const { return getIntList("transp_interpolations"); }

	//! The gradient for remapping the Opacity input to opacity.
 	//! [UI Guides] displayName=Opacity Gradient, enableIf: ?targ!=0,?targ!=4
 	bool set_transp_remap(const Plugin& plugin) { return setValue("transp_remap", plugin); }
	//! The gradient for remapping the Opacity input to opacity.
 	//! [UI Guides] displayName=Opacity Gradient, enableIf: ?targ!=0,?targ!=4
 	Plugin get_transp_remap() const { return getPlugin("transp_remap"); }

	//! [UI Guides] displayName=Input Offset, enableIf: ?targ!=0,?targ!=4
 	//! [Default value] 0
	bool set_transp_offset(float val) { return setValue("transp_offset", val); }
	//! [UI Guides] displayName=Input Offset, enableIf: ?targ!=0,?targ!=4
 	//! [Default value] 0
	float get_transp_offset() const { return getFloat("transp_offset"); }

	//! [UI Guides] displayName=Input Scale, minValue=0, enableIf: ?targ!=0,?targ!=4
 	//! [Default value] 1
	bool set_transp_scale(float val) { return setValue("transp_scale", val); }
	//! [UI Guides] displayName=Input Scale, minValue=0, enableIf: ?targ!=0,?targ!=4
 	//! [Default value] 1
	float get_transp_scale() const { return getFloat("transp_scale"); }

	//! [UI Guides] displayName=Opacity Scale, minValue=0, enableIf: ?targ!=0,?targ!=4
 	//! [Default value] 1
	bool set_tmult(float val) { return setValue("tmult", val); }
	//! [UI Guides] displayName=Opacity Scale, minValue=0, enableIf: ?targ!=0,?targ!=4
 	//! [Default value] 1
	float get_tmult() const { return getFloat("tmult"); }

	//! deprecated
 	//! [Default value] 1
	bool set_transp_power(float val) { return setValue("transp_power", val); }
	//! deprecated
 	//! [Default value] 1
	float get_transp_power() const { return getFloat("transp_power"); }

	//! (description missing)
	//! [Default value] 1
	bool set_shadow_opacity(float val) { return setValue("shadow_opacity", val); }
	//! (description missing)
	//! [Default value] 1
	float get_shadow_opacity() const { return getFloat("shadow_opacity"); }

	//! Cell stretch aspect for the 3 axes
 	//! [Default value] 1
	bool set_cell_aspect(const FloatList& floatList) { return setValue("cell_aspect", floatList); }
	//! Cell stretch aspect for the 3 axes
 	//! [Default value] 1
	bool set_cell_aspect(const float* floats, size_t count) { return setArray("cell_aspect", floats, count); }
	//! Cell stretch aspect for the 3 axes
 	//! [Default value] 1
	template<size_t count> bool set_cell_aspect(const float (&floats)[count]) { return setArray("cell_aspect", floats, count); }
	//! Cell stretch aspect for the 3 axes
 	//! [Default value] 1
	FloatList get_cell_aspect() const { return getFloatList("cell_aspect"); }

	//! 0-normal velocity; 2-texture
 	//! [Default value] 0
	bool set_varg(int val) { return setValue("varg", val); }
	//! 0-normal velocity; 2-texture
 	//! [Default value] 0
	int get_varg() const { return getInt("varg"); }

	//! Velocity Texture - used by Maya Fluids
 	//! [UI Guides] displayName=Velocity Texture, attributes=textureSlot
 	bool set_vtex(const Plugin& texture) { return setValue("vtex", texture); }
	//! Velocity Texture - used by Maya Fluids
 	//! [UI Guides] displayName=Velocity Texture, attributes=textureSlot
 	bool set_vtex(const AColor& texture) { return setValue("vtex", texture); }
	//! Velocity Texture - used by Maya Fluids
 	//! [UI Guides] displayName=Velocity Texture, attributes=textureSlot
 	Value get_vtex() const { return getValue("vtex"); }

	//! (description missing)
	//! [Default value] 0
	bool set_mod_v(int val) { return setValue("mod_v", val); }
	//! (description missing)
	//! [Default value] 0
	int get_mod_v() const { return getInt("mod_v"); }

	//! Specify directly the velocities in distance per frame
 	//! [Default value] Color(0, 0, 0)
	bool set_velocities(const ColorList& colorList) { return setValue("velocities", colorList); }
	//! Specify directly the velocities in distance per frame
 	//! [Default value] Color(0, 0, 0)
	bool set_velocities(const Color* colors, size_t count) { return setArray("velocities", colors, count); }
	//! Specify directly the velocities in distance per frame
 	//! [Default value] Color(0, 0, 0)
	template<size_t count> bool set_velocities(const Color (&colors)[count]) { return setArray("velocities", colors, count); }
	//! Specify directly the velocities in distance per frame
 	//! [Default value] Color(0, 0, 0)
	ColorList get_velocities() const { return getColorList("velocities"); }

	//! enable using of render cutter
 	//! [Default value] 0
	bool set_usegizmo(int val) { return setValue("usegizmo", val); }
	//! enable using of render cutter
 	//! [Default value] 0
	int get_usegizmo() const { return getInt("usegizmo"); }

	//! invert the volume of the render cutter
 	//! [Default value] 0
	bool set_invgizmo(int val) { return setValue("invgizmo", val); }
	//! invert the volume of the render cutter
 	//! [Default value] 0
	int get_invgizmo() const { return getInt("invgizmo"); }

	//! geometry to define the rendering volume
 	bool set_gizmo(const Plugin& plugin) { return setValue("gizmo", plugin); }
	//! geometry to define the rendering volume
 	Plugin get_gizmo() const { return getPlugin("gizmo"); }

	//! world transformation of the gizmo
 	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	bool set_gizmo_transform(const Transform& transform) { return setValue("gizmo_transform", transform); }
	//! world transformation of the gizmo
 	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	Transform get_gizmo_transform() const { return getTransform("gizmo_transform"); }

	//! enable the additional emissive lights
 	//! [UI Guides] displayName=Emit Light, startRollout=Light from Fire
 	//! [Default value] true
	bool set_al_enable(bool val) { return setValue("al_enable", val); }
	//! enable the additional emissive lights
 	//! [UI Guides] displayName=Emit Light, startRollout=Light from Fire
 	//! [Default value] true
	bool get_al_enable() const { return getBool("al_enable"); }

	//! additional number of emissive lights
 	//! [UI Guides] displayName=Lights Count, minValue=0, maxValue=1000, enableIf: ?al_enable=1
 	//! [Default value] 0
	bool set_lights(int val) { return setValue("lights", val); }
	//! additional number of emissive lights
 	//! [UI Guides] displayName=Lights Count, minValue=0, maxValue=1000, enableIf: ?al_enable=1
 	//! [Default value] 0
	int get_lights() const { return getInt("lights"); }

	//! emissive lights placement type, 0-simple, 1-inside, 2-grid
 	//! [UI Guides] displayName=Lights Placement, enum=0:Simple;1:Inside;2:Reduced Grid, enableIf: ?al_enable=1
 	//! [Default value] 2
	bool set_al_placing(int val) { return setValue("al_placing", val); }
	//! emissive lights placement type, 0-simple, 1-inside, 2-grid
 	//! [UI Guides] displayName=Lights Placement, enum=0:Simple;1:Inside;2:Reduced Grid, enableIf: ?al_enable=1
 	//! [Default value] 2
	int get_al_placing() const { return getInt("al_placing"); }

	//! sampling type, 0-simple, 1-DMC
 	//! [UI Guides] displayName=Sampling, enum=0:Simple;1:DMC, enableIf: ?al_enable=1
 	//! [Default value] 1
	bool set_al_sampling(int val) { return setValue("al_sampling", val); }
	//! sampling type, 0-simple, 1-DMC
 	//! [UI Guides] displayName=Sampling, enum=0:Simple;1:DMC, enableIf: ?al_enable=1
 	//! [Default value] 1
	int get_al_sampling() const { return getInt("al_sampling"); }

	//! number of subdivision for the DMC light sampling
 	//! [UI Guides] displayName=Direct Subdivs, minValue=0, maxValue=20000, enableIf: ?al_enable=1
 	//! [Default value] 8
	bool set_al_subdivs(int val) { return setValue("al_subdivs", val); }
	//! number of subdivision for the DMC light sampling
 	//! [UI Guides] displayName=Direct Subdivs, minValue=0, maxValue=20000, enableIf: ?al_enable=1
 	//! [Default value] 8
	int get_al_subdivs() const { return getInt("al_subdivs"); }

	//! number of caustics subdivision for lights
 	//! [UI Guides] displayName=Caustics Subdivs, minValue=0, enableIf: ?al_enable=1
 	//! [Default value] 1000
	bool set_al_csubdivs(int val) { return setValue("al_csubdivs", val); }
	//! number of caustics subdivision for lights
 	//! [UI Guides] displayName=Caustics Subdivs, minValue=0, enableIf: ?al_enable=1
 	//! [Default value] 1000
	int get_al_csubdivs() const { return getInt("al_csubdivs"); }

	//! [UI Guides] displayName=Caustics Multiplier, enableIf: ?al_enable=1
 	//! [Default value] 1
	bool set_al_cmult(float val) { return setValue("al_cmult", val); }
	//! [UI Guides] displayName=Caustics Multiplier, enableIf: ?al_enable=1
 	//! [Default value] 1
	float get_al_cmult() const { return getFloat("al_cmult"); }

	//! if true, the emissive lights will be created, even the volume is not renderable
 	//! [UI Guides] enableIf: ?al_enable=1
 	//! [Default value] false
	bool set_persistlights(bool val) { return setValue("persistlights", val); }
	//! if true, the emissive lights will be created, even the volume is not renderable
 	//! [UI Guides] enableIf: ?al_enable=1
 	//! [Default value] false
	bool get_persistlights() const { return getBool("persistlights"); }

	//! if 1, the emission lights will cast raytraced shadows to the volume. if 2, a grid map will be used to determine illumination.
 	//! [UI Guides] displayName=Self-shadowing, enum=0:None;1:Ray-traced;2:Grid-based, enableIf: ?al_enable=1
 	//! [Default value] 2
	bool set_selfshadow(int val) { return setValue("selfshadow", val); }
	//! if 1, the emission lights will cast raytraced shadows to the volume. if 2, a grid map will be used to determine illumination.
 	//! [UI Guides] displayName=Self-shadowing, enum=0:None;1:Ray-traced;2:Grid-based, enableIf: ?al_enable=1
 	//! [Default value] 2
	int get_selfshadow() const { return getInt("selfshadow"); }

	//! 0-none, 1-inverse, 2-inverse square
 	//! [UI Guides] displayName=Decay Type, enum=0:None;1:Inverse;2:Inverse Square, enableIf: ?al_enable=1
 	//! [Default value] 2
	bool set_al_decay(int val) { return setValue("al_decay", val); }
	//! 0-none, 1-inverse, 2-inverse square
 	//! [UI Guides] displayName=Decay Type, enum=0:None;1:Inverse;2:Inverse Square, enableIf: ?al_enable=1
 	//! [Default value] 2
	int get_al_decay() const { return getInt("al_decay"); }

	//! [UI Guides] displayName=Reduce Grid to %, minValue=0.01, maxValue=100, enableIf: ?al_enable=1
 	//! [Default value] 5
	bool set_gridreduct(float val) { return setValue("gridreduct", val); }
	//! [UI Guides] displayName=Reduce Grid to %, minValue=0.01, maxValue=100, enableIf: ?al_enable=1
 	//! [Default value] 5
	float get_gridreduct() const { return getFloat("gridreduct"); }

	//! [UI Guides] displayName=Light Power on Scene, minValue=0, maxValue=100, enableIf: ?al_enable=1
 	//! [Default value] 1
	bool set_lightsmult(float val) { return setValue("lightsmult", val); }
	//! [UI Guides] displayName=Light Power on Scene, minValue=0, maxValue=100, enableIf: ?al_enable=1
 	//! [Default value] 1
	float get_lightsmult() const { return getFloat("lightsmult"); }

	//! [UI Guides] displayName=Light Power on Self, minValue=0, maxValue=100, enableIf: ?al_enable=1
 	//! [Default value] 1
	bool set_lightsmultself(float val) { return setValue("lightsmultself", val); }
	//! [UI Guides] displayName=Light Power on Self, minValue=0, maxValue=100, enableIf: ?al_enable=1
 	//! [Default value] 1
	float get_lightsmultself() const { return getFloat("lightsmultself"); }

	//! cut off threshold for the lights
 	//! [UI Guides] displayName=Light Cut-off, minValue=0, maxValue=1, enableIf: ?al_enable=1
 	//! [Default value] 0.001
	bool set_lightscut(float val) { return setValue("lightscut", val); }
	//! cut off threshold for the lights
 	//! [UI Guides] displayName=Light Cut-off, minValue=0, maxValue=1, enableIf: ?al_enable=1
 	//! [Default value] 0.001
	float get_lightscut() const { return getFloat("lightscut"); }

	//! [UI Guides] displayName=Light radius multiplier, minValue=0, maxValue=1000, enableIf: ?al_enable=1
 	//! [Default value] 1
	bool set_radmult(float val) { return setValue("radmult", val); }
	//! [UI Guides] displayName=Light radius multiplier, minValue=0, maxValue=1000, enableIf: ?al_enable=1
 	//! [Default value] 1
	float get_radmult() const { return getFloat("radmult"); }

	//! (description missing)
	//! [Default value] 0.1
	bool set_self_illum_map_min_pow(float val) { return setValue("self_illum_map_min_pow", val); }
	//! (description missing)
	//! [Default value] 0.1
	float get_self_illum_map_min_pow() const { return getFloat("self_illum_map_min_pow"); }

	//! [UI Guides] displayName=Generate GI, startRollout=Visibility
 	//! [Default value] true
	bool set_generate_gi(bool val) { return setValue("generate_gi", val); }
	//! [UI Guides] displayName=Generate GI, startRollout=Visibility
 	//! [Default value] true
	bool get_generate_gi() const { return getBool("generate_gi"); }

	//! [UI Guides] displayName=Receive GI
 	//! [Default value] true
	bool set_receive_gi(bool val) { return setValue("receive_gi", val); }
	//! [UI Guides] displayName=Receive GI
 	//! [Default value] true
	bool get_receive_gi() const { return getBool("receive_gi"); }

	//! [UI Guides] displayName=Generate GI mult., minValue=0, enableIf: ?generate_gi=1
 	//! [Default value] 1
	bool set_gen_gi_mult(float val) { return setValue("gen_gi_mult", val); }
	//! [UI Guides] displayName=Generate GI mult., minValue=0, enableIf: ?generate_gi=1
 	//! [Default value] 1
	float get_gen_gi_mult() const { return getFloat("gen_gi_mult"); }

	//! [UI Guides] displayName=Receive GI mult., minValue=0, enableIf: ?receive_gi=1
 	//! [Default value] 1
	bool set_rec_gi_mult(float val) { return setValue("rec_gi_mult", val); }
	//! [UI Guides] displayName=Receive GI mult., minValue=0, enableIf: ?receive_gi=1
 	//! [Default value] 1
	float get_rec_gi_mult() const { return getFloat("rec_gi_mult"); }

	//! [UI Guides] displayName=Generate Caustics
 	//! [Default value] true
	bool set_generate_caust(bool val) { return setValue("generate_caust", val); }
	//! [UI Guides] displayName=Generate Caustics
 	//! [Default value] true
	bool get_generate_caust() const { return getBool("generate_caust"); }

	//! [UI Guides] displayName=Receive Caustics
 	//! [Default value] true
	bool set_receive_caust(bool val) { return setValue("receive_caust", val); }
	//! [UI Guides] displayName=Receive Caustics
 	//! [Default value] true
	bool get_receive_caust() const { return getBool("receive_caust"); }

	//! [UI Guides] displayName=Caustics mult., minValue=0
 	//! [Default value] 1
	bool set_caust_mult(float val) { return setValue("caust_mult", val); }
	//! [UI Guides] displayName=Caustics mult., minValue=0
 	//! [Default value] 1
	float get_caust_mult() const { return getFloat("caust_mult"); }

	//! [UI Guides] displayName=Visible to Camera, startRollout=
 	//! [Default value] true
	bool set_camera_visibility(bool val) { return setValue("camera_visibility", val); }
	//! [UI Guides] displayName=Visible to Camera, startRollout=
 	//! [Default value] true
	bool get_camera_visibility() const { return getBool("camera_visibility"); }

	//! [UI Guides] displayName=Visible to Reflections
 	//! [Default value] true
	bool set_reflections_visibility(bool val) { return setValue("reflections_visibility", val); }
	//! [UI Guides] displayName=Visible to Reflections
 	//! [Default value] true
	bool get_reflections_visibility() const { return getBool("reflections_visibility"); }

	//! [UI Guides] displayName=Visible to Refractions
 	//! [Default value] true
	bool set_refractions_visibility(bool val) { return setValue("refractions_visibility", val); }
	//! [UI Guides] displayName=Visible to Refractions
 	//! [Default value] true
	bool get_refractions_visibility() const { return getBool("refractions_visibility"); }

	//! [UI Guides] displayName=Visible to GI
 	//! [Default value] true
	bool set_gi_visibility(bool val) { return setValue("gi_visibility", val); }
	//! [UI Guides] displayName=Visible to GI
 	//! [Default value] true
	bool get_gi_visibility() const { return getBool("gi_visibility"); }

	//! [UI Guides] displayName=Cast Shadows
 	//! [Default value] true
	bool set_shadows_visibility(bool val) { return setValue("shadows_visibility", val); }
	//! [UI Guides] displayName=Cast Shadows
 	//! [Default value] true
	bool get_shadows_visibility() const { return getBool("shadows_visibility"); }

	//! Render channels the result of this light will be written to
 	bool set_channels(const ValueList& pluginList) { return setValue("channels", pluginList); }
	//! Render channels the result of this light will be written to
 	ValueList get_channels() const { return getValueList("channels"); }

	//! Render channels the raw diffuse result of this light will be written to
 	bool set_channels_raw(const ValueList& pluginList) { return setValue("channels_raw", pluginList); }
	//! Render channels the raw diffuse result of this light will be written to
 	ValueList get_channels_raw() const { return getValueList("channels_raw"); }

	//! Render channels the diffuse result of this light will be written to
 	bool set_channels_diffuse(const ValueList& pluginList) { return setValue("channels_diffuse", pluginList); }
	//! Render channels the diffuse result of this light will be written to
 	ValueList get_channels_diffuse() const { return getValueList("channels_diffuse"); }

	//! Render channels the specular result of this light will be written to
 	bool set_channels_specular(const ValueList& pluginList) { return setValue("channels_specular", pluginList); }
	//! Render channels the specular result of this light will be written to
 	ValueList get_channels_specular() const { return getValueList("channels_specular"); }

	//! Volumetric Material ID
 	//! [UI Guides] displayName=Volumetric Material ID, startRollout=Render Elements
 	//! [Default value] Color(0, 0, 0)
	bool set_material_id(const Color& color) { return setValue("material_id", color); }
	//! Volumetric Material ID
 	//! [UI Guides] displayName=Volumetric Material ID, startRollout=Render Elements
 	//! [Default value] Color(0, 0, 0)
	Color get_material_id() const { return getColor("material_id"); }

	//! if true, write to normals in volume mode
 	//! [UI Guides] displayName=Volumetric Normals, enum=0:Disable; 1:Separate channel
 	//! [Default value] 0
	bool set_volnorm(int val) { return setValue("volnorm", val); }
	//! if true, write to normals in volume mode
 	//! [UI Guides] displayName=Volumetric Normals, enum=0:Disable; 1:Separate channel
 	//! [Default value] 0
	int get_volnorm() const { return getInt("volnorm"); }

	//! if true, write to the z-depth render element
 	//! [UI Guides] displayName=Volumetric Z-Depth, enum=0:Disable; 1:Standard channel; 2:Separate channel
 	//! [Default value] 0
	bool set_volzdepth(int val) { return setValue("volzdepth", val); }
	//! if true, write to the z-depth render element
 	//! [UI Guides] displayName=Volumetric Z-Depth, enum=0:Disable; 1:Standard channel; 2:Separate channel
 	//! [Default value] 0
	int get_volzdepth() const { return getInt("volzdepth"); }
};

class PhxShaderSimGeom : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "PhxShaderSimGeom"; }

	//! A plugin that supports PhoenixSimInterface and can be used to load a Phoenix frame
 	bool set_phoenix_sim(const Plugin& plugin) { return setValue("phoenix_sim", plugin); }
	//! A plugin that supports PhoenixSimInterface and can be used to load a Phoenix frame
 	Plugin get_phoenix_sim() const { return getPlugin("phoenix_sim"); }

	//! Mode for DI computations on the GPU
 	//! [UI Guides] Mode for DI computations on the GPU
 	//! [Default value] 2
	bool set_gpu_di_mode(int val) { return setValue("gpu_di_mode", val); }
	//! Mode for DI computations on the GPU
 	//! [UI Guides] Mode for DI computations on the GPU
 	//! [Default value] 2
	int get_gpu_di_mode() const { return getInt("gpu_di_mode"); }

	//! Mode for GI computations on the GPU
 	//! [UI Guides] Mode for GI computations on the GPU
 	//! [Default value] 2
	bool set_gpu_gi_mode(int val) { return setValue("gpu_gi_mode", val); }
	//! Mode for GI computations on the GPU
 	//! [UI Guides] Mode for GI computations on the GPU
 	//! [Default value] 2
	int get_gpu_gi_mode() const { return getInt("gpu_gi_mode"); }

	//! Samples count for cache computation on the GPU
 	//! [UI Guides] Samples count for cache computation on the GPU
 	//! [Default value] 1
	bool set_gpu_samples_count(int val) { return setValue("gpu_samples_count", val); }
	//! Samples count for cache computation on the GPU
 	//! [UI Guides] Samples count for cache computation on the GPU
 	//! [Default value] 1
	int get_gpu_samples_count() const { return getInt("gpu_samples_count"); }
};

class PhxShaderSimMesh : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "PhxShaderSimMesh"; }

	//! A plugin that supports PhoenixSimInterface and can be used to load a Phoenix frame
 	bool set_phoenix_sim(const Plugin& plugin) { return setValue("phoenix_sim", plugin); }
	//! A plugin that supports PhoenixSimInterface and can be used to load a Phoenix frame
 	Plugin get_phoenix_sim() const { return getPlugin("phoenix_sim"); }

	//! The geometry used by the mesher
 	bool set_static_mesh(const Plugin& plugin) { return setValue("static_mesh", plugin); }
	//! The geometry used by the mesher
 	Plugin get_static_mesh() const { return getPlugin("static_mesh"); }
};

class PhxShaderSimVol : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "PhxShaderSimVol"; }

	//! List of plugins that support PhoenixSimInterface and can be used to load a Phoenix frame
 	bool set_phoenix_sim(const ValueList& pluginList) { return setValue("phoenix_sim", pluginList); }
	//! List of plugins that support PhoenixSimInterface and can be used to load a Phoenix frame
 	ValueList get_phoenix_sim() const { return getValueList("phoenix_sim"); }

	//! Probabilistic samples override, -1 won't override
 	//! [Default value] -1
	bool set_force_prob_samples(int val) { return setValue("force_prob_samples", val); }
	//! Probabilistic samples override, -1 won't override
 	//! [Default value] -1
	int get_force_prob_samples() const { return getInt("force_prob_samples"); }

	//! Probabilistic samples for GI override, -1 won't override
 	//! [Default value] -1
	bool set_force_prob_samples_gi(int val) { return setValue("force_prob_samples_gi", val); }
	//! Probabilistic samples for GI override, -1 won't override
 	//! [Default value] -1
	int get_force_prob_samples_gi() const { return getInt("force_prob_samples_gi"); }
};

class PhxShaderTex : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "PhxShaderTex"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! (description missing)
	//! [Default value] false
	bool set_use_3d_mapping(bool val) { return setValue("use_3d_mapping", val); }
	//! (description missing)
	//! [Default value] false
	bool get_use_3d_mapping() const { return getBool("use_3d_mapping"); }

	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	bool set_placement_type(int val) { return setValue("placement_type", val); }
	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	int get_placement_type() const { return getInt("placement_type"); }

	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_u(float val) { return setValue("u", val); }
	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_u() const { return getFloat("u"); }

	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_v(float val) { return setValue("v", val); }
	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_v() const { return getFloat("v"); }

	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_w(float val) { return setValue("w", val); }
	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_w() const { return getFloat("w"); }

	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_h(float val) { return setValue("h", val); }
	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_h() const { return getFloat("h"); }

	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	bool set_jitter(float val) { return setValue("jitter", val); }
	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	float get_jitter() const { return getFloat("jitter"); }

	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_u(bool val) { return setValue("tile_u", val); }
	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_u() const { return getBool("tile_u"); }

	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_v(bool val) { return setValue("tile_v", val); }
	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_v() const { return getBool("tile_v"); }

	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool set_uv_noise_on(bool val) { return setValue("uv_noise_on", val); }
	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool get_uv_noise_on() const { return getBool("uv_noise_on"); }

	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool set_uv_noise_animate(bool val) { return setValue("uv_noise_animate", val); }
	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool get_uv_noise_animate() const { return getBool("uv_noise_animate"); }

	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	bool set_uv_noise_amount(float val) { return setValue("uv_noise_amount", val); }
	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	float get_uv_noise_amount() const { return getFloat("uv_noise_amount"); }

	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	bool set_uv_noise_levels(float val) { return setValue("uv_noise_levels", val); }
	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	float get_uv_noise_levels() const { return getFloat("uv_noise_levels"); }

	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	bool set_uv_noise_size(float val) { return setValue("uv_noise_size", val); }
	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	float get_uv_noise_size() const { return getFloat("uv_noise_size"); }

	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	bool set_un_noise_phase(float val) { return setValue("un_noise_phase", val); }
	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	float get_un_noise_phase() const { return getFloat("un_noise_phase"); }

	//! A plugin that supports PhoenixSimInterface and can be used to load a Phoenix frame
 	bool set_phoenix_sim(const Plugin& plugin) { return setValue("phoenix_sim", plugin); }
	//! A plugin that supports PhoenixSimInterface and can be used to load a Phoenix frame
 	Plugin get_phoenix_sim() const { return getPlugin("phoenix_sim"); }

	//! 0-emissive, 1-diffuse, 2-alpha, 3-velocity, 4-uvw, 5-temp, 6-smoke, 7-fuel, 8-scalar speed
 	//! [Default value] 0
	bool set_channel(int val) { return setValue("channel", val); }
	//! 0-emissive, 1-diffuse, 2-alpha, 3-velocity, 4-uvw, 5-temp, 6-smoke, 7-fuel, 8-scalar speed
 	//! [Default value] 0
	int get_channel() const { return getInt("channel"); }

	//! 0-single, 1-wrap, 2-mirror
 	//! [Default value] 0
	bool set_tiling(int val) { return setValue("tiling", val); }
	//! 0-single, 1-wrap, 2-mirror
 	//! [Default value] 0
	int get_tiling() const { return getInt("tiling"); }

	//! (description missing)
	//! [Default value] false
	bool set_skip_fine_displ(bool val) { return setValue("skip_fine_displ", val); }
	//! (description missing)
	//! [Default value] false
	bool get_skip_fine_displ() const { return getBool("skip_fine_displ"); }

	//! 0-x, 1-y, 2-z
 	//! [Default value] 0
	bool set_up_vector(int val) { return setValue("up_vector", val); }
	//! 0-x, 1-y, 2-z
 	//! [Default value] 0
	int get_up_vector() const { return getInt("up_vector"); }

	//! if true, the texture will act as two dimensional.
 	//! [Default value] false
	bool set_texture2d(bool val) { return setValue("texture2d", val); }
	//! if true, the texture will act as two dimensional.
 	//! [Default value] false
	bool get_texture2d() const { return getBool("texture2d"); }

	//! if true, the texture will no use the uvw generator, but the simulator for 3d mapping.
 	//! [Default value] false
	bool set_auto_map(bool val) { return setValue("auto_map", val); }
	//! if true, the texture will no use the uvw generator, but the simulator for 3d mapping.
 	//! [Default value] false
	bool get_auto_map() const { return getBool("auto_map"); }
};

class PhxShaderTexAlpha : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "PhxShaderTexAlpha"; }

	//! the input float texture
 	bool set_ttex(const Plugin& texturefloat) { return setValue("ttex", texturefloat); }
	//! the input float texture
 	bool set_ttex(float texturefloat) { return setValue("ttex", texturefloat); }
	//! the input float texture
 	Value get_ttex() const { return getValue("ttex"); }

	//! (description missing)
	//! [Default value] AColor(0.5, 0.5, 0.5, 1)
	bool set_transparency(const AColor& acolor) { return setValue("transparency", acolor); }
	//! (description missing)
	//! [Default value] AColor(0.5, 0.5, 0.5, 1)
	AColor get_transparency() const { return getAColor("transparency"); }
};

class RTEngine : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "RTEngine"; }

	//! true to enable the RT engine and false to disable it
 	//! [Default value] true
	bool set_enabled(bool val) { return setValue("enabled", val); }
	//! true to enable the RT engine and false to disable it
 	//! [Default value] true
	bool get_enabled() const { return getBool("enabled"); }

	//! (description missing)
	//! [Default value] false
	bool set_use_opencl(bool val) { return setValue("use_opencl", val); }
	//! (description missing)
	//! [Default value] false
	bool get_use_opencl() const { return getBool("use_opencl"); }

	//! true to open a separate window for the RTEngine, and false to use the V-Ray VFB
 	//! [Default value] true
	bool set_separate_window(bool val) { return setValue("separate_window", val); }
	//! true to open a separate window for the RTEngine, and false to use the V-Ray VFB
 	//! [Default value] true
	bool get_separate_window() const { return getBool("separate_window"); }
};

class RawBitmapBuffer : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "RawBitmapBuffer"; }

	//! -1 - nearest; 0 - no filtering; 1 - mip-map filtering; 2 - summed area table filtering; 3 - elliptical filtering
 	//! [UI Guides] enum=-1:Nearest;0:No filtering;1:Mip-map filtering;2:Summed are table filtering;3:Elliptical filtering
 	//! [Default value] 1
	bool set_filter_type(int val) { return setValue("filter_type", val); }
	//! -1 - nearest; 0 - no filtering; 1 - mip-map filtering; 2 - summed area table filtering; 3 - elliptical filtering
 	//! [UI Guides] enum=-1:Nearest;0:No filtering;1:Mip-map filtering;2:Summed are table filtering;3:Elliptical filtering
 	//! [Default value] 1
	int get_filter_type() const { return getInt("filter_type"); }

	//! (description missing)
	//! [Default value] 1
	bool set_filter_blur(float val) { return setValue("filter_blur", val); }
	//! (description missing)
	//! [Default value] 1
	float get_filter_blur() const { return getFloat("filter_blur"); }

	//! 0 - linear, 1 - gamma corrected, 2 - sRGB
 	//! [UI Guides] enum=0:Linear;1:Gamma corrected;2:sRGB
 	//! [Default value] 1
	bool set_color_space(int val) { return setValue("color_space", val); }
	//! 0 - linear, 1 - gamma corrected, 2 - sRGB
 	//! [UI Guides] enum=0:Linear;1:Gamma corrected;2:sRGB
 	//! [Default value] 1
	int get_color_space() const { return getInt("color_space"); }

	//! (description missing)
	//! [Default value] 1
	bool set_gamma(float val) { return setValue("gamma", val); }
	//! (description missing)
	//! [Default value] 1
	float get_gamma() const { return getFloat("gamma"); }

	//! (description missing)
	//! [Default value] false
	bool set_maya_compatible(bool val) { return setValue("maya_compatible", val); }
	//! (description missing)
	//! [Default value] false
	bool get_maya_compatible() const { return getBool("maya_compatible"); }

	//! if false negative colors will be clamped
 	//! [Default value] false
	bool set_allow_negative_colors(bool val) { return setValue("allow_negative_colors", val); }
	//! if false negative colors will be clamped
 	//! [Default value] false
	bool get_allow_negative_colors() const { return getBool("allow_negative_colors"); }

	//! Interpolation method for the mip-map filtering (0 - bilinear, 1 - bicubic, 2 - biquadratic)
 	//! [UI Guides] enum=0:Bilinear;1:Bicubic;2:Biquadratic
 	//! [Default value] 0
	bool set_interpolation(int val) { return setValue("interpolation", val); }
	//! Interpolation method for the mip-map filtering (0 - bilinear, 1 - bicubic, 2 - biquadratic)
 	//! [UI Guides] enum=0:Bilinear;1:Bicubic;2:Biquadratic
 	//! [Default value] 0
	int get_interpolation() const { return getInt("interpolation"); }

	//! When working with image sequences, this parameter specifies which image out of the sequence should be used.  If parameter is omitted or defaulted, the frame number depends on the current frame time value.
 	//! [Default value] -2147483648
	bool set_frame_number(int val) { return setValue("frame_number", val); }
	//! When working with image sequences, this parameter specifies which image out of the sequence should be used.  If parameter is omitted or defaulted, the frame number depends on the current frame time value.
 	//! [Default value] -2147483648
	int get_frame_number() const { return getInt("frame_number"); }

	//! Start frame offset for image sequences
 	//! [Default value] 0
	bool set_frame_offset(int val) { return setValue("frame_offset", val); }
	//! Start frame offset for image sequences
 	//! [Default value] 0
	int get_frame_offset() const { return getInt("frame_offset"); }

	//! The raw pixels used in the bitmap
 	//! [Default value] 0
	bool set_pixels(const IntList& intList) { return setValue("pixels", intList); }
	//! The raw pixels used in the bitmap
 	//! [Default value] 0
	bool set_pixels(const int* ints, size_t count) { return setArray("pixels", ints, count); }
	//! The raw pixels used in the bitmap
 	//! [Default value] 0
	template<size_t count> bool set_pixels(const int (&ints)[count]) { return setArray("pixels", ints, count); }
	//! The raw pixels used in the bitmap
 	//! [Default value] 0
	IntList get_pixels() const { return getIntList("pixels"); }

	//! Optional raw alpha values. Alpha=1 used if empty and type is RGB/Gray. Can be set to a list of one value for constant alpha. Otherwise must match pixels size
 	//! [Default value] 0
	bool set_alpha_pixels(const IntList& intList) { return setValue("alpha_pixels", intList); }
	//! Optional raw alpha values. Alpha=1 used if empty and type is RGB/Gray. Can be set to a list of one value for constant alpha. Otherwise must match pixels size
 	//! [Default value] 0
	bool set_alpha_pixels(const int* ints, size_t count) { return setArray("alpha_pixels", ints, count); }
	//! Optional raw alpha values. Alpha=1 used if empty and type is RGB/Gray. Can be set to a list of one value for constant alpha. Otherwise must match pixels size
 	//! [Default value] 0
	template<size_t count> bool set_alpha_pixels(const int (&ints)[count]) { return setArray("alpha_pixels", ints, count); }
	//! Optional raw alpha values. Alpha=1 used if empty and type is RGB/Gray. Can be set to a list of one value for constant alpha. Otherwise must match pixels size
 	//! [Default value] 0
	IntList get_alpha_pixels() const { return getIntList("alpha_pixels"); }

	//! 0: 8-bit RGBA, 1: float RGBA, 2: 8-bit RGBE, 3: 16-bit RGBA, 4: 8-bit RGB, 5: half RGBA, 6: float Gray, 7: 8-bit Gray, 8: half Gray, 9: signed 8-bit Gray, 10: signed 8-bit RGB, 11: signed 8-bit RGBA, 12: signed 16-bit RGBA
 	//! [UI Guides] enum=0:8-bit RBGA;1:Float RGBA;2:8-bit RBGE;3:16-bit RBGA;4:8-bit RGB;5:Half-Float RGBA;6:Float Grayscale;7:8-bit Grayscale;8:Half-Float Grayscale;9:Signed 8-bit Grayscale;10:Signed 8-bit RGB;11:Signed 8-bit RGBA;12:Signed 16-bit RGBA
 	//! [Default value] 0
	bool set_pixels_type(int val) { return setValue("pixels_type", val); }
	//! 0: 8-bit RGBA, 1: float RGBA, 2: 8-bit RGBE, 3: 16-bit RGBA, 4: 8-bit RGB, 5: half RGBA, 6: float Gray, 7: 8-bit Gray, 8: half Gray, 9: signed 8-bit Gray, 10: signed 8-bit RGB, 11: signed 8-bit RGBA, 12: signed 16-bit RGBA
 	//! [UI Guides] enum=0:8-bit RBGA;1:Float RGBA;2:8-bit RBGE;3:16-bit RBGA;4:8-bit RGB;5:Half-Float RGBA;6:Float Grayscale;7:8-bit Grayscale;8:Half-Float Grayscale;9:Signed 8-bit Grayscale;10:Signed 8-bit RGB;11:Signed 8-bit RGBA;12:Signed 16-bit RGBA
 	//! [Default value] 0
	int get_pixels_type() const { return getInt("pixels_type"); }

	//! The width of the raw bitmap
 	//! [Default value] 0
	bool set_width(int val) { return setValue("width", val); }
	//! The width of the raw bitmap
 	//! [Default value] 0
	int get_width() const { return getInt("width"); }

	//! The height of the raw bitmap
 	//! [Default value] 0
	bool set_height(int val) { return setValue("height", val); }
	//! The height of the raw bitmap
 	//! [Default value] 0
	int get_height() const { return getInt("height"); }
};

class RenderChannelBumpNormals : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "RenderChannelBumpNormals"; }

	//! (description missing)
	//! [Default value] true
	bool set_enableDeepOutput(bool val) { return setValue("enableDeepOutput", val); }
	//! (description missing)
	//! [Default value] true
	bool get_enableDeepOutput() const { return getBool("enableDeepOutput"); }

	//! (description missing)
	//! [Default value] BumpNormals
	bool set_name(const char* str) { return setValue("name", str); }
	//! (description missing)
	//! [Default value] BumpNormals
	bool set_name(const std::string& str) { return setValue("name", str); }
	//! (description missing)
	//! [Default value] BumpNormals
	std::string get_name() const { return getString("name"); }

	//! (description missing)
	//! [Default value] true
	bool set_filtering(bool val) { return setValue("filtering", val); }
	//! (description missing)
	//! [Default value] true
	bool get_filtering() const { return getBool("filtering"); }
};

class RenderChannelColor : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "RenderChannelColor"; }

	//! (description missing)
	//! [Default value] true
	bool set_enableDeepOutput(bool val) { return setValue("enableDeepOutput", val); }
	//! (description missing)
	//! [Default value] true
	bool get_enableDeepOutput() const { return getBool("enableDeepOutput"); }

	//! (description missing)
	//! [Default value] ColorChannel
	bool set_name(const char* str) { return setValue("name", str); }
	//! (description missing)
	//! [Default value] ColorChannel
	bool set_name(const std::string& str) { return setValue("name", str); }
	//! (description missing)
	//! [Default value] ColorChannel
	std::string get_name() const { return getString("name"); }

	//! (description missing)
	//! [Default value] 1000
	bool set_alias(int val) { return setValue("alias", val); }
	//! (description missing)
	//! [Default value] 1000
	int get_alias() const { return getInt("alias"); }

	//! true to apply color mapping to the channel; false otherwise
 	//! [Default value] false
	bool set_color_mapping(bool val) { return setValue("color_mapping", val); }
	//! true to apply color mapping to the channel; false otherwise
 	//! [Default value] false
	bool get_color_mapping() const { return getBool("color_mapping"); }

	//! (description missing)
	//! [Default value] false
	bool set_consider_for_aa(bool val) { return setValue("consider_for_aa", val); }
	//! (description missing)
	//! [Default value] false
	bool get_consider_for_aa() const { return getBool("consider_for_aa"); }

	//! (description missing)
	//! [Default value] true
	bool set_filtering(bool val) { return setValue("filtering", val); }
	//! (description missing)
	//! [Default value] true
	bool get_filtering() const { return getBool("filtering"); }

	//! true if raw channels should be derived from the respective color and filter channel
 	//! [Default value] true
	bool set_derive_raw_channels(bool val) { return setValue("derive_raw_channels", val); }
	//! true if raw channels should be derived from the respective color and filter channel
 	//! [Default value] true
	bool get_derive_raw_channels() const { return getBool("derive_raw_channels"); }

	//! False to disable ALL VFB color corrections(sRGB, curves, white balance, etc...) when saving the channel data to a file or showing it on a display. True to apply VFB color corrections when saving the channel data to a file or showing it on a display. If true some color corrections might still be disabled, based on the type of file being saved.
 	//! [Default value] true
	bool set_vfb_color_corrections(bool val) { return setValue("vfb_color_corrections", val); }
	//! False to disable ALL VFB color corrections(sRGB, curves, white balance, etc...) when saving the channel data to a file or showing it on a display. True to apply VFB color corrections when saving the channel data to a file or showing it on a display. If true some color corrections might still be disabled, based on the type of file being saved.
 	//! [Default value] true
	bool get_vfb_color_corrections() const { return getBool("vfb_color_corrections"); }
};

class RenderChannelColorModo : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "RenderChannelColorModo"; }

	//! (description missing)
	//! [Default value] true
	bool set_enableDeepOutput(bool val) { return setValue("enableDeepOutput", val); }
	//! (description missing)
	//! [Default value] true
	bool get_enableDeepOutput() const { return getBool("enableDeepOutput"); }

	//! (description missing)
	//! [Default value] ColorChannel
	bool set_name(const char* str) { return setValue("name", str); }
	//! (description missing)
	//! [Default value] ColorChannel
	bool set_name(const std::string& str) { return setValue("name", str); }
	//! (description missing)
	//! [Default value] ColorChannel
	std::string get_name() const { return getString("name"); }

	//! (description missing)
	//! [Default value] 1000
	bool set_alias(int val) { return setValue("alias", val); }
	//! (description missing)
	//! [Default value] 1000
	int get_alias() const { return getInt("alias"); }

	//! true to apply color mapping to the channel; false otherwise
 	//! [Default value] false
	bool set_color_mapping(bool val) { return setValue("color_mapping", val); }
	//! true to apply color mapping to the channel; false otherwise
 	//! [Default value] false
	bool get_color_mapping() const { return getBool("color_mapping"); }

	//! (description missing)
	//! [Default value] false
	bool set_consider_for_aa(bool val) { return setValue("consider_for_aa", val); }
	//! (description missing)
	//! [Default value] false
	bool get_consider_for_aa() const { return getBool("consider_for_aa"); }

	//! (description missing)
	//! [Default value] true
	bool set_filtering(bool val) { return setValue("filtering", val); }
	//! (description missing)
	//! [Default value] true
	bool get_filtering() const { return getBool("filtering"); }

	//! true if raw channels should be derived from the respective color and filter channel
 	//! [Default value] true
	bool set_derive_raw_channels(bool val) { return setValue("derive_raw_channels", val); }
	//! true if raw channels should be derived from the respective color and filter channel
 	//! [Default value] true
	bool get_derive_raw_channels() const { return getBool("derive_raw_channels"); }

	//! False to disable ALL VFB color corrections(sRGB, curves, white balance, etc...) when saving the channel data to a file or showing it on a display. True to apply VFB color corrections when saving the channel data to a file or showing it on a display. If true some color corrections might still be disabled, based on the type of file being saved.
 	//! [Default value] true
	bool set_vfb_color_corrections(bool val) { return setValue("vfb_color_corrections", val); }
	//! False to disable ALL VFB color corrections(sRGB, curves, white balance, etc...) when saving the channel data to a file or showing it on a display. True to apply VFB color corrections when saving the channel data to a file or showing it on a display. If true some color corrections might still be disabled, based on the type of file being saved.
 	//! [Default value] true
	bool get_vfb_color_corrections() const { return getBool("vfb_color_corrections"); }

	//! USE WITH CAUTION - setting this to true can increase render times significantly ! Used only when consider_for_aa is true.
 	//! [Default value] false
	bool set_aa_override_foreground_intensity(bool val) { return setValue("aa_override_foreground_intensity", val); }
	//! USE WITH CAUTION - setting this to true can increase render times significantly ! Used only when consider_for_aa is true.
 	//! [Default value] false
	bool get_aa_override_foreground_intensity() const { return getBool("aa_override_foreground_intensity"); }

	//! This should be setup by the exporter. It should have a unique value for each render element that has it enabled. And the minimum difference between these values should be big enough to achieve good AA on black/white edges.
 	//! [Default value] 0
	bool set_aa_foreground_intensity(float val) { return setValue("aa_foreground_intensity", val); }
	//! This should be setup by the exporter. It should have a unique value for each render element that has it enabled. And the minimum difference between these values should be big enough to achieve good AA on black/white edges.
 	//! [Default value] 0
	float get_aa_foreground_intensity() const { return getFloat("aa_foreground_intensity"); }
};

class RenderChannelCoverage : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "RenderChannelCoverage"; }

	//! (description missing)
	//! [Default value] true
	bool set_enableDeepOutput(bool val) { return setValue("enableDeepOutput", val); }
	//! (description missing)
	//! [Default value] true
	bool get_enableDeepOutput() const { return getBool("enableDeepOutput"); }

	//! (description missing)
	//! [Default value] Coverage
	bool set_name(const char* str) { return setValue("name", str); }
	//! (description missing)
	//! [Default value] Coverage
	bool set_name(const std::string& str) { return setValue("name", str); }
	//! (description missing)
	//! [Default value] Coverage
	std::string get_name() const { return getString("name"); }
};

class RenderChannelDRBucket : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "RenderChannelDRBucket"; }

	//! (description missing)
	//! [Default value] true
	bool set_enableDeepOutput(bool val) { return setValue("enableDeepOutput", val); }
	//! (description missing)
	//! [Default value] true
	bool get_enableDeepOutput() const { return getBool("enableDeepOutput"); }

	//! (description missing)
	//! [Default value] DR
	bool set_name(const char* str) { return setValue("name", str); }
	//! (description missing)
	//! [Default value] DR
	bool set_name(const std::string& str) { return setValue("name", str); }
	//! (description missing)
	//! [Default value] DR
	std::string get_name() const { return getString("name"); }

	//! (description missing)
	//! [Default value] 1
	bool set_text_alignment(int val) { return setValue("text_alignment", val); }
	//! (description missing)
	//! [Default value] 1
	int get_text_alignment() const { return getInt("text_alignment"); }
};

class RenderChannelDenoiser : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "RenderChannelDenoiser"; }

	//! (description missing)
	//! [Default value] true
	bool set_enableDeepOutput(bool val) { return setValue("enableDeepOutput", val); }
	//! (description missing)
	//! [Default value] true
	bool get_enableDeepOutput() const { return getBool("enableDeepOutput"); }

	//! True to enable the denoising render element.
 	//! [UI Guides] displayName=Enable
 	//! [Default value] true
	bool set_enabled(bool val) { return setValue("enabled", val); }
	//! True to enable the denoising render element.
 	//! [UI Guides] displayName=Enable
 	//! [Default value] true
	bool get_enabled() const { return getBool("enabled"); }

	//! The name of the render element containing the denoised image.
 	//! [UI Guides] displayName=Render element name, enableIf: ?enabled=1
 	//! [Default value] denoiser
	bool set_name(const char* str) { return setValue("name", str); }
	//! The name of the render element containing the denoised image.
 	//! [UI Guides] displayName=Render element name, enableIf: ?enabled=1
 	//! [Default value] denoiser
	bool set_name(const std::string& str) { return setValue("name", str); }
	//! The name of the render element containing the denoised image.
 	//! [UI Guides] displayName=Render element name, enableIf: ?enabled=1
 	//! [Default value] denoiser
	std::string get_name() const { return getString("name"); }

	//! The way the denoiser operates - only generate the needed render elements without running the denoiser, hide the channel with the denoised result in VFB, or show the channel with the denoised result in VFB.
 	//! [UI Guides] enum=0:Only generate render elements;1:Hide the channel with the denoised result in VFB;2:Show the channel with the denoised result in VFB, enableIf: ?enabled=1
 	//! [Default value] 2
	bool set_mode(int val) { return setValue("mode", val); }
	//! The way the denoiser operates - only generate the needed render elements without running the denoiser, hide the channel with the denoised result in VFB, or show the channel with the denoised result in VFB.
 	//! [UI Guides] enum=0:Only generate render elements;1:Hide the channel with the denoised result in VFB;2:Show the channel with the denoised result in VFB, enableIf: ?enabled=1
 	//! [Default value] 2
	int get_mode() const { return getInt("mode"); }

	//! Denoising can be calculated either as a single pass on the RGB image (faster with better noise removal but may blur texture details), or separately on the various render elements which are then combined into the final result (slower, may fail to clean up some kinds of noise, but preserves texture detail better). When denoising elements separately, the presence of color mapping may cause the brightness of the denoised result to be different than the computed RGB.
 	//! [UI Guides] enum=0:Single pass denoise on RGB only;1:Denoise render elements separately, enableIf: ?enabled=1
 	//! [Default value] 0
	bool set_type(int val) { return setValue("type", val); }
	//! Denoising can be calculated either as a single pass on the RGB image (faster with better noise removal but may blur texture details), or separately on the various render elements which are then combined into the final result (slower, may fail to clean up some kinds of noise, but preserves texture detail better). When denoising elements separately, the presence of color mapping may cause the brightness of the denoised result to be different than the computed RGB.
 	//! [UI Guides] enum=0:Single pass denoise on RGB only;1:Denoise render elements separately, enableIf: ?enabled=1
 	//! [Default value] 0
	int get_type() const { return getInt("type"); }

	//! Set the strength and radius to a few predefined values: 0.5/5 for mild denoising, 1/10 for default denoising, and 2/15 for strong denoising. Set to custom to enable the 'strength' and 'radius' parameters.
 	//! [UI Guides] enum=0:Mild;1:Default;2:Strong;3:Custom, enableIf: ?enabled=1
 	//! [Default value] 1
	bool set_preset(int val) { return setValue("preset", val); }
	//! Set the strength and radius to a few predefined values: 0.5/5 for mild denoising, 1/10 for default denoising, and 2/15 for strong denoising. Set to custom to enable the 'strength' and 'radius' parameters.
 	//! [UI Guides] enum=0:Mild;1:Default;2:Strong;3:Custom, enableIf: ?enabled=1
 	//! [Default value] 1
	int get_preset() const { return getInt("preset"); }

	//! The main denoiser control. Lower values modify the original image less, but may fail to clean up noise. Larger values are more effective at denoising, but may cause loss of detail. 0.5 is for mild denoising, 1.0 for normal strength and 2.0 for strong denoising.
 	//! [UI Guides] minValue=0.1, maxValue10, enableIf: ?enabled=1,?preset=3
 	//! [Default value] 1
	bool set_strength(float val) { return setValue("strength", val); }
	//! The main denoiser control. Lower values modify the original image less, but may fail to clean up noise. Larger values are more effective at denoising, but may cause loss of detail. 0.5 is for mild denoising, 1.0 for normal strength and 2.0 for strong denoising.
 	//! [UI Guides] minValue=0.1, maxValue10, enableIf: ?enabled=1,?preset=3
 	//! [Default value] 1
	float get_strength() const { return getFloat("strength"); }

	//! The pixel radius within which to look for similar pixel blocks. Larger values are slower, but may produce smoother results. Lower values are faster but may produce blotches. This value does not affect the strength of the denoising. A value of 10 is sufficient for most cases.
 	//! [UI Guides] minValue=0.01, maxValue50, enableIf: ?enabled=1,?preset=3
 	//! [Default value] 10
	bool set_radius(float val) { return setValue("radius", val); }
	//! The pixel radius within which to look for similar pixel blocks. Larger values are slower, but may produce smoother results. Lower values are faster but may produce blotches. This value does not affect the strength of the denoising. A value of 10 is sufficient for most cases.
 	//! [UI Guides] minValue=0.01, maxValue50, enableIf: ?enabled=1,?preset=3
 	//! [Default value] 10
	float get_radius() const { return getFloat("radius"); }

	//! Enable usage of GPU version if OpenCL support is found.
 	//! [UI Guides] displayName=Use GPU acceleration, enableIf: ?enabled=1
 	//! [Default value] false
	bool set_use_gpu(bool val) { return setValue("use_gpu", val); }
	//! Enable usage of GPU version if OpenCL support is found.
 	//! [UI Guides] displayName=Use GPU acceleration, enableIf: ?enabled=1
 	//! [Default value] false
	bool get_use_gpu() const { return getBool("use_gpu"); }

	//! The frequency of updates during progressive rendering; roughly the percentage of time denoising is allowed to take compared to total render time. Zero disables updates during progressive rendering; larger values cause the denoiser to be updated more often; 100 causes update as often as possible. Values of 5 to 10 are usually sufficient.
 	//! [UI Guides] displayName=Progressive Update Freq., minValue=0, maxValue=100, enableIf: ?enabled=1
 	//! [Default value] 0
	bool set_progressive_update(int val) { return setValue("progressive_update", val); }
	//! The frequency of updates during progressive rendering; roughly the percentage of time denoising is allowed to take compared to total render time. Zero disables updates during progressive rendering; larger values cause the denoiser to be updated more often; 100 causes update as often as possible. Values of 5 to 10 are usually sufficient.
 	//! [UI Guides] displayName=Progressive Update Freq., minValue=0, maxValue=100, enableIf: ?enabled=1
 	//! [Default value] 0
	int get_progressive_update() const { return getInt("progressive_update"); }

	//! Specify what render elements to add to the rendered image. 'Manual' adds only the noise level and defocus amount elements; the rest must be added manually. 'Depending on denoiser type' adds only the elements needed for the chosen denoiser type (one-pass or by render elements). 'All' adds all elements that could be required by the denoiser and allows switching between the different types.
 	//! [UI Guides] enum=0:Manual;1:Depending on denoising type;2:All possible denoising elements;, enableIf: ?enabled=1
 	//! [Default value] 2
	bool set_generate_render_elements(int val) { return setValue("generate_render_elements", val); }
	//! Specify what render elements to add to the rendered image. 'Manual' adds only the noise level and defocus amount elements; the rest must be added manually. 'Depending on denoiser type' adds only the elements needed for the chosen denoiser type (one-pass or by render elements). 'All' adds all elements that could be required by the denoiser and allows switching between the different types.
 	//! [UI Guides] enum=0:Manual;1:Depending on denoising type;2:All possible denoising elements;, enableIf: ?enabled=1
 	//! [Default value] 2
	int get_generate_render_elements() const { return getInt("generate_render_elements"); }
};

class RenderChannelExtraTex : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "RenderChannelExtraTex"; }

	//! (description missing)
	//! [Default value] true
	bool set_enableDeepOutput(bool val) { return setValue("enableDeepOutput", val); }
	//! (description missing)
	//! [Default value] true
	bool get_enableDeepOutput() const { return getBool("enableDeepOutput"); }

	//! (description missing)
	//! [Default value] ExtraTexChannel
	bool set_name(const char* str) { return setValue("name", str); }
	//! (description missing)
	//! [Default value] ExtraTexChannel
	bool set_name(const std::string& str) { return setValue("name", str); }
	//! (description missing)
	//! [Default value] ExtraTexChannel
	std::string get_name() const { return getString("name"); }

	//! (description missing)
	//! [Default value] true
	bool set_consider_for_aa(bool val) { return setValue("consider_for_aa", val); }
	//! (description missing)
	//! [Default value] true
	bool get_consider_for_aa() const { return getBool("consider_for_aa"); }

	//! (description missing)
	//! [Default value] true
	bool set_affect_matte_objects(bool val) { return setValue("affect_matte_objects", val); }
	//! (description missing)
	//! [Default value] true
	bool get_affect_matte_objects() const { return getBool("affect_matte_objects"); }

	//! (description missing)
	bool set_texmap(const Plugin& texture) { return setValue("texmap", texture); }
	//! (description missing)
	bool set_texmap(const AColor& texture) { return setValue("texmap", texture); }
	//! (description missing)
	Value get_texmap() const { return getValue("texmap"); }

	//! (description missing)
	//! [Default value] true
	bool set_filtering(bool val) { return setValue("filtering", val); }
	//! (description missing)
	//! [Default value] true
	bool get_filtering() const { return getBool("filtering"); }

	//! (description missing)
	bool set_exclude_list(const ValueList& pluginList) { return setValue("exclude_list", pluginList); }
	//! (description missing)
	ValueList get_exclude_list() const { return getValueList("exclude_list"); }

	//! true : apply extra texture only to objects in excludeList; false : apply extra texture to all objects out of excludeList
 	//! [Default value] false
	bool set_exclude_list_as_inclusive_set(bool val) { return setValue("exclude_list_as_inclusive_set", val); }
	//! true : apply extra texture only to objects in excludeList; false : apply extra texture to all objects out of excludeList
 	//! [Default value] false
	bool get_exclude_list_as_inclusive_set() const { return getBool("exclude_list_as_inclusive_set"); }
};

class RenderChannelExtraTexFloat : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "RenderChannelExtraTexFloat"; }

	//! (description missing)
	//! [Default value] true
	bool set_enableDeepOutput(bool val) { return setValue("enableDeepOutput", val); }
	//! (description missing)
	//! [Default value] true
	bool get_enableDeepOutput() const { return getBool("enableDeepOutput"); }

	//! (description missing)
	//! [Default value] ExtraTexChannel
	bool set_name(const char* str) { return setValue("name", str); }
	//! (description missing)
	//! [Default value] ExtraTexChannel
	bool set_name(const std::string& str) { return setValue("name", str); }
	//! (description missing)
	//! [Default value] ExtraTexChannel
	std::string get_name() const { return getString("name"); }

	//! (description missing)
	bool set_texmap(const Plugin& texturefloat) { return setValue("texmap", texturefloat); }
	//! (description missing)
	bool set_texmap(float texturefloat) { return setValue("texmap", texturefloat); }
	//! (description missing)
	Value get_texmap() const { return getValue("texmap"); }

	//! (description missing)
	//! [Default value] true
	bool set_affect_matte_objects(bool val) { return setValue("affect_matte_objects", val); }
	//! (description missing)
	//! [Default value] true
	bool get_affect_matte_objects() const { return getBool("affect_matte_objects"); }

	//! (description missing)
	bool set_exclude_list(const ValueList& pluginList) { return setValue("exclude_list", pluginList); }
	//! (description missing)
	ValueList get_exclude_list() const { return getValueList("exclude_list"); }

	//! true : apply extra texture only to objects in excludeList; false : apply extra texture to all objects out of excludeList
 	//! [Default value] false
	bool set_exclude_list_as_inclusive_set(bool val) { return setValue("exclude_list_as_inclusive_set", val); }
	//! true : apply extra texture only to objects in excludeList; false : apply extra texture to all objects out of excludeList
 	//! [Default value] false
	bool get_exclude_list_as_inclusive_set() const { return getBool("exclude_list_as_inclusive_set"); }
};

class RenderChannelExtraTexInt : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "RenderChannelExtraTexInt"; }

	//! (description missing)
	//! [Default value] true
	bool set_enableDeepOutput(bool val) { return setValue("enableDeepOutput", val); }
	//! (description missing)
	//! [Default value] true
	bool get_enableDeepOutput() const { return getBool("enableDeepOutput"); }

	//! (description missing)
	//! [Default value] ExtraTexChannel
	bool set_name(const char* str) { return setValue("name", str); }
	//! (description missing)
	//! [Default value] ExtraTexChannel
	bool set_name(const std::string& str) { return setValue("name", str); }
	//! (description missing)
	//! [Default value] ExtraTexChannel
	std::string get_name() const { return getString("name"); }

	//! (description missing)
	bool set_texmap(const Plugin& textureint) { return setValue("texmap", textureint); }
	//! (description missing)
	bool set_texmap(int textureint) { return setValue("texmap", textureint); }
	//! (description missing)
	Value get_texmap() const { return getValue("texmap"); }

	//! (description missing)
	//! [Default value] true
	bool set_affect_matte_objects(bool val) { return setValue("affect_matte_objects", val); }
	//! (description missing)
	//! [Default value] true
	bool get_affect_matte_objects() const { return getBool("affect_matte_objects"); }

	//! (description missing)
	bool set_exclude_list(const ValueList& pluginList) { return setValue("exclude_list", pluginList); }
	//! (description missing)
	ValueList get_exclude_list() const { return getValueList("exclude_list"); }

	//! true : apply extra texture only to objects in excludeList; false : apply extra texture to all objects out of excludeList
 	//! [Default value] false
	bool set_exclude_list_as_inclusive_set(bool val) { return setValue("exclude_list_as_inclusive_set", val); }
	//! true : apply extra texture only to objects in excludeList; false : apply extra texture to all objects out of excludeList
 	//! [Default value] false
	bool get_exclude_list_as_inclusive_set() const { return getBool("exclude_list_as_inclusive_set"); }
};

class RenderChannelGlossiness : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "RenderChannelGlossiness"; }

	//! (description missing)
	//! [Default value] true
	bool set_enableDeepOutput(bool val) { return setValue("enableDeepOutput", val); }
	//! (description missing)
	//! [Default value] true
	bool get_enableDeepOutput() const { return getBool("enableDeepOutput"); }

	//! (description missing)
	//! [Default value] GlossinessColorChannel
	bool set_name(const char* str) { return setValue("name", str); }
	//! (description missing)
	//! [Default value] GlossinessColorChannel
	bool set_name(const std::string& str) { return setValue("name", str); }
	//! (description missing)
	//! [Default value] GlossinessColorChannel
	std::string get_name() const { return getString("name"); }

	//! (description missing)
	//! [Default value] 1000
	bool set_alias(int val) { return setValue("alias", val); }
	//! (description missing)
	//! [Default value] 1000
	int get_alias() const { return getInt("alias"); }

	//! (description missing)
	//! [Default value] true
	bool set_filtering(bool val) { return setValue("filtering", val); }
	//! (description missing)
	//! [Default value] true
	bool get_filtering() const { return getBool("filtering"); }
};

class RenderChannelInvertedFloat : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "RenderChannelInvertedFloat"; }

	//! (description missing)
	//! [Default value] true
	bool set_enableDeepOutput(bool val) { return setValue("enableDeepOutput", val); }
	//! (description missing)
	//! [Default value] true
	bool get_enableDeepOutput() const { return getBool("enableDeepOutput"); }

	//! (description missing)
	//! [Default value] FresnelIORChannel
	bool set_name(const char* str) { return setValue("name", str); }
	//! (description missing)
	//! [Default value] FresnelIORChannel
	bool set_name(const std::string& str) { return setValue("name", str); }
	//! (description missing)
	//! [Default value] FresnelIORChannel
	std::string get_name() const { return getString("name"); }

	//! (description missing)
	//! [Default value] 1000
	bool set_alias(int val) { return setValue("alias", val); }
	//! (description missing)
	//! [Default value] 1000
	int get_alias() const { return getInt("alias"); }

	//! (description missing)
	//! [Default value] true
	bool set_filtering(bool val) { return setValue("filtering", val); }
	//! (description missing)
	//! [Default value] true
	bool get_filtering() const { return getBool("filtering"); }
};

class RenderChannelMtlID : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "RenderChannelMtlID"; }

	//! (description missing)
	//! [Default value] true
	bool set_enableDeepOutput(bool val) { return setValue("enableDeepOutput", val); }
	//! (description missing)
	//! [Default value] true
	bool get_enableDeepOutput() const { return getBool("enableDeepOutput"); }

	//! (description missing)
	//! [Default value] MaterialID
	bool set_name(const char* str) { return setValue("name", str); }
	//! (description missing)
	//! [Default value] MaterialID
	bool set_name(const std::string& str) { return setValue("name", str); }
	//! (description missing)
	//! [Default value] MaterialID
	std::string get_name() const { return getString("name"); }
};

class RenderChannelMultiMatte : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "RenderChannelMultiMatte"; }

	//! (description missing)
	//! [Default value] true
	bool set_enableDeepOutput(bool val) { return setValue("enableDeepOutput", val); }
	//! (description missing)
	//! [Default value] true
	bool get_enableDeepOutput() const { return getBool("enableDeepOutput"); }

	//! (description missing)
	//! [Default value] MultiMatte
	bool set_name(const char* str) { return setValue("name", str); }
	//! (description missing)
	//! [Default value] MultiMatte
	bool set_name(const std::string& str) { return setValue("name", str); }
	//! (description missing)
	//! [Default value] MultiMatte
	std::string get_name() const { return getString("name"); }

	//! The object ID that will be written as the red channel (0 to disable the red channel)
 	//! [Default value] 0
	bool set_red_id(int val) { return setValue("red_id", val); }
	//! The object ID that will be written as the red channel (0 to disable the red channel)
 	//! [Default value] 0
	int get_red_id() const { return getInt("red_id"); }

	//! The object ID that will be written as the green channel (0 to disable the green channel)
 	//! [Default value] 0
	bool set_green_id(int val) { return setValue("green_id", val); }
	//! The object ID that will be written as the green channel (0 to disable the green channel)
 	//! [Default value] 0
	int get_green_id() const { return getInt("green_id"); }

	//! The object ID that will be written as the blue channel (0 to disable the blue channel)
 	//! [Default value] 0
	bool set_blue_id(int val) { return setValue("blue_id", val); }
	//! The object ID that will be written as the blue channel (0 to disable the blue channel)
 	//! [Default value] 0
	int get_blue_id() const { return getInt("blue_id"); }

	//! true to use the material IDs instead of the object IDs
 	//! [Default value] false
	bool set_use_mtl_id(bool val) { return setValue("use_mtl_id", val); }
	//! true to use the material IDs instead of the object IDs
 	//! [Default value] false
	bool get_use_mtl_id() const { return getBool("use_mtl_id"); }

	//! false to not affect Matte Objects
 	//! [Default value] true
	bool set_affect_matte_objects(bool val) { return setValue("affect_matte_objects", val); }
	//! false to not affect Matte Objects
 	//! [Default value] true
	bool get_affect_matte_objects() const { return getBool("affect_matte_objects"); }

	//! true to consider this render element for antialiasing (may slow down rendering)
 	//! [Default value] false
	bool set_consider_for_aa(bool val) { return setValue("consider_for_aa", val); }
	//! true to consider this render element for antialiasing (may slow down rendering)
 	//! [Default value] false
	bool get_consider_for_aa() const { return getBool("consider_for_aa"); }
};

class RenderChannelNodeID : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "RenderChannelNodeID"; }

	//! (description missing)
	//! [Default value] true
	bool set_enableDeepOutput(bool val) { return setValue("enableDeepOutput", val); }
	//! (description missing)
	//! [Default value] true
	bool get_enableDeepOutput() const { return getBool("enableDeepOutput"); }

	//! (description missing)
	//! [Default value] ObjectID
	bool set_name(const char* str) { return setValue("name", str); }
	//! (description missing)
	//! [Default value] ObjectID
	bool set_name(const std::string& str) { return setValue("name", str); }
	//! (description missing)
	//! [Default value] ObjectID
	std::string get_name() const { return getString("name"); }
};

class RenderChannelNormals : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "RenderChannelNormals"; }

	//! (description missing)
	//! [Default value] true
	bool set_enableDeepOutput(bool val) { return setValue("enableDeepOutput", val); }
	//! (description missing)
	//! [Default value] true
	bool get_enableDeepOutput() const { return getBool("enableDeepOutput"); }

	//! (description missing)
	//! [Default value] Normals
	bool set_name(const char* str) { return setValue("name", str); }
	//! (description missing)
	//! [Default value] Normals
	bool set_name(const std::string& str) { return setValue("name", str); }
	//! (description missing)
	//! [Default value] Normals
	std::string get_name() const { return getString("name"); }

	//! (description missing)
	//! [Default value] true
	bool set_filtering(bool val) { return setValue("filtering", val); }
	//! (description missing)
	//! [Default value] true
	bool get_filtering() const { return getBool("filtering"); }
};

class RenderChannelObjectSelect : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "RenderChannelObjectSelect"; }

	//! (description missing)
	//! [Default value] true
	bool set_enableDeepOutput(bool val) { return setValue("enableDeepOutput", val); }
	//! (description missing)
	//! [Default value] true
	bool get_enableDeepOutput() const { return getBool("enableDeepOutput"); }

	//! (description missing)
	//! [Default value] ObjectSelect
	bool set_name(const char* str) { return setValue("name", str); }
	//! (description missing)
	//! [Default value] ObjectSelect
	bool set_name(const std::string& str) { return setValue("name", str); }
	//! (description missing)
	//! [Default value] ObjectSelect
	std::string get_name() const { return getString("name"); }

	//! The object/material ID that will be extracted
 	//! [Default value] 0
	bool set_id(int val) { return setValue("id", val); }
	//! The object/material ID that will be extracted
 	//! [Default value] 0
	int get_id() const { return getInt("id"); }

	//! The object/material IDs (more than one) that will be extracted
 	//! [Default value] 0
	bool set_ids(const IntList& intList) { return setValue("ids", intList); }
	//! The object/material IDs (more than one) that will be extracted
 	//! [Default value] 0
	bool set_ids(const int* ints, size_t count) { return setArray("ids", ints, count); }
	//! The object/material IDs (more than one) that will be extracted
 	//! [Default value] 0
	template<size_t count> bool set_ids(const int (&ints)[count]) { return setArray("ids", ints, count); }
	//! The object/material IDs (more than one) that will be extracted
 	//! [Default value] 0
	IntList get_ids() const { return getIntList("ids"); }

	//! true to use the material IDs instead of the object IDs
 	//! [Default value] false
	bool set_use_mtl_id(bool val) { return setValue("use_mtl_id", val); }
	//! true to use the material IDs instead of the object IDs
 	//! [Default value] false
	bool get_use_mtl_id() const { return getBool("use_mtl_id"); }

	//! false to not affect Matte Objects
 	//! [Default value] true
	bool set_affect_matte_objects(bool val) { return setValue("affect_matte_objects", val); }
	//! false to not affect Matte Objects
 	//! [Default value] true
	bool get_affect_matte_objects() const { return getBool("affect_matte_objects"); }

	//! (description missing)
	//! [Default value] false
	bool set_consider_for_aa(bool val) { return setValue("consider_for_aa", val); }
	//! (description missing)
	//! [Default value] false
	bool get_consider_for_aa() const { return getBool("consider_for_aa"); }

	//! true to use object/material IDs different from the specified by id
 	//! [Default value] false
	bool set_invert_selection(bool val) { return setValue("invert_selection", val); }
	//! true to use object/material IDs different from the specified by id
 	//! [Default value] false
	bool get_invert_selection() const { return getBool("invert_selection"); }
};

class RenderChannelRenderID : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "RenderChannelRenderID"; }

	//! (description missing)
	//! [Default value] true
	bool set_enableDeepOutput(bool val) { return setValue("enableDeepOutput", val); }
	//! (description missing)
	//! [Default value] true
	bool get_enableDeepOutput() const { return getBool("enableDeepOutput"); }

	//! (description missing)
	//! [Default value] RenderID
	bool set_name(const char* str) { return setValue("name", str); }
	//! (description missing)
	//! [Default value] RenderID
	bool set_name(const std::string& str) { return setValue("name", str); }
	//! (description missing)
	//! [Default value] RenderID
	std::string get_name() const { return getString("name"); }
};

class RenderChannelVelocity : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "RenderChannelVelocity"; }

	//! (description missing)
	//! [Default value] true
	bool set_enableDeepOutput(bool val) { return setValue("enableDeepOutput", val); }
	//! (description missing)
	//! [Default value] true
	bool get_enableDeepOutput() const { return getBool("enableDeepOutput"); }

	//! (description missing)
	//! [Default value] Velocity
	bool set_name(const char* str) { return setValue("name", str); }
	//! (description missing)
	//! [Default value] Velocity
	bool set_name(const std::string& str) { return setValue("name", str); }
	//! (description missing)
	//! [Default value] Velocity
	std::string get_name() const { return getString("name"); }

	//! (description missing)
	//! [Default value] true
	bool set_clamp_velocity(bool val) { return setValue("clamp_velocity", val); }
	//! (description missing)
	//! [Default value] true
	bool get_clamp_velocity() const { return getBool("clamp_velocity"); }

	//! (description missing)
	//! [Default value] 1
	bool set_max_velocity(float val) { return setValue("max_velocity", val); }
	//! (description missing)
	//! [Default value] 1
	float get_max_velocity() const { return getFloat("max_velocity"); }

	//! (description missing)
	//! [Default value] 0
	bool set_max_velocity_last_frame(float val) { return setValue("max_velocity_last_frame", val); }
	//! (description missing)
	//! [Default value] 0
	float get_max_velocity_last_frame() const { return getFloat("max_velocity_last_frame"); }

	//! (description missing)
	//! [Default value] true
	bool set_ignore_z(bool val) { return setValue("ignore_z", val); }
	//! (description missing)
	//! [Default value] true
	bool get_ignore_z() const { return getBool("ignore_z"); }

	//! (description missing)
	//! [Default value] true
	bool set_filtering(bool val) { return setValue("filtering", val); }
	//! (description missing)
	//! [Default value] true
	bool get_filtering() const { return getBool("filtering"); }
};

class RenderChannelZDepth : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "RenderChannelZDepth"; }

	//! (description missing)
	//! [Default value] true
	bool set_enableDeepOutput(bool val) { return setValue("enableDeepOutput", val); }
	//! (description missing)
	//! [Default value] true
	bool get_enableDeepOutput() const { return getBool("enableDeepOutput"); }

	//! (description missing)
	//! [Default value] ZDepth
	bool set_name(const char* str) { return setValue("name", str); }
	//! (description missing)
	//! [Default value] ZDepth
	bool set_name(const std::string& str) { return setValue("name", str); }
	//! (description missing)
	//! [Default value] ZDepth
	std::string get_name() const { return getString("name"); }

	//! (description missing)
	//! [Default value] false
	bool set_depth_from_camera(bool val) { return setValue("depth_from_camera", val); }
	//! (description missing)
	//! [Default value] false
	bool get_depth_from_camera() const { return getBool("depth_from_camera"); }

	//! (description missing)
	//! [Default value] 0
	bool set_depth_black(float val) { return setValue("depth_black", val); }
	//! (description missing)
	//! [Default value] 0
	float get_depth_black() const { return getFloat("depth_black"); }

	//! (description missing)
	//! [Default value] 1000
	bool set_depth_white(float val) { return setValue("depth_white", val); }
	//! (description missing)
	//! [Default value] 1000
	float get_depth_white() const { return getFloat("depth_white"); }

	//! (description missing)
	//! [Default value] true
	bool set_depth_clamp(bool val) { return setValue("depth_clamp", val); }
	//! (description missing)
	//! [Default value] true
	bool get_depth_clamp() const { return getBool("depth_clamp"); }

	//! (description missing)
	//! [Default value] true
	bool set_filtering(bool val) { return setValue("filtering", val); }
	//! (description missing)
	//! [Default value] true
	bool get_filtering() const { return getBool("filtering"); }
};

class RenderView : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "RenderView"; }

	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	bool set_transform(const Transform& transform) { return setValue("transform", transform); }
	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	Transform get_transform() const { return getTransform("transform"); }

	//! (description missing)
	//! [Default value] 0.785398
	bool set_fov(float val) { return setValue("fov", val); }
	//! (description missing)
	//! [Default value] 0.785398
	float get_fov() const { return getFloat("fov"); }

	//! [UI Guides] quantityType=distance
 	//! [Default value] 1
	bool set_focalDistance(float val) { return setValue("focalDistance", val); }
	//! [UI Guides] quantityType=distance
 	//! [Default value] 1
	float get_focalDistance() const { return getFloat("focalDistance"); }

	//! (description missing)
	//! [Default value] 0.1
	bool set_aperture(float val) { return setValue("aperture", val); }
	//! (description missing)
	//! [Default value] 0.1
	float get_aperture() const { return getFloat("aperture"); }

	//! (description missing)
	//! [Default value] 0
	bool set_lens_rotation(float val) { return setValue("lens_rotation", val); }
	//! (description missing)
	//! [Default value] 0
	float get_lens_rotation() const { return getFloat("lens_rotation"); }

	//! Number of samples per frame for the transformation
 	//! [Default value] 2
	bool set_frame_samples(int val) { return setValue("frame_samples", val); }
	//! Number of samples per frame for the transformation
 	//! [Default value] 2
	int get_frame_samples() const { return getInt("frame_samples"); }

	//! true to enable clipping planes
 	//! [Default value] false
	bool set_clipping(bool val) { return setValue("clipping", val); }
	//! true to enable clipping planes
 	//! [Default value] false
	bool get_clipping() const { return getBool("clipping"); }

	//! The near clipping plane
 	//! [UI Guides] quantityType=distance
 	//! [Default value] 0
	bool set_clipping_near(float val) { return setValue("clipping_near", val); }
	//! The near clipping plane
 	//! [UI Guides] quantityType=distance
 	//! [Default value] 0
	float get_clipping_near() const { return getFloat("clipping_near"); }

	//! The far clipping plane
 	//! [UI Guides] quantityType=distance
 	//! [Default value] 1e+018
	bool set_clipping_far(float val) { return setValue("clipping_far", val); }
	//! The far clipping plane
 	//! [UI Guides] quantityType=distance
 	//! [Default value] 1e+018
	float get_clipping_far() const { return getFloat("clipping_far"); }

	//! Zoom factor
 	//! [Default value] 1
	bool set_zoom(float val) { return setValue("zoom", val); }
	//! Zoom factor
 	//! [Default value] 1
	float get_zoom() const { return getFloat("zoom"); }

	//! (description missing)
	//! [Default value] false
	bool set_orthographic(bool val) { return setValue("orthographic", val); }
	//! (description missing)
	//! [Default value] false
	bool get_orthographic() const { return getBool("orthographic"); }

	//! [UI Guides] quantityType=distance
 	//! [Default value] 1
	bool set_orthographicWidth(float val) { return setValue("orthographicWidth", val); }
	//! [UI Guides] quantityType=distance
 	//! [Default value] 1
	float get_orthographicWidth() const { return getFloat("orthographicWidth"); }

	//! This is here so we can suppress a RenderView node from affecting the main VRayRenderer sequence and frame data.
 	//! [Default value] false
	bool set_dont_affect_settings(bool val) { return setValue("dont_affect_settings", val); }
	//! This is here so we can suppress a RenderView node from affecting the main VRayRenderer sequence and frame data.
 	//! [Default value] false
	bool get_dont_affect_settings() const { return getBool("dont_affect_settings"); }

	//! If true, the scene will be internally translated relative to the render view
 	//! [Default value] true
	bool set_use_scene_offset(bool val) { return setValue("use_scene_offset", val); }
	//! If true, the scene will be internally translated relative to the render view
 	//! [Default value] true
	bool get_use_scene_offset() const { return getBool("use_scene_offset"); }

	//! (description missing)
	//! [Default value] 1
	bool set_mayaFocalLength(float val) { return setValue("mayaFocalLength", val); }
	//! (description missing)
	//! [Default value] 1
	float get_mayaFocalLength() const { return getFloat("mayaFocalLength"); }

	//! (description missing)
	//! [Default value] 1
	bool set_mayaApperture(float val) { return setValue("mayaApperture", val); }
	//! (description missing)
	//! [Default value] 1
	float get_mayaApperture() const { return getFloat("mayaApperture"); }

	//! Enable stereo rendering and select output layout
 	//! [UI Guides] enum=0:disbled; 1:enabled, side-by-side; 2:enabled, top-bottom
 	//! [Default value] 0
	bool set_stereo_on(int val) { return setValue("stereo_on", val); }
	//! Enable stereo rendering and select output layout
 	//! [UI Guides] enum=0:disbled; 1:enabled, side-by-side; 2:enabled, top-bottom
 	//! [Default value] 0
	int get_stereo_on() const { return getInt("stereo_on"); }

	//! The distance between the two stereo views
 	//! [Default value] 1
	bool set_stereo_eye_distance(float val) { return setValue("stereo_eye_distance", val); }
	//! The distance between the two stereo views
 	//! [Default value] 1
	float get_stereo_eye_distance() const { return getFloat("stereo_eye_distance"); }

	//! Specifies the camera position relative to the left and right views: 0 - center, 1 - keep left view, 2 - keep right view
 	//! [Default value] 0
	bool set_stereo_interocular_method(int val) { return setValue("stereo_interocular_method", val); }
	//! Specifies the camera position relative to the left and right views: 0 - center, 1 - keep left view, 2 - keep right view
 	//! [Default value] 0
	int get_stereo_interocular_method() const { return getInt("stereo_interocular_method"); }

	//! true to specify a separate distance for the stereo focus
 	//! [Default value] false
	bool set_stereo_specify_focus(bool val) { return setValue("stereo_specify_focus", val); }
	//! true to specify a separate distance for the stereo focus
 	//! [Default value] false
	bool get_stereo_specify_focus() const { return getBool("stereo_specify_focus"); }

	//! The focus distance if specify_focus is enabled
 	//! [Default value] 1
	bool set_stereo_focus_distance(float val) { return setValue("stereo_focus_distance", val); }
	//! The focus distance if specify_focus is enabled
 	//! [Default value] 1
	float get_stereo_focus_distance() const { return getFloat("stereo_focus_distance"); }

	//! The focus method: 0 - parallel, 1 - rotate, 2 - shift
 	//! [Default value] 0
	bool set_stereo_focus_method(int val) { return setValue("stereo_focus_method", val); }
	//! The focus method: 0 - parallel, 1 - rotate, 2 - shift
 	//! [Default value] 0
	int get_stereo_focus_method() const { return getInt("stereo_focus_method"); }

	//! Specifies which view to render: 0 - both views, 1 - left view, 2 - right view.
 	//! [Default value] 0
	bool set_stereo_view(int val) { return setValue("stereo_view", val); }
	//! Specifies which view to render: 0 - both views, 1 - left view, 2 - right view.
 	//! [Default value] 0
	int get_stereo_view() const { return getInt("stereo_view"); }

	//! Top merge angle for panoramic pole merging
 	//! [UI Guides] units=radians
 	//! [Default value] 1.0472
	bool set_stereo_top_merge_angle(float val) { return setValue("stereo_top_merge_angle", val); }
	//! Top merge angle for panoramic pole merging
 	//! [UI Guides] units=radians
 	//! [Default value] 1.0472
	float get_stereo_top_merge_angle() const { return getFloat("stereo_top_merge_angle"); }

	//! Bottom merge angle for panoramic pole merging
 	//! [UI Guides] units=radians
 	//! [Default value] 1.0472
	bool set_stereo_bottom_merge_angle(float val) { return setValue("stereo_bottom_merge_angle", val); }
	//! Bottom merge angle for panoramic pole merging
 	//! [UI Guides] units=radians
 	//! [Default value] 1.0472
	float get_stereo_bottom_merge_angle() const { return getFloat("stereo_bottom_merge_angle"); }
};

class SceneModifierTest : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "SceneModifierTest"; }

	//! The particle .vrscene
 	//! [UI Guides] fileAsset=vrscene, fileAssetNames=V-Ray scene, fileAssetOp=load
 	bool set_particle_scene(const char* str) { return setValue("particle_scene", str); }
	//! The particle .vrscene
 	//! [UI Guides] fileAsset=vrscene, fileAssetNames=V-Ray scene, fileAssetOp=load
 	bool set_particle_scene(const std::string& str) { return setValue("particle_scene", str); }
	//! The particle .vrscene
 	//! [UI Guides] fileAsset=vrscene, fileAssetNames=V-Ray scene, fileAssetOp=load
 	std::string get_particle_scene() const { return getString("particle_scene"); }

	//! The proxy .vrscene
 	//! [UI Guides] fileAsset=vrscene, fileAssetNames=V-Ray scene, fileAssetOp=load
 	bool set_proxy_scene(const char* str) { return setValue("proxy_scene", str); }
	//! The proxy .vrscene
 	//! [UI Guides] fileAsset=vrscene, fileAssetNames=V-Ray scene, fileAssetOp=load
 	bool set_proxy_scene(const std::string& str) { return setValue("proxy_scene", str); }
	//! The proxy .vrscene
 	//! [UI Guides] fileAsset=vrscene, fileAssetNames=V-Ray scene, fileAssetOp=load
 	std::string get_proxy_scene() const { return getString("proxy_scene"); }

	//! The material .vrscene
 	//! [UI Guides] fileAsset=vrscene, fileAssetNames=V-Ray scene, fileAssetOp=load
 	bool set_material_scene(const char* str) { return setValue("material_scene", str); }
	//! The material .vrscene
 	//! [UI Guides] fileAsset=vrscene, fileAssetNames=V-Ray scene, fileAssetOp=load
 	bool set_material_scene(const std::string& str) { return setValue("material_scene", str); }
	//! The material .vrscene
 	//! [UI Guides] fileAsset=vrscene, fileAssetNames=V-Ray scene, fileAssetOp=load
 	std::string get_material_scene() const { return getString("material_scene"); }
};

class SettingsCamera : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "SettingsCamera"; }

	//! Camera type: 0 - default, 1 - spherical, 2 - cylindrical point, 3 - cylindrical ortho, 4 - box, 5 - fish-eye, 6 - warped spherical, 7 - orthogonal, 8 - pinhole, 9 - spherical panorama, 10 - cube 6x1
 	//! [UI Guides] displayName=Camera type, enum=0:Standard; 1:Spherical; 2:Cylindrical point; 3:Cylindrical ortho; 4:Box; 5:Fish eye; 6:Warped spherical; 7:Orthogonal; 8:Pinhole; 9:Spherical panorama; 10:Cube 6x1
 	//! [Default value] 0
	bool set_type(int val) { return setValue("type", val); }
	//! Camera type: 0 - default, 1 - spherical, 2 - cylindrical point, 3 - cylindrical ortho, 4 - box, 5 - fish-eye, 6 - warped spherical, 7 - orthogonal, 8 - pinhole, 9 - spherical panorama, 10 - cube 6x1
 	//! [UI Guides] displayName=Camera type, enum=0:Standard; 1:Spherical; 2:Cylindrical point; 3:Cylindrical ortho; 4:Box; 5:Fish eye; 6:Warped spherical; 7:Orthogonal; 8:Pinhole; 9:Spherical panorama; 10:Cube 6x1
 	//! [Default value] 0
	int get_type() const { return getInt("type"); }

	//! Height of the cylindrical (ortho) camera
 	//! [UI Guides] enableIf: ?type=3, displayName=Height, minValue=0.0, maxValue=1e9
 	//! [Default value] 400
	bool set_height(float val) { return setValue("height", val); }
	//! Height of the cylindrical (ortho) camera
 	//! [UI Guides] enableIf: ?type=3, displayName=Height, minValue=0.0, maxValue=1e9
 	//! [Default value] 400
	float get_height() const { return getFloat("height"); }

	//! Applies only to fish-eye camera. Controls distance to the sphere center
 	//! [UI Guides] enableIf: ?type=5, ?auto_fit=0, displayName=Distance, minValue=0.0, maxValue=1e9
 	//! [Default value] 2
	bool set_dist(float val) { return setValue("dist", val); }
	//! Applies only to fish-eye camera. Controls distance to the sphere center
 	//! [UI Guides] enableIf: ?type=5, ?auto_fit=0, displayName=Distance, minValue=0.0, maxValue=1e9
 	//! [Default value] 2
	float get_dist() const { return getFloat("dist"); }

	//! Field of view; if negative, the field of view will not be modified
 	//! [UI Guides] displayName=FOV, minValue=0.0, maxValue=6.283185307
 	//! [Default value] 0.785398
	bool set_fov(float val) { return setValue("fov", val); }
	//! Field of view; if negative, the field of view will not be modified
 	//! [UI Guides] displayName=FOV, minValue=0.0, maxValue=6.283185307
 	//! [Default value] 0.785398
	float get_fov() const { return getFloat("fov"); }

	//! The auto-fit option of the fish-eye camera
 	//! [UI Guides] enableIf: ?type=5, displayName=Auto-fit
 	//! [Default value] true
	bool set_auto_fit(bool val) { return setValue("auto_fit", val); }
	//! The auto-fit option of the fish-eye camera
 	//! [UI Guides] enableIf: ?type=5, displayName=Auto-fit
 	//! [Default value] true
	bool get_auto_fit() const { return getBool("auto_fit"); }

	//! Controls the way the rendered images is warped. Applies only to fish-eye camera
 	//! [UI Guides] enableIf: ?type=5, displayName=Curve, minValue=0.0, maxValue=1e9
 	//! [Default value] 1
	bool set_curve(float val) { return setValue("curve", val); }
	//! Controls the way the rendered images is warped. Applies only to fish-eye camera
 	//! [UI Guides] enableIf: ?type=5, displayName=Curve, minValue=0.0, maxValue=1e9
 	//! [Default value] 1
	float get_curve() const { return getFloat("curve"); }

	//! This is here so we can suppress a SettingsCamera node from affecting the main VRayRenderer sequence and frame data
 	//! [UI Guides] displayName=Don't affect settings
 	//! [Default value] false
	bool set_dont_affect_settings(bool val) { return setValue("dont_affect_settings", val); }
	//! This is here so we can suppress a SettingsCamera node from affecting the main VRayRenderer sequence and frame data
 	//! [UI Guides] displayName=Don't affect settings
 	//! [Default value] false
	bool get_dont_affect_settings() const { return getBool("dont_affect_settings"); }

	//! Used only to force a re-export of the image plane geometry in RT rendering
 	bool set_image_planes(const Plugin& plugin) { return setValue("image_planes", plugin); }
	//! Used only to force a re-export of the image plane geometry in RT rendering
 	Plugin get_image_planes() const { return getPlugin("image_planes"); }
};

class SettingsCameraDof : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "SettingsCameraDof"; }

	//! True to indicate DOF should be computed.
 	//! [UI Guides] displayName=Enable depth-of-field
 	//! [Default value] false
	bool set_on(bool val) { return setValue("on", val); }
	//! True to indicate DOF should be computed.
 	//! [UI Guides] displayName=Enable depth-of-field
 	//! [Default value] false
	bool get_on() const { return getBool("on"); }

	//! [UI Guides] enableIf: ?on!=0, displayName=Aperture, minValue=0.0, maxValue=1e6
 	//! [Default value] 5
	bool set_aperture(float val) { return setValue("aperture", val); }
	//! [UI Guides] enableIf: ?on!=0, displayName=Aperture, minValue=0.0, maxValue=1e6
 	//! [Default value] 5
	float get_aperture() const { return getFloat("aperture"); }

	//! Center bias for the DOF effect; between -1.0f and 1.0f; 0.0f means no bias.
 	//! [UI Guides] enableIf: ?on!=0, displayName=Center bias, minValue=-1.0, maxValue=1.0
 	//! [Default value] 0
	bool set_center_bias(float val) { return setValue("center_bias", val); }
	//! Center bias for the DOF effect; between -1.0f and 1.0f; 0.0f means no bias.
 	//! [UI Guides] enableIf: ?on!=0, displayName=Center bias, minValue=-1.0, maxValue=1.0
 	//! [Default value] 0
	float get_center_bias() const { return getFloat("center_bias"); }

	//! [UI Guides] enableIf: ?on!=0, displayName=Focus distance, quantityType=distance, minValue=0.0, maxValue=1e6
 	//! [Default value] 200
	bool set_focal_dist(float val) { return setValue("focal_dist", val); }
	//! [UI Guides] enableIf: ?on!=0, displayName=Focus distance, quantityType=distance, minValue=0.0, maxValue=1e6
 	//! [Default value] 200
	float get_focal_dist() const { return getFloat("focal_dist"); }

	//! True to make the aperture a regular polygon, instead of a circle.
 	//! [UI Guides] enableIf: ?on!=0, displayName=Sides
 	//! [Default value] false
	bool set_sides_on(bool val) { return setValue("sides_on", val); }
	//! True to make the aperture a regular polygon, instead of a circle.
 	//! [UI Guides] enableIf: ?on!=0, displayName=Sides
 	//! [Default value] false
	bool get_sides_on() const { return getBool("sides_on"); }

	//! Sides of the polygon, if 'Sides' is true.
 	//! [UI Guides] enableIf: ?on!=0, ?sides_on!=0, displayName=Number of sides, minValue=3, maxValue=12
 	//! [Default value] 5
	bool set_sides_num(int val) { return setValue("sides_num", val); }
	//! Sides of the polygon, if 'Sides' is true.
 	//! [UI Guides] enableIf: ?on!=0, ?sides_on!=0, displayName=Number of sides, minValue=3, maxValue=12
 	//! [Default value] 5
	int get_sides_num() const { return getInt("sides_num"); }

	//! [UI Guides] enableIf: ?on!=0, ?sides_on!=0, displayName=Rotation, minValue=0.0, maxValue=1e6
 	//! [Default value] 0
	bool set_rotation(float val) { return setValue("rotation", val); }
	//! [UI Guides] enableIf: ?on!=0, ?sides_on!=0, displayName=Rotation, minValue=0.0, maxValue=1e6
 	//! [Default value] 0
	float get_rotation() const { return getFloat("rotation"); }

	//! Anisotropy; allows an anamorphic effect.
 	//! [UI Guides] enableIf: ?on!=0, displayName=Anisotropy, minValue=-1.0, maxValue=1.0
 	//! [Default value] 0
	bool set_anisotropy(float val) { return setValue("anisotropy", val); }
	//! Anisotropy; allows an anamorphic effect.
 	//! [UI Guides] enableIf: ?on!=0, displayName=Anisotropy, minValue=-1.0, maxValue=1.0
 	//! [Default value] 0
	float get_anisotropy() const { return getFloat("anisotropy"); }

	//! Determines the number of samples for the DOF effect.
 	//! [UI Guides] enableIf: ?on!=0, displayName=Subdivs, minValue=1, maxValue=100
 	//! [Default value] 1
	bool set_subdivs(int val) { return setValue("subdivs", val); }
	//! Determines the number of samples for the DOF effect.
 	//! [UI Guides] enableIf: ?on!=0, displayName=Subdivs, minValue=1, maxValue=100
 	//! [Default value] 1
	int get_subdivs() const { return getInt("subdivs"); }
};

class SettingsCaustics : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "SettingsCaustics"; }

	//! [UI Guides] displayName=Enable caustics
 	//! [Default value] false
	bool set_on(bool val) { return setValue("on", val); }
	//! [UI Guides] displayName=Enable caustics
 	//! [Default value] false
	bool get_on() const { return getBool("on"); }

	//! Max. number of photons to look for; if 0, all photons within the search distance will be considered.
 	//! [UI Guides] enableIf: ?on=1, displayName=Max photons, minValue=0, maxValue=10000
 	//! [Default value] 30
	bool set_max_photons(int val) { return setValue("max_photons", val); }
	//! Max. number of photons to look for; if 0, all photons within the search distance will be considered.
 	//! [UI Guides] enableIf: ?on=1, displayName=Max photons, minValue=0, maxValue=10000
 	//! [Default value] 30
	int get_max_photons() const { return getInt("max_photons"); }

	//! Search distance for caustic photons.
 	//! [UI Guides] enableIf: ?on=1, displayName=Search distance, quantityType=distance, minValue=0.0, maxValue=1e8
 	//! [Default value] 1e+018
	bool set_search_distance(float val) { return setValue("search_distance", val); }
	//! Search distance for caustic photons.
 	//! [UI Guides] enableIf: ?on=1, displayName=Search distance, quantityType=distance, minValue=0.0, maxValue=1e8
 	//! [Default value] 1e+018
	float get_search_distance() const { return getFloat("search_distance"); }

	//! [UI Guides] enableIf: ?on=1, displayName=Max density, quantityType=distance, minValue=0.0, maxValue=1e8
 	//! [Default value] 0
	bool set_max_density(float val) { return setValue("max_density", val); }
	//! [UI Guides] enableIf: ?on=1, displayName=Max density, quantityType=distance, minValue=0.0, maxValue=1e8
 	//! [Default value] 0
	float get_max_density() const { return getFloat("max_density"); }

	//! [UI Guides] enableIf: ?on=1, displayName=Multiplier, minValue=0.0, maxValue=1e6
 	//! [Default value] 1
	bool set_multiplier(float val) { return setValue("multiplier", val); }
	//! [UI Guides] enableIf: ?on=1, displayName=Multiplier, minValue=0.0, maxValue=1e6
 	//! [Default value] 1
	float get_multiplier() const { return getFloat("multiplier"); }

	//! [UI Guides] enableIf: ?on=1, enum=0:New map; 1:From file, displayName=Mode
 	//! [Default value] 0
	bool set_mode(int val) { return setValue("mode", val); }
	//! [UI Guides] enableIf: ?on=1, enum=0:New map; 1:From file, displayName=Mode
 	//! [Default value] 0
	int get_mode() const { return getInt("mode"); }

	//! [UI Guides] enableIf: ?on=1, ?mode=1, displayName=Caustics Photon Map File, fileAsset=vrpmap, fileAssetNames=V-Ray Photon map
 	bool set_file(const char* str) { return setValue("file", str); }
	//! [UI Guides] enableIf: ?on=1, ?mode=1, displayName=Caustics Photon Map File, fileAsset=vrpmap, fileAssetNames=V-Ray Photon map
 	bool set_file(const std::string& str) { return setValue("file", str); }
	//! [UI Guides] enableIf: ?on=1, ?mode=1, displayName=Caustics Photon Map File, fileAsset=vrpmap, fileAssetNames=V-Ray Photon map
 	std::string get_file() const { return getString("file"); }

	//! If true, the caustics photon map will not be deleted after rendering is complete.
 	//! [UI Guides] enableIf: ?on=1, displayName=Don't delete
 	//! [Default value] true
	bool set_dont_delete(bool val) { return setValue("dont_delete", val); }
	//! If true, the caustics photon map will not be deleted after rendering is complete.
 	//! [UI Guides] enableIf: ?on=1, displayName=Don't delete
 	//! [Default value] true
	bool get_dont_delete() const { return getBool("dont_delete"); }

	//! True to save the caustics photon map automatically at the end of the rendering
 	//! [UI Guides] enableIf: ?on=1, ?mode!=1, displayName=Auto save
 	//! [Default value] false
	bool set_auto_save(bool val) { return setValue("auto_save", val); }
	//! True to save the caustics photon map automatically at the end of the rendering
 	//! [UI Guides] enableIf: ?on=1, ?mode!=1, displayName=Auto save
 	//! [Default value] false
	bool get_auto_save() const { return getBool("auto_save"); }

	//! [UI Guides] enableIf: ?on=1, ?mode!=1, ?auto_save=1, displayName=Auto save file, fileAsset=vrpmap, fileAssetNames=V-Ray Photon map, fileAssetOp=save
 	bool set_auto_save_file(const char* str) { return setValue("auto_save_file", str); }
	//! [UI Guides] enableIf: ?on=1, ?mode!=1, ?auto_save=1, displayName=Auto save file, fileAsset=vrpmap, fileAssetNames=V-Ray Photon map, fileAssetOp=save
 	bool set_auto_save_file(const std::string& str) { return setValue("auto_save_file", str); }
	//! [UI Guides] enableIf: ?on=1, ?mode!=1, ?auto_save=1, displayName=Auto save file, fileAsset=vrpmap, fileAssetNames=V-Ray Photon map, fileAssetOp=save
 	std::string get_auto_save_file() const { return getString("auto_save_file"); }

	//! True to show the calculation of the caustics map
 	//! [UI Guides] enableIf: ?on=1, displayName=Show calculation phase
 	//! [Default value] false
	bool set_show_calc_phase(bool val) { return setValue("show_calc_phase", val); }
	//! True to show the calculation of the caustics map
 	//! [UI Guides] enableIf: ?on=1, displayName=Show calculation phase
 	//! [Default value] false
	bool get_show_calc_phase() const { return getBool("show_calc_phase"); }
};

class SettingsColorMapping : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "SettingsColorMapping"; }

	//! Type of color mapping.
 	//! [UI Guides] displayName=Type, enum=0:Linear; 1:Exponential; 2:HSV exponential; 3:Intensity exponential; 4:Gamma correction; 5:Intensity gamma; 6:Reinhard
 	//! [Default value] 0
	bool set_type(int val) { return setValue("type", val); }
	//! Type of color mapping.
 	//! [UI Guides] displayName=Type, enum=0:Linear; 1:Exponential; 2:HSV exponential; 3:Intensity exponential; 4:Gamma correction; 5:Intensity gamma; 6:Reinhard
 	//! [Default value] 0
	int get_type() const { return getInt("type"); }

	//! True if color mapping should affect the background.
 	//! [UI Guides] displayName=Affect background
 	//! [Default value] true
	bool set_affect_background(bool val) { return setValue("affect_background", val); }
	//! True if color mapping should affect the background.
 	//! [UI Guides] displayName=Affect background
 	//! [Default value] true
	bool get_affect_background() const { return getBool("affect_background"); }

	//! Multiplier for dark colors.
 	//! [UI Guides] displayName=Dark multiplier, minValue=-1000.0, maxValue=1000.0
 	//! [Default value] 1
	bool set_dark_mult(float val) { return setValue("dark_mult", val); }
	//! Multiplier for dark colors.
 	//! [UI Guides] displayName=Dark multiplier, minValue=-1000.0, maxValue=1000.0
 	//! [Default value] 1
	float get_dark_mult() const { return getFloat("dark_mult"); }

	//! Multiplier for bright colors.
 	//! [UI Guides] displayName=Bright multiplier, minValue=-1000.0, maxValue=1000.0
 	//! [Default value] 1
	bool set_bright_mult(float val) { return setValue("bright_mult", val); }
	//! Multiplier for bright colors.
 	//! [UI Guides] displayName=Bright multiplier, minValue=-1000.0, maxValue=1000.0
 	//! [Default value] 1
	float get_bright_mult() const { return getFloat("bright_mult"); }

	//! Additional gamma correction.
 	//! [UI Guides] displayName=Gamma, minValue=0.05, maxValue=20.0
 	//! [Default value] 1
	bool set_gamma(float val) { return setValue("gamma", val); }
	//! Additional gamma correction.
 	//! [UI Guides] displayName=Gamma, minValue=0.05, maxValue=20.0
 	//! [Default value] 1
	float get_gamma() const { return getFloat("gamma"); }

	//! True if the color mapping should be applied on a subpixel level.
 	//! [UI Guides] displayName=Subpixel mapping
 	//! [Default value] false
	bool set_subpixel_mapping(bool val) { return setValue("subpixel_mapping", val); }
	//! True if the color mapping should be applied on a subpixel level.
 	//! [UI Guides] displayName=Subpixel mapping
 	//! [Default value] false
	bool get_subpixel_mapping() const { return getBool("subpixel_mapping"); }

	//! True if colors should be clamped after color mapping.
 	//! [UI Guides] displayName=Clamp output
 	//! [Default value] false
	bool set_clamp_output(bool val) { return setValue("clamp_output", val); }
	//! True if colors should be clamped after color mapping.
 	//! [UI Guides] displayName=Clamp output
 	//! [Default value] false
	bool get_clamp_output() const { return getBool("clamp_output"); }

	//! The level at which colors will be clamped if clamping is on.
 	//! [UI Guides] enableIf: ?clamp_output!=0, displayName=Clamp level, minValue=0.0, maxValue=100.0
 	//! [Default value] 1
	bool set_clamp_level(float val) { return setValue("clamp_level", val); }
	//! The level at which colors will be clamped if clamping is on.
 	//! [UI Guides] enableIf: ?clamp_output!=0, displayName=Clamp level, minValue=0.0, maxValue=100.0
 	//! [Default value] 1
	float get_clamp_level() const { return getFloat("clamp_level"); }

	//! Specifies whether color mapping and gamma are applied to the image: 0 - both color mapping and gamma are applied; 1 - nothing is applied; 2 - only color mapping is applied
 	//! [UI Guides] displayName=Mode, enum=0:Color mapping and gamma; 1:None don't apply anything; 2:Color mapping only no gamma
 	//! [Default value] 0
	bool set_adaptation_only(int val) { return setValue("adaptation_only", val); }
	//! Specifies whether color mapping and gamma are applied to the image: 0 - both color mapping and gamma are applied; 1 - nothing is applied; 2 - only color mapping is applied
 	//! [UI Guides] displayName=Mode, enum=0:Color mapping and gamma; 1:None don't apply anything; 2:Color mapping only no gamma
 	//! [Default value] 0
	int get_adaptation_only() const { return getInt("adaptation_only"); }

	//! True to enforce linear workflow.
 	//! [UI Guides] displayName=Linear workflow
 	//! [Default value] false
	bool set_linearWorkflow(bool val) { return setValue("linearWorkflow", val); }
	//! True to enforce linear workflow.
 	//! [UI Guides] displayName=Linear workflow
 	//! [Default value] false
	bool get_linearWorkflow() const { return getBool("linearWorkflow"); }

	//! Additional image exposure.
 	//! [UI Guides] displayName=Image exposure
 	//! [Default value] Color(1, 1, 1)
	bool set_exposure(const Color& color) { return setValue("exposure", color); }
	//! Additional image exposure.
 	//! [UI Guides] displayName=Image exposure
 	//! [Default value] Color(1, 1, 1)
	Color get_exposure() const { return getColor("exposure"); }
};

class SettingsColorMappingModo : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "SettingsColorMappingModo"; }

	//! Type of color mapping.
 	//! [UI Guides] displayName=Type, enum=0:Linear; 1:Exponential; 2:HSV exponential; 3:Intensity exponential; 4:Gamma correction; 5:Intensity gamma; 6:Reinhard
 	//! [Default value] 0
	bool set_type(int val) { return setValue("type", val); }
	//! Type of color mapping.
 	//! [UI Guides] displayName=Type, enum=0:Linear; 1:Exponential; 2:HSV exponential; 3:Intensity exponential; 4:Gamma correction; 5:Intensity gamma; 6:Reinhard
 	//! [Default value] 0
	int get_type() const { return getInt("type"); }

	//! True if color mapping should affect the background.
 	//! [UI Guides] displayName=Affect background
 	//! [Default value] true
	bool set_affect_background(bool val) { return setValue("affect_background", val); }
	//! True if color mapping should affect the background.
 	//! [UI Guides] displayName=Affect background
 	//! [Default value] true
	bool get_affect_background() const { return getBool("affect_background"); }

	//! Multiplier for dark colors.
 	//! [UI Guides] displayName=Dark multiplier, minValue=-1000.0, maxValue=1000.0
 	//! [Default value] 1
	bool set_dark_mult(float val) { return setValue("dark_mult", val); }
	//! Multiplier for dark colors.
 	//! [UI Guides] displayName=Dark multiplier, minValue=-1000.0, maxValue=1000.0
 	//! [Default value] 1
	float get_dark_mult() const { return getFloat("dark_mult"); }

	//! Multiplier for bright colors.
 	//! [UI Guides] displayName=Bright multiplier, minValue=-1000.0, maxValue=1000.0
 	//! [Default value] 1
	bool set_bright_mult(float val) { return setValue("bright_mult", val); }
	//! Multiplier for bright colors.
 	//! [UI Guides] displayName=Bright multiplier, minValue=-1000.0, maxValue=1000.0
 	//! [Default value] 1
	float get_bright_mult() const { return getFloat("bright_mult"); }

	//! Additional gamma correction.
 	//! [UI Guides] displayName=Gamma, minValue=0.05, maxValue=20.0
 	//! [Default value] 1
	bool set_gamma(float val) { return setValue("gamma", val); }
	//! Additional gamma correction.
 	//! [UI Guides] displayName=Gamma, minValue=0.05, maxValue=20.0
 	//! [Default value] 1
	float get_gamma() const { return getFloat("gamma"); }

	//! True if the color mapping should be applied on a subpixel level.
 	//! [UI Guides] displayName=Subpixel mapping
 	//! [Default value] false
	bool set_subpixel_mapping(bool val) { return setValue("subpixel_mapping", val); }
	//! True if the color mapping should be applied on a subpixel level.
 	//! [UI Guides] displayName=Subpixel mapping
 	//! [Default value] false
	bool get_subpixel_mapping() const { return getBool("subpixel_mapping"); }

	//! True if colors should be clamped after color mapping.
 	//! [UI Guides] displayName=Clamp output
 	//! [Default value] false
	bool set_clamp_output(bool val) { return setValue("clamp_output", val); }
	//! True if colors should be clamped after color mapping.
 	//! [UI Guides] displayName=Clamp output
 	//! [Default value] false
	bool get_clamp_output() const { return getBool("clamp_output"); }

	//! The level at which colors will be clamped if clamping is on.
 	//! [UI Guides] enableIf: ?clamp_output!=0, displayName=Clamp level, minValue=0.0, maxValue=100.0
 	//! [Default value] 1
	bool set_clamp_level(float val) { return setValue("clamp_level", val); }
	//! The level at which colors will be clamped if clamping is on.
 	//! [UI Guides] enableIf: ?clamp_output!=0, displayName=Clamp level, minValue=0.0, maxValue=100.0
 	//! [Default value] 1
	float get_clamp_level() const { return getFloat("clamp_level"); }

	//! Specifies whether color mapping and gamma are applied to the image: 0 - both color mapping and gamma are applied; 1 - nothing is applied; 2 - only color mapping is applied
 	//! [UI Guides] displayName=Mode, enum=0:Color mapping and gamma; 1:None don't apply anything; 2:Color mapping only no gamma
 	//! [Default value] 0
	bool set_adaptation_only(int val) { return setValue("adaptation_only", val); }
	//! Specifies whether color mapping and gamma are applied to the image: 0 - both color mapping and gamma are applied; 1 - nothing is applied; 2 - only color mapping is applied
 	//! [UI Guides] displayName=Mode, enum=0:Color mapping and gamma; 1:None don't apply anything; 2:Color mapping only no gamma
 	//! [Default value] 0
	int get_adaptation_only() const { return getInt("adaptation_only"); }

	//! True to enforce linear workflow.
 	//! [UI Guides] displayName=Linear workflow
 	//! [Default value] false
	bool set_linearWorkflow(bool val) { return setValue("linearWorkflow", val); }
	//! True to enforce linear workflow.
 	//! [UI Guides] displayName=Linear workflow
 	//! [Default value] false
	bool get_linearWorkflow() const { return getBool("linearWorkflow"); }

	//! Additional image exposure.
 	//! [UI Guides] displayName=Image exposure
 	//! [Default value] Color(1, 1, 1)
	bool set_exposure(const Color& color) { return setValue("exposure", color); }
	//! Additional image exposure.
 	//! [UI Guides] displayName=Image exposure
 	//! [Default value] Color(1, 1, 1)
	Color get_exposure() const { return getColor("exposure"); }

	//! Multiplier for the "Gamma correction", "Intensity gamma" and "Reinhard" modes.
 	//! [UI Guides] displayName=Multiplier, minValue=-1000.0, maxValue=1000.0, enableIf: ?type=4;?type=5;?type=6
 	//! [Default value] 1
	bool set_multiplier(float val) { return setValue("multiplier", val); }
	//! Multiplier for the "Gamma correction", "Intensity gamma" and "Reinhard" modes.
 	//! [UI Guides] displayName=Multiplier, minValue=-1000.0, maxValue=1000.0, enableIf: ?type=4;?type=5;?type=6
 	//! [Default value] 1
	float get_multiplier() const { return getFloat("multiplier"); }

	//! Inverse gamma for the the "Gamma correction" and "Intensity gamma" modes.
 	//! [UI Guides] displayName=Inverse gamma, minValue=0.05, maxValue=20.0, enableIf: ?type=4;?type=5
 	//! [Default value] 1
	bool set_inverse_gamma(float val) { return setValue("inverse_gamma", val); }
	//! Inverse gamma for the the "Gamma correction" and "Intensity gamma" modes.
 	//! [UI Guides] displayName=Inverse gamma, minValue=0.05, maxValue=20.0, enableIf: ?type=4;?type=5
 	//! [Default value] 1
	float get_inverse_gamma() const { return getFloat("inverse_gamma"); }

	//! Burn value for the Reinhard color mapping.
 	//! [UI Guides] displayName=Burn value, minValue=-1000.0, maxValue=1000.0, enableIf: ?type=6
 	//! [Default value] 1
	bool set_reinhard_burn_value(float val) { return setValue("reinhard_burn_value", val); }
	//! Burn value for the Reinhard color mapping.
 	//! [UI Guides] displayName=Burn value, minValue=-1000.0, maxValue=1000.0, enableIf: ?type=6
 	//! [Default value] 1
	float get_reinhard_burn_value() const { return getFloat("reinhard_burn_value"); }
};

class SettingsCurrentFrame : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "SettingsCurrentFrame"; }

	//! current frame
 	//! [Default value] 0
	bool set_current_frame(int val) { return setValue("current_frame", val); }
	//! current frame
 	//! [Default value] 0
	int get_current_frame() const { return getInt("current_frame"); }
};

class SettingsDMCGI : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "SettingsDMCGI"; }

	//! Determines the number of samples (rays) for the direct GI integration mode. Larger values mean more samples and less noise, but may slow down the rendering.
 	//! [UI Guides] displayName=Subdivs, minValue=1, maxValue=5000, quantityType=localSubdivs
 	//! [Default value] 8
	bool set_subdivs(int val) { return setValue("subdivs", val); }
	//! Determines the number of samples (rays) for the direct GI integration mode. Larger values mean more samples and less noise, but may slow down the rendering.
 	//! [UI Guides] displayName=Subdivs, minValue=1, maxValue=5000, quantityType=localSubdivs
 	//! [Default value] 8
	int get_subdivs() const { return getInt("subdivs"); }

	//! Determines the ray depth for the direct GI integration mode. Larger values produce a more accurate lighting solution, but may slow down the rendering.
 	//! [UI Guides] displayName=Depth, minValue=1, maxValue=500
 	//! [Default value] 3
	bool set_depth(int val) { return setValue("depth", val); }
	//! Determines the ray depth for the direct GI integration mode. Larger values produce a more accurate lighting solution, but may slow down the rendering.
 	//! [UI Guides] displayName=Depth, minValue=1, maxValue=500
 	//! [Default value] 3
	int get_depth() const { return getInt("depth"); }
};

class SettingsDMCSampler : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "SettingsDMCSampler"; }

	//! If this is true, the sample pattern will vary from frame to frame.
 	//! [UI Guides] displayName=Animated noise pattern
 	//! [Default value] false
	bool set_time_dependent(bool val) { return setValue("time_dependent", val); }
	//! If this is true, the sample pattern will vary from frame to frame.
 	//! [UI Guides] displayName=Animated noise pattern
 	//! [Default value] false
	bool get_time_dependent() const { return getBool("time_dependent"); }

	//! Amount of adaptive sampling; 1.0 means full adaptation; 0.0 means no adaptation.
 	//! [UI Guides] displayName=Adaptive amount, minValue=0.0, maxValue=1.0
 	//! [Default value] 0.85
	bool set_adaptive_amount(float val) { return setValue("adaptive_amount", val); }
	//! Amount of adaptive sampling; 1.0 means full adaptation; 0.0 means no adaptation.
 	//! [UI Guides] displayName=Adaptive amount, minValue=0.0, maxValue=1.0
 	//! [Default value] 0.85
	float get_adaptive_amount() const { return getFloat("adaptive_amount"); }

	//! Noise threshold that determines when to stop sampling. Lower values reduce noise, but may take longer to render.
 	//! [UI Guides] displayName=Adaptive threshold, minValue=0.0, maxValue=1.0
 	//! [Default value] 0.005
	bool set_adaptive_threshold(float val) { return setValue("adaptive_threshold", val); }
	//! Noise threshold that determines when to stop sampling. Lower values reduce noise, but may take longer to render.
 	//! [UI Guides] displayName=Adaptive threshold, minValue=0.0, maxValue=1.0
 	//! [Default value] 0.005
	float get_adaptive_threshold() const { return getFloat("adaptive_threshold"); }

	//! Minimum amount of samples to take.
 	//! [UI Guides] displayName=Adaptive min samples, minValue=2, maxValue=1000
 	//! [Default value] 16
	bool set_adaptive_min_samples(int val) { return setValue("adaptive_min_samples", val); }
	//! Minimum amount of samples to take.
 	//! [UI Guides] displayName=Adaptive min samples, minValue=2, maxValue=1000
 	//! [Default value] 16
	int get_adaptive_min_samples() const { return getInt("adaptive_min_samples"); }

	//! A global subdivs multiplier. Handy for reducing overall quality for draft renders.
 	//! [UI Guides] displayName=Subdivs multiplier, minValue=0.0, maxValue=1e6, enableIf: ?use_local_subdivs=1
 	//! [Default value] 1
	bool set_subdivs_mult(float val) { return setValue("subdivs_mult", val); }
	//! A global subdivs multiplier. Handy for reducing overall quality for draft renders.
 	//! [UI Guides] displayName=Subdivs multiplier, minValue=0.0, maxValue=1e6, enableIf: ?use_local_subdivs=1
 	//! [Default value] 1
	float get_subdivs_mult() const { return getFloat("subdivs_mult"); }

	//! [UI Guides] displayName=Path sampler type; enum=0: Legacy; 1: Latin super cube; 2: Schlick
 	//! [Default value] 2
	bool set_path_sampler_type(int val) { return setValue("path_sampler_type", val); }
	//! [UI Guides] displayName=Path sampler type; enum=0: Legacy; 1: Latin super cube; 2: Schlick
 	//! [Default value] 2
	int get_path_sampler_type() const { return getInt("path_sampler_type"); }

	//! Allow VRay to divide the number of samples for lights, materials etc by the number of AA samples in order to achieve roughly the same quality and number of rays when changing AA settings.
 	//! [UI Guides] displayName=Divide shading subdivs
 	//! [Default value] true
	bool set_div_shade_subdivs(bool val) { return setValue("div_shade_subdivs", val); }
	//! Allow VRay to divide the number of samples for lights, materials etc by the number of AA samples in order to achieve roughly the same quality and number of rays when changing AA settings.
 	//! [UI Guides] displayName=Divide shading subdivs
 	//! [Default value] true
	bool get_div_shade_subdivs() const { return getBool("div_shade_subdivs"); }

	//! If non-zero, a random seed for the DMC sampler.
 	//! [Default value] 0
	bool set_random_seed(int val) { return setValue("random_seed", val); }
	//! If non-zero, a random seed for the DMC sampler.
 	//! [Default value] 0
	int get_random_seed() const { return getInt("random_seed"); }

	//! true if shading subdivs in materials/lights/GI should be used, and false to determine subdivs automatically.
 	//! [Default value] true
	bool set_use_local_subdivs(bool val) { return setValue("use_local_subdivs", val); }
	//! true if shading subdivs in materials/lights/GI should be used, and false to determine subdivs automatically.
 	//! [Default value] true
	bool get_use_local_subdivs() const { return getBool("use_local_subdivs"); }
};

class SettingsDR : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "SettingsDR"; }

	//! Strings that represent either an ip address or a hostname for machines to be used as DR Nodes
 	bool set_host_list(const ValueList& stringList) { return setValue("host_list", stringList); }
	//! Strings that represent either an ip address or a hostname for machines to be used as DR Nodes
 	ValueList get_host_list() const { return getValueList("host_list"); }

	//! Whether DR should be utilized for this render
 	//! [Default value] false
	bool set_on(bool val) { return setValue("on", val); }
	//! Whether DR should be utilized for this render
 	//! [Default value] false
	bool get_on() const { return getBool("on"); }
};

class SettingsDefaultDisplacement : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "SettingsDefaultDisplacement"; }

	//! [UI Guides] displayName=Override Max
 	//! [Default value] true
	bool set_override_on(bool val) { return setValue("override_on", val); }
	//! [UI Guides] displayName=Override Max
 	//! [Default value] true
	bool get_override_on() const { return getBool("override_on"); }

	//! Maximum edge length of the displaced sub-triangles.
 	//! [UI Guides] displayName=Edge length, minValue=0.0, maxValue=1000.0
 	//! [Default value] 4
	bool set_edgeLength(float val) { return setValue("edgeLength", val); }
	//! Maximum edge length of the displaced sub-triangles.
 	//! [UI Guides] displayName=Edge length, minValue=0.0, maxValue=1000.0
 	//! [Default value] 4
	float get_edgeLength() const { return getFloat("edgeLength"); }

	//! If true 'Edge length' is specified in pixels; otherwise 'Edge length' is in scene units.
 	//! [UI Guides] displayName=View dependent
 	//! [Default value] true
	bool set_viewDependent(bool val) { return setValue("viewDependent", val); }
	//! If true 'Edge length' is specified in pixels; otherwise 'Edge length' is in scene units.
 	//! [UI Guides] displayName=View dependent
 	//! [Default value] true
	bool get_viewDependent() const { return getBool("viewDependent"); }

	//! Maximum subdivisions for a triangle from the original undisplaced mesh.
 	//! [UI Guides] displayName=Max subdivs, minValue=1, maxValue=4096
 	//! [Default value] 256
	bool set_maxSubdivs(int val) { return setValue("maxSubdivs", val); }
	//! Maximum subdivisions for a triangle from the original undisplaced mesh.
 	//! [UI Guides] displayName=Max subdivs, minValue=1, maxValue=4096
 	//! [Default value] 256
	int get_maxSubdivs() const { return getInt("maxSubdivs"); }

	//! If true the displacement map will be presampled to determine the exact displacement bounds.
 	//! [UI Guides] displayName=Tight bounds
 	//! [Default value] true
	bool set_tightBounds(bool val) { return setValue("tightBounds", val); }
	//! If true the displacement map will be presampled to determine the exact displacement bounds.
 	//! [UI Guides] displayName=Tight bounds
 	//! [Default value] true
	bool get_tightBounds() const { return getBool("tightBounds"); }

	//! A global multiplier for the displacement amount.
 	//! [UI Guides] displayName=Amount, minValue=-100.0, maxValue=100.0
 	//! [Default value] 1
	bool set_amount(float val) { return setValue("amount", val); }
	//! A global multiplier for the displacement amount.
 	//! [UI Guides] displayName=Amount, minValue=-100.0, maxValue=100.0
 	//! [Default value] 1
	float get_amount() const { return getFloat("amount"); }

	//! [UI Guides] displayName=Relative
 	//! [Default value] false
	bool set_relative(bool val) { return setValue("relative", val); }
	//! [UI Guides] displayName=Relative
 	//! [Default value] false
	bool get_relative() const { return getBool("relative"); }
};

class SettingsEXR : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "SettingsEXR"; }

	//! Compression for OpenEXR output (0 - default, 1 - no compression, 2 - RLE, 3 - ZIPS, 4 - ZIP, 5 - PIZ, 6 - PXR24, 7 - B44, 8 - B44A, 9 - DWAA, 10 - DWAB)
 	//! [Default value] 3
	bool set_compression(int val) { return setValue("compression", val); }
	//! Compression for OpenEXR output (0 - default, 1 - no compression, 2 - RLE, 3 - ZIPS, 4 - ZIP, 5 - PIZ, 6 - PXR24, 7 - B44, 8 - B44A, 9 - DWAA, 10 - DWAB)
 	//! [Default value] 3
	int get_compression() const { return getInt("compression"); }

	//! Bits per channel (16 or 32)
 	//! [Default value] 16
	bool set_bits_per_channel(int val) { return setValue("bits_per_channel", val); }
	//! Bits per channel (16 or 32)
 	//! [Default value] 16
	int get_bits_per_channel() const { return getInt("bits_per_channel"); }

	//! Extra attributes to write in the header
 	bool set_extra_attributes(const char* str) { return setValue("extra_attributes", str); }
	//! Extra attributes to write in the header
 	bool set_extra_attributes(const std::string& str) { return setValue("extra_attributes", str); }
	//! Extra attributes to write in the header
 	std::string get_extra_attributes() const { return getString("extra_attributes"); }

	//! true to enable auto data window based on the alpha channel when writing scanline-based multichannel OpenEXR files
 	//! [Default value] false
	bool set_auto_data_window(bool val) { return setValue("auto_data_window", val); }
	//! true to enable auto data window based on the alpha channel when writing scanline-based multichannel OpenEXR files
 	//! [Default value] false
	bool get_auto_data_window() const { return getBool("auto_data_window"); }

	//! true to write integer elemnt ids when using Image Format exr
 	//! [Default value] false
	bool set_write_integer_ids(bool val) { return setValue("write_integer_ids", val); }
	//! true to write integer elemnt ids when using Image Format exr
 	//! [Default value] false
	bool get_write_integer_ids() const { return getBool("write_integer_ids"); }

	//! true to create multi-part exr file
 	//! [Default value] false
	bool set_multipart(bool val) { return setValue("multipart", val); }
	//! true to create multi-part exr file
 	//! [Default value] false
	bool get_multipart() const { return getBool("multipart"); }

	//! Deep alpha colors (0 - monochrome, 1 - RGB, 2 - monochrome+RGB)
 	//! [UI Guides] enum=0:Monochrome;1:RGB;2:Monochrome+RGB
 	//! [Default value] 0
	bool set_deep_alpha_colors(int val) { return setValue("deep_alpha_colors", val); }
	//! Deep alpha colors (0 - monochrome, 1 - RGB, 2 - monochrome+RGB)
 	//! [UI Guides] enum=0:Monochrome;1:RGB;2:Monochrome+RGB
 	//! [Default value] 0
	int get_deep_alpha_colors() const { return getInt("deep_alpha_colors"); }
};

class SettingsEnvironment : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "SettingsEnvironment"; }

	//! Environment color
 	//! [Default value] Color(0, 0, 0)
	bool set_bg_color(const Color& color) { return setValue("bg_color", color); }
	//! Environment color
 	//! [Default value] Color(0, 0, 0)
	Color get_bg_color() const { return getColor("bg_color"); }

	//! Environment map
 	bool set_bg_tex(const Plugin& texture) { return setValue("bg_tex", texture); }
	//! Environment map
 	bool set_bg_tex(const AColor& texture) { return setValue("bg_tex", texture); }
	//! Environment map
 	Value get_bg_tex() const { return getValue("bg_tex"); }

	//! Environment map multiplier
 	//! [Default value] 1
	bool set_bg_tex_mult(float val) { return setValue("bg_tex_mult", val); }
	//! Environment map multiplier
 	//! [Default value] 1
	float get_bg_tex_mult() const { return getFloat("bg_tex_mult"); }

	//! GI (skylight) color
 	//! [Default value] Color(0, 0, 0)
	bool set_gi_color(const Color& color) { return setValue("gi_color", color); }
	//! GI (skylight) color
 	//! [Default value] Color(0, 0, 0)
	Color get_gi_color() const { return getColor("gi_color"); }

	//! GI (skylight) map
 	bool set_gi_tex(const Plugin& texture) { return setValue("gi_tex", texture); }
	//! GI (skylight) map
 	bool set_gi_tex(const AColor& texture) { return setValue("gi_tex", texture); }
	//! GI (skylight) map
 	Value get_gi_tex() const { return getValue("gi_tex"); }

	//! GI (skylight) map multiplier
 	//! [Default value] 1
	bool set_gi_tex_mult(float val) { return setValue("gi_tex_mult", val); }
	//! GI (skylight) map multiplier
 	//! [Default value] 1
	float get_gi_tex_mult() const { return getFloat("gi_tex_mult"); }

	//! Reflection color
 	//! [Default value] Color(0, 0, 0)
	bool set_reflect_color(const Color& color) { return setValue("reflect_color", color); }
	//! Reflection color
 	//! [Default value] Color(0, 0, 0)
	Color get_reflect_color() const { return getColor("reflect_color"); }

	//! Reflection map
 	bool set_reflect_tex(const Plugin& texture) { return setValue("reflect_tex", texture); }
	//! Reflection map
 	bool set_reflect_tex(const AColor& texture) { return setValue("reflect_tex", texture); }
	//! Reflection map
 	Value get_reflect_tex() const { return getValue("reflect_tex"); }

	//! Reflection map multiplier
 	//! [Default value] 1
	bool set_reflect_tex_mult(float val) { return setValue("reflect_tex_mult", val); }
	//! Reflection map multiplier
 	//! [Default value] 1
	float get_reflect_tex_mult() const { return getFloat("reflect_tex_mult"); }

	//! Refraction color
 	//! [Default value] Color(0, 0, 0)
	bool set_refract_color(const Color& color) { return setValue("refract_color", color); }
	//! Refraction color
 	//! [Default value] Color(0, 0, 0)
	Color get_refract_color() const { return getColor("refract_color"); }

	//! Refraction map
 	bool set_refract_tex(const Plugin& texture) { return setValue("refract_tex", texture); }
	//! Refraction map
 	bool set_refract_tex(const AColor& texture) { return setValue("refract_tex", texture); }
	//! Refraction map
 	Value get_refract_tex() const { return getValue("refract_tex"); }

	//! Refraction map multiplier
 	//! [Default value] 1
	bool set_refract_tex_mult(float val) { return setValue("refract_tex_mult", val); }
	//! Refraction map multiplier
 	//! [Default value] 1
	float get_refract_tex_mult() const { return getFloat("refract_tex_mult"); }

	//! Secondary matte color
 	//! [Default value] Color(0, 0, 0)
	bool set_secondary_matte_color(const Color& color) { return setValue("secondary_matte_color", color); }
	//! Secondary matte color
 	//! [Default value] Color(0, 0, 0)
	Color get_secondary_matte_color() const { return getColor("secondary_matte_color"); }

	//! Secondary matte texture
 	bool set_secondary_matte_tex(const Plugin& texture) { return setValue("secondary_matte_tex", texture); }
	//! Secondary matte texture
 	bool set_secondary_matte_tex(const AColor& texture) { return setValue("secondary_matte_tex", texture); }
	//! Secondary matte texture
 	Value get_secondary_matte_tex() const { return getValue("secondary_matte_tex"); }

	//! Secondary matte texture map multiplier
 	//! [Default value] 1
	bool set_secondary_matte_tex_mult(float val) { return setValue("secondary_matte_tex_mult", val); }
	//! Secondary matte texture map multiplier
 	//! [Default value] 1
	float get_secondary_matte_tex_mult() const { return getFloat("secondary_matte_tex_mult"); }

	//! A list of environment volumes for the scene
 	bool set_environment_volume(const ValueList& pluginList) { return setValue("environment_volume", pluginList); }
	//! A list of environment volumes for the scene
 	ValueList get_environment_volume() const { return getValueList("environment_volume"); }

	//! Used for implementing image planes
 	//! [Default value] 0
	bool set_num_environment_objects(int val) { return setValue("num_environment_objects", val); }
	//! Used for implementing image planes
 	//! [Default value] 0
	int get_num_environment_objects() const { return getInt("num_environment_objects"); }

	//! A global light level multiplier for all lights
 	//! [Default value] Color(1, 1, 1)
	bool set_global_light_level(const Color& color) { return setValue("global_light_level", color); }
	//! A global light level multiplier for all lights
 	//! [Default value] Color(1, 1, 1)
	Color get_global_light_level() const { return getColor("global_light_level"); }

	//! Whether to set the background color/map
 	//! [Default value] true
	bool set_use_bg(bool val) { return setValue("use_bg", val); }
	//! Whether to set the background color/map
 	//! [Default value] true
	bool get_use_bg() const { return getBool("use_bg"); }

	//! Whether to set the GI color/map
 	//! [Default value] true
	bool set_use_gi(bool val) { return setValue("use_gi", val); }
	//! Whether to set the GI color/map
 	//! [Default value] true
	bool get_use_gi() const { return getBool("use_gi"); }

	//! Whether to set the reflect color/map
 	//! [Default value] true
	bool set_use_reflect(bool val) { return setValue("use_reflect", val); }
	//! Whether to set the reflect color/map
 	//! [Default value] true
	bool get_use_reflect() const { return getBool("use_reflect"); }

	//! Whether to set the refract color/map
 	//! [Default value] true
	bool set_use_refract(bool val) { return setValue("use_refract", val); }
	//! Whether to set the refract color/map
 	//! [Default value] true
	bool get_use_refract() const { return getBool("use_refract"); }

	//! Whether to use the secondary matte color/map
 	//! [Default value] true
	bool set_use_secondary_matte(bool val) { return setValue("use_secondary_matte", val); }
	//! Whether to use the secondary matte color/map
 	//! [Default value] true
	bool get_use_secondary_matte() const { return getBool("use_secondary_matte"); }
};

class SettingsGI : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "SettingsGI"; }

	//! [UI Guides] displayName=On
 	//! [Default value] false
	bool set_on(bool val) { return setValue("on", val); }
	//! [UI Guides] displayName=On
 	//! [Default value] false
	bool get_on() const { return getBool("on"); }

	//! [UI Guides] enableIf: ?on!=0, displayName=Refractive Caustics
 	//! [Default value] true
	bool set_refract_caustics(bool val) { return setValue("refract_caustics", val); }
	//! [UI Guides] enableIf: ?on!=0, displayName=Refractive Caustics
 	//! [Default value] true
	bool get_refract_caustics() const { return getBool("refract_caustics"); }

	//! [UI Guides] displayName=Reflective Caustics
 	//! [Default value] false
	bool set_reflect_caustics(bool val) { return setValue("reflect_caustics", val); }
	//! [UI Guides] displayName=Reflective Caustics
 	//! [Default value] false
	bool get_reflect_caustics() const { return getBool("reflect_caustics"); }

	//! [UI Guides] enableIf: ?on!=0, displayName=Saturation, minValue=0.0, maxValue=1e6
 	//! [Default value] 1
	bool set_saturation(float val) { return setValue("saturation", val); }
	//! [UI Guides] enableIf: ?on!=0, displayName=Saturation, minValue=0.0, maxValue=1e6
 	//! [Default value] 1
	float get_saturation() const { return getFloat("saturation"); }

	//! [UI Guides] enableIf: ?on!=0, displayName=Contrast, minValue=0.0, maxValue=1e6
 	//! [Default value] 1
	bool set_contrast(float val) { return setValue("contrast", val); }
	//! [UI Guides] enableIf: ?on!=0, displayName=Contrast, minValue=0.0, maxValue=1e6
 	//! [Default value] 1
	float get_contrast() const { return getFloat("contrast"); }

	//! [UI Guides] enableIf: ?on!=0, displayName=Contrast Base, minValue=0.0, maxValue=1e6
 	//! [Default value] 0.5
	bool set_contrast_base(float val) { return setValue("contrast_base", val); }
	//! [UI Guides] enableIf: ?on!=0, displayName=Contrast Base, minValue=0.0, maxValue=1e6
 	//! [Default value] 0.5
	float get_contrast_base() const { return getFloat("contrast_base"); }

	//! [UI Guides] enum=0:Irradiance Map; 1:Photon Map; 2:Brute force; 3:Light Cache;, enableIf: ?on!=0, displayName=Primary Engine
 	//! [Default value] 0
	bool set_primary_engine(int val) { return setValue("primary_engine", val); }
	//! [UI Guides] enum=0:Irradiance Map; 1:Photon Map; 2:Brute force; 3:Light Cache;, enableIf: ?on!=0, displayName=Primary Engine
 	//! [Default value] 0
	int get_primary_engine() const { return getInt("primary_engine"); }

	//! [UI Guides] enableIf: ?on!=0, displayName=Primary Multiplier, minValue=0.0, maxValue=1e6, spinStep=0.05
 	//! [Default value] 1
	bool set_primary_multiplier(float val) { return setValue("primary_multiplier", val); }
	//! [UI Guides] enableIf: ?on!=0, displayName=Primary Multiplier, minValue=0.0, maxValue=1e6, spinStep=0.05
 	//! [Default value] 1
	float get_primary_multiplier() const { return getFloat("primary_multiplier"); }

	//! [UI Guides] enum=0:None; 1:Photon Map; 2:Brute force; 3:Light Cache;, enableIf: ?on!=0, displayName=Secondary Engine
 	//! [Default value] 2
	bool set_secondary_engine(int val) { return setValue("secondary_engine", val); }
	//! [UI Guides] enum=0:None; 1:Photon Map; 2:Brute force; 3:Light Cache;, enableIf: ?on!=0, displayName=Secondary Engine
 	//! [Default value] 2
	int get_secondary_engine() const { return getInt("secondary_engine"); }

	//! [UI Guides] enableIf: ?on!=0, ?secondary_engine!=0, displayName=Secondary Multiplier, minValue=0.0, maxValue=1.0, spinStep=0.05
 	//! [Default value] 1
	bool set_secondary_multiplier(float val) { return setValue("secondary_multiplier", val); }
	//! [UI Guides] enableIf: ?on!=0, ?secondary_engine!=0, displayName=Secondary Multiplier, minValue=0.0, maxValue=1.0, spinStep=0.05
 	//! [Default value] 1
	float get_secondary_multiplier() const { return getFloat("secondary_multiplier"); }

	//! [UI Guides] enableIf: ?on!=0, displayName=Ray Distance On
 	//! [Default value] false
	bool set_ray_distance_on(bool val) { return setValue("ray_distance_on", val); }
	//! [UI Guides] enableIf: ?on!=0, displayName=Ray Distance On
 	//! [Default value] false
	bool get_ray_distance_on() const { return getBool("ray_distance_on"); }

	//! [UI Guides] enableIf: ?on!=0, ?ray_distance_on!=0, displayName=Ray Distance, quantityType=distance, minValue=0.0, maxValue=1e5, spinStep=1.0
 	//! [Default value] 100000
	bool set_ray_distance(float val) { return setValue("ray_distance", val); }
	//! [UI Guides] enableIf: ?on!=0, ?ray_distance_on!=0, displayName=Ray Distance, quantityType=distance, minValue=0.0, maxValue=1e5, spinStep=1.0
 	//! [Default value] 100000
	float get_ray_distance() const { return getFloat("ray_distance"); }

	//! [UI Guides] enableIf: ?on!=0, displayName=Ambient Occlusion On
 	//! [Default value] false
	bool set_ao_on(bool val) { return setValue("ao_on", val); }
	//! [UI Guides] enableIf: ?on!=0, displayName=Ambient Occlusion On
 	//! [Default value] false
	bool get_ao_on() const { return getBool("ao_on"); }

	//! [UI Guides] enableIf: ?on!=0, ?ao_on!=0, displayName=AO Multiplier, minValue=0.0, maxValue=100.0
 	//! [Default value] 0.8
	bool set_ao_amount(float val) { return setValue("ao_amount", val); }
	//! [UI Guides] enableIf: ?on!=0, ?ao_on!=0, displayName=AO Multiplier, minValue=0.0, maxValue=100.0
 	//! [Default value] 0.8
	float get_ao_amount() const { return getFloat("ao_amount"); }

	//! [UI Guides] enableIf: ?on!=0, ?ao_on!=0, displayName=AO Radius, quantityType=distance, minValue=0.0, maxValue=1e8, spinStep=0.1
 	//! [Default value] 10
	bool set_ao_radius(float val) { return setValue("ao_radius", val); }
	//! [UI Guides] enableIf: ?on!=0, ?ao_on!=0, displayName=AO Radius, quantityType=distance, minValue=0.0, maxValue=1e8, spinStep=0.1
 	//! [Default value] 10
	float get_ao_radius() const { return getFloat("ao_radius"); }

	//! [UI Guides] enableIf: ?on!=0, ?ao_on!=0, displayName=AO Subdivs, minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	bool set_ao_subdivs(int val) { return setValue("ao_subdivs", val); }
	//! [UI Guides] enableIf: ?on!=0, ?ao_on!=0, displayName=AO Subdivs, minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	int get_ao_subdivs() const { return getInt("ao_subdivs"); }
};

class SettingsHair : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "SettingsHair"; }

	//! Minimum hair width in pixels, for plugins that support it and do not have that option overridden
 	//! [Default value] 0
	bool set_min_hair_width(float val) { return setValue("min_hair_width", val); }
	//! Minimum hair width in pixels, for plugins that support it and do not have that option overridden
 	//! [Default value] 0
	float get_min_hair_width() const { return getFloat("min_hair_width"); }
};

class SettingsImageFilter : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "SettingsImageFilter"; }

	//! Enable/disable image filter
 	//! [Default value] false
	bool set_on(bool val) { return setValue("on", val); }
	//! Enable/disable image filter
 	//! [Default value] false
	bool get_on() const { return getBool("on"); }

	//! 0 - Sinc, 1 - Lanczos, 2 - Catmull Rom, 3 - Triangle, 4 - Box, 5- Area
 	//! [Default value] 0
	bool set_type(int val) { return setValue("type", val); }
	//! 0 - Sinc, 1 - Lanczos, 2 - Catmull Rom, 3 - Triangle, 4 - Box, 5- Area
 	//! [Default value] 0
	int get_type() const { return getInt("type"); }

	//! Image filter size (where applicable)
 	//! [Default value] 1
	bool set_size(float val) { return setValue("size", val); }
	//! Image filter size (where applicable)
 	//! [Default value] 1
	float get_size() const { return getFloat("size"); }
};

class SettingsImageSampler : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "SettingsImageSampler"; }

	//! The type of the image sampler (0 - fixed rate, 1 - adaptive, 2 - adaptive subdivision, 3 - progressive)
 	//! [UI Guides] enum=0:Fixed rate; 1:Adaptive; 2:Adaptive subdivision; 3:Progressive, displayName=Sampler Type
 	//! [Default value] 0
	bool set_type(int val) { return setValue("type", val); }
	//! The type of the image sampler (0 - fixed rate, 1 - adaptive, 2 - adaptive subdivision, 3 - progressive)
 	//! [UI Guides] enum=0:Fixed rate; 1:Adaptive; 2:Adaptive subdivision; 3:Progressive, displayName=Sampler Type
 	//! [Default value] 0
	int get_type() const { return getInt("type"); }

	//! Control the number of rays shot for AA versus rays for other effects like glossy reflections, GI, area shadows etc. Higher values mean that less time will be spent on AA, and more effort will be put in the sampling of shading effects.
 	//! [UI Guides] displayName=Min shading rate, minValue=1, maxValue=10000
 	//! [Default value] 0
	bool set_min_shade_rate(int val) { return setValue("min_shade_rate", val); }
	//! Control the number of rays shot for AA versus rays for other effects like glossy reflections, GI, area shadows etc. Higher values mean that less time will be spent on AA, and more effort will be put in the sampling of shading effects.
 	//! [UI Guides] displayName=Min shading rate, minValue=1, maxValue=10000
 	//! [Default value] 0
	int get_min_shade_rate() const { return getInt("min_shade_rate"); }

	//! Subdivs value for the fixed sampler
 	//! [UI Guides] enableIf: ?type=0, displayName=Subdivs, minValue=1, maxValue=1000
 	//! [Default value] 1
	bool set_fixed_subdivs(int val) { return setValue("fixed_subdivs", val); }
	//! Subdivs value for the fixed sampler
 	//! [UI Guides] enableIf: ?type=0, displayName=Subdivs, minValue=1, maxValue=1000
 	//! [Default value] 1
	int get_fixed_subdivs() const { return getInt("fixed_subdivs"); }

	//! True to enable per-pixel filtering for the fixed sampler
 	//! [UI Guides] enableIf: ?type=0, displayName=Per-pixel filtering
 	//! [Default value] false
	bool set_fixed_per_pixel_filtering(bool val) { return setValue("fixed_per_pixel_filtering", val); }
	//! True to enable per-pixel filtering for the fixed sampler
 	//! [UI Guides] enableIf: ?type=0, displayName=Per-pixel filtering
 	//! [Default value] false
	bool get_fixed_per_pixel_filtering() const { return getBool("fixed_per_pixel_filtering"); }

	//! Min. subdivs value for the adaptive DMC image sampler
 	//! [UI Guides] enableIf: ?type=1, displayName=Min subdivs, minValue=1, maxValue=1000
 	//! [Default value] 1
	bool set_dmc_minSubdivs(int val) { return setValue("dmc_minSubdivs", val); }
	//! Min. subdivs value for the adaptive DMC image sampler
 	//! [UI Guides] enableIf: ?type=1, displayName=Min subdivs, minValue=1, maxValue=1000
 	//! [Default value] 1
	int get_dmc_minSubdivs() const { return getInt("dmc_minSubdivs"); }

	//! Max. subdivs value for the adaptive DMC image sampler
 	//! [UI Guides] enableIf: ?type=1, displayName=Max subdivs, minValue=1, maxValue=1000
 	//! [Default value] 4
	bool set_dmc_maxSubdivs(int val) { return setValue("dmc_maxSubdivs", val); }
	//! Max. subdivs value for the adaptive DMC image sampler
 	//! [UI Guides] enableIf: ?type=1, displayName=Max subdivs, minValue=1, maxValue=1000
 	//! [Default value] 4
	int get_dmc_maxSubdivs() const { return getInt("dmc_maxSubdivs"); }

	//! Color threshold for the adaptive DMC image sampler
 	//! [UI Guides] enableIf: ?type=1, displayName=Threshold, minValue=0.0, maxValue=1000.0
 	//! [Default value] 0.01
	bool set_dmc_threshold(float val) { return setValue("dmc_threshold", val); }
	//! Color threshold for the adaptive DMC image sampler
 	//! [UI Guides] enableIf: ?type=1, displayName=Threshold, minValue=0.0, maxValue=1000.0
 	//! [Default value] 0.01
	float get_dmc_threshold() const { return getFloat("dmc_threshold"); }

	//! Switches between legacy and new adaptive sampling
 	//! [UI Guides] enableIf: ?type=1, enum=0:Legacy; 1:Default, displayName=Adaptive method
 	//! [Default value] 0
	bool set_dmc_adaptive_method(int val) { return setValue("dmc_adaptive_method", val); }
	//! Switches between legacy and new adaptive sampling
 	//! [UI Guides] enableIf: ?type=1, enum=0:Legacy; 1:Default, displayName=Adaptive method
 	//! [Default value] 0
	int get_dmc_adaptive_method() const { return getInt("dmc_adaptive_method"); }

	//! True to enable per-pixel filtering for the adaptive DMC image sampler
 	//! [UI Guides] enableIf: ?type=1, displayName=Per-pixel filtering
 	//! [Default value] false
	bool set_dmc_per_pixel_filtering(bool val) { return setValue("dmc_per_pixel_filtering", val); }
	//! True to enable per-pixel filtering for the adaptive DMC image sampler
 	//! [UI Guides] enableIf: ?type=1, displayName=Per-pixel filtering
 	//! [Default value] false
	bool get_dmc_per_pixel_filtering() const { return getBool("dmc_per_pixel_filtering"); }

	//! Determines the minimum sampling rate for the adaptive subdivision sampler. A value of 0 means that samples will be one pixel apart. Positive values will put samples inside the pixels, while negative values will space the samples over several pixels.
 	//! [UI Guides] enableIf: ?type=2, displayName=Min rate, minValue=-3, maxValue=8
 	//! [Default value] -1
	bool set_subdivision_minRate(int val) { return setValue("subdivision_minRate", val); }
	//! Determines the minimum sampling rate for the adaptive subdivision sampler. A value of 0 means that samples will be one pixel apart. Positive values will put samples inside the pixels, while negative values will space the samples over several pixels.
 	//! [UI Guides] enableIf: ?type=2, displayName=Min rate, minValue=-3, maxValue=8
 	//! [Default value] -1
	int get_subdivision_minRate() const { return getInt("subdivision_minRate"); }

	//! Determines the maximum sampling rate for the adaptive subdivision sampler. A value of 0 means that samples will be one pixel apart. Positive values will put samples inside the pixels, while negative values will space the samples over several pixels.
 	//! [UI Guides] enableIf: ?type=2, displayName=Max rate, minValue=-3, maxValue=8
 	//! [Default value] 2
	bool set_subdivision_maxRate(int val) { return setValue("subdivision_maxRate", val); }
	//! Determines the maximum sampling rate for the adaptive subdivision sampler. A value of 0 means that samples will be one pixel apart. Positive values will put samples inside the pixels, while negative values will space the samples over several pixels.
 	//! [UI Guides] enableIf: ?type=2, displayName=Max rate, minValue=-3, maxValue=8
 	//! [Default value] 2
	int get_subdivision_maxRate() const { return getInt("subdivision_maxRate"); }

	//! If this is true, samples will be displaced randomly, for better AA of nearly horizontal or vertical edges.
 	//! [UI Guides] enableIf: ?type=2, displayName=Jitter
 	//! [Default value] true
	bool set_subdivision_jitter(bool val) { return setValue("subdivision_jitter", val); }
	//! If this is true, samples will be displaced randomly, for better AA of nearly horizontal or vertical edges.
 	//! [UI Guides] enableIf: ?type=2, displayName=Jitter
 	//! [Default value] true
	bool get_subdivision_jitter() const { return getBool("subdivision_jitter"); }

	//! [UI Guides] enableIf: ?type=2, displayName=Threshold, minValue=0.0, maxValue=1000.0
 	//! [Default value] 0.15
	bool set_subdivision_threshold(float val) { return setValue("subdivision_threshold", val); }
	//! [UI Guides] enableIf: ?type=2, displayName=Threshold, minValue=0.0, maxValue=1000.0
 	//! [Default value] 0.15
	float get_subdivision_threshold() const { return getFloat("subdivision_threshold"); }

	//! [UI Guides] enableIf: ?type=2, displayName=Edges
 	//! [Default value] false
	bool set_subdivision_edges(bool val) { return setValue("subdivision_edges", val); }
	//! [UI Guides] enableIf: ?type=2, displayName=Edges
 	//! [Default value] false
	bool get_subdivision_edges() const { return getBool("subdivision_edges"); }

	//! [UI Guides] enableIf: ?type=2, displayName=Normals
 	//! [Default value] false
	bool set_subdivision_normals(bool val) { return setValue("subdivision_normals", val); }
	//! [UI Guides] enableIf: ?type=2, displayName=Normals
 	//! [Default value] false
	bool get_subdivision_normals() const { return getBool("subdivision_normals"); }

	//! [UI Guides] enableIf: ?type=2, displayName=Normals threshold, minValue=0.0, maxValue=1000.0
 	//! [Default value] 0.1
	bool set_subdivision_normals_threshold(float val) { return setValue("subdivision_normals_threshold", val); }
	//! [UI Guides] enableIf: ?type=2, displayName=Normals threshold, minValue=0.0, maxValue=1000.0
 	//! [Default value] 0.1
	float get_subdivision_normals_threshold() const { return getFloat("subdivision_normals_threshold"); }

	//! Min. subdivs value for the progressive image sampler
 	//! [UI Guides] enableIf: ?type=3, displayName=Min subdivs, minValue=0, maxValue=1000
 	//! [Default value] 1
	bool set_progressive_minSubdivs(int val) { return setValue("progressive_minSubdivs", val); }
	//! Min. subdivs value for the progressive image sampler
 	//! [UI Guides] enableIf: ?type=3, displayName=Min subdivs, minValue=0, maxValue=1000
 	//! [Default value] 1
	int get_progressive_minSubdivs() const { return getInt("progressive_minSubdivs"); }

	//! Max. subdivs value for the progressive image sampler
 	//! [UI Guides] enableIf: ?type=3, displayName=Max subdivs, minValue=0, maxValue=1000000
 	//! [Default value] 4
	bool set_progressive_maxSubdivs(int val) { return setValue("progressive_maxSubdivs", val); }
	//! Max. subdivs value for the progressive image sampler
 	//! [UI Guides] enableIf: ?type=3, displayName=Max subdivs, minValue=0, maxValue=1000000
 	//! [Default value] 4
	int get_progressive_maxSubdivs() const { return getInt("progressive_maxSubdivs"); }

	//! Noise threshold for the progressive image sampler
 	//! [UI Guides] enableIf: ?type=3, displayName=Noise threshold, minValue=0.0, maxValue=1000.0
 	//! [Default value] 0.01
	bool set_progressive_threshold(float val) { return setValue("progressive_threshold", val); }
	//! Noise threshold for the progressive image sampler
 	//! [UI Guides] enableIf: ?type=3, displayName=Noise threshold, minValue=0.0, maxValue=1000.0
 	//! [Default value] 0.01
	float get_progressive_threshold() const { return getFloat("progressive_threshold"); }

	//! Max. render time for the progressive image sampler
 	//! [UI Guides] enableIf: ?type=3, displayName=Max. render time in min, minValue=0.0, maxValue=1500.0
 	//! [Default value] 0
	bool set_progressive_maxTime(float val) { return setValue("progressive_maxTime", val); }
	//! Max. render time for the progressive image sampler
 	//! [UI Guides] enableIf: ?type=3, displayName=Max. render time in min, minValue=0.0, maxValue=1500.0
 	//! [Default value] 0
	float get_progressive_maxTime() const { return getFloat("progressive_maxTime"); }

	//! Bundle size for the progressive image sampler
 	//! [UI Guides] enableIf: ?type=3, displayName=Ray bundle size, minValue=1, maxValue=2048
 	//! [Default value] 64
	bool set_progressive_bundleSize(int val) { return setValue("progressive_bundleSize", val); }
	//! Bundle size for the progressive image sampler
 	//! [UI Guides] enableIf: ?type=3, displayName=Ray bundle size, minValue=1, maxValue=2048
 	//! [Default value] 64
	int get_progressive_bundleSize() const { return getInt("progressive_bundleSize"); }

	//! If true, the AA mask will be rendered
 	//! [UI Guides] enableIf: ?type=3, displayName=Show AA mask
 	//! [Default value] false
	bool set_progressive_showMask(bool val) { return setValue("progressive_showMask", val); }
	//! If true, the AA mask will be rendered
 	//! [UI Guides] enableIf: ?type=3, displayName=Show AA mask
 	//! [Default value] false
	bool get_progressive_showMask() const { return getBool("progressive_showMask"); }

	//! Progressive noise threshold active pixels percent at which the threshold is reduced.
 	//! [UI Guides] enableIf: ?type=3, displayName=Progressive noise threshold, minValue=0, maxValue=100
 	//! [Default value] 80
	bool set_progressive_progNoiseThreshold(int val) { return setValue("progressive_progNoiseThreshold", val); }
	//! Progressive noise threshold active pixels percent at which the threshold is reduced.
 	//! [UI Guides] enableIf: ?type=3, displayName=Progressive noise threshold, minValue=0, maxValue=100
 	//! [Default value] 80
	int get_progressive_progNoiseThreshold() const { return getInt("progressive_progNoiseThreshold"); }

	//! Roughly, the fraction of render time which post effects calculation will take.
 	//! [Default value] 10
	bool set_progressive_effectsUpdate(int val) { return setValue("progressive_effectsUpdate", val); }
	//! Roughly, the fraction of render time which post effects calculation will take.
 	//! [Default value] 10
	int get_progressive_effectsUpdate() const { return getInt("progressive_effectsUpdate"); }

	//! Sets the mode for the render mask. The mode controls which render_mask_* parameter will be used to generate the mask from (0 - Disable, 1 - Texture, 2 - Objects, 3 - ObjectIDs)
 	//! [UI Guides] enum=0:Disabled;1:Texture;2:Objects;3:ObjectIDs
 	//! [Default value] 0
	bool set_render_mask_mode(int val) { return setValue("render_mask_mode", val); }
	//! Sets the mode for the render mask. The mode controls which render_mask_* parameter will be used to generate the mask from (0 - Disable, 1 - Texture, 2 - Objects, 3 - ObjectIDs)
 	//! [UI Guides] enum=0:Disabled;1:Texture;2:Objects;3:ObjectIDs
 	//! [Default value] 0
	int get_render_mask_mode() const { return getInt("render_mask_mode"); }

	//! Texture used for render mask when render_mask_mode=Texture.This accepts float textures, where a value of <=1e-6, means that V-Ray won't render in this pixel
 	bool set_render_mask_texture(const Plugin& texturefloat) { return setValue("render_mask_texture", texturefloat); }
	//! Texture used for render mask when render_mask_mode=Texture.This accepts float textures, where a value of <=1e-6, means that V-Ray won't render in this pixel
 	bool set_render_mask_texture(float texturefloat) { return setValue("render_mask_texture", texturefloat); }
	//! Texture used for render mask when render_mask_mode=Texture.This accepts float textures, where a value of <=1e-6, means that V-Ray won't render in this pixel
 	Value get_render_mask_texture() const { return getValue("render_mask_texture"); }

	//! List of Node/GeomGen plugins which will be used for render mask when render_mask_mode=Objects
 	bool set_render_mask_objects(const ValueList& pluginList) { return setValue("render_mask_objects", pluginList); }
	//! List of Node/GeomGen plugins which will be used for render mask when render_mask_mode=Objects
 	ValueList get_render_mask_objects() const { return getValueList("render_mask_objects"); }

	//! List of integers object ids, which will be used for render mask when render_mask_mode=ObjectIDs
 	//! [Default value] 0
	bool set_render_mask_object_ids(const IntList& intList) { return setValue("render_mask_object_ids", intList); }
	//! List of integers object ids, which will be used for render mask when render_mask_mode=ObjectIDs
 	//! [Default value] 0
	bool set_render_mask_object_ids(const int* ints, size_t count) { return setArray("render_mask_object_ids", ints, count); }
	//! List of integers object ids, which will be used for render mask when render_mask_mode=ObjectIDs
 	//! [Default value] 0
	template<size_t count> bool set_render_mask_object_ids(const int (&ints)[count]) { return setArray("render_mask_object_ids", ints, count); }
	//! List of integers object ids, which will be used for render mask when render_mask_mode=ObjectIDs
 	//! [Default value] 0
	IntList get_render_mask_object_ids() const { return getIntList("render_mask_object_ids"); }

	//! Render mask clearing mode. Affects only IPR rendering. If enabled, the parts that are not rendered will be blank, rather than keeping the old image.
 	//! [UI Guides] enum=0:Don't clear;1:Clear
 	//! [Default value] 1
	bool set_render_mask_clear(int val) { return setValue("render_mask_clear", val); }
	//! Render mask clearing mode. Affects only IPR rendering. If enabled, the parts that are not rendered will be blank, rather than keeping the old image.
 	//! [UI Guides] enum=0:Don't clear;1:Clear
 	//! [Default value] 1
	int get_render_mask_clear() const { return getInt("render_mask_clear"); }
};

class SettingsIrradianceMap : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "SettingsIrradianceMap"; }

	//! [UI Guides] displayName=Min rate, minValue=-100, maxValue=100
 	//! [Default value] -3
	bool set_min_rate(int val) { return setValue("min_rate", val); }
	//! [UI Guides] displayName=Min rate, minValue=-100, maxValue=100
 	//! [Default value] -3
	int get_min_rate() const { return getInt("min_rate"); }

	//! [UI Guides] displayName=Max rate, minValue=-100, maxValue=100
 	//! [Default value] 0
	bool set_max_rate(int val) { return setValue("max_rate", val); }
	//! [UI Guides] displayName=Max rate, minValue=-100, maxValue=100
 	//! [Default value] 0
	int get_max_rate() const { return getInt("max_rate"); }

	//! Hemispheric subdivs (determines the number of samples/rays that will be used)
 	//! [UI Guides] displayName=Subdivs, minValue=1, maxValue=1000
 	//! [Default value] 50
	bool set_subdivs(int val) { return setValue("subdivs", val); }
	//! Hemispheric subdivs (determines the number of samples/rays that will be used)
 	//! [UI Guides] displayName=Subdivs, minValue=1, maxValue=1000
 	//! [Default value] 50
	int get_subdivs() const { return getInt("subdivs"); }

	//! Interpolation samples
 	//! [UI Guides] displayName=Interp. samples, minValue=1, maxValue=10000
 	//! [Default value] 20
	bool set_interp_samples(int val) { return setValue("interp_samples", val); }
	//! Interpolation samples
 	//! [UI Guides] displayName=Interp. samples, minValue=1, maxValue=10000
 	//! [Default value] 20
	int get_interp_samples() const { return getInt("interp_samples"); }

	//! Samples looked up during the prepass phase
 	//! [UI Guides] displayName=Calc. interp. samples, minValue=1, maxValue=1000
 	//! [Default value] 15
	bool set_calc_interp_samples(int val) { return setValue("calc_interp_samples", val); }
	//! Samples looked up during the prepass phase
 	//! [UI Guides] displayName=Calc. interp. samples, minValue=1, maxValue=1000
 	//! [Default value] 15
	int get_calc_interp_samples() const { return getInt("calc_interp_samples"); }

	//! Number of frames to load for the animation irradiance map mode (0 is just the current frame, 1 is one frame before and after etc).
 	//! [UI Guides] displayName=Interp. frames, minValue=0
 	//! [Default value] 2
	bool set_interp_frames(int val) { return setValue("interp_frames", val); }
	//! Number of frames to load for the animation irradiance map mode (0 is just the current frame, 1 is one frame before and after etc).
 	//! [UI Guides] displayName=Interp. frames, minValue=0
 	//! [Default value] 2
	int get_interp_frames() const { return getInt("interp_frames"); }

	//! Sensitivity to changes in GI intensity
 	//! [UI Guides] displayName=Color threshold, minValue=0.0
 	//! [Default value] 0.3
	bool set_color_threshold(float val) { return setValue("color_threshold", val); }
	//! Sensitivity to changes in GI intensity
 	//! [UI Guides] displayName=Color threshold, minValue=0.0
 	//! [Default value] 0.3
	float get_color_threshold() const { return getFloat("color_threshold"); }

	//! Sensitivity to changes in surface normals
 	//! [UI Guides] displayName=Normal threshold, minValue=0.0
 	//! [Default value] 0.1
	bool set_normal_threshold(float val) { return setValue("normal_threshold", val); }
	//! Sensitivity to changes in surface normals
 	//! [UI Guides] displayName=Normal threshold, minValue=0.0
 	//! [Default value] 0.1
	float get_normal_threshold() const { return getFloat("normal_threshold"); }

	//! Sensitivity to object proximity
 	//! [UI Guides] displayName=Distance threshold, minValue=0.0
 	//! [Default value] 0.1
	bool set_distance_threshold(float val) { return setValue("distance_threshold", val); }
	//! Sensitivity to object proximity
 	//! [UI Guides] displayName=Distance threshold, minValue=0.0
 	//! [Default value] 0.1
	float get_distance_threshold() const { return getFloat("distance_threshold"); }

	//! True if additional DMC sampling should be used to enhance details.
 	//! [UI Guides] displayName=Detail enhancement
 	//! [Default value] false
	bool set_detail_enhancement(bool val) { return setValue("detail_enhancement", val); }
	//! True if additional DMC sampling should be used to enhance details.
 	//! [UI Guides] displayName=Detail enhancement
 	//! [Default value] false
	bool get_detail_enhancement() const { return getBool("detail_enhancement"); }

	//! Radius for the detail sampling in pixels.
 	//! [UI Guides] displayName=Detail radius [px];enableIf: ?detail_enhancement=1, minValue=0.0, maxValue=1e9
 	//! [Default value] 60
	bool set_detail_radius(float val) { return setValue("detail_radius", val); }
	//! Radius for the detail sampling in pixels.
 	//! [UI Guides] displayName=Detail radius [px];enableIf: ?detail_enhancement=1, minValue=0.0, maxValue=1e9
 	//! [Default value] 60
	float get_detail_radius() const { return getFloat("detail_radius"); }

	//! A multiplier for the subdivs when doing detailed sampling.
 	//! [UI Guides] displayName=Detail subdivs mult;enableIf: ?detail_enhancement=1, minValue=0.0, maxValue=1e9
 	//! [Default value] 0.3
	bool set_detail_subdivs_mult(float val) { return setValue("detail_subdivs_mult", val); }
	//! A multiplier for the subdivs when doing detailed sampling.
 	//! [UI Guides] displayName=Detail subdivs mult;enableIf: ?detail_enhancement=1, minValue=0.0, maxValue=1e9
 	//! [Default value] 0.3
	float get_detail_subdivs_mult() const { return getFloat("detail_subdivs_mult"); }

	//! The scale mode for the detail enhancement.
 	//! [UI Guides] displayName=Detail scale;enableIf: ?detail_enhancement=1;enum=0:Screen; 1:World
 	//! [Default value] 0
	bool set_detail_scale(int val) { return setValue("detail_scale", val); }
	//! The scale mode for the detail enhancement.
 	//! [UI Guides] displayName=Detail scale;enableIf: ?detail_enhancement=1;enum=0:Screen; 1:World
 	//! [Default value] 0
	int get_detail_scale() const { return getInt("detail_scale"); }

	//! If true, prepass samples will be randomly displaced
 	//! [UI Guides] displayName=Randomize samples
 	//! [Default value] true
	bool set_randomize_samples(bool val) { return setValue("randomize_samples", val); }
	//! If true, prepass samples will be randomly displaced
 	//! [UI Guides] displayName=Randomize samples
 	//! [Default value] true
	bool get_randomize_samples() const { return getBool("randomize_samples"); }

	//! [UI Guides] enum=0:Weighted average; 1:Least-squares fit; 2:Local Delaunay triangulation; 3:Least-squares with Voronoi weights, displayName=Interpolation mode
 	//! [Default value] 1
	bool set_interpolation_mode(int val) { return setValue("interpolation_mode", val); }
	//! [UI Guides] enum=0:Weighted average; 1:Least-squares fit; 2:Local Delaunay triangulation; 3:Least-squares with Voronoi weights, displayName=Interpolation mode
 	//! [Default value] 1
	int get_interpolation_mode() const { return getInt("interpolation_mode"); }

	//! Type of sample look-up
 	//! [UI Guides] enum=0:Nearest draft; 1:Quad-balanced good; 2:Overlapping very good/fast; 3:Density-based best, displayName=Lookup mode
 	//! [Default value] 3
	bool set_lookup_mode(int val) { return setValue("lookup_mode", val); }
	//! Type of sample look-up
 	//! [UI Guides] enum=0:Nearest draft; 1:Quad-balanced good; 2:Overlapping very good/fast; 3:Density-based best, displayName=Lookup mode
 	//! [Default value] 3
	int get_lookup_mode() const { return getInt("lookup_mode"); }

	//! [UI Guides] enum=0:Single frame; 1:Multiframe incremental; 2:From file; 3:Add to current map; 4:Incremental add to current map; 5:Bucket mode; 6:Animation prepass; 7:Animation rendering, displayName=Mode
 	//! [Default value] 0
	bool set_mode(int val) { return setValue("mode", val); }
	//! [UI Guides] enum=0:Single frame; 1:Multiframe incremental; 2:From file; 3:Add to current map; 4:Incremental add to current map; 5:Bucket mode; 6:Animation prepass; 7:Animation rendering, displayName=Mode
 	//! [Default value] 0
	int get_mode() const { return getInt("mode"); }

	//! If true, the map will not be deleted from memory at the end of the rendering
 	//! [UI Guides] displayName=Don't delete
 	//! [Default value] true
	bool set_dont_delete(bool val) { return setValue("dont_delete", val); }
	//! If true, the map will not be deleted from memory at the end of the rendering
 	//! [UI Guides] displayName=Don't delete
 	//! [Default value] true
	bool get_dont_delete() const { return getBool("dont_delete"); }

	//! [UI Guides] enableIf: ?mode=2; ?mode=7, displayName=Irradiance File, fileAsset=vrmap, fileAssetNames=V-Ray Irradiance map
 	bool set_file(const char* str) { return setValue("file", str); }
	//! [UI Guides] enableIf: ?mode=2; ?mode=7, displayName=Irradiance File, fileAsset=vrmap, fileAssetNames=V-Ray Irradiance map
 	bool set_file(const std::string& str) { return setValue("file", str); }
	//! [UI Guides] enableIf: ?mode=2; ?mode=7, displayName=Irradiance File, fileAsset=vrmap, fileAssetNames=V-Ray Irradiance map
 	std::string get_file() const { return getString("file"); }

	//! If true, the samples in the map will be shown in the final rendering
 	//! [UI Guides] displayName=Show samples
 	//! [Default value] false
	bool set_show_samples(bool val) { return setValue("show_samples", val); }
	//! If true, the samples in the map will be shown in the final rendering
 	//! [UI Guides] displayName=Show samples
 	//! [Default value] false
	bool get_show_samples() const { return getBool("show_samples"); }

	//! Shows the prepasses
 	//! [UI Guides] displayName=Show calc phase
 	//! [Default value] true
	bool set_show_calc_phase(bool val) { return setValue("show_calc_phase", val); }
	//! Shows the prepasses
 	//! [UI Guides] displayName=Show calc phase
 	//! [Default value] true
	bool get_show_calc_phase() const { return getBool("show_calc_phase"); }

	//! Shows the direct light during the prepasses (although VRay doesn't need it)
 	//! [UI Guides] enableIf: ?show_calc_phase=1, displayName=Show direct light
 	//! [Default value] false
	bool set_show_direct_light(bool val) { return setValue("show_direct_light", val); }
	//! Shows the direct light during the prepasses (although VRay doesn't need it)
 	//! [UI Guides] enableIf: ?show_calc_phase=1, displayName=Show direct light
 	//! [Default value] false
	bool get_show_direct_light() const { return getBool("show_direct_light"); }

	//! True to calculate the irradiance map from multiple viewpoints along the camera path.
 	//! [UI Guides] displayName=Use camera path
 	//! [Default value] false
	bool set_multiple_views(bool val) { return setValue("multiple_views", val); }
	//! True to calculate the irradiance map from multiple viewpoints along the camera path.
 	//! [UI Guides] displayName=Use camera path
 	//! [Default value] false
	bool get_multiple_views() const { return getBool("multiple_views"); }

	//! If true, V-Ray will do several prepasses; if false, only one prepass at the image resolution will be made
 	//! [UI Guides] displayName=Multipass
 	//! [Default value] true
	bool set_multipass(bool val) { return setValue("multipass", val); }
	//! If true, V-Ray will do several prepasses; if false, only one prepass at the image resolution will be made
 	//! [UI Guides] displayName=Multipass
 	//! [Default value] true
	bool get_multipass() const { return getBool("multipass"); }

	//! If true, sample visibility will be checked during final rendering
 	//! [UI Guides] displayName=Check sample visibility
 	//! [Default value] false
	bool set_check_sample_visibility(bool val) { return setValue("check_sample_visibility", val); }
	//! If true, sample visibility will be checked during final rendering
 	//! [UI Guides] displayName=Check sample visibility
 	//! [Default value] false
	bool get_check_sample_visibility() const { return getBool("check_sample_visibility"); }

	//! If true, the map will be automatically saved at the end of the rendering
 	//! [UI Guides] enableIf: ?mode!=2, ?mode!=5, ?mode!=7, displayName=Auto save
 	//! [Default value] false
	bool set_auto_save(bool val) { return setValue("auto_save", val); }
	//! If true, the map will be automatically saved at the end of the rendering
 	//! [UI Guides] enableIf: ?mode!=2, ?mode!=5, ?mode!=7, displayName=Auto save
 	//! [Default value] false
	bool get_auto_save() const { return getBool("auto_save"); }

	//! [UI Guides] enableIf: ?mode!=2, ?mode!=5, ?mode!=7, ?auto_save=1, displayName=Auto save file, fileAsset=vrmap, fileAssetNames=V-Ray Irradiance map, fileAssetOp=save
 	bool set_auto_save_file(const char* str) { return setValue("auto_save_file", str); }
	//! [UI Guides] enableIf: ?mode!=2, ?mode!=5, ?mode!=7, ?auto_save=1, displayName=Auto save file, fileAsset=vrmap, fileAssetNames=V-Ray Irradiance map, fileAssetOp=save
 	bool set_auto_save_file(const std::string& str) { return setValue("auto_save_file", str); }
	//! [UI Guides] enableIf: ?mode!=2, ?mode!=5, ?mode!=7, ?auto_save=1, displayName=Auto save file, fileAsset=vrmap, fileAssetNames=V-Ray Irradiance map, fileAssetOp=save
 	std::string get_auto_save_file() const { return getString("auto_save_file"); }
};

class SettingsJPEG : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "SettingsJPEG"; }

	//! JPEG quality (1-100)
 	//! [Default value] 85
	bool set_quality(int val) { return setValue("quality", val); }
	//! JPEG quality (1-100)
 	//! [Default value] 85
	int get_quality() const { return getInt("quality"); }
};

class SettingsLightCache : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "SettingsLightCache"; }

	//! Subdivisions for the light cache.
 	//! [UI Guides] displayName=Subdivs, minValue=1, maxValue=65000
 	//! [Default value] 500
	bool set_subdivs(int val) { return setValue("subdivs", val); }
	//! Subdivisions for the light cache.
 	//! [UI Guides] displayName=Subdivs, minValue=1, maxValue=65000
 	//! [Default value] 500
	int get_subdivs() const { return getInt("subdivs"); }

	//! Sample size when calculating the light cache.
 	//! [UI Guides] displayName=Sample size, minValue=0.0, maxValue=1e9
 	//! [Default value] 0.02
	bool set_sample_size(float val) { return setValue("sample_size", val); }
	//! Sample size when calculating the light cache.
 	//! [UI Guides] displayName=Sample size, minValue=0.0, maxValue=1e9
 	//! [Default value] 0.02
	float get_sample_size() const { return getFloat("sample_size"); }

	//! Filter type when reconstructing the illumination from the cache. 0 - no filter; 1 - nearest; 2 - fixed
 	//! [UI Guides] enum=0:None; 1:Nearest; 2:Fixed, displayName=Filter type, enableIf: ?mode!=3
 	//! [Default value] 1
	bool set_filter_type(int val) { return setValue("filter_type", val); }
	//! Filter type when reconstructing the illumination from the cache. 0 - no filter; 1 - nearest; 2 - fixed
 	//! [UI Guides] enum=0:None; 1:Nearest; 2:Fixed, displayName=Filter type, enableIf: ?mode!=3
 	//! [Default value] 1
	int get_filter_type() const { return getInt("filter_type"); }

	//! Number of samples to look for with the 'nearest' filter type.
 	//! [UI Guides] enableIf: ?filter_type=1, ?mode!=3, displayName=Filter samples, minValue=1, maxValue=10000
 	//! [Default value] 5
	bool set_filter_samples(int val) { return setValue("filter_samples", val); }
	//! Number of samples to look for with the 'nearest' filter type.
 	//! [UI Guides] enableIf: ?filter_type=1, ?mode!=3, displayName=Filter samples, minValue=1, maxValue=10000
 	//! [Default value] 5
	int get_filter_samples() const { return getInt("filter_samples"); }

	//! Filter size for the 'fixed' filter type.
 	//! [UI Guides] enableIf: ?filter_type=2, ?mode!=3, displayName=Filter size, minValue=0.0, maxValue=1e9
 	//! [Default value] 0.06
	bool set_filter_size(float val) { return setValue("filter_size", val); }
	//! Filter size for the 'fixed' filter type.
 	//! [UI Guides] enableIf: ?filter_type=2, ?mode!=3, displayName=Filter size, minValue=0.0, maxValue=1e9
 	//! [Default value] 0.06
	float get_filter_size() const { return getFloat("filter_size"); }

	//! True if the light cache should be prefiltered to smooth the illumination in it.
 	//! [UI Guides] displayName=Prefilter, enableIf: ?mode!=3
 	//! [Default value] false
	bool set_prefilter(bool val) { return setValue("prefilter", val); }
	//! True if the light cache should be prefiltered to smooth the illumination in it.
 	//! [UI Guides] displayName=Prefilter, enableIf: ?mode!=3
 	//! [Default value] false
	bool get_prefilter() const { return getBool("prefilter"); }

	//! Number of samples to look for when prefiltering the light cache.
 	//! [UI Guides] enableIf: ?prefilter!=0, ?mode!=3, displayName=Prefilter samples, minValue=2, maxValue=1000
 	//! [Default value] 10
	bool set_prefilter_samples(int val) { return setValue("prefilter_samples", val); }
	//! Number of samples to look for when prefiltering the light cache.
 	//! [UI Guides] enableIf: ?prefilter!=0, ?mode!=3, displayName=Prefilter samples, minValue=2, maxValue=1000
 	//! [Default value] 10
	int get_prefilter_samples() const { return getInt("prefilter_samples"); }

	//! Maximum bounces for the light cache. Leave this to the default value of 100. Note that, because of the way the light cache is calculated, the solution always converges to that of infinite light bounces, regardless of this value.
 	//! [UI Guides] displayName=Depth, minValue=0, maxValue=100
 	//! [Default value] 100
	bool set_depth(int val) { return setValue("depth", val); }
	//! Maximum bounces for the light cache. Leave this to the default value of 100. Note that, because of the way the light cache is calculated, the solution always converges to that of infinite light bounces, regardless of this value.
 	//! [UI Guides] displayName=Depth, minValue=0, maxValue=100
 	//! [Default value] 100
	int get_depth() const { return getInt("depth"); }

	//! Shows a preview of the scene while the light cache is calculated.
 	//! [UI Guides] displayName=Show calc. phase, enableIf: ?mode!=3
 	//! [Default value] true
	bool set_show_calc_phase(bool val) { return setValue("show_calc_phase", val); }
	//! Shows a preview of the scene while the light cache is calculated.
 	//! [UI Guides] displayName=Show calc. phase, enableIf: ?mode!=3
 	//! [Default value] true
	bool get_show_calc_phase() const { return getBool("show_calc_phase"); }

	//! Stores direct lighting with the light cache.
 	//! [UI Guides] displayName=Store direct light
 	//! [Default value] true
	bool set_store_direct_light(bool val) { return setValue("store_direct_light", val); }
	//! Stores direct lighting with the light cache.
 	//! [UI Guides] displayName=Store direct light
 	//! [Default value] true
	bool get_store_direct_light() const { return getBool("store_direct_light"); }

	//! [UI Guides] displayName=World scale
 	//! [Default value] false
	bool set_world_scale(bool val) { return setValue("world_scale", val); }
	//! [UI Guides] displayName=World scale
 	//! [Default value] false
	bool get_world_scale() const { return getBool("world_scale"); }

	//! [UI Guides] enum=0:Single frame; 1:Fly-through; 2:From File; 3:Progressive path tracing, displayName=Mode
 	//! [Default value] 0
	bool set_mode(int val) { return setValue("mode", val); }
	//! [UI Guides] enum=0:Single frame; 1:Fly-through; 2:From File; 3:Progressive path tracing, displayName=Mode
 	//! [Default value] 0
	int get_mode() const { return getInt("mode"); }

	//! [UI Guides] enableIf: ?mode=2, displayName=Light Cache File, fileAsset=vrlmap, fileAssetNames=V-Ray Light Cache map
 	bool set_file(const char* str) { return setValue("file", str); }
	//! [UI Guides] enableIf: ?mode=2, displayName=Light Cache File, fileAsset=vrlmap, fileAssetNames=V-Ray Light Cache map
 	bool set_file(const std::string& str) { return setValue("file", str); }
	//! [UI Guides] enableIf: ?mode=2, displayName=Light Cache File, fileAsset=vrlmap, fileAssetNames=V-Ray Light Cache map
 	std::string get_file() const { return getString("file"); }

	//! True if the light cache should not be deleted at the end of the rendering.
 	//! [UI Guides] displayName=Don't delete
 	//! [Default value] true
	bool set_dont_delete(bool val) { return setValue("dont_delete", val); }
	//! True if the light cache should not be deleted at the end of the rendering.
 	//! [UI Guides] displayName=Don't delete
 	//! [Default value] true
	bool get_dont_delete() const { return getBool("dont_delete"); }

	//! True if the light cache should be saved at the end of the rendering.
 	//! [UI Guides] enableIf: ?mode!=2, displayName=Auto save
 	//! [Default value] true
	bool set_auto_save(bool val) { return setValue("auto_save", val); }
	//! True if the light cache should be saved at the end of the rendering.
 	//! [UI Guides] enableIf: ?mode!=2, displayName=Auto save
 	//! [Default value] true
	bool get_auto_save() const { return getBool("auto_save"); }

	//! [UI Guides] enableIf: ?mode!=2, ?auto_save=1, displayName=Auto save file, fileAsset=vrlmap, fileAssetNames=V-Ray Light Cache map, fileAssetOp=save
 	bool set_auto_save_file(const char* str) { return setValue("auto_save_file", str); }
	//! [UI Guides] enableIf: ?mode!=2, ?auto_save=1, displayName=Auto save file, fileAsset=vrlmap, fileAssetNames=V-Ray Light Cache map, fileAssetOp=save
 	bool set_auto_save_file(const std::string& str) { return setValue("auto_save_file", str); }
	//! [UI Guides] enableIf: ?mode!=2, ?auto_save=1, displayName=Auto save file, fileAsset=vrlmap, fileAssetNames=V-Ray Light Cache map, fileAssetOp=save
 	std::string get_auto_save_file() const { return getString("auto_save_file"); }

	//! Number of passes for the light cache. Each pass is rendered in a single thread, therefore it is best to set this to the number of processors.
 	//! [UI Guides] displayName=Number of passes, minValue=0, maxValue=64
 	//! [Default value] 64
	bool set_num_passes(int val) { return setValue("num_passes", val); }
	//! Number of passes for the light cache. Each pass is rendered in a single thread, therefore it is best to set this to the number of processors.
 	//! [UI Guides] displayName=Number of passes, minValue=0, maxValue=64
 	//! [Default value] 64
	int get_num_passes() const { return getInt("num_passes"); }

	//! True if the light cache should be used to estimate GI for glossy rays, instead of the primary GI engine.
 	//! [UI Guides] displayName=Use for glossy rays
 	//! [Default value] false
	bool set_use_for_glossy_rays(bool val) { return setValue("use_for_glossy_rays", val); }
	//! True if the light cache should be used to estimate GI for glossy rays, instead of the primary GI engine.
 	//! [UI Guides] displayName=Use for glossy rays
 	//! [Default value] false
	bool get_use_for_glossy_rays() const { return getBool("use_for_glossy_rays"); }

	//! True if adaptive hemispheric sampling should be used. This requires more memory than the non-adaptive light cache.
 	//! [UI Guides] displayName=Adaptive sampling
 	//! [Default value] false
	bool set_adaptive_sampling(bool val) { return setValue("adaptive_sampling", val); }
	//! True if adaptive hemispheric sampling should be used. This requires more memory than the non-adaptive light cache.
 	//! [UI Guides] displayName=Adaptive sampling
 	//! [Default value] false
	bool get_adaptive_sampling() const { return getBool("adaptive_sampling"); }

	//! true to use premultiplied light cache when possible
 	//! [UI Guides] displayName=Premultiplied
 	//! [Default value] false
	bool set_premultiplied(bool val) { return setValue("premultiplied", val); }
	//! true to use premultiplied light cache when possible
 	//! [UI Guides] displayName=Premultiplied
 	//! [Default value] false
	bool get_premultiplied() const { return getBool("premultiplied"); }

	//! This causes the light cache to be calculated for the entire camera path, even when in single frame mode.
 	//! [UI Guides] displayName=Use camera path
 	//! [Default value] false
	bool set_multiple_views(bool val) { return setValue("multiple_views", val); }
	//! This causes the light cache to be calculated for the entire camera path, even when in single frame mode.
 	//! [UI Guides] displayName=Use camera path
 	//! [Default value] false
	bool get_multiple_views() const { return getBool("multiple_views"); }

	//! True to enable retrace of the light cache.
 	//! [UI Guides] displayName=Use retrace threshold
 	//! [Default value] false
	bool set_retrace_enabled(bool val) { return setValue("retrace_enabled", val); }
	//! True to enable retrace of the light cache.
 	//! [UI Guides] displayName=Use retrace threshold
 	//! [Default value] false
	bool get_retrace_enabled() const { return getBool("retrace_enabled"); }

	//! Retrace threshold, relative to the light cache sample size.
 	//! [UI Guides] enableIf: ?retrace_enabled!=0, displayName=Retrace threshold, minValue=0.0, maxValue=1e9
 	//! [Default value] 1
	bool set_retrace_threshold(float val) { return setValue("retrace_threshold", val); }
	//! Retrace threshold, relative to the light cache sample size.
 	//! [UI Guides] enableIf: ?retrace_enabled!=0, displayName=Retrace threshold, minValue=0.0, maxValue=1e9
 	//! [Default value] 1
	float get_retrace_threshold() const { return getFloat("retrace_threshold"); }

	//! Enables additional checks to mimize light leaks; 0.0 means no checks
 	//! [UI Guides] enableIf: ?retrace_enabled!=0, displayName=Leak prevention, minValue=0.0, maxValue=1.0
 	//! [Default value] 0
	bool set_retrace_leak_prevention(float val) { return setValue("retrace_leak_prevention", val); }
	//! Enables additional checks to mimize light leaks; 0.0 means no checks
 	//! [UI Guides] enableIf: ?retrace_enabled!=0, displayName=Leak prevention, minValue=0.0, maxValue=1.0
 	//! [Default value] 0
	float get_retrace_leak_prevention() const { return getFloat("retrace_leak_prevention"); }
};

class SettingsLightLinker : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "SettingsLightLinker"; }

	//! List containing lists of plugins. Every sub list contains a light plugin (always the first element) and some node plugins the light is not illuminating.
 	bool set_ignored_lights(const ValueList& list) { return setValue("ignored_lights", list); }
	//! List containing lists of plugins. Every sub list contains a light plugin (always the first element) and some node plugins the light is not illuminating.
 	ValueList get_ignored_lights() const { return getValueList("ignored_lights"); }

	//! List containing list of plugins. Every sub list contains a light plugin (always the first element) and some node plugins, which do not cast shadows from this light
 	bool set_ignored_shadow_lights(const ValueList& list) { return setValue("ignored_shadow_lights", list); }
	//! List containing list of plugins. Every sub list contains a light plugin (always the first element) and some node plugins, which do not cast shadows from this light
 	ValueList get_ignored_shadow_lights() const { return getValueList("ignored_shadow_lights"); }

	//! List containing a flag for every light in the ignored_lights list. 0 - the list is an exclude list (default). 1 - the list is an include list. 2 - ignored_lights is ignored and the light illuminates all objects in the scene, useful for animating the light linking.
 	bool set_include_exclude_light_flags(const IntList& intList) { return setValue("include_exclude_light_flags", intList); }
	//! List containing a flag for every light in the ignored_lights list. 0 - the list is an exclude list (default). 1 - the list is an include list. 2 - ignored_lights is ignored and the light illuminates all objects in the scene, useful for animating the light linking.
 	bool set_include_exclude_light_flags(const int* ints, size_t count) { return setArray("include_exclude_light_flags", ints, count); }
	//! List containing a flag for every light in the ignored_lights list. 0 - the list is an exclude list (default). 1 - the list is an include list. 2 - ignored_lights is ignored and the light illuminates all objects in the scene, useful for animating the light linking.
 	template<size_t count> bool set_include_exclude_light_flags(const int (&ints)[count]) { return setArray("include_exclude_light_flags", ints, count); }
	//! List containing a flag for every light in the ignored_lights list. 0 - the list is an exclude list (default). 1 - the list is an include list. 2 - ignored_lights is ignored and the light illuminates all objects in the scene, useful for animating the light linking.
 	IntList get_include_exclude_light_flags() const { return getIntList("include_exclude_light_flags"); }

	//! List containing a flag for every light in the ignored_shadow_lights list. 0 - the list is an exclude list (default). 1 - the list is an include list. 2 - ignored_shadow_lights is ignored and the light casts shadows from all objects in the scene, useful for animating the light linking.
 	bool set_include_exclude_shadow_flags(const IntList& intList) { return setValue("include_exclude_shadow_flags", intList); }
	//! List containing a flag for every light in the ignored_shadow_lights list. 0 - the list is an exclude list (default). 1 - the list is an include list. 2 - ignored_shadow_lights is ignored and the light casts shadows from all objects in the scene, useful for animating the light linking.
 	bool set_include_exclude_shadow_flags(const int* ints, size_t count) { return setArray("include_exclude_shadow_flags", ints, count); }
	//! List containing a flag for every light in the ignored_shadow_lights list. 0 - the list is an exclude list (default). 1 - the list is an include list. 2 - ignored_shadow_lights is ignored and the light casts shadows from all objects in the scene, useful for animating the light linking.
 	template<size_t count> bool set_include_exclude_shadow_flags(const int (&ints)[count]) { return setArray("include_exclude_shadow_flags", ints, count); }
	//! List containing a flag for every light in the ignored_shadow_lights list. 0 - the list is an exclude list (default). 1 - the list is an include list. 2 - ignored_shadow_lights is ignored and the light casts shadows from all objects in the scene, useful for animating the light linking.
 	IntList get_include_exclude_shadow_flags() const { return getIntList("include_exclude_shadow_flags"); }
};

class SettingsLightTree : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "SettingsLightTree"; }

	//! [UI Guides] displayName=On
 	//! [Default value] false
	bool set_on(bool val) { return setValue("on", val); }
	//! [UI Guides] displayName=On
 	//! [Default value] false
	bool get_on() const { return getBool("on"); }

	//! [UI Guides] enableIf: ?on!=0, enum=0:Disabled; 1:Auto; 2:Enabled, displayName=Use solids
 	//! [Default value] 1
	bool set_solids_enabled(int val) { return setValue("solids_enabled", val); }
	//! [UI Guides] enableIf: ?on!=0, enum=0:Disabled; 1:Auto; 2:Enabled, displayName=Use solids
 	//! [Default value] 1
	int get_solids_enabled() const { return getInt("solids_enabled"); }

	//! [UI Guides] enableIf: ?on!=0, enum=0:Auto; 1:Optimal; 2:Fast, displayName=Tree quality
 	//! [Default value] 0
	bool set_build_quality(int val) { return setValue("build_quality", val); }
	//! [UI Guides] enableIf: ?on!=0, enum=0:Auto; 1:Optimal; 2:Fast, displayName=Tree quality
 	//! [Default value] 0
	int get_build_quality() const { return getInt("build_quality"); }
};

class SettingsMotionBlur : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "SettingsMotionBlur"; }

	//! [UI Guides] displayName=Enable motion blur
 	//! [Default value] false
	bool set_on(bool val) { return setValue("on", val); }
	//! [UI Guides] displayName=Enable motion blur
 	//! [Default value] false
	bool get_on() const { return getBool("on"); }

	//! [UI Guides] displayName=Geometry samples, minValue=2, maxValue=1000
 	//! [Default value] 2
	bool set_geom_samples(int val) { return setValue("geom_samples", val); }
	//! [UI Guides] displayName=Geometry samples, minValue=2, maxValue=1000
 	//! [Default value] 2
	int get_geom_samples() const { return getInt("geom_samples"); }

	//! [UI Guides] displayName=Prepass samples, minValue=1, maxValue=1000
 	//! [Default value] 1
	bool set_low_samples(int val) { return setValue("low_samples", val); }
	//! [UI Guides] displayName=Prepass samples, minValue=1, maxValue=1000
 	//! [Default value] 1
	int get_low_samples() const { return getInt("low_samples"); }

	//! [UI Guides] enableIf: ?on!=0, displayName=Duration frames, minValue=0.0, maxValue=1000.0
 	//! [Default value] 1
	bool set_duration(float val) { return setValue("duration", val); }
	//! [UI Guides] enableIf: ?on!=0, displayName=Duration frames, minValue=0.0, maxValue=1000.0
 	//! [Default value] 1
	float get_duration() const { return getFloat("duration"); }

	//! [UI Guides] enableIf: ?on!=0, displayName=Subdivs, minValue=1, maxValue=100
 	//! [Default value] 1
	bool set_subdivs(int val) { return setValue("subdivs", val); }
	//! [UI Guides] enableIf: ?on!=0, displayName=Subdivs, minValue=1, maxValue=100
 	//! [Default value] 1
	int get_subdivs() const { return getInt("subdivs"); }

	//! [UI Guides] enableIf: ?on!=0, displayName=Bias
 	//! [Default value] 0
	bool set_bias(float val) { return setValue("bias", val); }
	//! [UI Guides] enableIf: ?on!=0, displayName=Bias
 	//! [Default value] 0
	float get_bias() const { return getFloat("bias"); }

	//! [UI Guides] enableIf: ?on!=0, displayName=Shutter Efficiency, minValue=0.5, maxValue=1.0
 	//! [Default value] 1
	bool set_shutter_efficiency(float val) { return setValue("shutter_efficiency", val); }
	//! [UI Guides] enableIf: ?on!=0, displayName=Shutter Efficiency, minValue=0.5, maxValue=1.0
 	//! [Default value] 1
	float get_shutter_efficiency() const { return getFloat("shutter_efficiency"); }

	//! [UI Guides] enableIf: ?on!=0, displayName=Interval center, minValue=-1.0, maxValue=1.0
 	//! [Default value] 0.5
	bool set_interval_center(float val) { return setValue("interval_center", val); }
	//! [UI Guides] enableIf: ?on!=0, displayName=Interval center, minValue=-1.0, maxValue=1.0
 	//! [Default value] 0.5
	float get_interval_center() const { return getFloat("interval_center"); }

	//! [UI Guides] enableIf: ?on!=0, displayName=Camera motion blur
 	//! [Default value] true
	bool set_camera_motion_blur(bool val) { return setValue("camera_motion_blur", val); }
	//! [UI Guides] enableIf: ?on!=0, displayName=Camera motion blur
 	//! [Default value] true
	bool get_camera_motion_blur() const { return getBool("camera_motion_blur"); }

	//! Type of sampling: 0 - normal, 1 - sample only shutter open, 2 - sample only shutter middle
 	//! [UI Guides] enableIf: ?on!=0, displayName=Sampling type, enum=0:Normal; 1:Sample only shutter open; 2:Sample only shutter middle
 	//! [Default value] 0
	bool set_sampling_type(int val) { return setValue("sampling_type", val); }
	//! Type of sampling: 0 - normal, 1 - sample only shutter open, 2 - sample only shutter middle
 	//! [UI Guides] enableIf: ?on!=0, displayName=Sampling type, enum=0:Normal; 1:Sample only shutter open; 2:Sample only shutter middle
 	//! [Default value] 0
	int get_sampling_type() const { return getInt("sampling_type"); }
};

class SettingsOptions : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "SettingsOptions"; }

	//! True if displacement should be computed.
 	//! [UI Guides] displayName=Enable displacement
 	//! [Default value] true
	bool set_geom_displacement(bool val) { return setValue("geom_displacement", val); }
	//! True if displacement should be computed.
 	//! [UI Guides] displayName=Enable displacement
 	//! [Default value] true
	bool get_geom_displacement() const { return getBool("geom_displacement"); }

	//! True if hidden geometry should be used.
 	//! [UI Guides] displayName=Render hidden geometry
 	//! [Default value] true
	bool set_geom_doHidden(bool val) { return setValue("geom_doHidden", val); }
	//! True if hidden geometry should be used.
 	//! [UI Guides] displayName=Render hidden geometry
 	//! [Default value] true
	bool get_geom_doHidden() const { return getBool("geom_doHidden"); }

	//! [UI Guides] displayName=Use lights
 	//! [Default value] true
	bool set_light_doLights(bool val) { return setValue("light_doLights", val); }
	//! [UI Guides] displayName=Use lights
 	//! [Default value] true
	bool get_light_doLights() const { return getBool("light_doLights"); }

	//! [UI Guides] displayName=Use default lights
 	//! [Default value] true
	bool set_light_doDefaultLights(bool val) { return setValue("light_doDefaultLights", val); }
	//! [UI Guides] displayName=Use default lights
 	//! [Default value] true
	bool get_light_doDefaultLights() const { return getBool("light_doDefaultLights"); }

	//! [UI Guides] displayName=Use hidden lights
 	//! [Default value] true
	bool set_light_doHiddenLights(bool val) { return setValue("light_doHiddenLights", val); }
	//! [UI Guides] displayName=Use hidden lights
 	//! [Default value] true
	bool get_light_doHiddenLights() const { return getBool("light_doHiddenLights"); }

	//! [UI Guides] displayName=Shadows
 	//! [Default value] true
	bool set_light_doShadows(bool val) { return setValue("light_doShadows", val); }
	//! [UI Guides] displayName=Shadows
 	//! [Default value] true
	bool get_light_doShadows() const { return getBool("light_doShadows"); }

	//! [UI Guides] displayName=Show GI only
 	//! [Default value] false
	bool set_light_onlyGI(bool val) { return setValue("light_onlyGI", val); }
	//! [UI Guides] displayName=Show GI only
 	//! [Default value] false
	bool get_light_onlyGI() const { return getBool("light_onlyGI"); }

	//! If true - will disable self-Illumination
 	//! [UI Guides] displayName=Disable self-illumination
 	//! [Default value] false
	bool set_light_disableSelfIllumination(bool val) { return setValue("light_disableSelfIllumination", val); }
	//! If true - will disable self-Illumination
 	//! [UI Guides] displayName=Disable self-illumination
 	//! [Default value] false
	bool get_light_disableSelfIllumination() const { return getBool("light_disableSelfIllumination"); }

	//! Don't render final image
 	//! [UI Guides] displayName=Don't render final image
 	//! [Default value] false
	bool set_gi_dontRenderImage(bool val) { return setValue("gi_dontRenderImage", val); }
	//! Don't render final image
 	//! [UI Guides] displayName=Don't render final image
 	//! [Default value] false
	bool get_gi_dontRenderImage() const { return getBool("gi_dontRenderImage"); }

	//! [UI Guides] displayName=Reflection / Refraction
 	//! [Default value] true
	bool set_mtl_reflectionRefraction(bool val) { return setValue("mtl_reflectionRefraction", val); }
	//! [UI Guides] displayName=Reflection / Refraction
 	//! [Default value] true
	bool get_mtl_reflectionRefraction() const { return getBool("mtl_reflectionRefraction"); }

	//! Limit max depth
 	//! [UI Guides] displayName=Use global max depth
 	//! [Default value] false
	bool set_mtl_limitDepth(bool val) { return setValue("mtl_limitDepth", val); }
	//! Limit max depth
 	//! [UI Guides] displayName=Use global max depth
 	//! [Default value] false
	bool get_mtl_limitDepth() const { return getBool("mtl_limitDepth"); }

	//! Max. ray depth for reflections and refractions
 	//! [UI Guides] enableIf: ?mtl_limitDepth!=0, displayName=Global max depth, minValue=0, maxValue=1000
 	//! [Default value] 5
	bool set_mtl_maxDepth(int val) { return setValue("mtl_maxDepth", val); }
	//! Max. ray depth for reflections and refractions
 	//! [UI Guides] enableIf: ?mtl_limitDepth!=0, displayName=Global max depth, minValue=0, maxValue=1000
 	//! [Default value] 5
	int get_mtl_maxDepth() const { return getInt("mtl_maxDepth"); }

	//! [UI Guides] displayName=Maps
 	//! [Default value] true
	bool set_mtl_doMaps(bool val) { return setValue("mtl_doMaps", val); }
	//! [UI Guides] displayName=Maps
 	//! [Default value] true
	bool get_mtl_doMaps() const { return getBool("mtl_doMaps"); }

	//! [UI Guides] enableIf: ?mtl_doMaps=1, displayName=Filter maps
 	//! [Default value] true
	bool set_mtl_filterMaps(bool val) { return setValue("mtl_filterMaps", val); }
	//! [UI Guides] enableIf: ?mtl_doMaps=1, displayName=Filter maps
 	//! [Default value] true
	bool get_mtl_filterMaps() const { return getBool("mtl_filterMaps"); }

	//! [UI Guides] displayName=SSS enabled
 	//! [Default value] true
	bool set_mtl_SSSEnabled(bool val) { return setValue("mtl_SSSEnabled", val); }
	//! [UI Guides] displayName=SSS enabled
 	//! [Default value] true
	bool get_mtl_SSSEnabled() const { return getBool("mtl_SSSEnabled"); }

	//! false to turn off filtering for glossy and GI rays
 	//! [UI Guides] enableIf: ?mtl_doMaps=1,?mtl_filterMaps=1, displayName=Filter maps for glossy/GI rays
 	//! [Default value] true
	bool set_mtl_filterMapsForSecondaryRays(bool val) { return setValue("mtl_filterMapsForSecondaryRays", val); }
	//! false to turn off filtering for glossy and GI rays
 	//! [UI Guides] enableIf: ?mtl_doMaps=1,?mtl_filterMaps=1, displayName=Filter maps for glossy/GI rays
 	//! [Default value] true
	bool get_mtl_filterMapsForSecondaryRays() const { return getBool("mtl_filterMapsForSecondaryRays"); }

	//! Max. transparency levels
 	//! [UI Guides] displayName=Max. transparency levels, minValue=1, maxValue=1000
 	//! [Default value] 50
	bool set_mtl_transpMaxLevels(int val) { return setValue("mtl_transpMaxLevels", val); }
	//! Max. transparency levels
 	//! [UI Guides] displayName=Max. transparency levels, minValue=1, maxValue=1000
 	//! [Default value] 50
	int get_mtl_transpMaxLevels() const { return getInt("mtl_transpMaxLevels"); }

	//! Transparency cutoff
 	//! [UI Guides] displayName=Transparency cutoff, minValue=0.0, maxValue=1000.0
 	//! [Default value] 0.001
	bool set_mtl_transpCutoff(float val) { return setValue("mtl_transpCutoff", val); }
	//! Transparency cutoff
 	//! [UI Guides] displayName=Transparency cutoff, minValue=0.0, maxValue=1000.0
 	//! [Default value] 0.001
	float get_mtl_transpCutoff() const { return getFloat("mtl_transpCutoff"); }

	//! Override material
 	//! [UI Guides] displayName=Override material
 	//! [Default value] false
	bool set_mtl_override_on(bool val) { return setValue("mtl_override_on", val); }
	//! Override material
 	//! [UI Guides] displayName=Override material
 	//! [Default value] false
	bool get_mtl_override_on() const { return getBool("mtl_override_on"); }

	//! Glossy effects
 	//! [UI Guides] displayName=Glossy effects
 	//! [Default value] true
	bool set_mtl_glossy(bool val) { return setValue("mtl_glossy", val); }
	//! Glossy effects
 	//! [UI Guides] displayName=Glossy effects
 	//! [Default value] true
	bool get_mtl_glossy() const { return getBool("mtl_glossy"); }

	//! If true the normal bump in tangent space will not be inverted on flipped UVs
 	//! [UI Guides] displayName=Uninverted normal bump
 	//! [Default value] false
	bool set_mtl_uninvertedNormalBump(bool val) { return setValue("mtl_uninvertedNormalBump", val); }
	//! If true the normal bump in tangent space will not be inverted on flipped UVs
 	//! [UI Guides] displayName=Uninverted normal bump
 	//! [Default value] false
	bool get_mtl_uninvertedNormalBump() const { return getBool("mtl_uninvertedNormalBump"); }

	//! If true, back faces will be invisible to camera and shadow rays
 	//! [UI Guides] displayName=Force back face culling
 	//! [Default value] false
	bool set_geom_backfaceCull(bool val) { return setValue("geom_backfaceCull", val); }
	//! If true, back faces will be invisible to camera and shadow rays
 	//! [UI Guides] displayName=Force back face culling
 	//! [Default value] false
	bool get_geom_backfaceCull() const { return getBool("geom_backfaceCull"); }

	//! Secondary ray bias
 	//! [UI Guides] displayName=Secondary ray bias, quantityType=distance, minValue=0.0, maxValue=1000.0
 	//! [Default value] 0
	bool set_ray_bias(float val) { return setValue("ray_bias", val); }
	//! Secondary ray bias
 	//! [UI Guides] displayName=Secondary ray bias, quantityType=distance, minValue=0.0, maxValue=1000.0
 	//! [Default value] 0
	float get_ray_bias() const { return getFloat("ray_bias"); }

	//! GI texturing filtering multiplier
 	//! [UI Guides] enableIf: ?mtl_doMaps=1,?mtl_filterMaps=1,?mtl_filterMapsForSecondaryRays=1, displayName=GI texture filtering multiplier, minValue=1.0
 	//! [Default value] 1
	bool set_gi_texFilteringMultiplier(float val) { return setValue("gi_texFilteringMultiplier", val); }
	//! GI texturing filtering multiplier
 	//! [UI Guides] enableIf: ?mtl_doMaps=1,?mtl_filterMaps=1,?mtl_filterMapsForSecondaryRays=1, displayName=GI texture filtering multiplier, minValue=1.0
 	//! [Default value] 1
	float get_gi_texFilteringMultiplier() const { return getFloat("gi_texFilteringMultiplier"); }

	//! [UI Guides] displayName=Abort rendering on missing asset
 	//! [Default value] false
	bool set_misc_abortOnMissingAsset(bool val) { return setValue("misc_abortOnMissingAsset", val); }
	//! [UI Guides] displayName=Abort rendering on missing asset
 	//! [Default value] false
	bool get_misc_abortOnMissingAsset() const { return getBool("misc_abortOnMissingAsset"); }

	//! Transfer missing assets on DR
 	//! [UI Guides] displayName=Transfer missing assets on DR
 	//! [Default value] false
	bool set_misc_transferAssets(bool val) { return setValue("misc_transferAssets", val); }
	//! Transfer missing assets on DR
 	//! [UI Guides] displayName=Transfer missing assets on DR
 	//! [Default value] false
	bool get_misc_transferAssets() const { return getBool("misc_transferAssets"); }

	//! Use cached assets on DR
 	//! [UI Guides] displayName=Use cached assets on DR
 	//! [Default value] true
	bool set_misc_useCachedAssets(bool val) { return setValue("misc_useCachedAssets", val); }
	//! Use cached assets on DR
 	//! [UI Guides] displayName=Use cached assets on DR
 	//! [Default value] true
	bool get_misc_useCachedAssets() const { return getBool("misc_useCachedAssets"); }

	//! Type of the assets cache limit
 	//! [UI Guides] enum=0:none; 1:age hours; 2:size GBs;, displayName=Cache limit type
 	//! [Default value] 0
	bool set_dr_assetsCacheLimitType(int val) { return setValue("dr_assetsCacheLimitType", val); }
	//! Type of the assets cache limit
 	//! [UI Guides] enum=0:none; 1:age hours; 2:size GBs;, displayName=Cache limit type
 	//! [Default value] 0
	int get_dr_assetsCacheLimitType() const { return getInt("dr_assetsCacheLimitType"); }

	//! Value of the assets cache limit
 	//! [UI Guides] displayName=Cache limit value, minValue=0.0
 	//! [Default value] 0
	bool set_dr_assetsCacheLimitValue(float val) { return setValue("dr_assetsCacheLimitValue", val); }
	//! Value of the assets cache limit
 	//! [UI Guides] displayName=Cache limit value, minValue=0.0
 	//! [Default value] 0
	float get_dr_assetsCacheLimitValue() const { return getFloat("dr_assetsCacheLimitValue"); }

	//! If true the client's cache settings will overwrite server settings
 	//! [UI Guides] displayName=Overwrite local cache settings
 	//! [Default value] false
	bool set_dr_overwriteLocalCacheSettings(bool val) { return setValue("dr_overwriteLocalCacheSettings", val); }
	//! If true the client's cache settings will overwrite server settings
 	//! [UI Guides] displayName=Overwrite local cache settings
 	//! [Default value] false
	bool get_dr_overwriteLocalCacheSettings() const { return getBool("dr_overwriteLocalCacheSettings"); }

	//! Enable clamping of secondary rays
 	//! [UI Guides] displayName=Clamp max ray intensity
 	//! [Default value] false
	bool set_ray_max_intensity_on(bool val) { return setValue("ray_max_intensity_on", val); }
	//! Enable clamping of secondary rays
 	//! [UI Guides] displayName=Clamp max ray intensity
 	//! [Default value] false
	bool get_ray_max_intensity_on() const { return getBool("ray_max_intensity_on"); }

	//! The max secondary ray intensity when ray_max_intensity_on is enabled
 	//! [UI Guides] enableIf: ?ray_max_intensity_on!=0, displayName=Max ray intensity, minValue=0.0, maxValue=1000.0
 	//! [Default value] 20
	bool set_ray_max_intensity(float val) { return setValue("ray_max_intensity", val); }
	//! The max secondary ray intensity when ray_max_intensity_on is enabled
 	//! [UI Guides] enableIf: ?ray_max_intensity_on!=0, displayName=Max ray intensity, minValue=0.0, maxValue=1000.0
 	//! [Default value] 20
	float get_ray_max_intensity() const { return getFloat("ray_max_intensity"); }

	//! Light evaluation (0 - full evaluation; 1 - uniform probabilistic; 2 - adaptive lights)
 	//! [UI Guides] displayName=Light evalaution mode
 	//! [Default value] 0
	bool set_probabilistic_lights_on(int val) { return setValue("probabilistic_lights_on", val); }
	//! Light evaluation (0 - full evaluation; 1 - uniform probabilistic; 2 - adaptive lights)
 	//! [UI Guides] displayName=Light evalaution mode
 	//! [Default value] 0
	int get_probabilistic_lights_on() const { return getInt("probabilistic_lights_on"); }

	//! The number of probabilistic lights to use when probabilistic_lights_on is true
 	//! [UI Guides] enableIf: ?probabilistic_lights_on!=0, displayName=Number of probabilistic lights, minValue=1, maxValue=1000000
 	//! [Default value] 8
	bool set_num_probabilistic_lights(int val) { return setValue("num_probabilistic_lights", val); }
	//! The number of probabilistic lights to use when probabilistic_lights_on is true
 	//! [UI Guides] enableIf: ?probabilistic_lights_on!=0, displayName=Number of probabilistic lights, minValue=1, maxValue=1000000
 	//! [Default value] 8
	int get_num_probabilistic_lights() const { return getInt("num_probabilistic_lights"); }

	//! Enable probabilistic volumetric sampling
 	//! [UI Guides] displayName=Enable probabilistic volumetrics
 	//! [Default value] false
	bool set_probabilistic_vol_on(bool val) { return setValue("probabilistic_vol_on", val); }
	//! Enable probabilistic volumetric sampling
 	//! [UI Guides] displayName=Enable probabilistic volumetrics
 	//! [Default value] false
	bool get_probabilistic_vol_on() const { return getBool("probabilistic_vol_on"); }

	//! The number of probabilistic samples to shade for primary/shadow rays when probabilistic_vol_on is true
 	//! [UI Guides] enableIf: ?probabilistic_vol_on!=0, displayName=Number of direct samples, minValue=1, maxValue=1000000
 	//! [Default value] 5
	bool set_probabilistic_vol_samples(int val) { return setValue("probabilistic_vol_samples", val); }
	//! The number of probabilistic samples to shade for primary/shadow rays when probabilistic_vol_on is true
 	//! [UI Guides] enableIf: ?probabilistic_vol_on!=0, displayName=Number of direct samples, minValue=1, maxValue=1000000
 	//! [Default value] 5
	int get_probabilistic_vol_samples() const { return getInt("probabilistic_vol_samples"); }

	//! The number of probabilistic samples to shade for gi/glossy when probabilistic_vol_on is true
 	//! [UI Guides] enableIf: ?probabilistic_vol_on!=0, displayName=Number of GI samples, minValue=1, maxValue=1000000
 	//! [Default value] 5
	bool set_probabilistic_vol_gi_samples(int val) { return setValue("probabilistic_vol_gi_samples", val); }
	//! The number of probabilistic samples to shade for gi/glossy when probabilistic_vol_on is true
 	//! [UI Guides] enableIf: ?probabilistic_vol_on!=0, displayName=Number of GI samples, minValue=1, maxValue=1000000
 	//! [Default value] 5
	int get_probabilistic_vol_gi_samples() const { return getInt("probabilistic_vol_gi_samples"); }

	//! [UI Guides] displayName=Low thread priority
 	//! [Default value] false
	bool set_misc_lowThreadPriority(bool val) { return setValue("misc_lowThreadPriority", val); }
	//! [UI Guides] displayName=Low thread priority
 	//! [Default value] false
	bool get_misc_lowThreadPriority() const { return getBool("misc_lowThreadPriority"); }
};

class SettingsOutput : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "SettingsOutput"; }

	//! Output image width
 	//! [UI Guides] displayName=Image width
 	//! [Default value] 640
	bool set_img_width(int val) { return setValue("img_width", val); }
	//! Output image width
 	//! [UI Guides] displayName=Image width
 	//! [Default value] 640
	int get_img_width() const { return getInt("img_width"); }

	//! Output image height
 	//! [UI Guides] displayName=Image height
 	//! [Default value] 480
	bool set_img_height(int val) { return setValue("img_height", val); }
	//! Output image height
 	//! [UI Guides] displayName=Image height
 	//! [Default value] 480
	int get_img_height() const { return getInt("img_height"); }

	//! Output image pixel aspect
 	//! [UI Guides] displayName=Pixel aspect
 	//! [Default value] 1
	bool set_img_pixelAspect(float val) { return setValue("img_pixelAspect", val); }
	//! Output image pixel aspect
 	//! [UI Guides] displayName=Pixel aspect
 	//! [Default value] 1
	float get_img_pixelAspect() const { return getFloat("img_pixelAspect"); }

	//! Output image file
 	//! [UI Guides] displayName=File name
 	bool set_img_file(const char* str) { return setValue("img_file", str); }
	//! Output image file
 	//! [UI Guides] displayName=File name
 	bool set_img_file(const std::string& str) { return setValue("img_file", str); }
	//! Output image file
 	//! [UI Guides] displayName=File name
 	std::string get_img_file() const { return getString("img_file"); }

	//! Output image dir
 	//! [UI Guides] displayName=Dir name
 	bool set_img_dir(const char* str) { return setValue("img_dir", str); }
	//! Output image dir
 	//! [UI Guides] displayName=Dir name
 	bool set_img_dir(const std::string& str) { return setValue("img_dir", str); }
	//! Output image dir
 	//! [UI Guides] displayName=Dir name
 	std::string get_img_dir() const { return getString("img_dir"); }

	//! If true, the frame number is added to the image file name
 	//! [Default value] false
	bool set_img_file_needFrameNumber(bool val) { return setValue("img_file_needFrameNumber", val); }
	//! If true, the frame number is added to the image file name
 	//! [Default value] false
	bool get_img_file_needFrameNumber() const { return getBool("img_file_needFrameNumber"); }

	//! If true, the alpha channel will be written to a separate file
 	//! [Default value] false
	bool set_img_separateAlpha(bool val) { return setValue("img_separateAlpha", val); }
	//! If true, the alpha channel will be written to a separate file
 	//! [Default value] false
	bool get_img_separateAlpha() const { return getBool("img_separateAlpha"); }

	//! If true, the alpha channel will not be written the final image
 	//! [Default value] false
	bool set_img_noAlpha(bool val) { return setValue("img_noAlpha", val); }
	//! If true, the alpha channel will not be written the final image
 	//! [Default value] false
	bool get_img_noAlpha() const { return getBool("img_noAlpha"); }

	//! If true, the RGB channel will not be saved to disk
 	//! [Default value] false
	bool set_img_dontSaveRgbChannel(bool val) { return setValue("img_dontSaveRgbChannel", val); }
	//! If true, the RGB channel will not be saved to disk
 	//! [Default value] false
	bool get_img_dontSaveRgbChannel() const { return getBool("img_dontSaveRgbChannel"); }

	//! If true, Velocity channel will be saved zero base instead of the default 0.5 based.
 	//! [Default value] false
	bool set_img_saveVelocityZeroBase(bool val) { return setValue("img_saveVelocityZeroBase", val); }
	//! If true, Velocity channel will be saved zero base instead of the default 0.5 based.
 	//! [Default value] false
	bool get_img_saveVelocityZeroBase() const { return getBool("img_saveVelocityZeroBase"); }

	//! If true, V-Ray will will generate deep image file (valid for vrst and exr)
 	//! [Default value] false
	bool set_img_deepFile(bool val) { return setValue("img_deepFile", val); }
	//! If true, V-Ray will will generate deep image file (valid for vrst and exr)
 	//! [Default value] false
	bool get_img_deepFile() const { return getBool("img_deepFile"); }

	//! If true, V-Ray will render to a tiled file format (.vrimg or .exr). This is automatically turned on for file formats that only support tiled writing (like .vrimg)
 	//! [Default value] false
	bool set_img_rawFile(bool val) { return setValue("img_rawFile", val); }
	//! If true, V-Ray will render to a tiled file format (.vrimg or .exr). This is automatically turned on for file formats that only support tiled writing (like .vrimg)
 	//! [Default value] false
	bool get_img_rawFile() const { return getBool("img_rawFile"); }

	//! If writing to a tiled file format, specifies whether a memory VFB window should be displayed (0 - no memory VFB, 1 - full memory VFB, 2 - preview)
 	//! [Default value] 1
	bool set_img_rawFileVFB(int val) { return setValue("img_rawFileVFB", val); }
	//! If writing to a tiled file format, specifies whether a memory VFB window should be displayed (0 - no memory VFB, 1 - full memory VFB, 2 - preview)
 	//! [Default value] 1
	int get_img_rawFileVFB() const { return getInt("img_rawFileVFB"); }

	//! Start of animation range in time units
 	//! [UI Guides] displayName=Start animation
 	//! [Default value] 0
	bool set_anim_start(const Value& val) { return setValue("anim_start", val); }
	//! Start of animation range in time units
 	//! [UI Guides] displayName=Start animation
 	//! [Default value] 0
	Value get_anim_start() const { return getValue("anim_start"); }

	//! End of animation range in time units
 	//! [UI Guides] displayName=End animation
 	//! [Default value] 1
	bool set_anim_end(const Value& val) { return setValue("anim_end", val); }
	//! End of animation range in time units
 	//! [UI Guides] displayName=End animation
 	//! [Default value] 1
	Value get_anim_end() const { return getValue("anim_end"); }

	//! Animation Frame Name Padding
 	//! [UI Guides] displayName=Frame Padding
 	//! [Default value] 4
	bool set_anim_frame_padding(int val) { return setValue("anim_frame_padding", val); }
	//! Animation Frame Name Padding
 	//! [UI Guides] displayName=Frame Padding
 	//! [Default value] 4
	int get_anim_frame_padding() const { return getInt("anim_frame_padding"); }

	//! If true, frame renumbering is used
 	//! [Default value] false
	bool set_anim_renumber_on(bool val) { return setValue("anim_renumber_on", val); }
	//! If true, frame renumbering is used
 	//! [Default value] false
	bool get_anim_renumber_on() const { return getBool("anim_renumber_on"); }

	//! Start number for renumber frames
 	//! [UI Guides] displayName=Renumber start number
 	//! [Default value] 0
	bool set_anim_renumber_start(float val) { return setValue("anim_renumber_start", val); }
	//! Start number for renumber frames
 	//! [UI Guides] displayName=Renumber start number
 	//! [Default value] 0
	float get_anim_renumber_start() const { return getFloat("anim_renumber_start"); }

	//! Renumber frames step
 	//! [UI Guides] displayName=Renumber frames step
 	//! [Default value] 1
	bool set_anim_renumber_step(float val) { return setValue("anim_renumber_step", val); }
	//! Renumber frames step
 	//! [UI Guides] displayName=Renumber frames step
 	//! [Default value] 1
	float get_anim_renumber_step() const { return getFloat("anim_renumber_step"); }

	//! First frame of animation range
 	//! [UI Guides] displayName=First frame of animation range
 	//! [Default value] 0
	bool set_anim_ren_frame_start(float val) { return setValue("anim_ren_frame_start", val); }
	//! First frame of animation range
 	//! [UI Guides] displayName=First frame of animation range
 	//! [Default value] 0
	float get_anim_ren_frame_start() const { return getFloat("anim_ren_frame_start"); }

	//! The frame number at the start of the animation range
 	//! [UI Guides] displayName=Frame start
 	//! [Default value] 0
	bool set_frame_start(int val) { return setValue("frame_start", val); }
	//! The frame number at the start of the animation range
 	//! [UI Guides] displayName=Frame start
 	//! [Default value] 0
	int get_frame_start() const { return getInt("frame_start"); }

	//! Number of frames per unit time
 	//! [UI Guides] displayName=Frames per unit time
 	//! [Default value] 1
	bool set_frames_per_second(float val) { return setValue("frames_per_second", val); }
	//! Number of frames per unit time
 	//! [UI Guides] displayName=Frames per unit time
 	//! [Default value] 1
	float get_frames_per_second() const { return getFloat("frames_per_second"); }

	//! List of frames to be rendered. May contain intervals in the form of lists with start and end frame
 	bool set_frames(const ValueList& list) { return setValue("frames", list); }
	//! List of frames to be rendered. May contain intervals in the form of lists with start and end frame
 	ValueList get_frames() const { return getValueList("frames"); }

	//! Image output region left coord
 	//! [UI Guides] displayName=Image output region left coord
 	//! [Default value] 0
	bool set_rgn_left(float val) { return setValue("rgn_left", val); }
	//! Image output region left coord
 	//! [UI Guides] displayName=Image output region left coord
 	//! [Default value] 0
	float get_rgn_left() const { return getFloat("rgn_left"); }

	//! Image output region width
 	//! [UI Guides] displayName=Image output region width
 	//! [Default value] 640
	bool set_rgn_width(float val) { return setValue("rgn_width", val); }
	//! Image output region width
 	//! [UI Guides] displayName=Image output region width
 	//! [Default value] 640
	float get_rgn_width() const { return getFloat("rgn_width"); }

	//! Image output region top coord
 	//! [UI Guides] displayName=Image output region top coord
 	//! [Default value] 0
	bool set_rgn_top(float val) { return setValue("rgn_top", val); }
	//! Image output region top coord
 	//! [UI Guides] displayName=Image output region top coord
 	//! [Default value] 0
	float get_rgn_top() const { return getFloat("rgn_top"); }

	//! Image output region height
 	//! [UI Guides] displayName=Image output region height
 	//! [Default value] 480
	bool set_rgn_height(float val) { return setValue("rgn_height", val); }
	//! Image output region height
 	//! [UI Guides] displayName=Image output region height
 	//! [Default value] 480
	float get_rgn_height() const { return getFloat("rgn_height"); }

	//! Output bitmap width
 	//! [UI Guides] displayName=Bitmap width
 	//! [Default value] 640
	bool set_bmp_width(int val) { return setValue("bmp_width", val); }
	//! Output bitmap width
 	//! [UI Guides] displayName=Bitmap width
 	//! [Default value] 640
	int get_bmp_width() const { return getInt("bmp_width"); }

	//! Output bitmap height
 	//! [UI Guides] displayName=Bitmap height
 	//! [Default value] 480
	bool set_bmp_height(int val) { return setValue("bmp_height", val); }
	//! Output bitmap height
 	//! [UI Guides] displayName=Bitmap height
 	//! [Default value] 480
	int get_bmp_height() const { return getInt("bmp_height"); }

	//! Bitmap output region left coord
 	//! [UI Guides] displayName=Bitmap output region left coord
 	//! [Default value] 0
	bool set_r_left(int val) { return setValue("r_left", val); }
	//! Bitmap output region left coord
 	//! [UI Guides] displayName=Bitmap output region left coord
 	//! [Default value] 0
	int get_r_left() const { return getInt("r_left"); }

	//! Bitmap output region width
 	//! [UI Guides] displayName=Bitmap output region width
 	//! [Default value] 640
	bool set_r_width(int val) { return setValue("r_width", val); }
	//! Bitmap output region width
 	//! [UI Guides] displayName=Bitmap output region width
 	//! [Default value] 640
	int get_r_width() const { return getInt("r_width"); }

	//! Bitmap output region top coord
 	//! [UI Guides] displayName=Bitmap output region top coord
 	//! [Default value] 0
	bool set_r_top(int val) { return setValue("r_top", val); }
	//! Bitmap output region top coord
 	//! [UI Guides] displayName=Bitmap output region top coord
 	//! [Default value] 0
	int get_r_top() const { return getInt("r_top"); }

	//! Bitmap output region height
 	//! [UI Guides] displayName=Bitmap output region height
 	//! [Default value] 480
	bool set_r_height(int val) { return setValue("r_height", val); }
	//! Bitmap output region height
 	//! [UI Guides] displayName=Bitmap output region height
 	//! [Default value] 480
	int get_r_height() const { return getInt("r_height"); }

	//! true to enable the VFB frame stamp
 	//! [Default value] false
	bool set_frame_stamp_enabled(bool val) { return setValue("frame_stamp_enabled", val); }
	//! true to enable the VFB frame stamp
 	//! [Default value] false
	bool get_frame_stamp_enabled() const { return getBool("frame_stamp_enabled"); }

	//! Frame stamp text
 	bool set_frame_stamp_text(const char* str) { return setValue("frame_stamp_text", str); }
	//! Frame stamp text
 	bool set_frame_stamp_text(const std::string& str) { return setValue("frame_stamp_text", str); }
	//! Frame stamp text
 	std::string get_frame_stamp_text() const { return getString("frame_stamp_text"); }

	//! true to save render elements in separate folders
 	//! [Default value] false
	bool set_relements_separateFolders(bool val) { return setValue("relements_separateFolders", val); }
	//! true to save render elements in separate folders
 	//! [Default value] false
	bool get_relements_separateFolders() const { return getBool("relements_separateFolders"); }

	//! true to save the main RGBA elment in a separate folder too, if relements_separateFolders is specified
 	//! [Default value] false
	bool set_relements_separate_rgba(bool val) { return setValue("relements_separate_rgba", val); }
	//! true to save the main RGBA elment in a separate folder too, if relements_separateFolders is specified
 	//! [Default value] false
	bool get_relements_separate_rgba() const { return getBool("relements_separate_rgba"); }

	//! Render elements name separator
 	//! [Default value] .
	bool set_relements_divider(const char* str) { return setValue("relements_divider", str); }
	//! Render elements name separator
 	//! [Default value] .
	bool set_relements_divider(const std::string& str) { return setValue("relements_divider", str); }
	//! Render elements name separator
 	//! [Default value] .
	std::string get_relements_divider() const { return getString("relements_divider"); }

	//! Horizontal film offset
 	//! [Default value] 0
	bool set_film_offset_x(float val) { return setValue("film_offset_x", val); }
	//! Horizontal film offset
 	//! [Default value] 0
	float get_film_offset_x() const { return getFloat("film_offset_x"); }

	//! Vertical film offset
 	//! [Default value] 0
	bool set_film_offset_y(float val) { return setValue("film_offset_y", val); }
	//! Vertical film offset
 	//! [Default value] 0
	float get_film_offset_y() const { return getFloat("film_offset_y"); }
};

class SettingsPNG : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "SettingsPNG"; }

	//! Compression for PNG output (0-9)
 	//! [Default value] 9
	bool set_compression(int val) { return setValue("compression", val); }
	//! Compression for PNG output (0-9)
 	//! [Default value] 9
	int get_compression() const { return getInt("compression"); }

	//! Bits per channel (8 or 16)
 	//! [Default value] 8
	bool set_bits_per_channel(int val) { return setValue("bits_per_channel", val); }
	//! Bits per channel (8 or 16)
 	//! [Default value] 8
	int get_bits_per_channel() const { return getInt("bits_per_channel"); }
};

class SettingsPhotonMap : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "SettingsPhotonMap"; }

	//! The maximum number of light bounces.
 	//! [UI Guides] displayName=Bounces, minValue=0, maxValue=100
 	//! [Default value] 10
	bool set_bounces(int val) { return setValue("bounces", val); }
	//! The maximum number of light bounces.
 	//! [UI Guides] displayName=Bounces, minValue=0, maxValue=100
 	//! [Default value] 10
	int get_bounces() const { return getInt("bounces"); }

	//! Number of photons to search for.
 	//! [UI Guides] displayName=Max photons, minValue=0, maxValue=10000
 	//! [Default value] 30
	bool set_max_photons(int val) { return setValue("max_photons", val); }
	//! Number of photons to search for.
 	//! [UI Guides] displayName=Max photons, minValue=0, maxValue=10000
 	//! [Default value] 30
	int get_max_photons() const { return getInt("max_photons"); }

	//! True if irradiance will be precomputed.
 	//! [UI Guides] displayName=Prefilter
 	//! [Default value] false
	bool set_prefilter(bool val) { return setValue("prefilter", val); }
	//! True if irradiance will be precomputed.
 	//! [UI Guides] displayName=Prefilter
 	//! [Default value] false
	bool get_prefilter() const { return getBool("prefilter"); }

	//! Number of interpolation samples when irradiance is precomputed.
 	//! [UI Guides] enableIf: ?prefilter=1, displayName=Prefilter samples, minValue=0, maxValue=1000
 	//! [Default value] 10
	bool set_prefilter_samples(int val) { return setValue("prefilter_samples", val); }
	//! Number of interpolation samples when irradiance is precomputed.
 	//! [UI Guides] enableIf: ?prefilter=1, displayName=Prefilter samples, minValue=0, maxValue=1000
 	//! [Default value] 10
	int get_prefilter_samples() const { return getInt("prefilter_samples"); }

	//! [UI Guides] enum=0:New map; 1:From file, displayName=Mode
 	//! [Default value] 0
	bool set_mode(int val) { return setValue("mode", val); }
	//! [UI Guides] enum=0:New map; 1:From file, displayName=Mode
 	//! [Default value] 0
	int get_mode() const { return getInt("mode"); }

	//! [UI Guides] enableIf: ?mode=1, displayName=Photon Map File, fileAsset=vrpmap, fileAssetNames=V-Ray Photon map
 	bool set_file(const char* str) { return setValue("file", str); }
	//! [UI Guides] enableIf: ?mode=1, displayName=Photon Map File, fileAsset=vrpmap, fileAssetNames=V-Ray Photon map
 	bool set_file(const std::string& str) { return setValue("file", str); }
	//! [UI Guides] enableIf: ?mode=1, displayName=Photon Map File, fileAsset=vrpmap, fileAssetNames=V-Ray Photon map
 	std::string get_file() const { return getString("file"); }

	//! If true, V-Ray will try to automatically find a suitable value for searchDist based on the desired number of photons in the estimate.
 	//! [UI Guides] displayName=Auto search distance
 	//! [Default value] true
	bool set_auto_search_distance(bool val) { return setValue("auto_search_distance", val); }
	//! If true, V-Ray will try to automatically find a suitable value for searchDist based on the desired number of photons in the estimate.
 	//! [UI Guides] displayName=Auto search distance
 	//! [Default value] true
	bool get_auto_search_distance() const { return getBool("auto_search_distance"); }

	//! Photon search distance.
 	//! [UI Guides] enableIf: ?auto_search_distance!=1, displayName=Search distance, quantityType=distance, minValue=0.0, maxValue=1e6
 	//! [Default value] 1e+018
	bool set_search_distance(float val) { return setValue("search_distance", val); }
	//! Photon search distance.
 	//! [UI Guides] enableIf: ?auto_search_distance!=1, displayName=Search distance, quantityType=distance, minValue=0.0, maxValue=1e6
 	//! [Default value] 1e+018
	float get_search_distance() const { return getFloat("search_distance"); }

	//! If true, the area covered by photons in the estimate will be calculated by the convex hull of the photons, projected along the surface normal.
 	//! [UI Guides] displayName=Convex hull estimate
 	//! [Default value] false
	bool set_convex_hull_estimate(bool val) { return setValue("convex_hull_estimate", val); }
	//! If true, the area covered by photons in the estimate will be calculated by the convex hull of the photons, projected along the surface normal.
 	//! [UI Guides] displayName=Convex hull estimate
 	//! [Default value] false
	bool get_convex_hull_estimate() const { return getBool("convex_hull_estimate"); }

	//! If true, the photon map will not be deleted after rendering is complete.
 	//! [UI Guides] displayName=Don't delete
 	//! [Default value] true
	bool set_dont_delete(bool val) { return setValue("dont_delete", val); }
	//! If true, the photon map will not be deleted after rendering is complete.
 	//! [UI Guides] displayName=Don't delete
 	//! [Default value] true
	bool get_dont_delete() const { return getBool("dont_delete"); }

	//! If true, the photon map will be saved to a file after rendering is complete.
 	//! [UI Guides] enableIf: ?mode!=1, displayName=Auto save
 	//! [Default value] false
	bool set_auto_save(bool val) { return setValue("auto_save", val); }
	//! If true, the photon map will be saved to a file after rendering is complete.
 	//! [UI Guides] enableIf: ?mode!=1, displayName=Auto save
 	//! [Default value] false
	bool get_auto_save() const { return getBool("auto_save"); }

	//! [UI Guides] enableIf: ?mode!=1, ?auto_save=1, displayName=Auto save file, fileAsset=vrpmap, fileAssetNames=V-Ray Photon map, fileAssetOp=save
 	bool set_auto_save_file(const char* str) { return setValue("auto_save_file", str); }
	//! [UI Guides] enableIf: ?mode!=1, ?auto_save=1, displayName=Auto save file, fileAsset=vrpmap, fileAssetNames=V-Ray Photon map, fileAssetOp=save
 	bool set_auto_save_file(const std::string& str) { return setValue("auto_save_file", str); }
	//! [UI Guides] enableIf: ?mode!=1, ?auto_save=1, displayName=Auto save file, fileAsset=vrpmap, fileAssetNames=V-Ray Photon map, fileAssetOp=save
 	std::string get_auto_save_file() const { return getString("auto_save_file"); }

	//! True if direct lighting should be stored with the photon map.
 	//! [UI Guides] displayName=Store direct light
 	//! [Default value] true
	bool set_store_direct_light(bool val) { return setValue("store_direct_light", val); }
	//! True if direct lighting should be stored with the photon map.
 	//! [UI Guides] displayName=Store direct light
 	//! [Default value] true
	bool get_store_direct_light() const { return getBool("store_direct_light"); }

	//! Multiplier for the photon map.
 	//! [UI Guides] displayName=Multiplier, minValue=0.0, maxValue=1e6
 	//! [Default value] 1
	bool set_multiplier(float val) { return setValue("multiplier", val); }
	//! Multiplier for the photon map.
 	//! [UI Guides] displayName=Multiplier, minValue=0.0, maxValue=1e6
 	//! [Default value] 1
	float get_multiplier() const { return getFloat("multiplier"); }

	//! Minimum allowed distance between photons in the map. If a photon falls with a smaller distance to another photon, the two photons are merged into one.
 	//! [UI Guides] displayName=Max density, quantityType=distance, minValue=0.0
 	//! [Default value] 0
	bool set_max_density(float val) { return setValue("max_density", val); }
	//! Minimum allowed distance between photons in the map. If a photon falls with a smaller distance to another photon, the two photons are merged into one.
 	//! [UI Guides] displayName=Max density, quantityType=distance, minValue=0.0
 	//! [Default value] 0
	float get_max_density() const { return getFloat("max_density"); }

	//! Set to > 0.0 if corner retracing should be used for more accurate estimate of GI in corners. Using this option is not recommended.
 	//! [UI Guides] displayName=Retrace threshold, minValue=0.0, maxValue=1e6
 	//! [Default value] 0
	bool set_retrace_corners(float val) { return setValue("retrace_corners", val); }
	//! Set to > 0.0 if corner retracing should be used for more accurate estimate of GI in corners. Using this option is not recommended.
 	//! [UI Guides] displayName=Retrace threshold, minValue=0.0, maxValue=1e6
 	//! [Default value] 0
	float get_retrace_corners() const { return getFloat("retrace_corners"); }

	//! Maximum number of bounces when retracing corners.
 	//! [UI Guides] enableIf: ?retrace_corners>0.0, displayName=Retrace bounces, minValue=0, maxValue=1000
 	//! [Default value] 10
	bool set_retrace_bounces(int val) { return setValue("retrace_bounces", val); }
	//! Maximum number of bounces when retracing corners.
 	//! [UI Guides] enableIf: ?retrace_corners>0.0, displayName=Retrace bounces, minValue=0, maxValue=1000
 	//! [Default value] 10
	int get_retrace_bounces() const { return getInt("retrace_bounces"); }

	//! True if the calculation phase for the photon map should be displayed.
 	//! [UI Guides] displayName=Show calculation phase
 	//! [Default value] false
	bool set_show_calc_phase(bool val) { return setValue("show_calc_phase", val); }
	//! True if the calculation phase for the photon map should be displayed.
 	//! [UI Guides] displayName=Show calculation phase
 	//! [Default value] false
	bool get_show_calc_phase() const { return getBool("show_calc_phase"); }
};

class SettingsPtexBaker : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "SettingsPtexBaker"; }

	//! A list of SceneNodes that will be baked
 	bool set_objects(const ValueList& pluginList) { return setValue("objects", pluginList); }
	//! A list of SceneNodes that will be baked
 	ValueList get_objects() const { return getValueList("objects"); }

	//! The base name for the Ptex files
 	bool set_texture_name(const char* str) { return setValue("texture_name", str); }
	//! The base name for the Ptex files
 	bool set_texture_name(const std::string& str) { return setValue("texture_name", str); }
	//! The base name for the Ptex files
 	std::string get_texture_name() const { return getString("texture_name"); }

	//! The resolution in the U direction in texture space is 2 ^ res_u.
 	//! [Default value] 8
	bool set_res_u(int val) { return setValue("res_u", val); }
	//! The resolution in the U direction in texture space is 2 ^ res_u.
 	//! [Default value] 8
	int get_res_u() const { return getInt("res_u"); }

	//! The resolution in the V direction in texture space is 2 ^ res_v.
 	//! [Default value] 8
	bool set_res_v(int val) { return setValue("res_v", val); }
	//! The resolution in the V direction in texture space is 2 ^ res_v.
 	//! [Default value] 8
	int get_res_v() const { return getInt("res_v"); }

	//! If true the textures will be quadrangular even if the mesh is purely triangular.
 	//! [Default value] 1
	bool set_force_quads(int val) { return setValue("force_quads", val); }
	//! If true the textures will be quadrangular even if the mesh is purely triangular.
 	//! [Default value] 1
	int get_force_quads() const { return getInt("force_quads"); }

	//! Type of texel data: 0 - 8 bit int, 1 - 16 bit int, 2 - 16 bit float, 3 - 32 bit float
 	//! [UI Guides] enum=0:8 bit int;1:16 bit int;2:16 bit float;3:32 bit float
 	//! [Default value] 3
	bool set_data_format(int val) { return setValue("data_format", val); }
	//! Type of texel data: 0 - 8 bit int, 1 - 16 bit int, 2 - 16 bit float, 3 - 32 bit float
 	//! [UI Guides] enum=0:8 bit int;1:16 bit int;2:16 bit float;3:32 bit float
 	//! [Default value] 3
	int get_data_format() const { return getInt("data_format"); }

	//! If true then meta data containing the degree of each mesh polygon will be included in the Ptex files.
 	//! [Default value] 0
	bool set_write_faces_degrees(int val) { return setValue("write_faces_degrees", val); }
	//! If true then meta data containing the degree of each mesh polygon will be included in the Ptex files.
 	//! [Default value] 0
	int get_write_faces_degrees() const { return getInt("write_faces_degrees"); }

	//! If true then meta data containing the vertices of each mesh polygon will be included in the Ptex files.
 	//! [Default value] 0
	bool set_write_faces_vertices(int val) { return setValue("write_faces_vertices", val); }
	//! If true then meta data containing the vertices of each mesh polygon will be included in the Ptex files.
 	//! [Default value] 0
	int get_write_faces_vertices() const { return getInt("write_faces_vertices"); }

	//! If true then meta data containing the positions of all vertices will be included in the Ptex files.
 	//! [Default value] 0
	bool set_write_vertex_positions(int val) { return setValue("write_vertex_positions", val); }
	//! If true then meta data containing the positions of all vertices will be included in the Ptex files.
 	//! [Default value] 0
	int get_write_vertex_positions() const { return getInt("write_vertex_positions"); }

	//! True to generate mipmaps and false otherwise.
 	//! [Default value] 1
	bool set_generate_mipmaps(int val) { return setValue("generate_mipmaps", val); }
	//! True to generate mipmaps and false otherwise.
 	//! [Default value] 1
	int get_generate_mipmaps() const { return getInt("generate_mipmaps"); }

	//! Type of border mode in U direction: 0 - clamp, 1 - black, 2 - periodic
 	//! [UI Guides] enum=0:Clamp;1:Black;2:Periodic
 	//! [Default value] 0
	bool set_border_mode_u(int val) { return setValue("border_mode_u", val); }
	//! Type of border mode in U direction: 0 - clamp, 1 - black, 2 - periodic
 	//! [UI Guides] enum=0:Clamp;1:Black;2:Periodic
 	//! [Default value] 0
	int get_border_mode_u() const { return getInt("border_mode_u"); }

	//! Type of border mode in V direction: 0 - clamp, 1 - black, 2 - periodic
 	//! [UI Guides] enum=0:Clamp;1:Black;2:Periodic
 	//! [Default value] 0
	bool set_border_mode_v(int val) { return setValue("border_mode_v", val); }
	//! Type of border mode in V direction: 0 - clamp, 1 - black, 2 - periodic
 	//! [UI Guides] enum=0:Clamp;1:Black;2:Periodic
 	//! [Default value] 0
	int get_border_mode_v() const { return getInt("border_mode_v"); }

	//! The number of samples shaded for each texel will be the square of this number.
 	//! [Default value] 1
	bool set_samplers_per_texel(int val) { return setValue("samplers_per_texel", val); }
	//! The number of samples shaded for each texel will be the square of this number.
 	//! [Default value] 1
	int get_samplers_per_texel() const { return getInt("samplers_per_texel"); }

	//! If this is true then all render elements will be baked into one Ptex file.
 	//! [Default value] 1
	bool set_multichannel_file(int val) { return setValue("multichannel_file", val); }
	//! If this is true then all render elements will be baked into one Ptex file.
 	//! [Default value] 1
	int get_multichannel_file() const { return getInt("multichannel_file"); }

	//! An offset along the geometric surface normal at which to perform shading in order to avoid surface acne.
 	//! [Default value] 0.001
	bool set_surface_offset(float val) { return setValue("surface_offset", val); }
	//! An offset along the geometric surface normal at which to perform shading in order to avoid surface acne.
 	//! [Default value] 0.001
	float get_surface_offset() const { return getFloat("surface_offset"); }

	//! If true then the resolution for each texture will be calculated adaptively, based on the size of the corresponding geometry.
 	//! [Default value] 1
	bool set_world_space_res(int val) { return setValue("world_space_res", val); }
	//! If true then the resolution for each texture will be calculated adaptively, based on the size of the corresponding geometry.
 	//! [Default value] 1
	int get_world_space_res() const { return getInt("world_space_res"); }

	//! (description missing)
	//! [Default value] 10
	bool set_length_u(float val) { return setValue("length_u", val); }
	//! (description missing)
	//! [Default value] 10
	float get_length_u() const { return getFloat("length_u"); }

	//! (description missing)
	//! [Default value] 10
	bool set_length_v(float val) { return setValue("length_v", val); }
	//! (description missing)
	//! [Default value] 10
	float get_length_v() const { return getFloat("length_v"); }

	//! (description missing)
	//! [Default value] 1
	bool set_resolution_multiplier(float val) { return setValue("resolution_multiplier", val); }
	//! (description missing)
	//! [Default value] 1
	float get_resolution_multiplier() const { return getFloat("resolution_multiplier"); }

	//! When NOT doing projection baking, whether to shoot rays from the camera (false), or from a point displaced a small distance from the surface normal (true). Default - false - shading rays are shot from the camera
 	//! [Default value] 0
	bool set_camera_independent_shading(int val) { return setValue("camera_independent_shading", val); }
	//! When NOT doing projection baking, whether to shoot rays from the camera (false), or from a point displaced a small distance from the surface normal (true). Default - false - shading rays are shot from the camera
 	//! [Default value] 0
	int get_camera_independent_shading() const { return getInt("camera_independent_shading"); }

	//! 0 - normal baking, 1 - projection baking
 	//! [UI Guides] enum=0:Nnormal;1:Projection
 	//! [Default value] 0
	bool set_projection_baking(int val) { return setValue("projection_baking", val); }
	//! 0 - normal baking, 1 - projection baking
 	//! [UI Guides] enum=0:Nnormal;1:Projection
 	//! [Default value] 0
	int get_projection_baking() const { return getInt("projection_baking"); }

	//! 0 - outside, 1 - inside, 2 - outside first, the inside, 3 - inside first, the outside, 4 - closest
 	//! [UI Guides] enum=0:Outside;1:inside;2:Outside first, the inside;3:Inside first, the outside;4:Closest
 	//! [Default value] 0
	bool set_mode(int val) { return setValue("mode", val); }
	//! 0 - outside, 1 - inside, 2 - outside first, the inside, 3 - inside first, the outside, 4 - closest
 	//! [UI Guides] enum=0:Outside;1:inside;2:Outside first, the inside;3:Inside first, the outside;4:Closest
 	//! [Default value] 0
	int get_mode() const { return getInt("mode"); }

	//! 0 - Smooth normal, 1 - Geometry normal
 	//! [Default value] 0
	bool set_normal(int val) { return setValue("normal", val); }
	//! 0 - Smooth normal, 1 - Geometry normal
 	//! [Default value] 0
	int get_normal() const { return getInt("normal"); }

	//! (description missing)
	//! [Default value] 0
	bool set_ray_offset(float val) { return setValue("ray_offset", val); }
	//! (description missing)
	//! [Default value] 0
	float get_ray_offset() const { return getFloat("ray_offset"); }

	//! Geometry that is intersected further than this value along the ray will be ignored. If the value is zero then no geometry will be ignored.
 	//! [Default value] 0
	bool set_max_depth(float val) { return setValue("max_depth", val); }
	//! Geometry that is intersected further than this value along the ray will be ignored. If the value is zero then no geometry will be ignored.
 	//! [Default value] 0
	float get_max_depth() const { return getFloat("max_depth"); }

	//! Number of rays shoot to test if sample is actually visible or not. Speeds up shading in the case when parts of the model are occluded. Set to 0 to disable.
 	//! [Default value] 32
	bool set_visibility_test_rays(int val) { return setValue("visibility_test_rays", val); }
	//! Number of rays shoot to test if sample is actually visible or not. Speeds up shading in the case when parts of the model are occluded. Set to 0 to disable.
 	//! [Default value] 32
	int get_visibility_test_rays() const { return getInt("visibility_test_rays"); }

	//! Maximum length of visibility test ray. It is adjusted by the sample size. If the ray travels at least this length before hitting another object, the sample is considered visible and is shaded, otherwise it's filled with black when baking to Ptex or entirely ommitted when baking to vrmesh point cloud.
 	//! [Default value] 16
	bool set_visibility_test_ray_max_length_factor(float val) { return setValue("visibility_test_ray_max_length_factor", val); }
	//! Maximum length of visibility test ray. It is adjusted by the sample size. If the ray travels at least this length before hitting another object, the sample is considered visible and is shaded, otherwise it's filled with black when baking to Ptex or entirely ommitted when baking to vrmesh point cloud.
 	//! [Default value] 16
	float get_visibility_test_ray_max_length_factor() const { return getFloat("visibility_test_ray_max_length_factor"); }
};

class SettingsRTEngine : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "SettingsRTEngine"; }

	//! Maximum trace depth for reflections/refractions etc.
 	//! [UI Guides] displayName=Trace depth, minValue=0, maxValue=100
 	//! [Default value] 5
	bool set_trace_depth(int val) { return setValue("trace_depth", val); }
	//! Maximum trace depth for reflections/refractions etc.
 	//! [UI Guides] displayName=Trace depth, minValue=0, maxValue=100
 	//! [Default value] 5
	int get_trace_depth() const { return getInt("trace_depth"); }

	//! Maximum trace depth for GI.
 	//! [UI Guides] displayName=GI depth, minValue=0, maxValue=100
 	//! [Default value] 3
	bool set_gi_depth(int val) { return setValue("gi_depth", val); }
	//! Maximum trace depth for GI.
 	//! [UI Guides] displayName=GI depth, minValue=0, maxValue=100
 	//! [Default value] 3
	int get_gi_depth() const { return getInt("gi_depth"); }

	//! Number of samples to transfer over the network for RT-CPU.
 	//! [UI Guides] displayName=CPU Ray bundle size, minValue=1, maxValue=1024
 	//! [Default value] 64
	bool set_cpu_bundle_size(int val) { return setValue("cpu_bundle_size", val); }
	//! Number of samples to transfer over the network for RT-CPU.
 	//! [UI Guides] displayName=CPU Ray bundle size, minValue=1, maxValue=1024
 	//! [Default value] 64
	int get_cpu_bundle_size() const { return getInt("cpu_bundle_size"); }

	//! Number of samples per pixel for RT-CPU.
 	//! [UI Guides] displayName=CPU Rays per pixel, minValue=1, maxValue=128
 	//! [Default value] 4
	bool set_cpu_samples_per_pixel(int val) { return setValue("cpu_samples_per_pixel", val); }
	//! Number of samples per pixel for RT-CPU.
 	//! [UI Guides] displayName=CPU Rays per pixel, minValue=1, maxValue=128
 	//! [Default value] 4
	int get_cpu_samples_per_pixel() const { return getInt("cpu_samples_per_pixel"); }

	//! Number of samples to transfer over the network for RT-GPU.
 	//! [UI Guides] displayName=GPU Ray bundle size, minValue=1, maxValue=1024
 	//! [Default value] 256
	bool set_gpu_bundle_size(int val) { return setValue("gpu_bundle_size", val); }
	//! Number of samples to transfer over the network for RT-GPU.
 	//! [UI Guides] displayName=GPU Ray bundle size, minValue=1, maxValue=1024
 	//! [Default value] 256
	int get_gpu_bundle_size() const { return getInt("gpu_bundle_size"); }

	//! Number of samples per pixel for RT-GPU.
 	//! [UI Guides] displayName=GPU Rays per pixel, minValue=1, maxValue=128
 	//! [Default value] 16
	bool set_gpu_samples_per_pixel(int val) { return setValue("gpu_samples_per_pixel", val); }
	//! Number of samples per pixel for RT-GPU.
 	//! [UI Guides] displayName=GPU Rays per pixel, minValue=1, maxValue=128
 	//! [Default value] 16
	int get_gpu_samples_per_pixel() const { return getInt("gpu_samples_per_pixel"); }

	//! true to enable coherent tracing of gi/reflections/refractions etc.
 	//! [UI Guides] displayName=Coherent tracing
 	//! [Default value] false
	bool set_coherent_tracing(bool val) { return setValue("coherent_tracing", val); }
	//! true to enable coherent tracing of gi/reflections/refractions etc.
 	//! [UI Guides] displayName=Coherent tracing
 	//! [Default value] false
	bool get_coherent_tracing() const { return getBool("coherent_tracing"); }

	//! Non-zero to enable side-by-side stereo rendering.
 	//! [UI Guides] displayName=Enable stereo
 	//! [Default value] false
	bool set_stereo_mode(bool val) { return setValue("stereo_mode", val); }
	//! Non-zero to enable side-by-side stereo rendering.
 	//! [UI Guides] displayName=Enable stereo
 	//! [Default value] false
	bool get_stereo_mode() const { return getBool("stereo_mode"); }

	//! Distance between the two cameras for stereo mode.
 	//! [UI Guides] displayName=Stereo eye distance
 	//! [Default value] 6.5
	bool set_stereo_eye_distance(float val) { return setValue("stereo_eye_distance", val); }
	//! Distance between the two cameras for stereo mode.
 	//! [UI Guides] displayName=Stereo eye distance
 	//! [Default value] 6.5
	float get_stereo_eye_distance() const { return getFloat("stereo_eye_distance"); }

	//! Focus mode (0 - none, 1 - rotation, 2 - shear)
 	//! [UI Guides] enum=0:None;1:Rotation;2:Shear, displayName=Stereo focus mode
 	//! [Default value] 2
	bool set_stereo_focus(int val) { return setValue("stereo_focus", val); }
	//! Focus mode (0 - none, 1 - rotation, 2 - shear)
 	//! [UI Guides] enum=0:None;1:Rotation;2:Shear, displayName=Stereo focus mode
 	//! [Default value] 2
	int get_stereo_focus() const { return getInt("stereo_focus"); }

	//! OpenCL Single Kernel maximum texture size - bigger textures are scaled to fit this size
 	//! [UI Guides] displayName=GPU Texture Size, minValue=64, maxValue=8192
 	//! [Default value] 512
	bool set_opencl_texsize(int val) { return setValue("opencl_texsize", val); }
	//! OpenCL Single Kernel maximum texture size - bigger textures are scaled to fit this size
 	//! [UI Guides] displayName=GPU Texture Size, minValue=64, maxValue=8192
 	//! [Default value] 512
	int get_opencl_texsize() const { return getInt("opencl_texsize"); }

	//! Textures transfer mode for the GPU
 	//! [UI Guides] enum=0:Transfer "as is" don't resize, don't use paging;1:Resize textures;2:Use texture pagingout-of-core textures CUDA only, displayName=GPU Resize textures
 	//! [Default value] 1
	bool set_opencl_resizeTextures(int val) { return setValue("opencl_resizeTextures", val); }
	//! Textures transfer mode for the GPU
 	//! [UI Guides] enum=0:Transfer "as is" don't resize, don't use paging;1:Resize textures;2:Use texture pagingout-of-core textures CUDA only, displayName=GPU Resize textures
 	//! [Default value] 1
	int get_opencl_resizeTextures() const { return getInt("opencl_resizeTextures"); }

	//! Format for the textures on the GPU (0 - 32-bit float per channel; 1 - 16-bit half float per channel; 2 - 8-bit per channel)
 	//! [UI Guides] enum=0:32-bit float per channel;1:16-bit half float per channel;2:8-bit per channel, displayName=GPU Texture Format
 	//! [Default value] 1
	bool set_opencl_textureFormat(int val) { return setValue("opencl_textureFormat", val); }
	//! Format for the textures on the GPU (0 - 32-bit float per channel; 1 - 16-bit half float per channel; 2 - 8-bit per channel)
 	//! [UI Guides] enum=0:32-bit float per channel;1:16-bit half float per channel;2:8-bit per channel, displayName=GPU Texture Format
 	//! [Default value] 1
	int get_opencl_textureFormat() const { return getInt("opencl_textureFormat"); }

	//! Progressive increase for 'Rays per pixel' (from 1 to real value). Use this for faster feadback.
 	//! [UI Guides] displayName=Progressive rays per pixel
 	//! [Default value] false
	bool set_progressive_samples_per_pixel(bool val) { return setValue("progressive_samples_per_pixel", val); }
	//! Progressive increase for 'Rays per pixel' (from 1 to real value). Use this for faster feadback.
 	//! [UI Guides] displayName=Progressive rays per pixel
 	//! [Default value] false
	bool get_progressive_samples_per_pixel() const { return getBool("progressive_samples_per_pixel"); }

	//! Non-zero to use undersampling, 0 otherwise. The value specifies the blur resolution. Value of n means 1/(2^n) initial resolution in each dimension.
 	//! [UI Guides] displayName=Undersampling, minValue=0, maxValue=5
 	//! [Default value] 4
	bool set_undersampling(int val) { return setValue("undersampling", val); }
	//! Non-zero to use undersampling, 0 otherwise. The value specifies the blur resolution. Value of n means 1/(2^n) initial resolution in each dimension.
 	//! [UI Guides] displayName=Undersampling, minValue=0, maxValue=5
 	//! [Default value] 4
	int get_undersampling() const { return getInt("undersampling"); }

	//! If true, RT will produce only RGBA. Default is false.
 	//! [UI Guides] displayName=Disable render elements
 	//! [Default value] false
	bool set_disable_render_elements(bool val) { return setValue("disable_render_elements", val); }
	//! If true, RT will produce only RGBA. Default is false.
 	//! [UI Guides] displayName=Disable render elements
 	//! [Default value] false
	bool get_disable_render_elements() const { return getBool("disable_render_elements"); }

	//! Max render time (0 = inf)
 	//! [UI Guides] displayName=Max. render time min, minValue=0.0, maxValue=525600.0
 	//! [Default value] 0
	bool set_max_render_time(float val) { return setValue("max_render_time", val); }
	//! Max render time (0 = inf)
 	//! [UI Guides] displayName=Max. render time min, minValue=0.0, maxValue=525600.0
 	//! [Default value] 0
	float get_max_render_time() const { return getFloat("max_render_time"); }

	//! Max paths per pixel (0 = inf)
 	//! [UI Guides] displayName=Max. paths per pixel, minValue=0, maxValue=1e9
 	//! [Default value] 10000
	bool set_max_sample_level(int val) { return setValue("max_sample_level", val); }
	//! Max paths per pixel (0 = inf)
 	//! [UI Guides] displayName=Max. paths per pixel, minValue=0, maxValue=1e9
 	//! [Default value] 10000
	int get_max_sample_level() const { return getInt("max_sample_level"); }

	//! Noise threshold for the image sampler (0 = inf)
 	//! [UI Guides] displayName=Max. noise
 	//! [Default value] 0.001
	bool set_noise_threshold(float val) { return setValue("noise_threshold", val); }
	//! Noise threshold for the image sampler (0 = inf)
 	//! [UI Guides] displayName=Max. noise
 	//! [Default value] 0.001
	float get_noise_threshold() const { return getFloat("noise_threshold"); }

	//! Show aa mask
 	//! [UI Guides] displayName=Show AA mask
 	//! [Default value] false
	bool set_enable_mask(bool val) { return setValue("enable_mask", val); }
	//! Show aa mask
 	//! [UI Guides] displayName=Show AA mask
 	//! [Default value] false
	bool get_enable_mask() const { return getBool("enable_mask"); }

	//! Max time, in milliseconds, between (partial) image updates (0=disable partial image updates)
 	//! [Default value] 0
	bool set_max_draw_interval(int val) { return setValue("max_draw_interval", val); }
	//! Max time, in milliseconds, between (partial) image updates (0=disable partial image updates)
 	//! [Default value] 0
	int get_max_draw_interval() const { return getInt("max_draw_interval"); }

	//! Min time, in milliseconds, between image updates (0=show all frames)
 	//! [Default value] 0
	bool set_min_draw_interval(int val) { return setValue("min_draw_interval", val); }
	//! Min time, in milliseconds, between image updates (0=show all frames)
 	//! [Default value] 0
	int get_min_draw_interval() const { return getInt("min_draw_interval"); }

	//! Flag used to disable some production-only features in interactive mode
 	//! [Default value] 0
	bool set_interactive(int val) { return setValue("interactive", val); }
	//! Flag used to disable some production-only features in interactive mode
 	//! [Default value] 0
	int get_interactive() const { return getInt("interactive"); }

	//! When 1 RT GPU tries to utilize the GPUs with attached displays less. If this is 1, it works best with gpu_samples_per_pixel=1 and gpu_bundle_size=64 (or less)
 	//! [Default value] 0
	bool set_low_gpu_thread_priority(int val) { return setValue("low_gpu_thread_priority", val); }
	//! When 1 RT GPU tries to utilize the GPUs with attached displays less. If this is 1, it works best with gpu_samples_per_pixel=1 and gpu_bundle_size=64 (or less)
 	//! [Default value] 0
	int get_low_gpu_thread_priority() const { return getInt("low_gpu_thread_priority"); }
};

class SettingsRaycaster : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "SettingsRaycaster"; }

	//! Max. tree depth
 	//! [UI Guides] displayName=Max tree depth, minValue=1
 	//! [Default value] 60
	bool set_maxLevels(int val) { return setValue("maxLevels", val); }
	//! Max. tree depth
 	//! [UI Guides] displayName=Max tree depth, minValue=1
 	//! [Default value] 60
	int get_maxLevels() const { return getInt("maxLevels"); }

	//! Min. voxel size
 	//! [UI Guides] displayName=Min leaf size, quantityType=distance, minValue=0.0, maxValue=100.0
 	//! [Default value] 0
	bool set_minLeafSize(float val) { return setValue("minLeafSize", val); }
	//! Min. voxel size
 	//! [UI Guides] displayName=Min leaf size, quantityType=distance, minValue=0.0, maxValue=100.0
 	//! [Default value] 0
	float get_minLeafSize() const { return getFloat("minLeafSize"); }

	//! Balance coefficient between depth and faces per voxel
 	//! [UI Guides] displayName=Face/level coeff, minValue=0.0, maxValue=100.0
 	//! [Default value] 2
	bool set_faceLevelCoef(float val) { return setValue("faceLevelCoef", val); }
	//! Balance coefficient between depth and faces per voxel
 	//! [UI Guides] displayName=Face/level coeff, minValue=0.0, maxValue=100.0
 	//! [Default value] 2
	float get_faceLevelCoef() const { return getFloat("faceLevelCoef"); }

	//! Limit for dynamic geometry, in megabytes. 0 means no limit. Negative numbers mean the amount of physical RAM with the negative number added to it.
 	//! [UI Guides] displayName=Dyn. memory limitMBs
 	//! [Default value] 4000
	bool set_dynMemLimit(int val) { return setValue("dynMemLimit", val); }
	//! Limit for dynamic geometry, in megabytes. 0 means no limit. Negative numbers mean the amount of physical RAM with the negative number added to it.
 	//! [UI Guides] displayName=Dyn. memory limitMBs
 	//! [Default value] 4000
	int get_dynMemLimit() const { return getInt("dynMemLimit"); }

	//! Optimization level (must be 0)
 	//! [UI Guides] displayName=Tree build quality, enum=0:Low; 2:Average; 4:High
 	//! [Default value] 0
	bool set_optLevel(int val) { return setValue("optLevel", val); }
	//! Optimization level (must be 0)
 	//! [UI Guides] displayName=Tree build quality, enum=0:Low; 2:Average; 4:High
 	//! [Default value] 0
	int get_optLevel() const { return getInt("optLevel"); }

	//! Enable/Disable using the Embree ray caster.
 	//! [UI Guides] displayName=Use Embree
 	//! [Default value] false
	bool set_embreeUse(bool val) { return setValue("embreeUse", val); }
	//! Enable/Disable using the Embree ray caster.
 	//! [UI Guides] displayName=Use Embree
 	//! [Default value] false
	bool get_embreeUse() const { return getBool("embreeUse"); }

	//! Enable/Disable using the Embree ray caster for motion blur.
 	//! [UI Guides] enableIf: ?embreeUse!=0, displayName=Use Embree for Motion Blur
 	//! [Default value] true
	bool set_embreeUseMB(bool val) { return setValue("embreeUseMB", val); }
	//! Enable/Disable using the Embree ray caster for motion blur.
 	//! [UI Guides] enableIf: ?embreeUse!=0, displayName=Use Embree for Motion Blur
 	//! [Default value] true
	bool get_embreeUseMB() const { return getBool("embreeUseMB"); }

	//! Enable/Disable the Embree ray caster for hair.
 	//! [UI Guides] enableIf: ?embreeUse!=0, displayName=Use Embree for hair
 	//! [Default value] true
	bool set_embreeHair(bool val) { return setValue("embreeHair", val); }
	//! Enable/Disable the Embree ray caster for hair.
 	//! [UI Guides] enableIf: ?embreeUse!=0, displayName=Use Embree for hair
 	//! [Default value] true
	bool get_embreeHair() const { return getBool("embreeHair"); }

	//! Try to conserve memory, using potentially slower algorithms.
 	//! [UI Guides] enableIf: ?embreeUse!=0, displayName=Conserve Memory
 	//! [Default value] false
	bool set_embreeLowMemory(bool val) { return setValue("embreeLowMemory", val); }
	//! Try to conserve memory, using potentially slower algorithms.
 	//! [UI Guides] enableIf: ?embreeUse!=0, displayName=Conserve Memory
 	//! [Default value] false
	bool get_embreeLowMemory() const { return getBool("embreeLowMemory"); }

	//! Turn on the packet ray casting.
 	//! [UI Guides] enableIf: ?embreeUse!=0, displayName=Use Ray Packets
 	//! [Default value] false
	bool set_embreeRayPackets(bool val) { return setValue("embreeRayPackets", val); }
	//! Turn on the packet ray casting.
 	//! [UI Guides] enableIf: ?embreeUse!=0, displayName=Use Ray Packets
 	//! [Default value] false
	bool get_embreeRayPackets() const { return getBool("embreeRayPackets"); }
};

class SettingsRegionsGenerator : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "SettingsRegionsGenerator"; }

	//! Max. width
 	//! [Default value] 48
	bool set_xc(int val) { return setValue("xc", val); }
	//! Max. width
 	//! [Default value] 48
	int get_xc() const { return getInt("xc"); }

	//! Max. height
 	//! [Default value] 48
	bool set_yc(int val) { return setValue("yc", val); }
	//! Max. height
 	//! [Default value] 48
	int get_yc() const { return getInt("yc"); }

	//! Size in pixels or number of regions
 	//! [UI Guides] displayName=Size in pixels or number of regions; enum=0: Size in pixels; 1: Number of regions
 	//! [Default value] 0
	bool set_xymeans(int val) { return setValue("xymeans", val); }
	//! Size in pixels or number of regions
 	//! [UI Guides] displayName=Size in pixels or number of regions; enum=0: Size in pixels; 1: Number of regions
 	//! [Default value] 0
	int get_xymeans() const { return getInt("xymeans"); }

	//! Sequence type
 	//! [UI Guides] enum=0: Top-Bottom; 1: Left-Right; 2: Checker; 3: Spiral; 4: Triangulation; 5: Hilbert curve; 6: Random;
 	//! [Default value] 4
	bool set_seqtype(int val) { return setValue("seqtype", val); }
	//! Sequence type
 	//! [UI Guides] enum=0: Top-Bottom; 1: Left-Right; 2: Checker; 3: Spiral; 4: Triangulation; 5: Hilbert curve; 6: Random;
 	//! [Default value] 4
	int get_seqtype() const { return getInt("seqtype"); }

	//! (description missing)
	//! [Default value] false
	bool set_reverse(bool val) { return setValue("reverse", val); }
	//! (description missing)
	//! [Default value] false
	bool get_reverse() const { return getBool("reverse"); }

	//! (description missing)
	//! [Default value] true
	bool set_dynbuckets(bool val) { return setValue("dynbuckets", val); }
	//! (description missing)
	//! [Default value] true
	bool get_dynbuckets() const { return getBool("dynbuckets"); }
};

class SettingsRenderChannels : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "SettingsRenderChannels"; }

	//! Determines which fragment to use for unfiltered render elements (0 - best coverage; 1 - closest to camera).
 	//! [UI Guides] enum=0:Best coverage;1:Closest to camera
 	//! [Default value] 0
	bool set_unfiltered_fragment_method(int val) { return setValue("unfiltered_fragment_method", val); }
	//! Determines which fragment to use for unfiltered render elements (0 - best coverage; 1 - closest to camera).
 	//! [UI Guides] enum=0:Best coverage;1:Closest to camera
 	//! [Default value] 0
	int get_unfiltered_fragment_method() const { return getInt("unfiltered_fragment_method"); }

	//! Determines how to blend fragments within a pixel (0 - by render ID; 1 - by Z-Depth, 2 - none).
 	//! [UI Guides] enum=0:By render ID;1:By z-depth;2:None
 	//! [Default value] 0
	bool set_deep_merge_mode(int val) { return setValue("deep_merge_mode", val); }
	//! Determines how to blend fragments within a pixel (0 - by render ID; 1 - by Z-Depth, 2 - none).
 	//! [UI Guides] enum=0:By render ID;1:By z-depth;2:None
 	//! [Default value] 0
	int get_deep_merge_mode() const { return getInt("deep_merge_mode"); }

	//! Determines the z-depth blending sensitivity when deep_merge_mode is 1.
 	//! [UI Guides] displayName=Deep merge z-depth threshold, minValue=0.0, enableIf: ?deep_merge_mode=1
 	//! [Default value] 1
	bool set_deep_merge_coeff(float val) { return setValue("deep_merge_coeff", val); }
	//! Determines the z-depth blending sensitivity when deep_merge_mode is 1.
 	//! [UI Guides] displayName=Deep merge z-depth threshold, minValue=0.0, enableIf: ?deep_merge_mode=1
 	//! [Default value] 1
	float get_deep_merge_coeff() const { return getFloat("deep_merge_coeff"); }
};

class SettingsSGI : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "SettingsSGI"; }

	//! Bits per channel (8 or 16)
 	//! [Default value] 8
	bool set_bits_per_channel(int val) { return setValue("bits_per_channel", val); }
	//! Bits per channel (8 or 16)
 	//! [Default value] 8
	int get_bits_per_channel() const { return getInt("bits_per_channel"); }
};

class SettingsTGA : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "SettingsTGA"; }

	//! Compression type for TGA output
 	//! [Default value] 2
	bool set_compression(int val) { return setValue("compression", val); }
	//! Compression type for TGA output
 	//! [Default value] 2
	int get_compression() const { return getInt("compression"); }
};

class SettingsTIFF : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "SettingsTIFF"; }

	//! Bits per channel (8, 16 bit fixed or 32-bit floating point)
 	//! [Default value] 32
	bool set_bits_per_channel(int val) { return setValue("bits_per_channel", val); }
	//! Bits per channel (8, 16 bit fixed or 32-bit floating point)
 	//! [Default value] 32
	int get_bits_per_channel() const { return getInt("bits_per_channel"); }

	//! If true, the TIFF color channels will be written interleaved (RGBRGB instead of RRGGBB)
 	//! [Default value] false
	bool set_interleaved(bool val) { return setValue("interleaved", val); }
	//! If true, the TIFF color channels will be written interleaved (RGBRGB instead of RRGGBB)
 	//! [Default value] false
	bool get_interleaved() const { return getBool("interleaved"); }
};

class SettingsTextureCache : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "SettingsTextureCache"; }

	//! Texture cache size. This parameter is set as value of envirment variable VRAY_TEXTURE_CACHE before renderBegin.
 	//! [Default value] 0
	bool set_cache_size(int val) { return setValue("cache_size", val); }
	//! Texture cache size. This parameter is set as value of envirment variable VRAY_TEXTURE_CACHE before renderBegin.
 	//! [Default value] 0
	int get_cache_size() const { return getInt("cache_size"); }
};

class SettingsUnitsInfo : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "SettingsUnitsInfo"; }

	//! The number by which a 3d distance must be multiplied to convert it into meters.
 	//! [Default value] 1
	bool set_meters_scale(float val) { return setValue("meters_scale", val); }
	//! The number by which a 3d distance must be multiplied to convert it into meters.
 	//! [Default value] 1
	float get_meters_scale() const { return getFloat("meters_scale"); }

	//! The number by which the power of photometric lights should be scaled when rendering.
 	//! [Default value] 0.001
	bool set_photometric_scale(float val) { return setValue("photometric_scale", val); }
	//! The number by which the power of photometric lights should be scaled when rendering.
 	//! [Default value] 0.001
	float get_photometric_scale() const { return getFloat("photometric_scale"); }

	//! The 'up' direction for the scene.
 	//! [Default value] Vector(0, 0, 1)
	bool set_scene_upDir(const Vector& vector) { return setValue("scene_upDir", vector); }
	//! The 'up' direction for the scene.
 	//! [Default value] Vector(0, 0, 1)
	Vector get_scene_upDir() const { return getVector("scene_upDir"); }

	//! The number by which a scene time unit must be multiplied to convert it to seconds.
 	//! [Default value] 1
	bool set_seconds_scale(float val) { return setValue("seconds_scale", val); }
	//! The number by which a scene time unit must be multiplied to convert it to seconds.
 	//! [Default value] 1
	float get_seconds_scale() const { return getFloat("seconds_scale"); }

	//! Frames per second, equal to 1/seconds_scale. If it is 0, then seconds_scale is used instead.
 	//! [Default value] 0
	bool set_frames_scale(float val) { return setValue("frames_scale", val); }
	//! Frames per second, equal to 1/seconds_scale. If it is 0, then seconds_scale is used instead.
 	//! [Default value] 0
	float get_frames_scale() const { return getFloat("frames_scale"); }

	//! The RGB color space of the renderer, used for the sun and sky (0 - legacy CIE RGB, 1 - sRGB)
 	//! [Default value] 0
	bool set_rgb_color_space(int val) { return setValue("rgb_color_space", val); }
	//! The RGB color space of the renderer, used for the sun and sky (0 - legacy CIE RGB, 1 - sRGB)
 	//! [Default value] 0
	int get_rgb_color_space() const { return getInt("rgb_color_space"); }
};

class SettingsVFB : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "SettingsVFB"; }

	//! (description missing)
	//! [Default value] false
	bool set_bloom_on(bool val) { return setValue("bloom_on", val); }
	//! (description missing)
	//! [Default value] false
	bool get_bloom_on() const { return getBool("bloom_on"); }

	//! (description missing)
	//! [Default value] true
	bool set_bloom_fill_edges(bool val) { return setValue("bloom_fill_edges", val); }
	//! (description missing)
	//! [Default value] true
	bool get_bloom_fill_edges() const { return getBool("bloom_fill_edges"); }

	//! (description missing)
	//! [Default value] 15
	bool set_bloom_weight(float val) { return setValue("bloom_weight", val); }
	//! (description missing)
	//! [Default value] 15
	float get_bloom_weight() const { return getFloat("bloom_weight"); }

	//! (description missing)
	//! [Default value] 15
	bool set_bloom_size(float val) { return setValue("bloom_size", val); }
	//! (description missing)
	//! [Default value] 15
	float get_bloom_size() const { return getFloat("bloom_size"); }

	//! (description missing)
	//! [Default value] 4
	bool set_bloom_shape(float val) { return setValue("bloom_shape", val); }
	//! (description missing)
	//! [Default value] 4
	float get_bloom_shape() const { return getFloat("bloom_shape"); }

	//! 0-image 1-image and buffer  2-buffer
 	//! [Default value] 0
	bool set_bloom_mode(int val) { return setValue("bloom_mode", val); }
	//! 0-image 1-image and buffer  2-buffer
 	//! [Default value] 0
	int get_bloom_mode() const { return getInt("bloom_mode"); }

	//! (description missing)
	//! [Default value] false
	bool set_bloom_mask_intensity_on(bool val) { return setValue("bloom_mask_intensity_on", val); }
	//! (description missing)
	//! [Default value] false
	bool get_bloom_mask_intensity_on() const { return getBool("bloom_mask_intensity_on"); }

	//! (description missing)
	//! [Default value] 3
	bool set_bloom_mask_intensity(float val) { return setValue("bloom_mask_intensity", val); }
	//! (description missing)
	//! [Default value] 3
	float get_bloom_mask_intensity() const { return getFloat("bloom_mask_intensity"); }

	//! (description missing)
	//! [Default value] false
	bool set_bloom_mask_objid_on(bool val) { return setValue("bloom_mask_objid_on", val); }
	//! (description missing)
	//! [Default value] false
	bool get_bloom_mask_objid_on() const { return getBool("bloom_mask_objid_on"); }

	//! (description missing)
	//! [Default value] 0
	bool set_bloom_mask_objid(int val) { return setValue("bloom_mask_objid", val); }
	//! (description missing)
	//! [Default value] 0
	int get_bloom_mask_objid() const { return getInt("bloom_mask_objid"); }

	//! (description missing)
	//! [Default value] false
	bool set_bloom_mask_mtlid_on(bool val) { return setValue("bloom_mask_mtlid_on", val); }
	//! (description missing)
	//! [Default value] false
	bool get_bloom_mask_mtlid_on() const { return getBool("bloom_mask_mtlid_on"); }

	//! (description missing)
	//! [Default value] 0
	bool set_bloom_mask_mtlid(int val) { return setValue("bloom_mask_mtlid", val); }
	//! (description missing)
	//! [Default value] 0
	int get_bloom_mask_mtlid() const { return getInt("bloom_mask_mtlid"); }

	//! (description missing)
	//! [Default value] false
	bool set_glare_on(bool val) { return setValue("glare_on", val); }
	//! (description missing)
	//! [Default value] false
	bool get_glare_on() const { return getBool("glare_on"); }

	//! (description missing)
	//! [Default value] true
	bool set_glare_fill_edges(bool val) { return setValue("glare_fill_edges", val); }
	//! (description missing)
	//! [Default value] true
	bool get_glare_fill_edges() const { return getBool("glare_fill_edges"); }

	//! (description missing)
	//! [Default value] 30
	bool set_glare_weight(float val) { return setValue("glare_weight", val); }
	//! (description missing)
	//! [Default value] 30
	float get_glare_weight() const { return getFloat("glare_weight"); }

	//! (description missing)
	//! [Default value] 10
	bool set_glare_size(float val) { return setValue("glare_size", val); }
	//! (description missing)
	//! [Default value] 10
	float get_glare_size() const { return getFloat("glare_size"); }

	//! 0- from image  1 - from render camera  2 - from camera params
 	//! [Default value] 2
	bool set_glare_type(int val) { return setValue("glare_type", val); }
	//! 0- from image  1 - from render camera  2 - from camera params
 	//! [Default value] 2
	int get_glare_type() const { return getInt("glare_type"); }

	//! 0-image 1-image and buffer  2-buffer
 	//! [Default value] 0
	bool set_glare_mode(int val) { return setValue("glare_mode", val); }
	//! 0-image 1-image and buffer  2-buffer
 	//! [Default value] 0
	int get_glare_mode() const { return getInt("glare_mode"); }

	//! (description missing)
	bool set_glare_image_path(const char* str) { return setValue("glare_image_path", str); }
	//! (description missing)
	bool set_glare_image_path(const std::string& str) { return setValue("glare_image_path", str); }
	//! (description missing)
	std::string get_glare_image_path() const { return getString("glare_image_path"); }

	//! (description missing)
	bool set_glare_obstacle_image_path(const char* str) { return setValue("glare_obstacle_image_path", str); }
	//! (description missing)
	bool set_glare_obstacle_image_path(const std::string& str) { return setValue("glare_obstacle_image_path", str); }
	//! (description missing)
	std::string get_glare_obstacle_image_path() const { return getString("glare_obstacle_image_path"); }

	//! (description missing)
	//! [Default value] false
	bool set_glare_diffraction_on(bool val) { return setValue("glare_diffraction_on", val); }
	//! (description missing)
	//! [Default value] false
	bool get_glare_diffraction_on() const { return getBool("glare_diffraction_on"); }

	//! (description missing)
	//! [Default value] false
	bool set_glare_use_obstacle_image(bool val) { return setValue("glare_use_obstacle_image", val); }
	//! (description missing)
	//! [Default value] false
	bool get_glare_use_obstacle_image() const { return getBool("glare_use_obstacle_image"); }

	//! (description missing)
	//! [Default value] true
	bool set_glare_cam_blades_on(bool val) { return setValue("glare_cam_blades_on", val); }
	//! (description missing)
	//! [Default value] true
	bool get_glare_cam_blades_on() const { return getBool("glare_cam_blades_on"); }

	//! (description missing)
	//! [Default value] 6
	bool set_glare_cam_num_blades(int val) { return setValue("glare_cam_num_blades", val); }
	//! (description missing)
	//! [Default value] 6
	int get_glare_cam_num_blades() const { return getInt("glare_cam_num_blades"); }

	//! Rotation in degrees from 0.0 - 360.0
 	//! [Default value] 15
	bool set_glare_cam_rotation(float val) { return setValue("glare_cam_rotation", val); }
	//! Rotation in degrees from 0.0 - 360.0
 	//! [Default value] 15
	float get_glare_cam_rotation() const { return getFloat("glare_cam_rotation"); }

	//! (description missing)
	//! [Default value] 8
	bool set_glare_cam_fnumber(float val) { return setValue("glare_cam_fnumber", val); }
	//! (description missing)
	//! [Default value] 8
	float get_glare_cam_fnumber() const { return getFloat("glare_cam_fnumber"); }

	//! (description missing)
	//! [Default value] false
	bool set_glare_mask_intensity_on(bool val) { return setValue("glare_mask_intensity_on", val); }
	//! (description missing)
	//! [Default value] false
	bool get_glare_mask_intensity_on() const { return getBool("glare_mask_intensity_on"); }

	//! (description missing)
	//! [Default value] 3
	bool set_glare_mask_intensity(float val) { return setValue("glare_mask_intensity", val); }
	//! (description missing)
	//! [Default value] 3
	float get_glare_mask_intensity() const { return getFloat("glare_mask_intensity"); }

	//! (description missing)
	//! [Default value] false
	bool set_glare_mask_objid_on(bool val) { return setValue("glare_mask_objid_on", val); }
	//! (description missing)
	//! [Default value] false
	bool get_glare_mask_objid_on() const { return getBool("glare_mask_objid_on"); }

	//! (description missing)
	//! [Default value] 0
	bool set_glare_mask_objid(int val) { return setValue("glare_mask_objid", val); }
	//! (description missing)
	//! [Default value] 0
	int get_glare_mask_objid() const { return getInt("glare_mask_objid"); }

	//! (description missing)
	//! [Default value] false
	bool set_glare_mask_mtlid_on(bool val) { return setValue("glare_mask_mtlid_on", val); }
	//! (description missing)
	//! [Default value] false
	bool get_glare_mask_mtlid_on() const { return getBool("glare_mask_mtlid_on"); }

	//! (description missing)
	//! [Default value] 0
	bool set_glare_mask_mtlid(int val) { return setValue("glare_mask_mtlid", val); }
	//! (description missing)
	//! [Default value] 0
	int get_glare_mask_mtlid() const { return getInt("glare_mask_mtlid"); }

	//! (description missing)
	//! [Default value] true
	bool set_interactive(bool val) { return setValue("interactive", val); }
	//! (description missing)
	//! [Default value] true
	bool get_interactive() const { return getBool("interactive"); }

	//! When this is 1, V-Ray will try to apply the lens effects using the best OpenCL device it can find. If there is no such (or error occures), it will fallback to a CPU implementation0
 	//! [Default value] true
	bool set_hardware_accelerated(bool val) { return setValue("hardware_accelerated", val); }
	//! When this is 1, V-Ray will try to apply the lens effects using the best OpenCL device it can find. If there is no such (or error occures), it will fallback to a CPU implementation0
 	//! [Default value] true
	bool get_hardware_accelerated() const { return getBool("hardware_accelerated"); }

	//! 0 - sRGB is ON, 1 - sRGB is OFF.
 	//! [Default value] true
	bool set_display_srgb(bool val) { return setValue("display_srgb", val); }
	//! 0 - sRGB is ON, 1 - sRGB is OFF.
 	//! [Default value] true
	bool get_display_srgb() const { return getBool("display_srgb"); }
};

class SettingsVFBChannels : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "SettingsVFBChannels"; }

	//! A list of strings that represent render channel names. There are too many to list here - see pixelbuffer.h for the list of RegionChannelAlias items that are available for the vfb
 	bool set_channel_names(const ValueList& stringList) { return setValue("channel_names", stringList); }
	//! A list of strings that represent render channel names. There are too many to list here - see pixelbuffer.h for the list of RegionChannelAlias items that are available for the vfb
 	ValueList get_channel_names() const { return getValueList("channel_names"); }

	//! Where the black color starts in zdepth
 	//! [Default value] 0.001
	bool set_zdepth_black(float val) { return setValue("zdepth_black", val); }
	//! Where the black color starts in zdepth
 	//! [Default value] 0.001
	float get_zdepth_black() const { return getFloat("zdepth_black"); }

	//! Where the white color starts in zdepth
 	//! [Default value] 1500
	bool set_zdepth_white(float val) { return setValue("zdepth_white", val); }
	//! Where the white color starts in zdepth
 	//! [Default value] 1500
	float get_zdepth_white() const { return getFloat("zdepth_white"); }

	//! whether we should clamp between near and far or allow outliers
 	//! [Default value] false
	bool set_zdepth_clamp(bool val) { return setValue("zdepth_clamp", val); }
	//! whether we should clamp between near and far or allow outliers
 	//! [Default value] false
	bool get_zdepth_clamp() const { return getBool("zdepth_clamp"); }
};

class SettingsVRST : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "SettingsVRST"; }

	//! Compression for VRST/VRSM output (0 - default, 1 - ZIP)
 	//! [Default value] 1
	bool set_compression(int val) { return setValue("compression", val); }
	//! Compression for VRST/VRSM output (0 - default, 1 - ZIP)
 	//! [Default value] 1
	int get_compression() const { return getInt("compression"); }

	//! Bits per channel (16 or 32)
 	//! [Default value] 16
	bool set_bits_per_channel(int val) { return setValue("bits_per_channel", val); }
	//! Bits per channel (16 or 32)
 	//! [Default value] 16
	int get_bits_per_channel() const { return getInt("bits_per_channel"); }
};

class SettingsVertexBaker : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "SettingsVertexBaker"; }

	//! (description missing)
	bool set_objects(const ValueList& pluginList) { return setValue("objects", pluginList); }
	//! (description missing)
	ValueList get_objects() const { return getValueList("objects"); }

	//! (description missing)
	bool set_color_set_name(const char* str) { return setValue("color_set_name", str); }
	//! (description missing)
	bool set_color_set_name(const std::string& str) { return setValue("color_set_name", str); }
	//! (description missing)
	std::string get_color_set_name() const { return getString("color_set_name"); }

	//! (description missing)
	//! [Default value] 1
	bool set_bake_rgb_color(int val) { return setValue("bake_rgb_color", val); }
	//! (description missing)
	//! [Default value] 1
	int get_bake_rgb_color() const { return getInt("bake_rgb_color"); }

	//! (description missing)
	//! [Default value] 1
	bool set_bake_alpha(int val) { return setValue("bake_alpha", val); }
	//! (description missing)
	//! [Default value] 1
	int get_bake_alpha() const { return getInt("bake_alpha"); }
};

class SphereFade : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "SphereFade"; }

	//! List of gizmos
 	bool set_gizmos(const ValueList& pluginList) { return setValue("gizmos", pluginList); }
	//! List of gizmos
 	ValueList get_gizmos() const { return getValueList("gizmos"); }

	//! (description missing)
	//! [Default value] Color(0.5, 0.5, 0.5)
	bool set_empty_color(const Color& color) { return setValue("empty_color", color); }
	//! (description missing)
	//! [Default value] Color(0.5, 0.5, 0.5)
	Color get_empty_color() const { return getColor("empty_color"); }

	//! (description missing)
	//! [Default value] false
	bool set_affect_alpha(bool val) { return setValue("affect_alpha", val); }
	//! (description missing)
	//! [Default value] false
	bool get_affect_alpha() const { return getBool("affect_alpha"); }

	//! (description missing)
	//! [Default value] 0.2
	bool set_falloff(float val) { return setValue("falloff", val); }
	//! (description missing)
	//! [Default value] 0.2
	float get_falloff() const { return getFloat("falloff"); }
};

class SphereFadeGizmo : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "SphereFadeGizmo"; }

	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	bool set_transform(const Transform& transform) { return setValue("transform", transform); }
	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	Transform get_transform() const { return getTransform("transform"); }

	//! (description missing)
	//! [Default value] 1
	bool set_radius(float val) { return setValue("radius", val); }
	//! (description missing)
	//! [Default value] 1
	float get_radius() const { return getFloat("radius"); }

	//! (description missing)
	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! (description missing)
	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! (description missing)
	//! [Default value] 0
	bool set_shape(int val) { return setValue("shape", val); }
	//! (description missing)
	//! [Default value] 0
	int get_shape() const { return getInt("shape"); }
};

class SphericalHarmonicsExporter : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "SphericalHarmonicsExporter"; }

	//! (description missing)
	//! [Default value] false
	bool set_anim_on(bool val) { return setValue("anim_on", val); }
	//! (description missing)
	//! [Default value] false
	bool get_anim_on() const { return getBool("anim_on"); }

	//! (description missing)
	//! [Default value] 0
	bool set_mode(int val) { return setValue("mode", val); }
	//! (description missing)
	//! [Default value] 0
	int get_mode() const { return getInt("mode"); }

	//! (description missing)
	//! [Default value] 4
	bool set_bands(int val) { return setValue("bands", val); }
	//! (description missing)
	//! [Default value] 4
	int get_bands() const { return getInt("bands"); }

	//! (description missing)
	//! [Default value] 50
	bool set_subdivs(int val) { return setValue("subdivs", val); }
	//! (description missing)
	//! [Default value] 50
	int get_subdivs() const { return getInt("subdivs"); }

	//! (description missing)
	//! [Default value] 1
	bool set_bounces(int val) { return setValue("bounces", val); }
	//! (description missing)
	//! [Default value] 1
	int get_bounces() const { return getInt("bounces"); }

	//! (description missing)
	//! [Default value] 0.001
	bool set_ray_bias(float val) { return setValue("ray_bias", val); }
	//! (description missing)
	//! [Default value] 0.001
	float get_ray_bias() const { return getFloat("ray_bias"); }

	//! [UI Guides] fileAsset=vrsh;xml
 	//! [Default value] C:\temp
	bool set_file_name(const char* str) { return setValue("file_name", str); }
	//! [UI Guides] fileAsset=vrsh;xml
 	//! [Default value] C:\temp
	bool set_file_name(const std::string& str) { return setValue("file_name", str); }
	//! [UI Guides] fileAsset=vrsh;xml
 	//! [Default value] C:\temp
	std::string get_file_name() const { return getString("file_name"); }

	//! (description missing)
	//! [Default value] 0
	bool set_file_format(int val) { return setValue("file_format", val); }
	//! (description missing)
	//! [Default value] 0
	int get_file_format() const { return getInt("file_format"); }

	//! (description missing)
	//! [Default value] false
	bool set_per_normal(bool val) { return setValue("per_normal", val); }
	//! (description missing)
	//! [Default value] false
	bool get_per_normal() const { return getBool("per_normal"); }

	//! (description missing)
	//! [Default value] false
	bool set_hit_recording(bool val) { return setValue("hit_recording", val); }
	//! (description missing)
	//! [Default value] false
	bool get_hit_recording() const { return getBool("hit_recording"); }

	//! (description missing)
	//! [Default value] 2000
	bool set_max_mem_usage(int val) { return setValue("max_mem_usage", val); }
	//! (description missing)
	//! [Default value] 2000
	int get_max_mem_usage() const { return getInt("max_mem_usage"); }

	//! (description missing)
	//! [Default value] false
	bool set_object_space(bool val) { return setValue("object_space", val); }
	//! (description missing)
	//! [Default value] false
	bool get_object_space() const { return getBool("object_space"); }

	//! (description missing)
	//! [Default value] false
	bool set_adaptive_on(bool val) { return setValue("adaptive_on", val); }
	//! (description missing)
	//! [Default value] false
	bool get_adaptive_on() const { return getBool("adaptive_on"); }

	//! (description missing)
	//! [Default value] 0.1
	bool set_adaptive_thresh(float val) { return setValue("adaptive_thresh", val); }
	//! (description missing)
	//! [Default value] 0.1
	float get_adaptive_thresh() const { return getFloat("adaptive_thresh"); }

	//! (description missing)
	//! [Default value] 3
	bool set_adaptive_depth(int val) { return setValue("adaptive_depth", val); }
	//! (description missing)
	//! [Default value] 3
	int get_adaptive_depth() const { return getInt("adaptive_depth"); }

	//! (description missing)
	//! [Default value] 0.1
	bool set_adaptive_edge(float val) { return setValue("adaptive_edge", val); }
	//! (description missing)
	//! [Default value] 0.1
	float get_adaptive_edge() const { return getFloat("adaptive_edge"); }

	//! (description missing)
	//! [Default value] false
	bool set_save_obj(bool val) { return setValue("save_obj", val); }
	//! (description missing)
	//! [Default value] false
	bool get_save_obj() const { return getBool("save_obj"); }

	//! Node of the mesh
 	bool set_node(const Plugin& plugin) { return setValue("node", plugin); }
	//! Node of the mesh
 	Plugin get_node() const { return getPlugin("node"); }
};

class SphericalHarmonicsRenderer : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "SphericalHarmonicsRenderer"; }

	//! [UI Guides] fileAsset=vrsh;xml
 	//! [Default value] C:\temp
	bool set_file_name(const char* str) { return setValue("file_name", str); }
	//! [UI Guides] fileAsset=vrsh;xml
 	//! [Default value] C:\temp
	bool set_file_name(const std::string& str) { return setValue("file_name", str); }
	//! [UI Guides] fileAsset=vrsh;xml
 	//! [Default value] C:\temp
	std::string get_file_name() const { return getString("file_name"); }

	//! (description missing)
	//! [Default value] 1
	bool set_use_single_vrsh(int val) { return setValue("use_single_vrsh", val); }
	//! (description missing)
	//! [Default value] 1
	int get_use_single_vrsh() const { return getInt("use_single_vrsh"); }

	//! (description missing)
	//! [Default value] 1
	bool set_precalc_light_per_frame(int val) { return setValue("precalc_light_per_frame", val); }
	//! (description missing)
	//! [Default value] 1
	int get_precalc_light_per_frame() const { return getInt("precalc_light_per_frame"); }

	//! (description missing)
	//! [Default value] 1
	bool set_sample_environment(int val) { return setValue("sample_environment", val); }
	//! (description missing)
	//! [Default value] 1
	int get_sample_environment() const { return getInt("sample_environment"); }

	//! (description missing)
	//! [Default value] 1
	bool set_is_hemispherical(int val) { return setValue("is_hemispherical", val); }
	//! (description missing)
	//! [Default value] 1
	int get_is_hemispherical() const { return getInt("is_hemispherical"); }

	//! (description missing)
	//! [Default value] 30
	bool set_subdivs(int val) { return setValue("subdivs", val); }
	//! (description missing)
	//! [Default value] 30
	int get_subdivs() const { return getInt("subdivs"); }

	//! (description missing)
	//! [Default value] 0
	bool set_apply_filtering(int val) { return setValue("apply_filtering", val); }
	//! (description missing)
	//! [Default value] 0
	int get_apply_filtering() const { return getInt("apply_filtering"); }

	//! (description missing)
	//! [Default value] 0.5
	bool set_filter_strength(float val) { return setValue("filter_strength", val); }
	//! (description missing)
	//! [Default value] 0.5
	float get_filter_strength() const { return getFloat("filter_strength"); }
};

class SunLight : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "SunLight"; }

	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	bool set_transform(const Transform& transform) { return setValue("transform", transform); }
	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	Transform get_transform() const { return getTransform("transform"); }

	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	bool set_target_transform(const Transform& transform) { return setValue("target_transform", transform); }
	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	Transform get_target_transform() const { return getTransform("target_transform"); }

	//! Determines the amount of dust in the air and affects the color of the sun and sky. Smaller values produce a clear/blue sky, larger values yellow and orange
 	//! [UI Guides] minValue=2, maxValue=20
 	//! [Default value] 3
	bool set_turbidity(float val) { return setValue("turbidity", val); }
	//! Determines the amount of dust in the air and affects the color of the sun and sky. Smaller values produce a clear/blue sky, larger values yellow and orange
 	//! [UI Guides] minValue=2, maxValue=20
 	//! [Default value] 3
	float get_turbidity() const { return getFloat("turbidity"); }

	//! Affects the color of the sun light (between 0.0 and 1.0). Smaller values make the sunlight more yellow, larger values make it blue
 	//! [UI Guides] minValue=0, maxValue=1
 	//! [Default value] 0.35
	bool set_ozone(float val) { return setValue("ozone", val); }
	//! Affects the color of the sun light (between 0.0 and 1.0). Smaller values make the sunlight more yellow, larger values make it blue
 	//! [UI Guides] minValue=0, maxValue=1
 	//! [Default value] 0.35
	float get_ozone() const { return getFloat("ozone"); }

	//! (description missing)
	//! [Default value] 2
	bool set_water_vapour(float val) { return setValue("water_vapour", val); }
	//! (description missing)
	//! [Default value] 2
	float get_water_vapour() const { return getFloat("water_vapour"); }

	//! [UI Guides] minValue=0
 	//! [Default value] 1
	bool set_intensity_multiplier(float val) { return setValue("intensity_multiplier", val); }
	//! [UI Guides] minValue=0
 	//! [Default value] 1
	float get_intensity_multiplier() const { return getFloat("intensity_multiplier"); }

	//! Controls the visible size of the sun. Affects the appearance of the sun disc as seen by the camera and reflections, as well as the blurriness of the sun shadows
 	//! [UI Guides] minValue=0
 	//! [Default value] 1
	bool set_size_multiplier(float val) { return setValue("size_multiplier", val); }
	//! Controls the visible size of the sun. Affects the appearance of the sun disc as seen by the camera and reflections, as well as the blurriness of the sun shadows
 	//! [UI Guides] minValue=0
 	//! [Default value] 1
	float get_size_multiplier() const { return getFloat("size_multiplier"); }

	//! Sunlight color. Used to add user control to light color definition
 	//! [Default value] Color(1, 1, 1)
	bool set_filter_color(const Color& color) { return setValue("filter_color", color); }
	//! Sunlight color. Used to add user control to light color definition
 	//! [Default value] Color(1, 1, 1)
	Color get_filter_color() const { return getColor("filter_color"); }

	//! Reflective property of the "ground". Affects sky-dome brightness and color
 	//! [Default value] Color(0.2, 0.2, 0.2)
	bool set_ground_albedo(const Color& color) { return setValue("ground_albedo", color); }
	//! Reflective property of the "ground". Affects sky-dome brightness and color
 	//! [Default value] Color(0.2, 0.2, 0.2)
	Color get_ground_albedo() const { return getColor("ground_albedo"); }

	//! The angle (in degrees) (up from the horizon) where the sky starts to blend with the ground albedo. Values close to 0.0 produce a sharper horizon line, while larger values produce a softer horizon line.
 	//! [UI Guides] minValue=0.0, maxValue=90.0, quantityType=angle, units=degrees
 	//! [Default value] 5.73917
	bool set_blend_angle(float val) { return setValue("blend_angle", val); }
	//! The angle (in degrees) (up from the horizon) where the sky starts to blend with the ground albedo. Values close to 0.0 produce a sharper horizon line, while larger values produce a softer horizon line.
 	//! [UI Guides] minValue=0.0, maxValue=90.0, quantityType=angle, units=degrees
 	//! [Default value] 5.73917
	float get_blend_angle() const { return getFloat("blend_angle"); }

	//! Horizon offset under the sky-dome. Allows the user to manually lower the horizon line.
 	//! [UI Guides] minValue=0.0, maxValue=90.0, quantityType=angle, units=degrees
 	//! [Default value] 0
	bool set_horizon_offset(float val) { return setValue("horizon_offset", val); }
	//! Horizon offset under the sky-dome. Allows the user to manually lower the horizon line.
 	//! [UI Guides] minValue=0.0, maxValue=90.0, quantityType=angle, units=degrees
 	//! [Default value] 0
	float get_horizon_offset() const { return getFloat("horizon_offset"); }

	//! This option affects the way the color in the Filter color parameter affects the color of the sun
 	//! [Default value] 0
	bool set_color_mode(int val) { return setValue("color_mode", val); }
	//! This option affects the way the color in the Filter color parameter affects the color of the sun
 	//! [Default value] 0
	int get_color_mode() const { return getInt("color_mode"); }

	//! (description missing)
	//! [Default value] Vector(0, 0, 1)
	bool set_up_vector(const Vector& vector) { return setValue("up_vector", vector); }
	//! (description missing)
	//! [Default value] Vector(0, 0, 1)
	Vector get_up_vector() const { return getVector("up_vector"); }

	//! When on, this option makes the sun invisible, both to the camera and to reflections
 	//! [Default value] false
	bool set_invisible(bool val) { return setValue("invisible", val); }
	//! When on, this option makes the sun invisible, both to the camera and to reflections
 	//! [Default value] false
	bool get_invisible() const { return getBool("invisible"); }

	//! Specifies the intensity (in lx) of the illumination on horizontal surfaces coming from the sky
 	//! [UI Guides] enableIf: ?sky_model==1;?sky_model==2, minValue=0
 	//! [Default value] 25000
	bool set_horiz_illum(float val) { return setValue("horiz_illum", val); }
	//! Specifies the intensity (in lx) of the illumination on horizontal surfaces coming from the sky
 	//! [UI Guides] enableIf: ?sky_model==1;?sky_model==2, minValue=0
 	//! [Default value] 25000
	float get_horiz_illum() const { return getFloat("horiz_illum"); }

	//! Selects the procedural model used to simulate the TexSky texture
 	//! [UI Guides] enum=0:Preetham et al;1:CIE Clear;2:CIE Overcast;3:Hosek et al
 	//! [Default value] 0
	bool set_sky_model(int val) { return setValue("sky_model", val); }
	//! Selects the procedural model used to simulate the TexSky texture
 	//! [UI Guides] enum=0:Preetham et al;1:CIE Clear;2:CIE Overcast;3:Hosek et al
 	//! [Default value] 0
	int get_sky_model() const { return getInt("sky_model"); }

	//! true if the light casts shadows and false otherwise
 	//! [Default value] true
	bool set_shadows(bool val) { return setValue("shadows", val); }
	//! true if the light casts shadows and false otherwise
 	//! [Default value] true
	bool get_shadows() const { return getBool("shadows"); }

	//! true if the light casts shadows from atmosperics and false otherwise
 	//! [Default value] true
	bool set_atmos_shadows(bool val) { return setValue("atmos_shadows", val); }
	//! true if the light casts shadows from atmosperics and false otherwise
 	//! [Default value] true
	bool get_atmos_shadows() const { return getBool("atmos_shadows"); }

	//! Shadow offset from the surface. Helps to prevent polygonal shadow artifacts on low-poly surfaces.
 	//! [UI Guides] quantityType=distance
 	//! [Default value] 0
	bool set_shadowBias(float val) { return setValue("shadowBias", val); }
	//! Shadow offset from the surface. Helps to prevent polygonal shadow artifacts on low-poly surfaces.
 	//! [UI Guides] quantityType=distance
 	//! [Default value] 0
	float get_shadowBias() const { return getFloat("shadowBias"); }

	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	bool set_shadow_subdivs(int val) { return setValue("shadow_subdivs", val); }
	//! [UI Guides] minValue=1, maxValue=1000, quantityType=localSubdivs
 	//! [Default value] 8
	int get_shadow_subdivs() const { return getInt("shadow_subdivs"); }

	//! The shadow color. Anything but black is not physically accurate.
 	//! [Default value] Color(0, 0, 0)
	bool set_shadow_color(const Color& color) { return setValue("shadow_color", color); }
	//! The shadow color. Anything but black is not physically accurate.
 	//! [Default value] Color(0, 0, 0)
	Color get_shadow_color() const { return getColor("shadow_color"); }

	//! A color texture that if present will override the shadowColor parameter
 	bool set_shadow_color_tex(const Plugin& texture) { return setValue("shadow_color_tex", texture); }
	//! A color texture that if present will override the shadowColor parameter
 	bool set_shadow_color_tex(const AColor& texture) { return setValue("shadow_color_tex", texture); }
	//! A color texture that if present will override the shadowColor parameter
 	Value get_shadow_color_tex() const { return getValue("shadow_color_tex"); }

	//! [UI Guides] quantityType=distance
 	//! [Default value] 50
	bool set_photon_radius(float val) { return setValue("photon_radius", val); }
	//! [UI Guides] quantityType=distance
 	//! [Default value] 50
	float get_photon_radius() const { return getFloat("photon_radius"); }

	//! (description missing)
	//! [Default value] 500
	bool set_photonSubdivs(int val) { return setValue("photonSubdivs", val); }
	//! (description missing)
	//! [Default value] 500
	int get_photonSubdivs() const { return getInt("photonSubdivs"); }

	//! (description missing)
	//! [Default value] 1000
	bool set_causticSubdivs(int val) { return setValue("causticSubdivs", val); }
	//! (description missing)
	//! [Default value] 1000
	int get_causticSubdivs() const { return getInt("causticSubdivs"); }

	//! (description missing)
	//! [Default value] 1
	bool set_diffuseMult(float val) { return setValue("diffuseMult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_diffuseMult() const { return getFloat("diffuseMult"); }

	//! (description missing)
	//! [Default value] 1
	bool set_causticMult(float val) { return setValue("causticMult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_causticMult() const { return getFloat("causticMult"); }

	//! true if the light is casting light (turned on) and false otherwise; it only makes sense to use this parameter if it is animated, or if another object depends on this node but it must not be rendered
 	//! [Default value] true
	bool set_enabled(bool val) { return setValue("enabled", val); }
	//! true if the light is casting light (turned on) and false otherwise; it only makes sense to use this parameter if it is animated, or if another object depends on this node but it must not be rendered
 	//! [Default value] true
	bool get_enabled() const { return getBool("enabled"); }

	//! true if the light produces diffuse lighting and false otherwise
 	//! [Default value] true
	bool set_affectDiffuse(bool val) { return setValue("affectDiffuse", val); }
	//! true if the light produces diffuse lighting and false otherwise
 	//! [Default value] true
	bool get_affectDiffuse() const { return getBool("affectDiffuse"); }

	//! true if the light produces specular hilights and false otherwise
 	//! [Default value] true
	bool set_affectSpecular(bool val) { return setValue("affectSpecular", val); }
	//! true if the light produces specular hilights and false otherwise
 	//! [Default value] true
	bool get_affectSpecular() const { return getBool("affectSpecular"); }

	//! Diffuse contribution for the light
 	//! [Default value] 1
	bool set_diffuse_contribution(float val) { return setValue("diffuse_contribution", val); }
	//! Diffuse contribution for the light
 	//! [Default value] 1
	float get_diffuse_contribution() const { return getFloat("diffuse_contribution"); }

	//! Specular contribution for the light
 	//! [Default value] 1
	bool set_specular_contribution(float val) { return setValue("specular_contribution", val); }
	//! Specular contribution for the light
 	//! [Default value] 1
	float get_specular_contribution() const { return getFloat("specular_contribution"); }

	//! Render channels the result of this light will be written to
 	bool set_channels(const ValueList& pluginList) { return setValue("channels", pluginList); }
	//! Render channels the result of this light will be written to
 	ValueList get_channels() const { return getValueList("channels"); }

	//! Render channels the raw diffuse result of this light will be written to
 	bool set_channels_raw(const ValueList& pluginList) { return setValue("channels_raw", pluginList); }
	//! Render channels the raw diffuse result of this light will be written to
 	ValueList get_channels_raw() const { return getValueList("channels_raw"); }

	//! Render channels the diffuse result of this light will be written to
 	bool set_channels_diffuse(const ValueList& pluginList) { return setValue("channels_diffuse", pluginList); }
	//! Render channels the diffuse result of this light will be written to
 	ValueList get_channels_diffuse() const { return getValueList("channels_diffuse"); }

	//! Render channels the specular result of this light will be written to
 	bool set_channels_specular(const ValueList& pluginList) { return setValue("channels_specular", pluginList); }
	//! Render channels the specular result of this light will be written to
 	ValueList get_channels_specular() const { return getValueList("channels_specular"); }

	//! true if the bumped normal should be used to check if the light dir is below the surface
 	//! [Default value] false
	bool set_bumped_below_surface_check(bool val) { return setValue("bumped_below_surface_check", val); }
	//! true if the bumped normal should be used to check if the light dir is below the surface
 	//! [Default value] false
	bool get_bumped_below_surface_check() const { return getBool("bumped_below_surface_check"); }
};

class TexAColor : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexAColor"; }

	//! (description missing)
	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! (description missing)
	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! (description missing)
	bool set_texture(const Plugin& texture) { return setValue("texture", texture); }
	//! (description missing)
	bool set_texture(const AColor& texture) { return setValue("texture", texture); }
	//! (description missing)
	Value get_texture() const { return getValue("texture"); }
};

class TexAColorChannel : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexAColorChannel"; }

	//! The first color
 	bool set_color_a(const Plugin& texture) { return setValue("color_a", texture); }
	//! The first color
 	bool set_color_a(const AColor& texture) { return setValue("color_a", texture); }
	//! The first color
 	Value get_color_a() const { return getValue("color_a"); }

	//! Multiplier for the first color
 	bool set_mult_a(const Plugin& texturefloat) { return setValue("mult_a", texturefloat); }
	//! Multiplier for the first color
 	bool set_mult_a(float texturefloat) { return setValue("mult_a", texturefloat); }
	//! Multiplier for the first color
 	Value get_mult_a() const { return getValue("mult_a"); }

	//! which component of the color should be returned - 0:red;1:green;2:blue;3:alpha;4:intensity
 	//! [UI Guides] enum=0:red;1:green;2:blue;3:alpha;4:intensity
 	//! [Default value] 0
	bool set_mode(int val) { return setValue("mode", val); }
	//! which component of the color should be returned - 0:red;1:green;2:blue;3:alpha;4:intensity
 	//! [UI Guides] enum=0:red;1:green;2:blue;3:alpha;4:intensity
 	//! [Default value] 0
	int get_mode() const { return getInt("mode"); }
};

class TexAColorOp : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexAColorOp"; }

	//! The first color
 	bool set_color_a(const Plugin& texture) { return setValue("color_a", texture); }
	//! The first color
 	bool set_color_a(const AColor& texture) { return setValue("color_a", texture); }
	//! The first color
 	Value get_color_a() const { return getValue("color_a"); }

	//! The second color
 	bool set_color_b(const Plugin& texture) { return setValue("color_b", texture); }
	//! The second color
 	bool set_color_b(const AColor& texture) { return setValue("color_b", texture); }
	//! The second color
 	Value get_color_b() const { return getValue("color_b"); }

	//! Multiplier for the first color
 	bool set_mult_a(const Plugin& texturefloat) { return setValue("mult_a", texturefloat); }
	//! Multiplier for the first color
 	bool set_mult_a(float texturefloat) { return setValue("mult_a", texturefloat); }
	//! Multiplier for the first color
 	Value get_mult_a() const { return getValue("mult_a"); }

	//! Multiplier for the second color
 	bool set_mult_b(const Plugin& texturefloat) { return setValue("mult_b", texturefloat); }
	//! Multiplier for the second color
 	bool set_mult_b(float texturefloat) { return setValue("mult_b", texturefloat); }
	//! Multiplier for the second color
 	Value get_mult_b() const { return getValue("mult_b"); }

	//! The alpha for the result; if not specified, the resulting alpha taken from the first color)
 	bool set_result_alpha(const Plugin& texturefloat) { return setValue("result_alpha", texturefloat); }
	//! The alpha for the result; if not specified, the resulting alpha taken from the first color)
 	bool set_result_alpha(float texturefloat) { return setValue("result_alpha", texturefloat); }
	//! The alpha for the result; if not specified, the resulting alpha taken from the first color)
 	Value get_result_alpha() const { return getValue("result_alpha"); }

	//! Which output should be considered as the output of the main texture (0 - result_a, 1 - result_b, 2 - product, 3 - sum, 4 - difference, 5 - power, 6 - division, 7 - Minimum, 8 - Maximum, 9 - absolute difference), 10 - Lower intensity color, 11 - Greater intensity color
 	//! [UI Guides] enum=0:result_a;1:result_b;2:product;3:sum;4:difference;5:power;6:division;7:minimum;8:maximum;9:absolute difference
 	//! [Default value] 0
	bool set_mode(int val) { return setValue("mode", val); }
	//! Which output should be considered as the output of the main texture (0 - result_a, 1 - result_b, 2 - product, 3 - sum, 4 - difference, 5 - power, 6 - division, 7 - Minimum, 8 - Maximum, 9 - absolute difference), 10 - Lower intensity color, 11 - Greater intensity color
 	//! [UI Guides] enum=0:result_a;1:result_b;2:product;3:sum;4:difference;5:power;6:division;7:minimum;8:maximum;9:absolute difference
 	//! [Default value] 0
	int get_mode() const { return getInt("mode"); }
};

class TexAnimationCurve : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexAnimationCurve"; }

	//! (description missing)
	bool set_input(const Plugin& texturefloat) { return setValue("input", texturefloat); }
	//! (description missing)
	bool set_input(float texturefloat) { return setValue("input", texturefloat); }
	//! (description missing)
	Value get_input() const { return getValue("input"); }

	//! List of control points.  Each is represented by six consecutivefloats: 0 - x (time), 1 - y (value), 2 - in-tangent vector x, 3 - in-tangent vector y, 4 - out-tangent vector x, 5 - out-tangent vector y.
 	//! [Default value] 0
	bool set_points(const FloatList& floatList) { return setValue("points", floatList); }
	//! List of control points.  Each is represented by six consecutivefloats: 0 - x (time), 1 - y (value), 2 - in-tangent vector x, 3 - in-tangent vector y, 4 - out-tangent vector x, 5 - out-tangent vector y.
 	//! [Default value] 0
	bool set_points(const float* floats, size_t count) { return setArray("points", floats, count); }
	//! List of control points.  Each is represented by six consecutivefloats: 0 - x (time), 1 - y (value), 2 - in-tangent vector x, 3 - in-tangent vector y, 4 - out-tangent vector x, 5 - out-tangent vector y.
 	//! [Default value] 0
	template<size_t count> bool set_points(const float (&floats)[count]) { return setArray("points", floats, count); }
	//! List of control points.  Each is represented by six consecutivefloats: 0 - x (time), 1 - y (value), 2 - in-tangent vector x, 3 - in-tangent vector y, 4 - out-tangent vector x, 5 - out-tangent vector y.
 	//! [Default value] 0
	FloatList get_points() const { return getFloatList("points"); }

	//! Each control point has two tangents.  Each of these tangents hasits type.  It is specified by an integer from the following table: 0 - Fixed, 1 - Linear, 2 - Flat, 3 - Step, 4 - Step next, 5 - Slow, 6 - Fast, 7 - Smooth, 8 - Clamped, 9 - Plateau, 10 - Auto.  For more information on their types, please visit Maya's documentation website.
 	//! [UI Guides] enum=0: Fixed; 1: Linear; 2: Flat; 3: Step; 4: Step next; 5: Slow; 6: Fast; 7: Smooth; 8: Clamped; 9: Plateau; 10: Auto
 	//! [Default value] 0
	bool set_tangent_types(const IntList& intList) { return setValue("tangent_types", intList); }
	//! Each control point has two tangents.  Each of these tangents hasits type.  It is specified by an integer from the following table: 0 - Fixed, 1 - Linear, 2 - Flat, 3 - Step, 4 - Step next, 5 - Slow, 6 - Fast, 7 - Smooth, 8 - Clamped, 9 - Plateau, 10 - Auto.  For more information on their types, please visit Maya's documentation website.
 	//! [UI Guides] enum=0: Fixed; 1: Linear; 2: Flat; 3: Step; 4: Step next; 5: Slow; 6: Fast; 7: Smooth; 8: Clamped; 9: Plateau; 10: Auto
 	//! [Default value] 0
	bool set_tangent_types(const int* ints, size_t count) { return setArray("tangent_types", ints, count); }
	//! Each control point has two tangents.  Each of these tangents hasits type.  It is specified by an integer from the following table: 0 - Fixed, 1 - Linear, 2 - Flat, 3 - Step, 4 - Step next, 5 - Slow, 6 - Fast, 7 - Smooth, 8 - Clamped, 9 - Plateau, 10 - Auto.  For more information on their types, please visit Maya's documentation website.
 	//! [UI Guides] enum=0: Fixed; 1: Linear; 2: Flat; 3: Step; 4: Step next; 5: Slow; 6: Fast; 7: Smooth; 8: Clamped; 9: Plateau; 10: Auto
 	//! [Default value] 0
	template<size_t count> bool set_tangent_types(const int (&ints)[count]) { return setArray("tangent_types", ints, count); }
	//! Each control point has two tangents.  Each of these tangents hasits type.  It is specified by an integer from the following table: 0 - Fixed, 1 - Linear, 2 - Flat, 3 - Step, 4 - Step next, 5 - Slow, 6 - Fast, 7 - Smooth, 8 - Clamped, 9 - Plateau, 10 - Auto.  For more information on their types, please visit Maya's documentation website.
 	//! [UI Guides] enum=0: Fixed; 1: Linear; 2: Flat; 3: Step; 4: Step next; 5: Slow; 6: Fast; 7: Smooth; 8: Clamped; 9: Plateau; 10: Auto
 	//! [Default value] 0
	IntList get_tangent_types() const { return getIntList("tangent_types"); }

	//! One of the following: 0 -- Constant, 1 -- Linear, 2 -- Cycle, 3 -- Cycle relative, 4 -- Oscillate.
 	//! [UI Guides] enum=0: Constant; 1: Linear; 2: Cycle; 3: Cycle relative; 4: Oscillate
 	//! [Default value] 0
	bool set_pre_infinity_type(int val) { return setValue("pre_infinity_type", val); }
	//! One of the following: 0 -- Constant, 1 -- Linear, 2 -- Cycle, 3 -- Cycle relative, 4 -- Oscillate.
 	//! [UI Guides] enum=0: Constant; 1: Linear; 2: Cycle; 3: Cycle relative; 4: Oscillate
 	//! [Default value] 0
	int get_pre_infinity_type() const { return getInt("pre_infinity_type"); }

	//! One of the following: 0 -- Constant, 1 -- Linear, 2 -- Cycle, 3 -- Cycle relative, 4 -- Oscillate.
 	//! [UI Guides] enum=0: Constant; 1: Linear; 2: Cycle; 3: Cycle relative; 4: Oscillate
 	//! [Default value] 0
	bool set_post_infinity_type(int val) { return setValue("post_infinity_type", val); }
	//! One of the following: 0 -- Constant, 1 -- Linear, 2 -- Cycle, 3 -- Cycle relative, 4 -- Oscillate.
 	//! [UI Guides] enum=0: Constant; 1: Linear; 2: Cycle; 3: Cycle relative; 4: Oscillate
 	//! [Default value] 0
	int get_post_infinity_type() const { return getInt("post_infinity_type"); }

	//! (description missing)
	//! [Default value] false
	bool set_weighted(bool val) { return setValue("weighted", val); }
	//! (description missing)
	//! [Default value] false
	bool get_weighted() const { return getBool("weighted"); }
};

class TexBerconDistortion : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexBerconDistortion"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	bool set_placement_type(int val) { return setValue("placement_type", val); }
	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	int get_placement_type() const { return getInt("placement_type"); }

	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_u(float val) { return setValue("u", val); }
	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_u() const { return getFloat("u"); }

	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_v(float val) { return setValue("v", val); }
	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_v() const { return getFloat("v"); }

	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_w(float val) { return setValue("w", val); }
	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_w() const { return getFloat("w"); }

	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_h(float val) { return setValue("h", val); }
	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_h() const { return getFloat("h"); }

	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	bool set_jitter(float val) { return setValue("jitter", val); }
	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	float get_jitter() const { return getFloat("jitter"); }

	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_u(bool val) { return setValue("tile_u", val); }
	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_u() const { return getBool("tile_u"); }

	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_v(bool val) { return setValue("tile_v", val); }
	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_v() const { return getBool("tile_v"); }

	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool set_uv_noise_on(bool val) { return setValue("uv_noise_on", val); }
	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool get_uv_noise_on() const { return getBool("uv_noise_on"); }

	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool set_uv_noise_animate(bool val) { return setValue("uv_noise_animate", val); }
	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool get_uv_noise_animate() const { return getBool("uv_noise_animate"); }

	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	bool set_uv_noise_amount(float val) { return setValue("uv_noise_amount", val); }
	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	float get_uv_noise_amount() const { return getFloat("uv_noise_amount"); }

	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	bool set_uv_noise_levels(float val) { return setValue("uv_noise_levels", val); }
	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	float get_uv_noise_levels() const { return getFloat("uv_noise_levels"); }

	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	bool set_uv_noise_size(float val) { return setValue("uv_noise_size", val); }
	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	float get_uv_noise_size() const { return getFloat("uv_noise_size"); }

	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	bool set_un_noise_phase(float val) { return setValue("un_noise_phase", val); }
	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	float get_un_noise_phase() const { return getFloat("un_noise_phase"); }

	//! map to be distorted
 	bool set_map_source(const ValueList& textureList) { return setValue("map_source", textureList); }
	//! map to be distorted
 	ValueList get_map_source() const { return getValueList("map_source"); }

	//! distortion map
 	bool set_dist_map(const ValueList& textureList) { return setValue("dist_map", textureList); }
	//! distortion map
 	ValueList get_dist_map() const { return getValueList("dist_map"); }

	//! distortion map 2
 	bool set_dist_map2(const ValueList& textureList) { return setValue("dist_map2", textureList); }
	//! distortion map 2
 	ValueList get_dist_map2() const { return getValueList("dist_map2"); }

	//! distortion strength
 	//! [Default value] 0.1
	bool set_dist_str(float val) { return setValue("dist_str", val); }
	//! distortion strength
 	//! [Default value] 0.1
	float get_dist_str() const { return getFloat("dist_str"); }

	//! use distortion
 	//! [Default value] false
	bool set_use_dist(bool val) { return setValue("use_dist", val); }
	//! use distortion
 	//! [Default value] false
	bool get_use_dist() const { return getBool("use_dist"); }
};

class TexBerconGrad : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexBerconGrad"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	bool set_placement_type(int val) { return setValue("placement_type", val); }
	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	int get_placement_type() const { return getInt("placement_type"); }

	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_u(float val) { return setValue("u", val); }
	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_u() const { return getFloat("u"); }

	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_v(float val) { return setValue("v", val); }
	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_v() const { return getFloat("v"); }

	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_w(float val) { return setValue("w", val); }
	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_w() const { return getFloat("w"); }

	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_h(float val) { return setValue("h", val); }
	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_h() const { return getFloat("h"); }

	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	bool set_jitter(float val) { return setValue("jitter", val); }
	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	float get_jitter() const { return getFloat("jitter"); }

	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_u(bool val) { return setValue("tile_u", val); }
	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_u() const { return getBool("tile_u"); }

	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_v(bool val) { return setValue("tile_v", val); }
	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_v() const { return getBool("tile_v"); }

	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool set_uv_noise_on(bool val) { return setValue("uv_noise_on", val); }
	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool get_uv_noise_on() const { return getBool("uv_noise_on"); }

	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool set_uv_noise_animate(bool val) { return setValue("uv_noise_animate", val); }
	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool get_uv_noise_animate() const { return getBool("uv_noise_animate"); }

	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	bool set_uv_noise_amount(float val) { return setValue("uv_noise_amount", val); }
	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	float get_uv_noise_amount() const { return getFloat("uv_noise_amount"); }

	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	bool set_uv_noise_levels(float val) { return setValue("uv_noise_levels", val); }
	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	float get_uv_noise_levels() const { return getFloat("uv_noise_levels"); }

	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	bool set_uv_noise_size(float val) { return setValue("uv_noise_size", val); }
	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	float get_uv_noise_size() const { return getFloat("uv_noise_size"); }

	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	bool set_un_noise_phase(float val) { return setValue("un_noise_phase", val); }
	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	float get_un_noise_phase() const { return getFloat("un_noise_phase"); }

	//! positions of the given colors
 	//! [Default value] 0.5
	bool set_positions(float val) { return setValue("positions", val); }
	//! positions of the given colors
 	//! [Default value] 0.5
	float get_positions() const { return getFloat("positions"); }

	//! the given colors
 	bool set_colors(const ValueList& textureList) { return setValue("colors", textureList); }
	//! the given colors
 	ValueList get_colors() const { return getValueList("colors"); }

	//! the texture used for mapped gradient ramp
 	bool set_texture_map(const Plugin& texture) { return setValue("texture_map", texture); }
	//! the texture used for mapped gradient ramp
 	bool set_texture_map(const AColor& texture) { return setValue("texture_map", texture); }
	//! the texture used for mapped gradient ramp
 	Value get_texture_map() const { return getValue("texture_map"); }

	//! 0:1D linear, 1:2D radial, 2:2D rectangle, 3:2D diagonal, 4:2D Pong, 5:2D Spiral, 6:2D Sweep, 7:2D tartan, 8:3D Spherical, 9:3D Box
 	//! [UI Guides] enum=0:1D linear; 1:2D radial; 2:2D rectangle; 3:2D diagonal; 4:2D Pong; 5:2D Spiral; 6:2D Sweep; 7:2D tartan; 8:3D Spherical; 9:3D Box
 	//! [Default value] 0
	bool set_gradient_type(int val) { return setValue("gradient_type", val); }
	//! 0:1D linear, 1:2D radial, 2:2D rectangle, 3:2D diagonal, 4:2D Pong, 5:2D Spiral, 6:2D Sweep, 7:2D tartan, 8:3D Spherical, 9:3D Box
 	//! [UI Guides] enum=0:1D linear; 1:2D radial; 2:2D rectangle; 3:2D diagonal; 4:2D Pong; 5:2D Spiral; 6:2D Sweep; 7:2D tartan; 8:3D Spherical; 9:3D Box
 	//! [Default value] 0
	int get_gradient_type() const { return getInt("gradient_type"); }

	//! 0:linear, 1:smooth, 2:solid nearest, 3:solid left, 4:solid right
 	//! [UI Guides] enum=0:linear; 1:smooth; 2:solid nearest; 3:solid left; 4:solid right
 	//! [Default value] 0
	bool set_interpolation(int val) { return setValue("interpolation", val); }
	//! 0:linear, 1:smooth, 2:solid nearest, 3:solid left, 4:solid right
 	//! [UI Guides] enum=0:linear; 1:smooth; 2:solid nearest; 3:solid left; 4:solid right
 	//! [Default value] 0
	int get_interpolation() const { return getInt("interpolation"); }

	//! Distortion noise amount
 	//! [Default value] 0
	bool set_noise_amount(float val) { return setValue("noise_amount", val); }
	//! Distortion noise amount
 	//! [Default value] 0
	float get_noise_amount() const { return getFloat("noise_amount"); }

	//! 0:regular, 1:fractal, 2:turbulence
 	//! [UI Guides] enum=0:Regular; 1:Fractal; 2:Turbulence
 	//! [Default value] 0
	bool set_noise_type(int val) { return setValue("noise_type", val); }
	//! 0:regular, 1:fractal, 2:turbulence
 	//! [UI Guides] enum=0:Regular; 1:Fractal; 2:Turbulence
 	//! [Default value] 0
	int get_noise_type() const { return getInt("noise_type"); }

	//! default = 1.0
 	//! [Default value] 1
	bool set_noise_size(float val) { return setValue("noise_size", val); }
	//! default = 1.0
 	//! [Default value] 1
	float get_noise_size() const { return getFloat("noise_size"); }

	//! default = 0.0
 	//! [Default value] 0
	bool set_noise_phase(float val) { return setValue("noise_phase", val); }
	//! default = 0.0
 	//! [Default value] 0
	float get_noise_phase() const { return getFloat("noise_phase"); }

	//! default = 4.0
 	//! [Default value] 4
	bool set_noise_levels(float val) { return setValue("noise_levels", val); }
	//! default = 4.0
 	//! [Default value] 4
	float get_noise_levels() const { return getFloat("noise_levels"); }

	//! default = 0.0f
 	//! [Default value] 0
	bool set_noise_treshold_low(float val) { return setValue("noise_treshold_low", val); }
	//! default = 0.0f
 	//! [Default value] 0
	float get_noise_treshold_low() const { return getFloat("noise_treshold_low"); }

	//! default = 1.0f
 	//! [Default value] 1
	bool set_noise_treshold_high(float val) { return setValue("noise_treshold_high", val); }
	//! default = 1.0f
 	//! [Default value] 1
	float get_noise_treshold_high() const { return getFloat("noise_treshold_high"); }

	//! default = 0.0f
 	//! [Default value] 0
	bool set_noise_smooth(float val) { return setValue("noise_smooth", val); }
	//! default = 0.0f
 	//! [Default value] 0
	float get_noise_smooth() const { return getFloat("noise_smooth"); }

	//! 0:UVW, 1:Normal, 2:Distance, 3:Light, 4:Map, 5:Random, 6:Particle age, 7:Particle speed, 8:Particle size
 	//! [UI Guides] enum=0:UVW; 1:Normal; 2:Distance; 3:Light; 4:Map; 5:Random; 6:Particle age; 7:Particle speed; 8:Particle size
 	//! [Default value] 0
	bool set_type(int val) { return setValue("type", val); }
	//! 0:UVW, 1:Normal, 2:Distance, 3:Light, 4:Map, 5:Random, 6:Particle age, 7:Particle speed, 8:Particle size
 	//! [UI Guides] enum=0:UVW; 1:Normal; 2:Distance; 3:Light; 4:Map; 5:Random; 6:Particle age; 7:Particle speed; 8:Particle size
 	//! [Default value] 0
	int get_type() const { return getInt("type"); }

	//! 0:View, 1:Local X, 2:Local Y, 3:Local Z, 4:World X, 5:World Y, 6:World Z, 7:Camera X, 8:Camera Y, 9:Camera Z, 10:To Object, 11:Object Z
 	//! [UI Guides] enum=0:View; 1:Local X; 2:Local Y; 3:Local Z; 4:World X; 5:World Y; 6:World Z; 7:Camera X; 8:Camera Y; 9:Camera Z; 10:To Object; 11:Object Z
 	//! [Default value] 0
	bool set_normal_type(int val) { return setValue("normal_type", val); }
	//! 0:View, 1:Local X, 2:Local Y, 3:Local Z, 4:World X, 5:World Y, 6:World Z, 7:Camera X, 8:Camera Y, 9:Camera Z, 10:To Object, 11:Object Z
 	//! [UI Guides] enum=0:View; 1:Local X; 2:Local Y; 3:Local Z; 4:World X; 5:World Y; 6:World Z; 7:Camera X; 8:Camera Y; 9:Camera Z; 10:To Object; 11:Object Z
 	//! [Default value] 0
	int get_normal_type() const { return getInt("normal_type"); }

	//! 0:Perpendicular, 1:Towards, 2:Fresnel
 	//! [UI Guides] enum=0:Perpendicular; 1:Towards; 2:Fresnel
 	//! [Default value] 0
	bool set_normal_function(int val) { return setValue("normal_function", val); }
	//! 0:Perpendicular, 1:Towards, 2:Fresnel
 	//! [UI Guides] enum=0:Perpendicular; 1:Towards; 2:Fresnel
 	//! [Default value] 0
	int get_normal_function() const { return getInt("normal_function"); }

	//! (description missing)
	//! [Default value] false
	bool set_use_curve_input(bool val) { return setValue("use_curve_input", val); }
	//! (description missing)
	//! [Default value] false
	bool get_use_curve_input() const { return getBool("use_curve_input"); }

	//! If curve is used the gradient value will be taken from this texture
 	bool set_curve_input(const Plugin& texturefloat) { return setValue("curve_input", texturefloat); }
	//! If curve is used the gradient value will be taken from this texture
 	bool set_curve_input(float texturefloat) { return setValue("curve_input", texturefloat); }
	//! If curve is used the gradient value will be taken from this texture
 	Value get_curve_input() const { return getValue("curve_input"); }
};

class TexBerconNoise : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexBerconNoise"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	bool set_placement_type(int val) { return setValue("placement_type", val); }
	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	int get_placement_type() const { return getInt("placement_type"); }

	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_u(float val) { return setValue("u", val); }
	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_u() const { return getFloat("u"); }

	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_v(float val) { return setValue("v", val); }
	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_v() const { return getFloat("v"); }

	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_w(float val) { return setValue("w", val); }
	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_w() const { return getFloat("w"); }

	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_h(float val) { return setValue("h", val); }
	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_h() const { return getFloat("h"); }

	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	bool set_jitter(float val) { return setValue("jitter", val); }
	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	float get_jitter() const { return getFloat("jitter"); }

	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_u(bool val) { return setValue("tile_u", val); }
	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_u() const { return getBool("tile_u"); }

	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_v(bool val) { return setValue("tile_v", val); }
	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_v() const { return getBool("tile_v"); }

	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool set_uv_noise_on(bool val) { return setValue("uv_noise_on", val); }
	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool get_uv_noise_on() const { return getBool("uv_noise_on"); }

	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool set_uv_noise_animate(bool val) { return setValue("uv_noise_animate", val); }
	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool get_uv_noise_animate() const { return getBool("uv_noise_animate"); }

	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	bool set_uv_noise_amount(float val) { return setValue("uv_noise_amount", val); }
	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	float get_uv_noise_amount() const { return getFloat("uv_noise_amount"); }

	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	bool set_uv_noise_levels(float val) { return setValue("uv_noise_levels", val); }
	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	float get_uv_noise_levels() const { return getFloat("uv_noise_levels"); }

	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	bool set_uv_noise_size(float val) { return setValue("uv_noise_size", val); }
	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	float get_uv_noise_size() const { return getFloat("uv_noise_size"); }

	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	bool set_un_noise_phase(float val) { return setValue("un_noise_phase", val); }
	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	float get_un_noise_phase() const { return getFloat("un_noise_phase"); }

	//! noise color 1
 	//! [UI Guides] displayName=Color 1
 	//! [Default value] Color(0, 0, 0)
	bool set_noise_color1(const Color& color) { return setValue("noise_color1", color); }
	//! noise color 1
 	//! [UI Guides] displayName=Color 1
 	//! [Default value] Color(0, 0, 0)
	Color get_noise_color1() const { return getColor("noise_color1"); }

	//! noise color 2
 	//! [UI Guides] displayName=Color 2
 	//! [Default value] Color(0, 0, 0)
	bool set_noise_color2(const Color& color) { return setValue("noise_color2", color); }
	//! noise color 2
 	//! [UI Guides] displayName=Color 2
 	//! [Default value] Color(0, 0, 0)
	Color get_noise_color2() const { return getColor("noise_color2"); }

	//! noise map 1
 	//! [UI Guides] displayName=Color 1 map
 	bool set_noise_map1(const Plugin& texture) { return setValue("noise_map1", texture); }
	//! noise map 1
 	//! [UI Guides] displayName=Color 1 map
 	bool set_noise_map1(const AColor& texture) { return setValue("noise_map1", texture); }
	//! noise map 1
 	//! [UI Guides] displayName=Color 1 map
 	Value get_noise_map1() const { return getValue("noise_map1"); }

	//! noise map 2
 	//! [UI Guides] displayName=Color 2 map
 	bool set_noise_map2(const Plugin& texture) { return setValue("noise_map2", texture); }
	//! noise map 2
 	//! [UI Guides] displayName=Color 2 map
 	bool set_noise_map2(const AColor& texture) { return setValue("noise_map2", texture); }
	//! noise map 2
 	//! [UI Guides] displayName=Color 2 map
 	Value get_noise_map2() const { return getValue("noise_map2"); }

	//! noise size
 	//! [UI Guides] startRollout=General, displayName=Size, minValue=0.0
 	//! [Default value] 25
	bool set_noise_size(float val) { return setValue("noise_size", val); }
	//! noise size
 	//! [UI Guides] startRollout=General, displayName=Size, minValue=0.0
 	//! [Default value] 25
	float get_noise_size() const { return getFloat("noise_size"); }

	//! default = 0.0f
 	//! [UI Guides] displayName=Low, minValue=0.0, maxValue=1000.0
 	//! [Default value] 0
	bool set_low_tresh(float val) { return setValue("low_tresh", val); }
	//! default = 0.0f
 	//! [UI Guides] displayName=Low, minValue=0.0, maxValue=1000.0
 	//! [Default value] 0
	float get_low_tresh() const { return getFloat("low_tresh"); }

	//! default = 1.0f
 	//! [UI Guides] displayName=High, minValue=0.0, maxValue=1000.0
 	//! [Default value] 1
	bool set_high_tresh(float val) { return setValue("high_tresh", val); }
	//! default = 1.0f
 	//! [UI Guides] displayName=High, minValue=0.0, maxValue=1000.0
 	//! [Default value] 1
	float get_high_tresh() const { return getFloat("high_tresh"); }

	//! UVW distance
 	//! [UI Guides] startRollout=Noise Function, displayName=UVW, enum=0:Normal;1:Radial;2:Spherical
 	//! [Default value] 1
	bool set_uvw_dist(int val) { return setValue("uvw_dist", val); }
	//! UVW distance
 	//! [UI Guides] startRollout=Noise Function, displayName=UVW, enum=0:Normal;1:Radial;2:Spherical
 	//! [Default value] 1
	int get_uvw_dist() const { return getInt("uvw_dist"); }

	//! noise function
 	//! [UI Guides] displayName=Noise Type, enum=0:Perlin 2D;1:Perlin 3D;2:Perlin 4D;3:Simplex 2D;4:Simplex 3D;5:Simplex 4D;6:Worley Voronoi
 	//! [Default value] 1
	bool set_noise_function(int val) { return setValue("noise_function", val); }
	//! noise function
 	//! [UI Guides] displayName=Noise Type, enum=0:Perlin 2D;1:Perlin 3D;2:Perlin 4D;3:Simplex 2D;4:Simplex 3D;5:Simplex 4D;6:Worley Voronoi
 	//! [Default value] 1
	int get_noise_function() const { return getInt("noise_function"); }

	//! noise phase
 	//! [UI Guides] displayName=Phase, enableIf: ?noise_function=2;?noise_function=5, minValue=-1000.0, maxValue=1000.0
 	//! [Default value] 0
	bool set_noise_phase(float val) { return setValue("noise_phase", val); }
	//! noise phase
 	//! [UI Guides] displayName=Phase, enableIf: ?noise_function=2;?noise_function=5, minValue=-1000.0, maxValue=1000.0
 	//! [Default value] 0
	float get_noise_phase() const { return getFloat("noise_phase"); }

	//! worley spread
 	//! [UI Guides] displayName=Spread, enableIf: ?noise_function=6, minValue=0.0, maxValue=1000.0
 	//! [Default value] 3
	bool set_worley_spread(float val) { return setValue("worley_spread", val); }
	//! worley spread
 	//! [UI Guides] displayName=Spread, enableIf: ?noise_function=6, minValue=0.0, maxValue=1000.0
 	//! [Default value] 3
	float get_worley_spread() const { return getFloat("worley_spread"); }

	//! worley F1
 	//! [UI Guides] displayName=F1, enableIf: ?noise_function=6, minValue=-1000.0, maxValue=1000.0
 	//! [Default value] 1
	bool set_worley_F1(float val) { return setValue("worley_F1", val); }
	//! worley F1
 	//! [UI Guides] displayName=F1, enableIf: ?noise_function=6, minValue=-1000.0, maxValue=1000.0
 	//! [Default value] 1
	float get_worley_F1() const { return getFloat("worley_F1"); }

	//! worley F2
 	//! [UI Guides] displayName=F2, enableIf: ?noise_function=6, minValue=-1000.0, maxValue=1000.0
 	//! [Default value] 0
	bool set_worley_F2(float val) { return setValue("worley_F2", val); }
	//! worley F2
 	//! [UI Guides] displayName=F2, enableIf: ?noise_function=6, minValue=-1000.0, maxValue=1000.0
 	//! [Default value] 0
	float get_worley_F2() const { return getFloat("worley_F2"); }

	//! worley F3
 	//! [UI Guides] displayName=F3, enableIf: ?noise_function=6, minValue=-1000.0, maxValue=1000.0
 	//! [Default value] 0
	bool set_worley_F3(float val) { return setValue("worley_F3", val); }
	//! worley F3
 	//! [UI Guides] displayName=F3, enableIf: ?noise_function=6, minValue=-1000.0, maxValue=1000.0
 	//! [Default value] 0
	float get_worley_F3() const { return getFloat("worley_F3"); }

	//! worley F4
 	//! [UI Guides] displayName=F4, enableIf: ?noise_function=6, minValue=-1000.0, maxValue=1000.0
 	//! [Default value] 0
	bool set_worley_F4(float val) { return setValue("worley_F4", val); }
	//! worley F4
 	//! [UI Guides] displayName=F4, enableIf: ?noise_function=6, minValue=-1000.0, maxValue=1000.0
 	//! [Default value] 0
	float get_worley_F4() const { return getFloat("worley_F4"); }

	//! worley distance
 	//! [UI Guides] displayName=Distance, enum=0:Linear;1:Square;2:Manhattan;3:Chebychev;4:Minkovsky 0.5;5:Minkovsky 4, enableIf: ?noise_function=6
 	//! [Default value] 0
	bool set_worley_distance(int val) { return setValue("worley_distance", val); }
	//! worley distance
 	//! [UI Guides] displayName=Distance, enum=0:Linear;1:Square;2:Manhattan;3:Chebychev;4:Minkovsky 0.5;5:Minkovsky 4, enableIf: ?noise_function=6
 	//! [Default value] 0
	int get_worley_distance() const { return getInt("worley_distance"); }

	//! fractal type
 	//! [UI Guides] startRollout=Noise Fractal, displayName=Fractal, enum=0:None;1:Fractal;2:Turbulence;3:fBm;4:fBm Turbulence;5:Hetero Terrain;6:Hybrid Multi Fractal;7:Ridged Multi Fractal
 	//! [Default value] 0
	bool set_fractal_type(int val) { return setValue("fractal_type", val); }
	//! fractal type
 	//! [UI Guides] startRollout=Noise Fractal, displayName=Fractal, enum=0:None;1:Fractal;2:Turbulence;3:fBm;4:fBm Turbulence;5:Hetero Terrain;6:Hybrid Multi Fractal;7:Ridged Multi Fractal
 	//! [Default value] 0
	int get_fractal_type() const { return getInt("fractal_type"); }

	//! fractal levels
 	//! [UI Guides] displayName=Levels, enableIf: ?fractal_type!=0, minValue=1.0, maxValue=20.0
 	//! [Default value] 3
	bool set_fractal_levels(float val) { return setValue("fractal_levels", val); }
	//! fractal levels
 	//! [UI Guides] displayName=Levels, enableIf: ?fractal_type!=0, minValue=1.0, maxValue=20.0
 	//! [Default value] 3
	float get_fractal_levels() const { return getFloat("fractal_levels"); }

	//! fractal offset
 	//! [UI Guides] displayName=Offset, enableIf: ?fractal_type=5;?fractal_type=6;?fractal_type=7, minValue=0.0, maxValue=100.0
 	//! [Default value] 0
	bool set_fractal_offset(float val) { return setValue("fractal_offset", val); }
	//! fractal offset
 	//! [UI Guides] displayName=Offset, enableIf: ?fractal_type=5;?fractal_type=6;?fractal_type=7, minValue=0.0, maxValue=100.0
 	//! [Default value] 0
	float get_fractal_offset() const { return getFloat("fractal_offset"); }

	//! fractal gain
 	//! [UI Guides] displayName=Gain, enableIf: ?fractal_type=6;?fractal_type=7, minValue=0.0, maxValue=100.0
 	//! [Default value] 5
	bool set_fractal_gain(float val) { return setValue("fractal_gain", val); }
	//! fractal gain
 	//! [UI Guides] displayName=Gain, enableIf: ?fractal_type=6;?fractal_type=7, minValue=0.0, maxValue=100.0
 	//! [Default value] 5
	float get_fractal_gain() const { return getFloat("fractal_gain"); }

	//! fractal lacunarity
 	//! [UI Guides] displayName=Lacunarity, enableIf: ?fractal_type>=3, minValue=0.0, maxValue=100.0
 	//! [Default value] 0
	bool set_fractal_lacunarity(float val) { return setValue("fractal_lacunarity", val); }
	//! fractal lacunarity
 	//! [UI Guides] displayName=Lacunarity, enableIf: ?fractal_type>=3, minValue=0.0, maxValue=100.0
 	//! [Default value] 0
	float get_fractal_lacunarity() const { return getFloat("fractal_lacunarity"); }

	//! fractal H
 	//! [UI Guides] displayName=Exponent, enableIf: ?fractal_type>=3, minValue=0.0, maxValue=100.0
 	//! [Default value] 0
	bool set_fractal_H(float val) { return setValue("fractal_H", val); }
	//! fractal H
 	//! [UI Guides] displayName=Exponent, enableIf: ?fractal_type>=3, minValue=0.0, maxValue=100.0
 	//! [Default value] 0
	float get_fractal_H() const { return getFloat("fractal_H"); }

	//! use distortion
 	//! [UI Guides] startRollout=Distortion, displayName=Use distortion
 	//! [Default value] false
	bool set_use_dist(bool val) { return setValue("use_dist", val); }
	//! use distortion
 	//! [UI Guides] startRollout=Distortion, displayName=Use distortion
 	//! [Default value] false
	bool get_use_dist() const { return getBool("use_dist"); }

	//! distortion strength
 	//! [UI Guides] displayName=Distortion Strength, enableIf: ?use_dist=1, minValue=0.0, maxValue=1000.0
 	//! [Default value] 0.1
	bool set_dist_str(float val) { return setValue("dist_str", val); }
	//! distortion strength
 	//! [UI Guides] displayName=Distortion Strength, enableIf: ?use_dist=1, minValue=0.0, maxValue=1000.0
 	//! [Default value] 0.1
	float get_dist_str() const { return getFloat("dist_str"); }

	//! distortion map - works similarly to a bump map, solid colors have no effect
 	//! [UI Guides] displayName=Distortion map, enableIf: ?use_dist=1, attributes=textureSlot
 	bool set_dist_map(const Plugin& texture) { return setValue("dist_map", texture); }
	//! distortion map - works similarly to a bump map, solid colors have no effect
 	//! [UI Guides] displayName=Distortion map, enableIf: ?use_dist=1, attributes=textureSlot
 	bool set_dist_map(const AColor& texture) { return setValue("dist_map", texture); }
	//! distortion map - works similarly to a bump map, solid colors have no effect
 	//! [UI Guides] displayName=Distortion map, enableIf: ?use_dist=1, attributes=textureSlot
 	Value get_dist_map() const { return getValue("dist_map"); }

	//! texture for distortion strength
 	//! [UI Guides] displayName=Distortion Strength map, enableIf: ?use_dist=1, attributes=textureSlot
 	bool set_dist_map2(const Plugin& texture) { return setValue("dist_map2", texture); }
	//! texture for distortion strength
 	//! [UI Guides] displayName=Distortion Strength map, enableIf: ?use_dist=1, attributes=textureSlot
 	bool set_dist_map2(const AColor& texture) { return setValue("dist_map2", texture); }
	//! texture for distortion strength
 	//! [UI Guides] displayName=Distortion Strength map, enableIf: ?use_dist=1, attributes=textureSlot
 	Value get_dist_map2() const { return getValue("dist_map2"); }

	//! texture for the size
 	//! [UI Guides] startRollout=Map parameters, displayName=Size map, attributes=textureSlot
 	bool set_tex_size(const Plugin& texture) { return setValue("tex_size", texture); }
	//! texture for the size
 	//! [UI Guides] startRollout=Map parameters, displayName=Size map, attributes=textureSlot
 	bool set_tex_size(const AColor& texture) { return setValue("tex_size", texture); }
	//! texture for the size
 	//! [UI Guides] startRollout=Map parameters, displayName=Size map, attributes=textureSlot
 	Value get_tex_size() const { return getValue("tex_size"); }

	//! texture for low threshold
 	//! [UI Guides] displayName=Threshold low map, attributes=textureSlot
 	bool set_tex_low(const Plugin& texture) { return setValue("tex_low", texture); }
	//! texture for low threshold
 	//! [UI Guides] displayName=Threshold low map, attributes=textureSlot
 	bool set_tex_low(const AColor& texture) { return setValue("tex_low", texture); }
	//! texture for low threshold
 	//! [UI Guides] displayName=Threshold low map, attributes=textureSlot
 	Value get_tex_low() const { return getValue("tex_low"); }

	//! texture for high threshold
 	//! [UI Guides] displayName=Threshold high map, attributes=textureSlot
 	bool set_tex_high(const Plugin& texture) { return setValue("tex_high", texture); }
	//! texture for high threshold
 	//! [UI Guides] displayName=Threshold high map, attributes=textureSlot
 	bool set_tex_high(const AColor& texture) { return setValue("tex_high", texture); }
	//! texture for high threshold
 	//! [UI Guides] displayName=Threshold high map, attributes=textureSlot
 	Value get_tex_high() const { return getValue("tex_high"); }

	//! texture for phase
 	//! [UI Guides] displayName=Phase map, attributes=textureSlot
 	bool set_tex_phase(const Plugin& texture) { return setValue("tex_phase", texture); }
	//! texture for phase
 	//! [UI Guides] displayName=Phase map, attributes=textureSlot
 	bool set_tex_phase(const AColor& texture) { return setValue("tex_phase", texture); }
	//! texture for phase
 	//! [UI Guides] displayName=Phase map, attributes=textureSlot
 	Value get_tex_phase() const { return getValue("tex_phase"); }

	//! texture for spread
 	//! [UI Guides] displayName=Spread map, attributes=textureSlot
 	bool set_tex_spread(const Plugin& texture) { return setValue("tex_spread", texture); }
	//! texture for spread
 	//! [UI Guides] displayName=Spread map, attributes=textureSlot
 	bool set_tex_spread(const AColor& texture) { return setValue("tex_spread", texture); }
	//! texture for spread
 	//! [UI Guides] displayName=Spread map, attributes=textureSlot
 	Value get_tex_spread() const { return getValue("tex_spread"); }

	//! texture for F1
 	//! [UI Guides] displayName=F1 map, attributes=textureSlot
 	bool set_tex_F1(const Plugin& texture) { return setValue("tex_F1", texture); }
	//! texture for F1
 	//! [UI Guides] displayName=F1 map, attributes=textureSlot
 	bool set_tex_F1(const AColor& texture) { return setValue("tex_F1", texture); }
	//! texture for F1
 	//! [UI Guides] displayName=F1 map, attributes=textureSlot
 	Value get_tex_F1() const { return getValue("tex_F1"); }

	//! texture for F2
 	//! [UI Guides] displayName=F2 map, attributes=textureSlot
 	bool set_tex_F2(const Plugin& texture) { return setValue("tex_F2", texture); }
	//! texture for F2
 	//! [UI Guides] displayName=F2 map, attributes=textureSlot
 	bool set_tex_F2(const AColor& texture) { return setValue("tex_F2", texture); }
	//! texture for F2
 	//! [UI Guides] displayName=F2 map, attributes=textureSlot
 	Value get_tex_F2() const { return getValue("tex_F2"); }

	//! texture for F3
 	//! [UI Guides] displayName=F3 map, attributes=textureSlot
 	bool set_tex_F3(const Plugin& texture) { return setValue("tex_F3", texture); }
	//! texture for F3
 	//! [UI Guides] displayName=F3 map, attributes=textureSlot
 	bool set_tex_F3(const AColor& texture) { return setValue("tex_F3", texture); }
	//! texture for F3
 	//! [UI Guides] displayName=F3 map, attributes=textureSlot
 	Value get_tex_F3() const { return getValue("tex_F3"); }

	//! texture for F4
 	//! [UI Guides] displayName=F4 map, attributes=textureSlot
 	bool set_tex_F4(const Plugin& texture) { return setValue("tex_F4", texture); }
	//! texture for F4
 	//! [UI Guides] displayName=F4 map, attributes=textureSlot
 	bool set_tex_F4(const AColor& texture) { return setValue("tex_F4", texture); }
	//! texture for F4
 	//! [UI Guides] displayName=F4 map, attributes=textureSlot
 	Value get_tex_F4() const { return getValue("tex_F4"); }

	//! texture for fractal levels
 	//! [UI Guides] displayName=Levels map, attributes=textureSlot
 	bool set_tex_levels(const Plugin& texture) { return setValue("tex_levels", texture); }
	//! texture for fractal levels
 	//! [UI Guides] displayName=Levels map, attributes=textureSlot
 	bool set_tex_levels(const AColor& texture) { return setValue("tex_levels", texture); }
	//! texture for fractal levels
 	//! [UI Guides] displayName=Levels map, attributes=textureSlot
 	Value get_tex_levels() const { return getValue("tex_levels"); }

	//! texture for fractal offset
 	//! [UI Guides] displayName=Offset map, attributes=textureSlot
 	bool set_tex_offset(const Plugin& texture) { return setValue("tex_offset", texture); }
	//! texture for fractal offset
 	//! [UI Guides] displayName=Offset map, attributes=textureSlot
 	bool set_tex_offset(const AColor& texture) { return setValue("tex_offset", texture); }
	//! texture for fractal offset
 	//! [UI Guides] displayName=Offset map, attributes=textureSlot
 	Value get_tex_offset() const { return getValue("tex_offset"); }

	//! texture for fractal gain
 	//! [UI Guides] displayName=Gain map, attributes=textureSlot
 	bool set_tex_gain(const Plugin& texture) { return setValue("tex_gain", texture); }
	//! texture for fractal gain
 	//! [UI Guides] displayName=Gain map, attributes=textureSlot
 	bool set_tex_gain(const AColor& texture) { return setValue("tex_gain", texture); }
	//! texture for fractal gain
 	//! [UI Guides] displayName=Gain map, attributes=textureSlot
 	Value get_tex_gain() const { return getValue("tex_gain"); }

	//! texture for fractal lacunarity
 	//! [UI Guides] displayName=Lacunarity map, attributes=textureSlot
 	bool set_tex_lacunarity(const Plugin& texture) { return setValue("tex_lacunarity", texture); }
	//! texture for fractal lacunarity
 	//! [UI Guides] displayName=Lacunarity map, attributes=textureSlot
 	bool set_tex_lacunarity(const AColor& texture) { return setValue("tex_lacunarity", texture); }
	//! texture for fractal lacunarity
 	//! [UI Guides] displayName=Lacunarity map, attributes=textureSlot
 	Value get_tex_lacunarity() const { return getValue("tex_lacunarity"); }

	//! texture for exponent
 	//! [UI Guides] displayName=Exponent map, attributes=textureSlot
 	bool set_tex_exponent(const Plugin& texture) { return setValue("tex_exponent", texture); }
	//! texture for exponent
 	//! [UI Guides] displayName=Exponent map, attributes=textureSlot
 	bool set_tex_exponent(const AColor& texture) { return setValue("tex_exponent", texture); }
	//! texture for exponent
 	//! [UI Guides] displayName=Exponent map, attributes=textureSlot
 	Value get_tex_exponent() const { return getValue("tex_exponent"); }

	//! (description missing)
	//! [Default value] false
	bool set_use_curve_input(bool val) { return setValue("use_curve_input", val); }
	//! (description missing)
	//! [Default value] false
	bool get_use_curve_input() const { return getBool("use_curve_input"); }

	//! If curve is used the output value will be taken from this texture
 	bool set_curve_input(const Plugin& texturefloat) { return setValue("curve_input", texturefloat); }
	//! If curve is used the output value will be taken from this texture
 	bool set_curve_input(float texturefloat) { return setValue("curve_input", texturefloat); }
	//! If curve is used the output value will be taken from this texture
 	Value get_curve_input() const { return getValue("curve_input"); }
};

class TexBerconTile : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexBerconTile"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	bool set_placement_type(int val) { return setValue("placement_type", val); }
	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	int get_placement_type() const { return getInt("placement_type"); }

	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_u(float val) { return setValue("u", val); }
	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_u() const { return getFloat("u"); }

	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_v(float val) { return setValue("v", val); }
	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_v() const { return getFloat("v"); }

	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_w(float val) { return setValue("w", val); }
	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_w() const { return getFloat("w"); }

	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_h(float val) { return setValue("h", val); }
	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_h() const { return getFloat("h"); }

	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	bool set_jitter(float val) { return setValue("jitter", val); }
	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	float get_jitter() const { return getFloat("jitter"); }

	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_u(bool val) { return setValue("tile_u", val); }
	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_u() const { return getBool("tile_u"); }

	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_v(bool val) { return setValue("tile_v", val); }
	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_v() const { return getBool("tile_v"); }

	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool set_uv_noise_on(bool val) { return setValue("uv_noise_on", val); }
	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool get_uv_noise_on() const { return getBool("uv_noise_on"); }

	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool set_uv_noise_animate(bool val) { return setValue("uv_noise_animate", val); }
	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool get_uv_noise_animate() const { return getBool("uv_noise_animate"); }

	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	bool set_uv_noise_amount(float val) { return setValue("uv_noise_amount", val); }
	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	float get_uv_noise_amount() const { return getFloat("uv_noise_amount"); }

	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	bool set_uv_noise_levels(float val) { return setValue("uv_noise_levels", val); }
	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	float get_uv_noise_levels() const { return getFloat("uv_noise_levels"); }

	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	bool set_uv_noise_size(float val) { return setValue("uv_noise_size", val); }
	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	float get_uv_noise_size() const { return getFloat("uv_noise_size"); }

	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	bool set_un_noise_phase(float val) { return setValue("un_noise_phase", val); }
	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	float get_un_noise_phase() const { return getFloat("un_noise_phase"); }

	//! noise color 1
 	//! [Default value] Color(0, 0, 0)
	bool set_noise_color1(const Color& color) { return setValue("noise_color1", color); }
	//! noise color 1
 	//! [Default value] Color(0, 0, 0)
	Color get_noise_color1() const { return getColor("noise_color1"); }

	//! noise color 2
 	//! [Default value] Color(0, 0, 0)
	bool set_noise_color2(const Color& color) { return setValue("noise_color2", color); }
	//! noise color 2
 	//! [Default value] Color(0, 0, 0)
	Color get_noise_color2() const { return getColor("noise_color2"); }

	//! noise color 3
 	//! [UI Guides] enableIf: ?lock_edge=0
 	//! [Default value] Color(0, 0, 0)
	bool set_noise_color3(const Color& color) { return setValue("noise_color3", color); }
	//! noise color 3
 	//! [UI Guides] enableIf: ?lock_edge=0
 	//! [Default value] Color(0, 0, 0)
	Color get_noise_color3() const { return getColor("noise_color3"); }

	//! noise map 1
 	//! [UI Guides] displayName=Color #1 map
 	bool set_noise_map1(const Plugin& texture) { return setValue("noise_map1", texture); }
	//! noise map 1
 	//! [UI Guides] displayName=Color #1 map
 	bool set_noise_map1(const AColor& texture) { return setValue("noise_map1", texture); }
	//! noise map 1
 	//! [UI Guides] displayName=Color #1 map
 	Value get_noise_map1() const { return getValue("noise_map1"); }

	//! noise map 2
 	//! [UI Guides] displayName=Edge color map
 	bool set_noise_map2(const Plugin& texture) { return setValue("noise_map2", texture); }
	//! noise map 2
 	//! [UI Guides] displayName=Edge color map
 	bool set_noise_map2(const AColor& texture) { return setValue("noise_map2", texture); }
	//! noise map 2
 	//! [UI Guides] displayName=Edge color map
 	Value get_noise_map2() const { return getValue("noise_map2"); }

	//! lock edge
 	//! [UI Guides] displayName=Color 2 same as Edge color
 	//! [Default value] true
	bool set_lock_edge(bool val) { return setValue("lock_edge", val); }
	//! lock edge
 	//! [UI Guides] displayName=Color 2 same as Edge color
 	//! [Default value] true
	bool get_lock_edge() const { return getBool("lock_edge"); }

	//! noise map 3
 	//! [UI Guides] displayName=Color #2 map, enableIf: ?lock_edge=0
 	bool set_noise_map3(const Plugin& texture) { return setValue("noise_map3", texture); }
	//! noise map 3
 	//! [UI Guides] displayName=Color #2 map, enableIf: ?lock_edge=0
 	bool set_noise_map3(const AColor& texture) { return setValue("noise_map3", texture); }
	//! noise map 3
 	//! [UI Guides] displayName=Color #2 map, enableIf: ?lock_edge=0
 	Value get_noise_map3() const { return getValue("noise_map3"); }

	//! tile size
 	//! [UI Guides] displayName=Size, startRollout=Tiling, minValue=0.0, maxValue=1000000.0
 	//! [Default value] 25
	bool set_tile_size(float val) { return setValue("tile_size", val); }
	//! tile size
 	//! [UI Guides] displayName=Size, startRollout=Tiling, minValue=0.0, maxValue=1000000.0
 	//! [Default value] 25
	float get_tile_size() const { return getFloat("tile_size"); }

	//! tile style
 	//! [UI Guides] displayName=Style, enum=0:Custom; 1:Herringbone; 2:Stack Bond; 3:Stretcher Bond; 4:Flemish Stretcher Bond; 5:Common Bond; 6:Flemish Bond; 7:Monk Bond; 8:Flemish Garden Wall Bond; 9:English Bond; 10:English Cross Bond; 11:Double English Cross Bond
 	//! [Default value] 0
	bool set_tile_style(int val) { return setValue("tile_style", val); }
	//! tile style
 	//! [UI Guides] displayName=Style, enum=0:Custom; 1:Herringbone; 2:Stack Bond; 3:Stretcher Bond; 4:Flemish Stretcher Bond; 5:Common Bond; 6:Flemish Bond; 7:Monk Bond; 8:Flemish Garden Wall Bond; 9:English Bond; 10:English Cross Bond; 11:Double English Cross Bond
 	//! [Default value] 0
	int get_tile_style() const { return getInt("tile_style"); }

	//! tile width
 	//! [UI Guides] displayName=Tile Width, minValue=0.0, maxValue=1000000.0
 	//! [Default value] 4
	bool set_tile_width(float val) { return setValue("tile_width", val); }
	//! tile width
 	//! [UI Guides] displayName=Tile Width, minValue=0.0, maxValue=1000000.0
 	//! [Default value] 4
	float get_tile_width() const { return getFloat("tile_width"); }

	//! tile height
 	//! [UI Guides] displayName=Tile Height, minValue=0.0, maxValue=1000000.0, enableIf: ?tile_style!=1
 	//! [Default value] 2
	bool set_tile_height(float val) { return setValue("tile_height", val); }
	//! tile height
 	//! [UI Guides] displayName=Tile Height, minValue=0.0, maxValue=1000000.0, enableIf: ?tile_style!=1
 	//! [Default value] 2
	float get_tile_height() const { return getFloat("tile_height"); }

	//! edge width
 	//! [UI Guides] displayName=Edge Width, minValue=0.0, maxValue=1000000.0
 	//! [Default value] 0.1
	bool set_edge_width(float val) { return setValue("edge_width", val); }
	//! edge width
 	//! [UI Guides] displayName=Edge Width, minValue=0.0, maxValue=1000000.0
 	//! [Default value] 0.1
	float get_edge_width() const { return getFloat("edge_width"); }

	//! edge height
 	//! [UI Guides] displayName=Edge Height, minValue=0.0, maxValue=1000000.0
 	//! [Default value] 0.1
	bool set_edge_height(float val) { return setValue("edge_height", val); }
	//! edge height
 	//! [UI Guides] displayName=Edge Height, minValue=0.0, maxValue=1000000.0
 	//! [Default value] 0.1
	float get_edge_height() const { return getFloat("edge_height"); }

	//! tile width 2
 	//! [UI Guides] displayName=Tile Width Variation %, startRollout=, minValue=0.0, maxValue=100.0, enableIf: ?tile_style!=1
 	//! [Default value] 0
	bool set_tile_width2(float val) { return setValue("tile_width2", val); }
	//! tile width 2
 	//! [UI Guides] displayName=Tile Width Variation %, startRollout=, minValue=0.0, maxValue=100.0, enableIf: ?tile_style!=1
 	//! [Default value] 0
	float get_tile_width2() const { return getFloat("tile_width2"); }

	//! tile height 2
 	//! [UI Guides] displayName=Tile Height Variation %, minValue=0.0, maxValue=100.0, enableIf: ?tile_style!=1
 	//! [Default value] 0
	bool set_tile_height2(float val) { return setValue("tile_height2", val); }
	//! tile height 2
 	//! [UI Guides] displayName=Tile Height Variation %, minValue=0.0, maxValue=100.0, enableIf: ?tile_style!=1
 	//! [Default value] 0
	float get_tile_height2() const { return getFloat("tile_height2"); }

	//! edge width 2
 	//! [UI Guides] displayName=Edge Width Variation %, minValue=0.0, maxValue=100.0
 	//! [Default value] 0
	bool set_edge_width2(float val) { return setValue("edge_width2", val); }
	//! edge width 2
 	//! [UI Guides] displayName=Edge Width Variation %, minValue=0.0, maxValue=100.0
 	//! [Default value] 0
	float get_edge_width2() const { return getFloat("edge_width2"); }

	//! edge height 2
 	//! [UI Guides] displayName=Edge Height Variation %, minValue=0.0, maxValue=100.0
 	//! [Default value] 0
	bool set_edge_height2(float val) { return setValue("edge_height2", val); }
	//! edge height 2
 	//! [UI Guides] displayName=Edge Height Variation %, minValue=0.0, maxValue=100.0
 	//! [Default value] 0
	float get_edge_height2() const { return getFloat("edge_height2"); }

	//! tile soften
 	//! [UI Guides] displayName=Soften, startRollout=, enum=0:None;1:Linear;2:Round;3:Smooth
 	//! [Default value] 2
	bool set_soften(int val) { return setValue("soften", val); }
	//! tile soften
 	//! [UI Guides] displayName=Soften, startRollout=, enum=0:None;1:Linear;2:Round;3:Smooth
 	//! [Default value] 2
	int get_soften() const { return getInt("soften"); }

	//! soften radius
 	//! [UI Guides] displayName=Soften Radius, minValue=0.0, maxValue=1000000.0, enableIf: ?soften!=0
 	//! [Default value] 0.1
	bool set_soften_rad(float val) { return setValue("soften_rad", val); }
	//! soften radius
 	//! [UI Guides] displayName=Soften Radius, minValue=0.0, maxValue=1000000.0, enableIf: ?soften!=0
 	//! [Default value] 0.1
	float get_soften_rad() const { return getFloat("soften_rad"); }

	//! round
 	//! [UI Guides] displayName=Round corners
 	//! [Default value] true
	bool set_round(bool val) { return setValue("round", val); }
	//! round
 	//! [UI Guides] displayName=Round corners
 	//! [Default value] true
	bool get_round() const { return getBool("round"); }

	//! round radius
 	//! [UI Guides] displayName=Round Radius, minValue=0.0, maxValue=1000000.0, enableIf: ?round=1
 	//! [Default value] 0.3
	bool set_round_rad(float val) { return setValue("round_rad", val); }
	//! round radius
 	//! [UI Guides] displayName=Round Radius, minValue=0.0, maxValue=1000000.0, enableIf: ?round=1
 	//! [Default value] 0.3
	float get_round_rad() const { return getFloat("round_rad"); }

	//! map uv
 	//! [UI Guides] displayName=Enable Tile Mapping, startRollout=Tile UV Mapping
 	//! [Default value] true
	bool set_map_uv(bool val) { return setValue("map_uv", val); }
	//! map uv
 	//! [UI Guides] displayName=Enable Tile Mapping, startRollout=Tile UV Mapping
 	//! [Default value] true
	bool get_map_uv() const { return getBool("map_uv"); }

	//! uv channel
 	//! [UI Guides] displayName=Tile UV Channel, minValue=1, maxValue=99, enableIf: ?map_uv=1
 	//! [Default value] 1
	bool set_uv_channel(int val) { return setValue("uv_channel", val); }
	//! uv channel
 	//! [UI Guides] displayName=Tile UV Channel, minValue=1, maxValue=99, enableIf: ?map_uv=1
 	//! [Default value] 1
	int get_uv_channel() const { return getInt("uv_channel"); }

	//! auto scaling
 	//! [UI Guides] displayName=Auto Scaling, enum=0:No auto scale; 1:UV; 2:UV Fit; 3:UV Fit Keep aspect; 4:UV Normalized; 5:UV Normalized Keep aspect, enableIf: ?map_uv=1
 	//! [Default value] 5
	bool set_auto(int val) { return setValue("auto", val); }
	//! auto scaling
 	//! [UI Guides] displayName=Auto Scaling, enum=0:No auto scale; 1:UV; 2:UV Fit; 3:UV Fit Keep aspect; 4:UV Normalized; 5:UV Normalized Keep aspect, enableIf: ?map_uv=1
 	//! [Default value] 5
	int get_auto() const { return getInt("auto"); }

	//! random X
 	//! [UI Guides] displayName=Random X Offset, minValue=0.0, maxValue=1000000.0, enableIf: ?map_uv=1
 	//! [Default value] 0
	bool set_rand_X(float val) { return setValue("rand_X", val); }
	//! random X
 	//! [UI Guides] displayName=Random X Offset, minValue=0.0, maxValue=1000000.0, enableIf: ?map_uv=1
 	//! [Default value] 0
	float get_rand_X() const { return getFloat("rand_X"); }

	//! random Y
 	//! [UI Guides] displayName=Random Y Offset, minValue=0.0, maxValue=1000000.0, enableIf: ?map_uv=1
 	//! [Default value] 0
	bool set_rand_Y(float val) { return setValue("rand_Y", val); }
	//! random Y
 	//! [UI Guides] displayName=Random Y Offset, minValue=0.0, maxValue=1000000.0, enableIf: ?map_uv=1
 	//! [Default value] 0
	float get_rand_Y() const { return getFloat("rand_Y"); }

	//! random SX
 	//! [UI Guides] displayName=Random X Scale, minValue=0.0, maxValue=1000000.0, enableIf: ?map_uv=1
 	//! [Default value] 0
	bool set_rand_SX(float val) { return setValue("rand_SX", val); }
	//! random SX
 	//! [UI Guides] displayName=Random X Scale, minValue=0.0, maxValue=1000000.0, enableIf: ?map_uv=1
 	//! [Default value] 0
	float get_rand_SX() const { return getFloat("rand_SX"); }

	//! random SY
 	//! [UI Guides] displayName=Random Y Scale, minValue=0.0, maxValue=1000000.0, enableIf: ?map_uv=1,?lock=0
 	//! [Default value] 0
	bool set_rand_SY(float val) { return setValue("rand_SY", val); }
	//! random SY
 	//! [UI Guides] displayName=Random Y Scale, minValue=0.0, maxValue=1000000.0, enableIf: ?map_uv=1,?lock=0
 	//! [Default value] 0
	float get_rand_SY() const { return getFloat("rand_SY"); }

	//! lock
 	//! [UI Guides] displayName=Uniform Scale, enableIf: ?map_uv=1
 	//! [Default value] true
	bool set_lock(bool val) { return setValue("lock", val); }
	//! lock
 	//! [UI Guides] displayName=Uniform Scale, enableIf: ?map_uv=1
 	//! [Default value] true
	bool get_lock() const { return getBool("lock"); }

	//! rotate uv
 	//! [UI Guides] displayName=Random Rotation, enum=0:None;1:180 Degrees;2:90 Degrees;3:Random, enableIf: ?map_uv=1
 	//! [Default value] 2
	bool set_rot_uv(int val) { return setValue("rot_uv", val); }
	//! rotate uv
 	//! [UI Guides] displayName=Random Rotation, enum=0:None;1:180 Degrees;2:90 Degrees;3:Random, enableIf: ?map_uv=1
 	//! [Default value] 2
	int get_rot_uv() const { return getInt("rot_uv"); }

	//! random rotation
 	//! [UI Guides] displayName=Degrees, minValue=0.0, maxValue=180.0, enableIf: ?map_uv=1,?rot_uv=3
 	//! [Default value] 0
	bool set_rand_rot(float val) { return setValue("rand_rot", val); }
	//! random rotation
 	//! [UI Guides] displayName=Degrees, minValue=0.0, maxValue=180.0, enableIf: ?map_uv=1,?rot_uv=3
 	//! [Default value] 0
	float get_rand_rot() const { return getFloat("rand_rot"); }

	//! flip X
 	//! [UI Guides] displayName=Random flip X-axis, enableIf: ?map_uv=1
 	//! [Default value] true
	bool set_flip_X(bool val) { return setValue("flip_X", val); }
	//! flip X
 	//! [UI Guides] displayName=Random flip X-axis, enableIf: ?map_uv=1
 	//! [Default value] true
	bool get_flip_X() const { return getBool("flip_X"); }

	//! flip Y
 	//! [UI Guides] displayName=Random flip Y-axis, enableIf: ?map_uv=1
 	//! [Default value] true
	bool set_flip_Y(bool val) { return setValue("flip_Y", val); }
	//! flip Y
 	//! [UI Guides] displayName=Random flip Y-axis, enableIf: ?map_uv=1
 	//! [Default value] true
	bool get_flip_Y() const { return getBool("flip_Y"); }

	//! center
 	//! [UI Guides] displayName=Center UV Mapping, startRollout=
 	//! [Default value] true
	bool set_center(bool val) { return setValue("center", val); }
	//! center
 	//! [UI Guides] displayName=Center UV Mapping, startRollout=
 	//! [Default value] true
	bool get_center() const { return getBool("center"); }

	//! center channel
 	//! [UI Guides] displayName=Center UV Channel, minValue=1, maxValue=99, enableIf: ?center=1
 	//! [Default value] 1
	bool set_center_channel(int val) { return setValue("center_channel", val); }
	//! center channel
 	//! [UI Guides] displayName=Center UV Channel, minValue=1, maxValue=99, enableIf: ?center=1
 	//! [Default value] 1
	int get_center_channel() const { return getInt("center_channel"); }

	//! random Z
 	//! [UI Guides] displayName=Randomize MultiTexture and BerconGradient, startRollout=
 	//! [Default value] true
	bool set_rand_Z(bool val) { return setValue("rand_Z", val); }
	//! random Z
 	//! [UI Guides] displayName=Randomize MultiTexture and BerconGradient, startRollout=
 	//! [Default value] true
	bool get_rand_Z() const { return getBool("rand_Z"); }

	//! offset, height, width1, width2, ... / offset, height, width1 ... Negative offset will be multiplied by row number try: -.25,1,1
 	//! [UI Guides] displayName=Pattern, startRollout=Custom Bond
 	//! [Default value] 0,1,1/.5,.5,1
	bool set_pattern(const char* str) { return setValue("pattern", str); }
	//! offset, height, width1, width2, ... / offset, height, width1 ... Negative offset will be multiplied by row number try: -.25,1,1
 	//! [UI Guides] displayName=Pattern, startRollout=Custom Bond
 	//! [Default value] 0,1,1/.5,.5,1
	bool set_pattern(const std::string& str) { return setValue("pattern", str); }
	//! offset, height, width1, width2, ... / offset, height, width1 ... Negative offset will be multiplied by row number try: -.25,1,1
 	//! [UI Guides] displayName=Pattern, startRollout=Custom Bond
 	//! [Default value] 0,1,1/.5,.5,1
	std::string get_pattern() const { return getString("pattern"); }

	//! use distortion
 	//! [UI Guides] displayName=Use Distortion, startRollout=Distortion
 	//! [Default value] false
	bool set_use_dist(bool val) { return setValue("use_dist", val); }
	//! use distortion
 	//! [UI Guides] displayName=Use Distortion, startRollout=Distortion
 	//! [Default value] false
	bool get_use_dist() const { return getBool("use_dist"); }

	//! distortion strength
 	//! [UI Guides] displayName=Strength, minValue=0.0, maxValue=1000.0, enableIf: ?use_dist=1
 	//! [Default value] 0.1
	bool set_dist_str(float val) { return setValue("dist_str", val); }
	//! distortion strength
 	//! [UI Guides] displayName=Strength, minValue=0.0, maxValue=1000.0, enableIf: ?use_dist=1
 	//! [Default value] 0.1
	float get_dist_str() const { return getFloat("dist_str"); }

	//! distortion map - works similarly to a bump map, solid colors have no effect
 	//! [UI Guides] displayName=Distortion map, enableIf: ?use_dist=1, attributes=textureSlot
 	bool set_dist_map(const Plugin& texture) { return setValue("dist_map", texture); }
	//! distortion map - works similarly to a bump map, solid colors have no effect
 	//! [UI Guides] displayName=Distortion map, enableIf: ?use_dist=1, attributes=textureSlot
 	bool set_dist_map(const AColor& texture) { return setValue("dist_map", texture); }
	//! distortion map - works similarly to a bump map, solid colors have no effect
 	//! [UI Guides] displayName=Distortion map, enableIf: ?use_dist=1, attributes=textureSlot
 	Value get_dist_map() const { return getValue("dist_map"); }

	//! texture for distortion strength
 	//! [UI Guides] displayName=Distortion Strength map, enableIf: ?use_dist=1, attributes=textureSlot
 	bool set_dist_map2(const Plugin& texture) { return setValue("dist_map2", texture); }
	//! texture for distortion strength
 	//! [UI Guides] displayName=Distortion Strength map, enableIf: ?use_dist=1, attributes=textureSlot
 	bool set_dist_map2(const AColor& texture) { return setValue("dist_map2", texture); }
	//! texture for distortion strength
 	//! [UI Guides] displayName=Distortion Strength map, enableIf: ?use_dist=1, attributes=textureSlot
 	Value get_dist_map2() const { return getValue("dist_map2"); }

	//! texture for soften radius
 	//! [UI Guides] startRollout=Map parameters, displayName=Soften Radius map, attributes=textureSlot
 	bool set_tex_soften_rad(const Plugin& texture) { return setValue("tex_soften_rad", texture); }
	//! texture for soften radius
 	//! [UI Guides] startRollout=Map parameters, displayName=Soften Radius map, attributes=textureSlot
 	bool set_tex_soften_rad(const AColor& texture) { return setValue("tex_soften_rad", texture); }
	//! texture for soften radius
 	//! [UI Guides] startRollout=Map parameters, displayName=Soften Radius map, attributes=textureSlot
 	Value get_tex_soften_rad() const { return getValue("tex_soften_rad"); }

	//! texture for round radius
 	//! [UI Guides] displayName=Round Radius map, attributes=textureSlot
 	bool set_tex_round_rad(const Plugin& texture) { return setValue("tex_round_rad", texture); }
	//! texture for round radius
 	//! [UI Guides] displayName=Round Radius map, attributes=textureSlot
 	bool set_tex_round_rad(const AColor& texture) { return setValue("tex_round_rad", texture); }
	//! texture for round radius
 	//! [UI Guides] displayName=Round Radius map, attributes=textureSlot
 	Value get_tex_round_rad() const { return getValue("tex_round_rad"); }
};

class TexBerconWood : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexBerconWood"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	bool set_placement_type(int val) { return setValue("placement_type", val); }
	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	int get_placement_type() const { return getInt("placement_type"); }

	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_u(float val) { return setValue("u", val); }
	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_u() const { return getFloat("u"); }

	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_v(float val) { return setValue("v", val); }
	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_v() const { return getFloat("v"); }

	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_w(float val) { return setValue("w", val); }
	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_w() const { return getFloat("w"); }

	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_h(float val) { return setValue("h", val); }
	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_h() const { return getFloat("h"); }

	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	bool set_jitter(float val) { return setValue("jitter", val); }
	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	float get_jitter() const { return getFloat("jitter"); }

	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_u(bool val) { return setValue("tile_u", val); }
	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_u() const { return getBool("tile_u"); }

	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_v(bool val) { return setValue("tile_v", val); }
	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_v() const { return getBool("tile_v"); }

	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool set_uv_noise_on(bool val) { return setValue("uv_noise_on", val); }
	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool get_uv_noise_on() const { return getBool("uv_noise_on"); }

	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool set_uv_noise_animate(bool val) { return setValue("uv_noise_animate", val); }
	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool get_uv_noise_animate() const { return getBool("uv_noise_animate"); }

	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	bool set_uv_noise_amount(float val) { return setValue("uv_noise_amount", val); }
	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	float get_uv_noise_amount() const { return getFloat("uv_noise_amount"); }

	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	bool set_uv_noise_levels(float val) { return setValue("uv_noise_levels", val); }
	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	float get_uv_noise_levels() const { return getFloat("uv_noise_levels"); }

	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	bool set_uv_noise_size(float val) { return setValue("uv_noise_size", val); }
	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	float get_uv_noise_size() const { return getFloat("uv_noise_size"); }

	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	bool set_un_noise_phase(float val) { return setValue("un_noise_phase", val); }
	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	float get_un_noise_phase() const { return getFloat("un_noise_phase"); }

	//! noise color 1
 	//! [UI Guides] displayName=Color 1
 	//! [Default value] Color(0, 0, 0)
	bool set_noise_color1(const Color& color) { return setValue("noise_color1", color); }
	//! noise color 1
 	//! [UI Guides] displayName=Color 1
 	//! [Default value] Color(0, 0, 0)
	Color get_noise_color1() const { return getColor("noise_color1"); }

	//! noise color 2
 	//! [UI Guides] displayName=Color 2
 	//! [Default value] Color(0, 0, 0)
	bool set_noise_color2(const Color& color) { return setValue("noise_color2", color); }
	//! noise color 2
 	//! [UI Guides] displayName=Color 2
 	//! [Default value] Color(0, 0, 0)
	Color get_noise_color2() const { return getColor("noise_color2"); }

	//! noise color 3
 	//! [UI Guides] displayName=Grain Color, enableIf: grain_lock=0
 	//! [Default value] Color(0, 0, 0)
	bool set_noise_color3(const Color& color) { return setValue("noise_color3", color); }
	//! noise color 3
 	//! [UI Guides] displayName=Grain Color, enableIf: grain_lock=0
 	//! [Default value] Color(0, 0, 0)
	Color get_noise_color3() const { return getColor("noise_color3"); }

	//! noise map 1
 	//! [UI Guides] displayName=Color 1 map
 	bool set_noise_map1(const Plugin& texture) { return setValue("noise_map1", texture); }
	//! noise map 1
 	//! [UI Guides] displayName=Color 1 map
 	bool set_noise_map1(const AColor& texture) { return setValue("noise_map1", texture); }
	//! noise map 1
 	//! [UI Guides] displayName=Color 1 map
 	Value get_noise_map1() const { return getValue("noise_map1"); }

	//! noise map 2
 	//! [UI Guides] displayName=Color 2 map
 	bool set_noise_map2(const Plugin& texture) { return setValue("noise_map2", texture); }
	//! noise map 2
 	//! [UI Guides] displayName=Color 2 map
 	bool set_noise_map2(const AColor& texture) { return setValue("noise_map2", texture); }
	//! noise map 2
 	//! [UI Guides] displayName=Color 2 map
 	Value get_noise_map2() const { return getValue("noise_map2"); }

	//! grain lock
 	//! [UI Guides] displayName=Grain Color same as Color 2
 	//! [Default value] false
	bool set_grain_lock(bool val) { return setValue("grain_lock", val); }
	//! grain lock
 	//! [UI Guides] displayName=Grain Color same as Color 2
 	//! [Default value] false
	bool get_grain_lock() const { return getBool("grain_lock"); }

	//! noise map 3
 	//! [UI Guides] displayName=Grain Color map, enableIf: ?grain_lock=0
 	bool set_noise_map3(const Plugin& texture) { return setValue("noise_map3", texture); }
	//! noise map 3
 	//! [UI Guides] displayName=Grain Color map, enableIf: ?grain_lock=0
 	bool set_noise_map3(const AColor& texture) { return setValue("noise_map3", texture); }
	//! noise map 3
 	//! [UI Guides] displayName=Grain Color map, enableIf: ?grain_lock=0
 	Value get_noise_map3() const { return getValue("noise_map3"); }

	//! random seed
 	//! [UI Guides] startRollout=General, displayName=Seed, minValue=0.0
 	//! [Default value] 12.345
	bool set_rand_seed(float val) { return setValue("rand_seed", val); }
	//! random seed
 	//! [UI Guides] startRollout=General, displayName=Seed, minValue=0.0
 	//! [Default value] 12.345
	float get_rand_seed() const { return getFloat("rand_seed"); }

	//! 0:Radial wood, 1:Perlin wood, 2:Simplex wood, 3:Linear wood
 	//! [UI Guides] enum=0:Radial wood; 1:Perlin wood; 2:Simplex wood; 3:Linear wood, displayName=Wood type
 	//! [Default value] 0
	bool set_wood_type(int val) { return setValue("wood_type", val); }
	//! 0:Radial wood, 1:Perlin wood, 2:Simplex wood, 3:Linear wood
 	//! [UI Guides] enum=0:Radial wood; 1:Perlin wood; 2:Simplex wood; 3:Linear wood, displayName=Wood type
 	//! [Default value] 0
	int get_wood_type() const { return getInt("wood_type"); }

	//! wood size
 	//! [UI Guides] displayName=Size, minValue=0.0
 	//! [Default value] 3
	bool set_wood_size(float val) { return setValue("wood_size", val); }
	//! wood size
 	//! [UI Guides] displayName=Size, minValue=0.0
 	//! [Default value] 3
	float get_wood_size() const { return getFloat("wood_size"); }

	//! low treshold
 	//! [UI Guides] displayName=Low, minValue=0.0, maxValue=1.0
 	//! [Default value] 0.3
	bool set_low_tresh(float val) { return setValue("low_tresh", val); }
	//! low treshold
 	//! [UI Guides] displayName=Low, minValue=0.0, maxValue=1.0
 	//! [Default value] 0.3
	float get_low_tresh() const { return getFloat("low_tresh"); }

	//! high treshold
 	//! [UI Guides] displayName=High, minValue=0.0, maxValue=1.0
 	//! [Default value] 1
	bool set_high_tresh(float val) { return setValue("high_tresh", val); }
	//! high treshold
 	//! [UI Guides] displayName=High, minValue=0.0, maxValue=1.0
 	//! [Default value] 1
	float get_high_tresh() const { return getFloat("high_tresh"); }

	//! wood skew
 	//! [UI Guides] displayName=Skew, minValue=0.0, maxValue=1.0
 	//! [Default value] 0.75
	bool set_wood_skew(float val) { return setValue("wood_skew", val); }
	//! wood skew
 	//! [UI Guides] displayName=Skew, minValue=0.0, maxValue=1.0
 	//! [Default value] 0.75
	float get_wood_skew() const { return getFloat("wood_skew"); }

	//! width variation
 	//! [UI Guides] displayName=Width Variation, minValue=0.0
 	//! [Default value] 0.5
	bool set_width_var(float val) { return setValue("width_var", val); }
	//! width variation
 	//! [UI Guides] displayName=Width Variation, minValue=0.0
 	//! [Default value] 0.5
	float get_width_var() const { return getFloat("width_var"); }

	//! gain variation
 	//! [UI Guides] displayName=Gain Variation, minValue=0.0, maxValue=1.0
 	//! [Default value] 0.75
	bool set_gain_var(float val) { return setValue("gain_var", val); }
	//! gain variation
 	//! [UI Guides] displayName=Gain Variation, minValue=0.0, maxValue=1.0
 	//! [Default value] 0.75
	float get_gain_var() const { return getFloat("gain_var"); }

	//! trunk strength
 	//! [UI Guides] startRollout=Trunk wobble, displayName=Strength, minValue=0.0
 	//! [Default value] 1
	bool set_trunk_str(float val) { return setValue("trunk_str", val); }
	//! trunk strength
 	//! [UI Guides] startRollout=Trunk wobble, displayName=Strength, minValue=0.0
 	//! [Default value] 1
	float get_trunk_str() const { return getFloat("trunk_str"); }

	//! trunk frequency
 	//! [UI Guides] displayName=Frequency, minValue=0.001
 	//! [Default value] 0.04
	bool set_trunk_freq(float val) { return setValue("trunk_freq", val); }
	//! trunk frequency
 	//! [UI Guides] displayName=Frequency, minValue=0.001
 	//! [Default value] 0.04
	float get_trunk_freq() const { return getFloat("trunk_freq"); }

	//! radial strength
 	//! [UI Guides] startRollout=Radial noise, displayName=Strength, minValue=0.0
 	//! [Default value] 0.25
	bool set_radial_str(float val) { return setValue("radial_str", val); }
	//! radial strength
 	//! [UI Guides] startRollout=Radial noise, displayName=Strength, minValue=0.0
 	//! [Default value] 0.25
	float get_radial_str() const { return getFloat("radial_str"); }

	//! radial frequency
 	//! [UI Guides] displayName=Frequency, minValue = 0.001
 	//! [Default value] 0.1
	bool set_radial_freq(float val) { return setValue("radial_freq", val); }
	//! radial frequency
 	//! [UI Guides] displayName=Frequency, minValue = 0.001
 	//! [Default value] 0.1
	float get_radial_freq() const { return getFloat("radial_freq"); }

	//! radial Z frequency
 	//! [UI Guides] displayName=Z Frequency, minValue = 0.0
 	//! [Default value] 0.01
	bool set_radial_z(float val) { return setValue("radial_z", val); }
	//! radial Z frequency
 	//! [UI Guides] displayName=Z Frequency, minValue = 0.0
 	//! [Default value] 0.01
	float get_radial_z() const { return getFloat("radial_z"); }

	//! angle strength
 	//! [UI Guides] startRollout=Angular noise, displayName=Strength, minValue=0.0
 	//! [Default value] 0.1
	bool set_angle_str(float val) { return setValue("angle_str", val); }
	//! angle strength
 	//! [UI Guides] startRollout=Angular noise, displayName=Strength, minValue=0.0
 	//! [Default value] 0.1
	float get_angle_str() const { return getFloat("angle_str"); }

	//! angle frequency
 	//! [UI Guides] displayName=Frequency, minValue=0.001
 	//! [Default value] 1
	bool set_angle_freq(float val) { return setValue("angle_freq", val); }
	//! angle frequency
 	//! [UI Guides] displayName=Frequency, minValue=0.001
 	//! [Default value] 1
	float get_angle_freq() const { return getFloat("angle_freq"); }

	//! angle radius
 	//! [UI Guides] displayName=Radius, minValue=0.001
 	//! [Default value] 15
	bool set_angle_rad(float val) { return setValue("angle_rad", val); }
	//! angle radius
 	//! [UI Guides] displayName=Radius, minValue=0.001
 	//! [Default value] 15
	float get_angle_rad() const { return getFloat("angle_rad"); }

	//! grain strength
 	//! [UI Guides] startRollout=Grain, displayName=Amount, minValue=0.0
 	//! [Default value] 0.2
	bool set_grain_str(float val) { return setValue("grain_str", val); }
	//! grain strength
 	//! [UI Guides] startRollout=Grain, displayName=Amount, minValue=0.0
 	//! [Default value] 0.2
	float get_grain_str() const { return getFloat("grain_str"); }

	//! grain frequency
 	//! [UI Guides] displayName=Frequency, minValue=0.001
 	//! [Default value] 5
	bool set_grain_freq(float val) { return setValue("grain_freq", val); }
	//! grain frequency
 	//! [UI Guides] displayName=Frequency, minValue=0.001
 	//! [Default value] 5
	float get_grain_freq() const { return getFloat("grain_freq"); }

	//! use distortion
 	//! [UI Guides] startRollout=Distortion, displayName=Use distortion
 	//! [Default value] false
	bool set_use_dist(bool val) { return setValue("use_dist", val); }
	//! use distortion
 	//! [UI Guides] startRollout=Distortion, displayName=Use distortion
 	//! [Default value] false
	bool get_use_dist() const { return getBool("use_dist"); }

	//! distortion strength
 	//! [UI Guides] displayName=Strength, enableIf: ?use_dist=1, minValue=0.0, maxValue=1000.0
 	//! [Default value] 0.1
	bool set_dist_str(float val) { return setValue("dist_str", val); }
	//! distortion strength
 	//! [UI Guides] displayName=Strength, enableIf: ?use_dist=1, minValue=0.0, maxValue=1000.0
 	//! [Default value] 0.1
	float get_dist_str() const { return getFloat("dist_str"); }

	//! distortion map - works similarly to a bump map, solid colors have no effect
 	//! [UI Guides] displayName=Distortion map, enableIf: ?use_dist=1, attributes=textureSlot
 	bool set_dist_map(const Plugin& texture) { return setValue("dist_map", texture); }
	//! distortion map - works similarly to a bump map, solid colors have no effect
 	//! [UI Guides] displayName=Distortion map, enableIf: ?use_dist=1, attributes=textureSlot
 	bool set_dist_map(const AColor& texture) { return setValue("dist_map", texture); }
	//! distortion map - works similarly to a bump map, solid colors have no effect
 	//! [UI Guides] displayName=Distortion map, enableIf: ?use_dist=1, attributes=textureSlot
 	Value get_dist_map() const { return getValue("dist_map"); }

	//! texture for distortion strength
 	//! [UI Guides] displayName=Distortion Strength map, enableIf: ?use_dist=1, attributes=textureSlot
 	bool set_dist_map2(const Plugin& texture) { return setValue("dist_map2", texture); }
	//! texture for distortion strength
 	//! [UI Guides] displayName=Distortion Strength map, enableIf: ?use_dist=1, attributes=textureSlot
 	bool set_dist_map2(const AColor& texture) { return setValue("dist_map2", texture); }
	//! texture for distortion strength
 	//! [UI Guides] displayName=Distortion Strength map, enableIf: ?use_dist=1, attributes=textureSlot
 	Value get_dist_map2() const { return getValue("dist_map2"); }

	//! samples
 	//! [UI Guides] startRollout=Super Sampling, displayName=Samples, minValue=1
 	//! [Default value] 4
	bool set_samples(int val) { return setValue("samples", val); }
	//! samples
 	//! [UI Guides] startRollout=Super Sampling, displayName=Samples, minValue=1
 	//! [Default value] 4
	int get_samples() const { return getInt("samples"); }

	//! texture for the size
 	//! [UI Guides] startRollout=Map parameters, displayName=Size map, attributes=textureSlot
 	bool set_tex_size(const Plugin& texture) { return setValue("tex_size", texture); }
	//! texture for the size
 	//! [UI Guides] startRollout=Map parameters, displayName=Size map, attributes=textureSlot
 	bool set_tex_size(const AColor& texture) { return setValue("tex_size", texture); }
	//! texture for the size
 	//! [UI Guides] startRollout=Map parameters, displayName=Size map, attributes=textureSlot
 	Value get_tex_size() const { return getValue("tex_size"); }

	//! texture for low treshhold
 	//! [UI Guides] displayName=Threshold low map, attributes=textureSlot
 	bool set_tex_low(const Plugin& texture) { return setValue("tex_low", texture); }
	//! texture for low treshhold
 	//! [UI Guides] displayName=Threshold low map, attributes=textureSlot
 	bool set_tex_low(const AColor& texture) { return setValue("tex_low", texture); }
	//! texture for low treshhold
 	//! [UI Guides] displayName=Threshold low map, attributes=textureSlot
 	Value get_tex_low() const { return getValue("tex_low"); }

	//! texture for high greshhold
 	//! [UI Guides] displayName=Threshold high map, attributes=textureSlot
 	bool set_tex_high(const Plugin& texture) { return setValue("tex_high", texture); }
	//! texture for high greshhold
 	//! [UI Guides] displayName=Threshold high map, attributes=textureSlot
 	bool set_tex_high(const AColor& texture) { return setValue("tex_high", texture); }
	//! texture for high greshhold
 	//! [UI Guides] displayName=Threshold high map, attributes=textureSlot
 	Value get_tex_high() const { return getValue("tex_high"); }

	//! texture for skew
 	//! [UI Guides] displayName=Skew map, attributes=textureSlot
 	bool set_tex_skew(const Plugin& texture) { return setValue("tex_skew", texture); }
	//! texture for skew
 	//! [UI Guides] displayName=Skew map, attributes=textureSlot
 	bool set_tex_skew(const AColor& texture) { return setValue("tex_skew", texture); }
	//! texture for skew
 	//! [UI Guides] displayName=Skew map, attributes=textureSlot
 	Value get_tex_skew() const { return getValue("tex_skew"); }

	//! texture for width variation
 	//! [UI Guides] displayName=Width variation map, attributes=textureSlot
 	bool set_tex_width_var(const Plugin& texture) { return setValue("tex_width_var", texture); }
	//! texture for width variation
 	//! [UI Guides] displayName=Width variation map, attributes=textureSlot
 	bool set_tex_width_var(const AColor& texture) { return setValue("tex_width_var", texture); }
	//! texture for width variation
 	//! [UI Guides] displayName=Width variation map, attributes=textureSlot
 	Value get_tex_width_var() const { return getValue("tex_width_var"); }

	//! texture for gain variation
 	//! [UI Guides] displayName=Gain variation map, attributes=textureSlot
 	bool set_tex_gain_var(const Plugin& texture) { return setValue("tex_gain_var", texture); }
	//! texture for gain variation
 	//! [UI Guides] displayName=Gain variation map, attributes=textureSlot
 	bool set_tex_gain_var(const AColor& texture) { return setValue("tex_gain_var", texture); }
	//! texture for gain variation
 	//! [UI Guides] displayName=Gain variation map, attributes=textureSlot
 	Value get_tex_gain_var() const { return getValue("tex_gain_var"); }

	//! texture for trunk strength
 	//! [UI Guides] displayName=Trunk strength map, attributes=textureSlot
 	bool set_tex_trunk_str(const Plugin& texture) { return setValue("tex_trunk_str", texture); }
	//! texture for trunk strength
 	//! [UI Guides] displayName=Trunk strength map, attributes=textureSlot
 	bool set_tex_trunk_str(const AColor& texture) { return setValue("tex_trunk_str", texture); }
	//! texture for trunk strength
 	//! [UI Guides] displayName=Trunk strength map, attributes=textureSlot
 	Value get_tex_trunk_str() const { return getValue("tex_trunk_str"); }

	//! texture for trunk frequency
 	//! [UI Guides] displayName=Trunk frequency map, attributes=textureSlot
 	bool set_tex_trunk_freq(const Plugin& texture) { return setValue("tex_trunk_freq", texture); }
	//! texture for trunk frequency
 	//! [UI Guides] displayName=Trunk frequency map, attributes=textureSlot
 	bool set_tex_trunk_freq(const AColor& texture) { return setValue("tex_trunk_freq", texture); }
	//! texture for trunk frequency
 	//! [UI Guides] displayName=Trunk frequency map, attributes=textureSlot
 	Value get_tex_trunk_freq() const { return getValue("tex_trunk_freq"); }

	//! texture for radial strength
 	//! [UI Guides] displayName=Radial strength map, attributes=textureSlot
 	bool set_tex_radial_str(const Plugin& texture) { return setValue("tex_radial_str", texture); }
	//! texture for radial strength
 	//! [UI Guides] displayName=Radial strength map, attributes=textureSlot
 	bool set_tex_radial_str(const AColor& texture) { return setValue("tex_radial_str", texture); }
	//! texture for radial strength
 	//! [UI Guides] displayName=Radial strength map, attributes=textureSlot
 	Value get_tex_radial_str() const { return getValue("tex_radial_str"); }

	//! texture for radial frequency
 	//! [UI Guides] displayName=Radial frequency map, attributes=textureSlot
 	bool set_tex_radial_freq(const Plugin& texture) { return setValue("tex_radial_freq", texture); }
	//! texture for radial frequency
 	//! [UI Guides] displayName=Radial frequency map, attributes=textureSlot
 	bool set_tex_radial_freq(const AColor& texture) { return setValue("tex_radial_freq", texture); }
	//! texture for radial frequency
 	//! [UI Guides] displayName=Radial frequency map, attributes=textureSlot
 	Value get_tex_radial_freq() const { return getValue("tex_radial_freq"); }

	//! texture for radial z strength
 	//! [UI Guides] displayName=Radial Z frequency map, attributes=textureSlot
 	bool set_tex_z_str(const Plugin& texture) { return setValue("tex_z_str", texture); }
	//! texture for radial z strength
 	//! [UI Guides] displayName=Radial Z frequency map, attributes=textureSlot
 	bool set_tex_z_str(const AColor& texture) { return setValue("tex_z_str", texture); }
	//! texture for radial z strength
 	//! [UI Guides] displayName=Radial Z frequency map, attributes=textureSlot
 	Value get_tex_z_str() const { return getValue("tex_z_str"); }

	//! texture for angular strength
 	//! [UI Guides] displayName=Angular strength map, attributes=textureSlot
 	bool set_tex_ang_str(const Plugin& texture) { return setValue("tex_ang_str", texture); }
	//! texture for angular strength
 	//! [UI Guides] displayName=Angular strength map, attributes=textureSlot
 	bool set_tex_ang_str(const AColor& texture) { return setValue("tex_ang_str", texture); }
	//! texture for angular strength
 	//! [UI Guides] displayName=Angular strength map, attributes=textureSlot
 	Value get_tex_ang_str() const { return getValue("tex_ang_str"); }

	//! texture for angular frequency
 	//! [UI Guides] displayName=Angular frequency map, attributes=textureSlot
 	bool set_tex_ang_freq(const Plugin& texture) { return setValue("tex_ang_freq", texture); }
	//! texture for angular frequency
 	//! [UI Guides] displayName=Angular frequency map, attributes=textureSlot
 	bool set_tex_ang_freq(const AColor& texture) { return setValue("tex_ang_freq", texture); }
	//! texture for angular frequency
 	//! [UI Guides] displayName=Angular frequency map, attributes=textureSlot
 	Value get_tex_ang_freq() const { return getValue("tex_ang_freq"); }

	//! texture for angular radius
 	//! [UI Guides] displayName=Angular radius map, attributes=textureSlot
 	bool set_tex_ang_rad(const Plugin& texture) { return setValue("tex_ang_rad", texture); }
	//! texture for angular radius
 	//! [UI Guides] displayName=Angular radius map, attributes=textureSlot
 	bool set_tex_ang_rad(const AColor& texture) { return setValue("tex_ang_rad", texture); }
	//! texture for angular radius
 	//! [UI Guides] displayName=Angular radius map, attributes=textureSlot
 	Value get_tex_ang_rad() const { return getValue("tex_ang_rad"); }

	//! texture for grain strength
 	//! [UI Guides] displayName=Grain strength map, attributes=textureSlot
 	bool set_tex_grain_str(const Plugin& texture) { return setValue("tex_grain_str", texture); }
	//! texture for grain strength
 	//! [UI Guides] displayName=Grain strength map, attributes=textureSlot
 	bool set_tex_grain_str(const AColor& texture) { return setValue("tex_grain_str", texture); }
	//! texture for grain strength
 	//! [UI Guides] displayName=Grain strength map, attributes=textureSlot
 	Value get_tex_grain_str() const { return getValue("tex_grain_str"); }

	//! texture for grain frequency
 	//! [UI Guides] displayName=Grain frequency map, attributes=textureSlot
 	bool set_tex_grain_freq(const Plugin& texture) { return setValue("tex_grain_freq", texture); }
	//! texture for grain frequency
 	//! [UI Guides] displayName=Grain frequency map, attributes=textureSlot
 	bool set_tex_grain_freq(const AColor& texture) { return setValue("tex_grain_freq", texture); }
	//! texture for grain frequency
 	//! [UI Guides] displayName=Grain frequency map, attributes=textureSlot
 	Value get_tex_grain_freq() const { return getValue("tex_grain_freq"); }

	//! (description missing)
	//! [Default value] false
	bool set_use_curve_input(bool val) { return setValue("use_curve_input", val); }
	//! (description missing)
	//! [Default value] false
	bool get_use_curve_input() const { return getBool("use_curve_input"); }

	//! If curve is used the output value will be taken from this texture
 	bool set_curve_input(const Plugin& texturefloat) { return setValue("curve_input", texturefloat); }
	//! If curve is used the output value will be taken from this texture
 	bool set_curve_input(float texturefloat) { return setValue("curve_input", texturefloat); }
	//! If curve is used the output value will be taken from this texture
 	Value get_curve_input() const { return getValue("curve_input"); }
};

class TexBezierCurve : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexBezierCurve"; }

	//! The input texture
 	bool set_input_float(const Plugin& texturefloat) { return setValue("input_float", texturefloat); }
	//! The input texture
 	bool set_input_float(float texturefloat) { return setValue("input_float", texturefloat); }
	//! The input texture
 	Value get_input_float() const { return getValue("input_float"); }

	//! The control points; 6 floats for each point: 2D coords of the point itself, and 2D coords of the left and right tangent.
 	//! [Default value] 0
	bool set_points(const FloatList& floatList) { return setValue("points", floatList); }
	//! The control points; 6 floats for each point: 2D coords of the point itself, and 2D coords of the left and right tangent.
 	//! [Default value] 0
	bool set_points(const float* floats, size_t count) { return setArray("points", floats, count); }
	//! The control points; 6 floats for each point: 2D coords of the point itself, and 2D coords of the left and right tangent.
 	//! [Default value] 0
	template<size_t count> bool set_points(const float (&floats)[count]) { return setArray("points", floats, count); }
	//! The control points; 6 floats for each point: 2D coords of the point itself, and 2D coords of the left and right tangent.
 	//! [Default value] 0
	FloatList get_points() const { return getFloatList("points"); }

	//! The type of the control points: 0 - free, 1 - bezier, 2- bezier smooth
 	//! [UI Guides] enum=0:Free; 1:Bezier; 2:Bezier smooth
 	//! [Default value] 0
	bool set_types(const IntList& intList) { return setValue("types", intList); }
	//! The type of the control points: 0 - free, 1 - bezier, 2- bezier smooth
 	//! [UI Guides] enum=0:Free; 1:Bezier; 2:Bezier smooth
 	//! [Default value] 0
	bool set_types(const int* ints, size_t count) { return setArray("types", ints, count); }
	//! The type of the control points: 0 - free, 1 - bezier, 2- bezier smooth
 	//! [UI Guides] enum=0:Free; 1:Bezier; 2:Bezier smooth
 	//! [Default value] 0
	template<size_t count> bool set_types(const int (&ints)[count]) { return setArray("types", ints, count); }
	//! The type of the control points: 0 - free, 1 - bezier, 2- bezier smooth
 	//! [UI Guides] enum=0:Free; 1:Bezier; 2:Bezier smooth
 	//! [Default value] 0
	IntList get_types() const { return getIntList("types"); }

	//! The number of precisely calculated points from bezier curves: default 256
 	//! [Default value] 256
	bool set_num_bezier_points(int val) { return setValue("num_bezier_points", val); }
	//! The number of precisely calculated points from bezier curves: default 256
 	//! [Default value] 256
	int get_num_bezier_points() const { return getInt("num_bezier_points"); }

	//! true to extrapolate beyound the control points
 	//! [Default value] true
	bool set_use_end_tangents(bool val) { return setValue("use_end_tangents", val); }
	//! true to extrapolate beyound the control points
 	//! [Default value] true
	bool get_use_end_tangents() const { return getBool("use_end_tangents"); }

	//! The type of extrapolation for points out of the control range: 0 - end tangnts, 1 - linear, 2 - constant. Used when use_end_tangents is true.
 	//! [UI Guides] enum=0:End tangent; 1:Linear; 2:Constant
 	//! [Default value] 0
	bool set_out_of_range_type(int val) { return setValue("out_of_range_type", val); }
	//! The type of extrapolation for points out of the control range: 0 - end tangnts, 1 - linear, 2 - constant. Used when use_end_tangents is true.
 	//! [UI Guides] enum=0:End tangent; 1:Linear; 2:Constant
 	//! [Default value] 0
	int get_out_of_range_type() const { return getInt("out_of_range_type"); }
};

class TexBezierCurveColor : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexBezierCurveColor"; }

	//! The input color texture.
 	bool set_input_color(const Plugin& texture) { return setValue("input_color", texture); }
	//! The input color texture.
 	bool set_input_color(const AColor& texture) { return setValue("input_color", texture); }
	//! The input color texture.
 	Value get_input_color() const { return getValue("input_color"); }

	//! The control points for R channel. If there are no G or B control points, this control points will be used instead; 6 floats for each point: 2D coords of the point itself, and 2D coords of the left and right tangent.
 	//! [Default value] 0
	bool set_points_r(const FloatList& floatList) { return setValue("points_r", floatList); }
	//! The control points for R channel. If there are no G or B control points, this control points will be used instead; 6 floats for each point: 2D coords of the point itself, and 2D coords of the left and right tangent.
 	//! [Default value] 0
	bool set_points_r(const float* floats, size_t count) { return setArray("points_r", floats, count); }
	//! The control points for R channel. If there are no G or B control points, this control points will be used instead; 6 floats for each point: 2D coords of the point itself, and 2D coords of the left and right tangent.
 	//! [Default value] 0
	template<size_t count> bool set_points_r(const float (&floats)[count]) { return setArray("points_r", floats, count); }
	//! The control points for R channel. If there are no G or B control points, this control points will be used instead; 6 floats for each point: 2D coords of the point itself, and 2D coords of the left and right tangent.
 	//! [Default value] 0
	FloatList get_points_r() const { return getFloatList("points_r"); }

	//! The control points for G channel. If this is empty, points_r will be used instead; 6 floats for each point: 2D coords of the point itself, and 2D coords of the left and right tangent.
 	//! [Default value] 0
	bool set_points_g(const FloatList& floatList) { return setValue("points_g", floatList); }
	//! The control points for G channel. If this is empty, points_r will be used instead; 6 floats for each point: 2D coords of the point itself, and 2D coords of the left and right tangent.
 	//! [Default value] 0
	bool set_points_g(const float* floats, size_t count) { return setArray("points_g", floats, count); }
	//! The control points for G channel. If this is empty, points_r will be used instead; 6 floats for each point: 2D coords of the point itself, and 2D coords of the left and right tangent.
 	//! [Default value] 0
	template<size_t count> bool set_points_g(const float (&floats)[count]) { return setArray("points_g", floats, count); }
	//! The control points for G channel. If this is empty, points_r will be used instead; 6 floats for each point: 2D coords of the point itself, and 2D coords of the left and right tangent.
 	//! [Default value] 0
	FloatList get_points_g() const { return getFloatList("points_g"); }

	//! The control points for B channel. If this is empty, points_r will be used instead; 6 floats for each point: 2D coords of the point itself, and 2D coords of the left and right tangent.
 	//! [Default value] 0
	bool set_points_b(const FloatList& floatList) { return setValue("points_b", floatList); }
	//! The control points for B channel. If this is empty, points_r will be used instead; 6 floats for each point: 2D coords of the point itself, and 2D coords of the left and right tangent.
 	//! [Default value] 0
	bool set_points_b(const float* floats, size_t count) { return setArray("points_b", floats, count); }
	//! The control points for B channel. If this is empty, points_r will be used instead; 6 floats for each point: 2D coords of the point itself, and 2D coords of the left and right tangent.
 	//! [Default value] 0
	template<size_t count> bool set_points_b(const float (&floats)[count]) { return setArray("points_b", floats, count); }
	//! The control points for B channel. If this is empty, points_r will be used instead; 6 floats for each point: 2D coords of the point itself, and 2D coords of the left and right tangent.
 	//! [Default value] 0
	FloatList get_points_b() const { return getFloatList("points_b"); }

	//! The type of the control points: 0 - free, 1 - bezier, 2- bezier smooth.
 	//! [UI Guides] enum=0:Free; 1:Bezier; 2:Bezier smooth
 	//! [Default value] 0
	bool set_types_r(const IntList& intList) { return setValue("types_r", intList); }
	//! The type of the control points: 0 - free, 1 - bezier, 2- bezier smooth.
 	//! [UI Guides] enum=0:Free; 1:Bezier; 2:Bezier smooth
 	//! [Default value] 0
	bool set_types_r(const int* ints, size_t count) { return setArray("types_r", ints, count); }
	//! The type of the control points: 0 - free, 1 - bezier, 2- bezier smooth.
 	//! [UI Guides] enum=0:Free; 1:Bezier; 2:Bezier smooth
 	//! [Default value] 0
	template<size_t count> bool set_types_r(const int (&ints)[count]) { return setArray("types_r", ints, count); }
	//! The type of the control points: 0 - free, 1 - bezier, 2- bezier smooth.
 	//! [UI Guides] enum=0:Free; 1:Bezier; 2:Bezier smooth
 	//! [Default value] 0
	IntList get_types_r() const { return getIntList("types_r"); }

	//! The type of the control points: 0 - free, 1 - bezier, 2- bezier smooth. If points_g is empty, types_r will be used
 	//! [UI Guides] enum=0:Free; 1:Bezier; 2:Bezier smooth
 	//! [Default value] 0
	bool set_types_g(const IntList& intList) { return setValue("types_g", intList); }
	//! The type of the control points: 0 - free, 1 - bezier, 2- bezier smooth. If points_g is empty, types_r will be used
 	//! [UI Guides] enum=0:Free; 1:Bezier; 2:Bezier smooth
 	//! [Default value] 0
	bool set_types_g(const int* ints, size_t count) { return setArray("types_g", ints, count); }
	//! The type of the control points: 0 - free, 1 - bezier, 2- bezier smooth. If points_g is empty, types_r will be used
 	//! [UI Guides] enum=0:Free; 1:Bezier; 2:Bezier smooth
 	//! [Default value] 0
	template<size_t count> bool set_types_g(const int (&ints)[count]) { return setArray("types_g", ints, count); }
	//! The type of the control points: 0 - free, 1 - bezier, 2- bezier smooth. If points_g is empty, types_r will be used
 	//! [UI Guides] enum=0:Free; 1:Bezier; 2:Bezier smooth
 	//! [Default value] 0
	IntList get_types_g() const { return getIntList("types_g"); }

	//! The type of the control points: 0 - free, 1 - bezier, 2- bezier smooth. If points_b is empty, types_r will be used
 	//! [UI Guides] enum=0:Free; 1:Bezier; 2:Bezier smooth
 	//! [Default value] 0
	bool set_types_b(const IntList& intList) { return setValue("types_b", intList); }
	//! The type of the control points: 0 - free, 1 - bezier, 2- bezier smooth. If points_b is empty, types_r will be used
 	//! [UI Guides] enum=0:Free; 1:Bezier; 2:Bezier smooth
 	//! [Default value] 0
	bool set_types_b(const int* ints, size_t count) { return setArray("types_b", ints, count); }
	//! The type of the control points: 0 - free, 1 - bezier, 2- bezier smooth. If points_b is empty, types_r will be used
 	//! [UI Guides] enum=0:Free; 1:Bezier; 2:Bezier smooth
 	//! [Default value] 0
	template<size_t count> bool set_types_b(const int (&ints)[count]) { return setArray("types_b", ints, count); }
	//! The type of the control points: 0 - free, 1 - bezier, 2- bezier smooth. If points_b is empty, types_r will be used
 	//! [UI Guides] enum=0:Free; 1:Bezier; 2:Bezier smooth
 	//! [Default value] 0
	IntList get_types_b() const { return getIntList("types_b"); }

	//! The number of precisely calculated points from bezier curves: default 256.
 	//! [Default value] 256
	bool set_num_bezier_points_r(int val) { return setValue("num_bezier_points_r", val); }
	//! The number of precisely calculated points from bezier curves: default 256.
 	//! [Default value] 256
	int get_num_bezier_points_r() const { return getInt("num_bezier_points_r"); }

	//! The number of precisely calculated points from bezier curves: default 256. If points_g is not set, num_bezier_points_r will be used instead
 	//! [Default value] 256
	bool set_num_bezier_points_g(int val) { return setValue("num_bezier_points_g", val); }
	//! The number of precisely calculated points from bezier curves: default 256. If points_g is not set, num_bezier_points_r will be used instead
 	//! [Default value] 256
	int get_num_bezier_points_g() const { return getInt("num_bezier_points_g"); }

	//! The number of precisely calculated points from bezier curves: default 256. If points_b is not set, num_bezier_points_r will be used instead
 	//! [Default value] 256
	bool set_num_bezier_points_b(int val) { return setValue("num_bezier_points_b", val); }
	//! The number of precisely calculated points from bezier curves: default 256. If points_b is not set, num_bezier_points_r will be used instead
 	//! [Default value] 256
	int get_num_bezier_points_b() const { return getInt("num_bezier_points_b"); }

	//! true to extrapolate beyound the control points.
 	//! [Default value] true
	bool set_use_end_tangents_r(bool val) { return setValue("use_end_tangents_r", val); }
	//! true to extrapolate beyound the control points.
 	//! [Default value] true
	bool get_use_end_tangents_r() const { return getBool("use_end_tangents_r"); }

	//! true to extrapolate beyound the control points. If points_g is empty, use_end_tangents_r will be used instead
 	//! [Default value] true
	bool set_use_end_tangents_g(bool val) { return setValue("use_end_tangents_g", val); }
	//! true to extrapolate beyound the control points. If points_g is empty, use_end_tangents_r will be used instead
 	//! [Default value] true
	bool get_use_end_tangents_g() const { return getBool("use_end_tangents_g"); }

	//! true to extrapolate beyound the control points. If points_b is empty, use_end_tangents_r will be used instead
 	//! [Default value] true
	bool set_use_end_tangents_b(bool val) { return setValue("use_end_tangents_b", val); }
	//! true to extrapolate beyound the control points. If points_b is empty, use_end_tangents_r will be used instead
 	//! [Default value] true
	bool get_use_end_tangents_b() const { return getBool("use_end_tangents_b"); }

	//! The type of extrapolation for points out of the control range: 0 - end tangnts, 1 - linear, 2 - constant. Used when use_end_tangents is true. 
 	//! [UI Guides] enum=0:End tangent; 1:Linear; 2:Constant
 	//! [Default value] 0
	bool set_out_of_range_type_r(int val) { return setValue("out_of_range_type_r", val); }
	//! The type of extrapolation for points out of the control range: 0 - end tangnts, 1 - linear, 2 - constant. Used when use_end_tangents is true. 
 	//! [UI Guides] enum=0:End tangent; 1:Linear; 2:Constant
 	//! [Default value] 0
	int get_out_of_range_type_r() const { return getInt("out_of_range_type_r"); }

	//! The type of extrapolation for points out of the control range: 0 - end tangnts, 1 - linear, 2 - constant. Used when use_end_tangents is true. If points_g is empty, out_of_range_type_r will be used instead
 	//! [UI Guides] enum=0:End tangent; 1:Linear; 2:Constant
 	//! [Default value] 0
	bool set_out_of_range_type_g(int val) { return setValue("out_of_range_type_g", val); }
	//! The type of extrapolation for points out of the control range: 0 - end tangnts, 1 - linear, 2 - constant. Used when use_end_tangents is true. If points_g is empty, out_of_range_type_r will be used instead
 	//! [UI Guides] enum=0:End tangent; 1:Linear; 2:Constant
 	//! [Default value] 0
	int get_out_of_range_type_g() const { return getInt("out_of_range_type_g"); }

	//! The type of extrapolation for points out of the control range: 0 - end tangnts, 1 - linear, 2 - constant. Used when use_end_tangents is true. If points_b is empty, out_of_range_type_r will be used instead
 	//! [UI Guides] enum=0:End tangent; 1:Linear; 2:Constant
 	//! [Default value] 0
	bool set_out_of_range_type_b(int val) { return setValue("out_of_range_type_b", val); }
	//! The type of extrapolation for points out of the control range: 0 - end tangnts, 1 - linear, 2 - constant. Used when use_end_tangents is true. If points_b is empty, out_of_range_type_r will be used instead
 	//! [UI Guides] enum=0:End tangent; 1:Linear; 2:Constant
 	//! [Default value] 0
	int get_out_of_range_type_b() const { return getInt("out_of_range_type_b"); }
};

class TexBifrostVVMix : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexBifrostVVMix"; }

	//! The velocity texture multiplier
 	//! [Default value] 1
	bool set_velocity_mult(float val) { return setValue("velocity_mult", val); }
	//! The velocity texture multiplier
 	//! [Default value] 1
	float get_velocity_mult() const { return getFloat("velocity_mult"); }

	//! The vorticity texture multiplier
 	//! [Default value] 1
	bool set_vorticity_mult(float val) { return setValue("vorticity_mult", val); }
	//! The vorticity texture multiplier
 	//! [Default value] 1
	float get_vorticity_mult() const { return getFloat("vorticity_mult"); }

	//! The vorticity texture. This must be connected to the bifrostVelocity color set of the mesh.
 	bool set_velocity_tex(const Plugin& texture) { return setValue("velocity_tex", texture); }
	//! The vorticity texture. This must be connected to the bifrostVelocity color set of the mesh.
 	bool set_velocity_tex(const AColor& texture) { return setValue("velocity_tex", texture); }
	//! The vorticity texture. This must be connected to the bifrostVelocity color set of the mesh.
 	Value get_velocity_tex() const { return getValue("velocity_tex"); }

	//! The vorticity texture. This must be connected to the bifrostVorticity color set of the mesh.
 	bool set_vorticity_tex(const Plugin& texture) { return setValue("vorticity_tex", texture); }
	//! The vorticity texture. This must be connected to the bifrostVorticity color set of the mesh.
 	bool set_vorticity_tex(const AColor& texture) { return setValue("vorticity_tex", texture); }
	//! The vorticity texture. This must be connected to the bifrostVorticity color set of the mesh.
 	Value get_vorticity_tex() const { return getValue("vorticity_tex"); }
};

class TexBillboardParticle : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexBillboardParticle"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	bool set_placement_type(int val) { return setValue("placement_type", val); }
	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	int get_placement_type() const { return getInt("placement_type"); }

	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_u(float val) { return setValue("u", val); }
	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_u() const { return getFloat("u"); }

	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_v(float val) { return setValue("v", val); }
	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_v() const { return getFloat("v"); }

	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_w(float val) { return setValue("w", val); }
	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_w() const { return getFloat("w"); }

	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_h(float val) { return setValue("h", val); }
	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_h() const { return getFloat("h"); }

	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	bool set_jitter(float val) { return setValue("jitter", val); }
	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	float get_jitter() const { return getFloat("jitter"); }

	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_u(bool val) { return setValue("tile_u", val); }
	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_u() const { return getBool("tile_u"); }

	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_v(bool val) { return setValue("tile_v", val); }
	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_v() const { return getBool("tile_v"); }

	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool set_uv_noise_on(bool val) { return setValue("uv_noise_on", val); }
	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool get_uv_noise_on() const { return getBool("uv_noise_on"); }

	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool set_uv_noise_animate(bool val) { return setValue("uv_noise_animate", val); }
	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool get_uv_noise_animate() const { return getBool("uv_noise_animate"); }

	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	bool set_uv_noise_amount(float val) { return setValue("uv_noise_amount", val); }
	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	float get_uv_noise_amount() const { return getFloat("uv_noise_amount"); }

	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	bool set_uv_noise_levels(float val) { return setValue("uv_noise_levels", val); }
	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	float get_uv_noise_levels() const { return getFloat("uv_noise_levels"); }

	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	bool set_uv_noise_size(float val) { return setValue("uv_noise_size", val); }
	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	float get_uv_noise_size() const { return getFloat("uv_noise_size"); }

	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	bool set_un_noise_phase(float val) { return setValue("un_noise_phase", val); }
	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	float get_un_noise_phase() const { return getFloat("un_noise_phase"); }

	//! Color texture, the particles'color
 	bool set_clr_txt(const Plugin& texture) { return setValue("clr_txt", texture); }
	//! Color texture, the particles'color
 	bool set_clr_txt(const AColor& texture) { return setValue("clr_txt", texture); }
	//! Color texture, the particles'color
 	Value get_clr_txt() const { return getValue("clr_txt"); }

	//! Surface Normal Type: Billboard or Spherical
 	//! [Default value] 0
	bool set_NormalType(int val) { return setValue("NormalType", val); }
	//! Surface Normal Type: Billboard or Spherical
 	//! [Default value] 0
	int get_NormalType() const { return getInt("NormalType"); }

	//! Face Direction: Camera, Incoming ray, Camera and Lights, Use Rotation
 	//! [Default value] 0
	bool set_Direction(int val) { return setValue("Direction", val); }
	//! Face Direction: Camera, Incoming ray, Camera and Lights, Use Rotation
 	//! [Default value] 0
	int get_Direction() const { return getInt("Direction"); }

	//! Planar, Particle's Local Space, Cloud's Local Space, World Space
 	//! [Default value] 0
	bool set_TextureSpace(int val) { return setValue("TextureSpace", val); }
	//! Planar, Particle's Local Space, Cloud's Local Space, World Space
 	//! [Default value] 0
	int get_TextureSpace() const { return getInt("TextureSpace"); }

	//! Shape: Square, Rectangular or Circular
 	//! [Default value] 0
	bool set_Shape(int val) { return setValue("Shape", val); }
	//! Shape: Square, Rectangular or Circular
 	//! [Default value] 0
	int get_Shape() const { return getInt("Shape"); }

	//! Particle billboard rotates in the direction of the velocity. This is disabled if the billboard Face Direction is set to Use Rotation
 	//! [Default value] 0
	bool set_FollowVelocity(int val) { return setValue("FollowVelocity", val); }
	//! Particle billboard rotates in the direction of the velocity. This is disabled if the billboard Face Direction is set to Use Rotation
 	//! [Default value] 0
	int get_FollowVelocity() const { return getInt("FollowVelocity"); }

	//! Shadows cast by the particles onto themselves are attenuated by this factor
 	//! [Default value] 1
	bool set_SelfShadow(float val) { return setValue("SelfShadow", val); }
	//! Shadows cast by the particles onto themselves are attenuated by this factor
 	//! [Default value] 1
	float get_SelfShadow() const { return getFloat("SelfShadow"); }

	//! Applies a simple shading model to the particles. If not selected, only shadows are calculated, and the particles are still visible even if no lights are applied to the cloud.
 	//! [Default value] 0
	bool set_UseShading(int val) { return setValue("UseShading", val); }
	//! Applies a simple shading model to the particles. If not selected, only shadows are calculated, and the particles are still visible even if no lights are applied to the cloud.
 	//! [Default value] 0
	int get_UseShading() const { return getInt("UseShading"); }

	//! % of Base Color (particle type color), Use Ambient Color (the values of the Color sliders below), or None.
 	//! [Default value] 0
	bool set_AmbientType(int val) { return setValue("AmbientType", val); }
	//! % of Base Color (particle type color), Use Ambient Color (the values of the Color sliders below), or None.
 	//! [Default value] 0
	int get_AmbientType() const { return getInt("AmbientType"); }

	//! Ambience colour
 	bool set_AmbienceClr(const Plugin& texture) { return setValue("AmbienceClr", texture); }
	//! Ambience colour
 	bool set_AmbienceClr(const AColor& texture) { return setValue("AmbienceClr", texture); }
	//! Ambience colour
 	Value get_AmbienceClr() const { return getValue("AmbienceClr"); }

	//! Ambient colour
 	bool set_AmbientClr(const Plugin& texture) { return setValue("AmbientClr", texture); }
	//! Ambient colour
 	bool set_AmbientClr(const AColor& texture) { return setValue("AmbientClr", texture); }
	//! Ambient colour
 	Value get_AmbientClr() const { return getValue("AmbientClr"); }

	//! Ambient % of base
 	//! [Default value] 1
	bool set_AmbientPart(float val) { return setValue("AmbientPart", val); }
	//! Ambient % of base
 	//! [Default value] 1
	float get_AmbientPart() const { return getFloat("AmbientPart"); }

	//! Specular type (0 = none, 1 = colour, 2 = % of base 
 	//! [UI Guides] enum=0:None; 1:Colour; 2:% of base
 	//! [Default value] 0
	bool set_SpecularType(int val) { return setValue("SpecularType", val); }
	//! Specular type (0 = none, 1 = colour, 2 = % of base 
 	//! [UI Guides] enum=0:None; 1:Colour; 2:% of base
 	//! [Default value] 0
	int get_SpecularType() const { return getInt("SpecularType"); }

	//! Specular colour
 	bool set_SpecularClr(const Plugin& texture) { return setValue("SpecularClr", texture); }
	//! Specular colour
 	bool set_SpecularClr(const AColor& texture) { return setValue("SpecularClr", texture); }
	//! Specular colour
 	Value get_SpecularClr() const { return getValue("SpecularClr"); }

	//! Specular % of base
 	//! [Default value] 1
	bool set_SpecularPart(float val) { return setValue("SpecularPart", val); }
	//! Specular % of base
 	//! [Default value] 1
	float get_SpecularPart() const { return getFloat("SpecularPart"); }

	//! Specular coeff
 	//! [Default value] 1
	bool set_SpecularCoeff(float val) { return setValue("SpecularCoeff", val); }
	//! Specular coeff
 	//! [Default value] 1
	float get_SpecularCoeff() const { return getFloat("SpecularCoeff"); }

	//! Irradiance type (0 = none, 1 = colour, 2 = % of base 
 	//! [UI Guides] enum=0:None; 1:Colour; 2:% of base
 	//! [Default value] 0
	bool set_IrradianceType(int val) { return setValue("IrradianceType", val); }
	//! Irradiance type (0 = none, 1 = colour, 2 = % of base 
 	//! [UI Guides] enum=0:None; 1:Colour; 2:% of base
 	//! [Default value] 0
	int get_IrradianceType() const { return getInt("IrradianceType"); }

	//! Irradiance colour
 	bool set_IrradianceClr(const Plugin& texture) { return setValue("IrradianceClr", texture); }
	//! Irradiance colour
 	bool set_IrradianceClr(const AColor& texture) { return setValue("IrradianceClr", texture); }
	//! Irradiance colour
 	Value get_IrradianceClr() const { return getValue("IrradianceClr"); }

	//! Irradiance % of base
 	//! [Default value] 1
	bool set_IrradiancePart(float val) { return setValue("IrradiancePart", val); }
	//! Irradiance % of base
 	//! [Default value] 1
	float get_IrradiancePart() const { return getFloat("IrradiancePart"); }

	//! Radiance type (0 = none, 1 = colour, 2 = % of base 
 	//! [UI Guides] enum=0:None; 1:Colour; 2:% of base
 	//! [Default value] 0
	bool set_RadianceType(int val) { return setValue("RadianceType", val); }
	//! Radiance type (0 = none, 1 = colour, 2 = % of base 
 	//! [UI Guides] enum=0:None; 1:Colour; 2:% of base
 	//! [Default value] 0
	int get_RadianceType() const { return getInt("RadianceType"); }

	//! Radiance colour
 	bool set_RadianceClr(const Plugin& texture) { return setValue("RadianceClr", texture); }
	//! Radiance colour
 	bool set_RadianceClr(const AColor& texture) { return setValue("RadianceClr", texture); }
	//! Radiance colour
 	Value get_RadianceClr() const { return getValue("RadianceClr"); }

	//! Radiance % of base
 	//! [Default value] 1
	bool set_RadiancePart(float val) { return setValue("RadiancePart", val); }
	//! Radiance % of base
 	//! [Default value] 1
	float get_RadiancePart() const { return getFloat("RadiancePart"); }

	//! Amount of colour burn to apply
 	//! [Default value] 0
	bool set_ColourBurn(float val) { return setValue("ColourBurn", val); }
	//! Amount of colour burn to apply
 	//! [Default value] 0
	float get_ColourBurn() const { return getFloat("ColourBurn"); }
};

class TexBitmap : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexBitmap"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! 0: not tiling; 1: tile in UV; 2: tile in U; 3: tile in V; 4: tile in UV, but not filter tiling;
 	//! [UI Guides] enum=0:No tiling;1:Tile in UV;2:Tile in U;3:Tile in V;4:Tile in UV, but no filter tiling
 	//! [Default value] 1
	bool set_tile(int val) { return setValue("tile", val); }
	//! 0: not tiling; 1: tile in UV; 2: tile in U; 3: tile in V; 4: tile in UV, but not filter tiling;
 	//! [UI Guides] enum=0:No tiling;1:Tile in UV;2:Tile in U;3:Tile in V;4:Tile in UV, but no filter tiling
 	//! [Default value] 1
	int get_tile() const { return getInt("tile"); }

	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	bool set_placement_type(int val) { return setValue("placement_type", val); }
	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	int get_placement_type() const { return getInt("placement_type"); }

	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_u(float val) { return setValue("u", val); }
	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_u() const { return getFloat("u"); }

	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_v(float val) { return setValue("v", val); }
	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_v() const { return getFloat("v"); }

	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_w(float val) { return setValue("w", val); }
	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_w() const { return getFloat("w"); }

	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_h(float val) { return setValue("h", val); }
	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_h() const { return getFloat("h"); }

	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	bool set_jitter(float val) { return setValue("jitter", val); }
	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	float get_jitter() const { return getFloat("jitter"); }

	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_u(bool val) { return setValue("tile_u", val); }
	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_u() const { return getBool("tile_u"); }

	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_v(bool val) { return setValue("tile_v", val); }
	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_v() const { return getBool("tile_v"); }

	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool set_uv_noise_on(bool val) { return setValue("uv_noise_on", val); }
	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool get_uv_noise_on() const { return getBool("uv_noise_on"); }

	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool set_uv_noise_animate(bool val) { return setValue("uv_noise_animate", val); }
	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool get_uv_noise_animate() const { return getBool("uv_noise_animate"); }

	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	bool set_uv_noise_amount(float val) { return setValue("uv_noise_amount", val); }
	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	float get_uv_noise_amount() const { return getFloat("uv_noise_amount"); }

	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	bool set_uv_noise_levels(float val) { return setValue("uv_noise_levels", val); }
	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	float get_uv_noise_levels() const { return getFloat("uv_noise_levels"); }

	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	bool set_uv_noise_size(float val) { return setValue("uv_noise_size", val); }
	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	float get_uv_noise_size() const { return getFloat("uv_noise_size"); }

	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	bool set_un_noise_phase(float val) { return setValue("un_noise_phase", val); }
	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	float get_un_noise_phase() const { return getFloat("un_noise_phase"); }

	//! (description missing)
	bool set_bitmap(const Plugin& plugin) { return setValue("bitmap", plugin); }
	//! (description missing)
	Plugin get_bitmap() const { return getPlugin("bitmap"); }
};

class TexBlend : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexBlend"; }

	//! (description missing)
	bool set_color_a(const Plugin& texture) { return setValue("color_a", texture); }
	//! (description missing)
	bool set_color_a(const AColor& texture) { return setValue("color_a", texture); }
	//! (description missing)
	Value get_color_a() const { return getValue("color_a"); }

	//! (description missing)
	bool set_color_b(const Plugin& texture) { return setValue("color_b", texture); }
	//! (description missing)
	bool set_color_b(const AColor& texture) { return setValue("color_b", texture); }
	//! (description missing)
	Value get_color_b() const { return getValue("color_b"); }

	//! (description missing)
	bool set_blend_amount(const Plugin& texturefloat) { return setValue("blend_amount", texturefloat); }
	//! (description missing)
	bool set_blend_amount(float texturefloat) { return setValue("blend_amount", texturefloat); }
	//! (description missing)
	Value get_blend_amount() const { return getValue("blend_amount"); }

	//! If true, color_b will be composited over color_a with the given weight, taking its alpha into account
 	//! [Default value] false
	bool set_composite(bool val) { return setValue("composite", val); }
	//! If true, color_b will be composited over color_a with the given weight, taking its alpha into account
 	//! [Default value] false
	bool get_composite() const { return getBool("composite"); }
};

class TexBlendBumpNormal : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexBlendBumpNormal"; }

	//! First tangent space normal map.
 	//! [UI Guides] displayName=Normal map 1
 	bool set_normalMap1(const Plugin& texture) { return setValue("normalMap1", texture); }
	//! First tangent space normal map.
 	//! [UI Guides] displayName=Normal map 1
 	bool set_normalMap1(const AColor& texture) { return setValue("normalMap1", texture); }
	//! First tangent space normal map.
 	//! [UI Guides] displayName=Normal map 1
 	Value get_normalMap1() const { return getValue("normalMap1"); }

	//! Weight of first tangent space normal map.
 	//! [UI Guides] displayName=Normal map 1 weight
 	bool set_normalMapWeight1(const Plugin& texturefloat) { return setValue("normalMapWeight1", texturefloat); }
	//! Weight of first tangent space normal map.
 	//! [UI Guides] displayName=Normal map 1 weight
 	bool set_normalMapWeight1(float texturefloat) { return setValue("normalMapWeight1", texturefloat); }
	//! Weight of first tangent space normal map.
 	//! [UI Guides] displayName=Normal map 1 weight
 	Value get_normalMapWeight1() const { return getValue("normalMapWeight1"); }

	//! Second tangent space normal map.
 	//! [UI Guides] displayName=Normal map 2
 	bool set_normalMap2(const Plugin& texture) { return setValue("normalMap2", texture); }
	//! Second tangent space normal map.
 	//! [UI Guides] displayName=Normal map 2
 	bool set_normalMap2(const AColor& texture) { return setValue("normalMap2", texture); }
	//! Second tangent space normal map.
 	//! [UI Guides] displayName=Normal map 2
 	Value get_normalMap2() const { return getValue("normalMap2"); }

	//! Weight of second tangent space normal map.
 	//! [UI Guides] displayName=Normal map 2 weight
 	bool set_normalMapWeight2(const Plugin& texturefloat) { return setValue("normalMapWeight2", texturefloat); }
	//! Weight of second tangent space normal map.
 	//! [UI Guides] displayName=Normal map 2 weight
 	bool set_normalMapWeight2(float texturefloat) { return setValue("normalMapWeight2", texturefloat); }
	//! Weight of second tangent space normal map.
 	//! [UI Guides] displayName=Normal map 2 weight
 	Value get_normalMapWeight2() const { return getValue("normalMapWeight2"); }

	//! First bump map.
 	//! [UI Guides] startRollout=, displayName=Bump map 1
 	bool set_bumpMap1(const Plugin& texture) { return setValue("bumpMap1", texture); }
	//! First bump map.
 	//! [UI Guides] startRollout=, displayName=Bump map 1
 	bool set_bumpMap1(const AColor& texture) { return setValue("bumpMap1", texture); }
	//! First bump map.
 	//! [UI Guides] startRollout=, displayName=Bump map 1
 	Value get_bumpMap1() const { return getValue("bumpMap1"); }

	//! Weight of first bump map.
 	//! [UI Guides] displayName=Bump map 1 weight
 	bool set_bumpMapWeight1(const Plugin& texturefloat) { return setValue("bumpMapWeight1", texturefloat); }
	//! Weight of first bump map.
 	//! [UI Guides] displayName=Bump map 1 weight
 	bool set_bumpMapWeight1(float texturefloat) { return setValue("bumpMapWeight1", texturefloat); }
	//! Weight of first bump map.
 	//! [UI Guides] displayName=Bump map 1 weight
 	Value get_bumpMapWeight1() const { return getValue("bumpMapWeight1"); }

	//! Second bump map.
 	//! [UI Guides] displayName=Bump map 2
 	bool set_bumpMap2(const Plugin& texture) { return setValue("bumpMap2", texture); }
	//! Second bump map.
 	//! [UI Guides] displayName=Bump map 2
 	bool set_bumpMap2(const AColor& texture) { return setValue("bumpMap2", texture); }
	//! Second bump map.
 	//! [UI Guides] displayName=Bump map 2
 	Value get_bumpMap2() const { return getValue("bumpMap2"); }

	//! Weight of second bump map.
 	//! [UI Guides] displayName=Bump map 2 weight
 	bool set_bumpMapWeight2(const Plugin& texturefloat) { return setValue("bumpMapWeight2", texturefloat); }
	//! Weight of second bump map.
 	//! [UI Guides] displayName=Bump map 2 weight
 	bool set_bumpMapWeight2(float texturefloat) { return setValue("bumpMapWeight2", texturefloat); }
	//! Weight of second bump map.
 	//! [UI Guides] displayName=Bump map 2 weight
 	Value get_bumpMapWeight2() const { return getValue("bumpMapWeight2"); }

	//! [UI Guides] startRollout=
 	//! [Default value] true
	bool set_sharpen(bool val) { return setValue("sharpen", val); }
	//! [UI Guides] startRollout=
 	//! [Default value] true
	bool get_sharpen() const { return getBool("sharpen"); }
};

class TexBulge : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexBulge"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	bool set_placement_type(int val) { return setValue("placement_type", val); }
	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	int get_placement_type() const { return getInt("placement_type"); }

	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_u(float val) { return setValue("u", val); }
	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_u() const { return getFloat("u"); }

	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_v(float val) { return setValue("v", val); }
	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_v() const { return getFloat("v"); }

	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_w(float val) { return setValue("w", val); }
	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_w() const { return getFloat("w"); }

	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_h(float val) { return setValue("h", val); }
	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_h() const { return getFloat("h"); }

	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	bool set_jitter(float val) { return setValue("jitter", val); }
	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	float get_jitter() const { return getFloat("jitter"); }

	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_u(bool val) { return setValue("tile_u", val); }
	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_u() const { return getBool("tile_u"); }

	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_v(bool val) { return setValue("tile_v", val); }
	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_v() const { return getBool("tile_v"); }

	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool set_uv_noise_on(bool val) { return setValue("uv_noise_on", val); }
	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool get_uv_noise_on() const { return getBool("uv_noise_on"); }

	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool set_uv_noise_animate(bool val) { return setValue("uv_noise_animate", val); }
	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool get_uv_noise_animate() const { return getBool("uv_noise_animate"); }

	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	bool set_uv_noise_amount(float val) { return setValue("uv_noise_amount", val); }
	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	float get_uv_noise_amount() const { return getFloat("uv_noise_amount"); }

	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	bool set_uv_noise_levels(float val) { return setValue("uv_noise_levels", val); }
	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	float get_uv_noise_levels() const { return getFloat("uv_noise_levels"); }

	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	bool set_uv_noise_size(float val) { return setValue("uv_noise_size", val); }
	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	float get_uv_noise_size() const { return getFloat("uv_noise_size"); }

	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	bool set_un_noise_phase(float val) { return setValue("un_noise_phase", val); }
	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	float get_un_noise_phase() const { return getFloat("un_noise_phase"); }

	//! [UI Guides] minValue=0, maxValue=1
 	//! [Default value] 0.1
	bool set_u_width(float val) { return setValue("u_width", val); }
	//! [UI Guides] minValue=0, maxValue=1
 	//! [Default value] 0.1
	float get_u_width() const { return getFloat("u_width"); }

	//! [UI Guides] minValue=0, maxValue=1
 	//! [Default value] 0.1
	bool set_v_width(float val) { return setValue("v_width", val); }
	//! [UI Guides] minValue=0, maxValue=1
 	//! [Default value] 0.1
	float get_v_width() const { return getFloat("v_width"); }
};

class TexCellular : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexCellular"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! (description missing)
	//! [Default value] false
	bool set_use_3d_mapping(bool val) { return setValue("use_3d_mapping", val); }
	//! (description missing)
	//! [Default value] false
	bool get_use_3d_mapping() const { return getBool("use_3d_mapping"); }

	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	bool set_placement_type(int val) { return setValue("placement_type", val); }
	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	int get_placement_type() const { return getInt("placement_type"); }

	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_u(float val) { return setValue("u", val); }
	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_u() const { return getFloat("u"); }

	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_v(float val) { return setValue("v", val); }
	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_v() const { return getFloat("v"); }

	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_w(float val) { return setValue("w", val); }
	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_w() const { return getFloat("w"); }

	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_h(float val) { return setValue("h", val); }
	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_h() const { return getFloat("h"); }

	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	bool set_jitter(float val) { return setValue("jitter", val); }
	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	float get_jitter() const { return getFloat("jitter"); }

	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_u(bool val) { return setValue("tile_u", val); }
	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_u() const { return getBool("tile_u"); }

	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_v(bool val) { return setValue("tile_v", val); }
	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_v() const { return getBool("tile_v"); }

	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool set_uv_noise_on(bool val) { return setValue("uv_noise_on", val); }
	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool get_uv_noise_on() const { return getBool("uv_noise_on"); }

	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool set_uv_noise_animate(bool val) { return setValue("uv_noise_animate", val); }
	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool get_uv_noise_animate() const { return getBool("uv_noise_animate"); }

	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	bool set_uv_noise_amount(float val) { return setValue("uv_noise_amount", val); }
	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	float get_uv_noise_amount() const { return getFloat("uv_noise_amount"); }

	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	bool set_uv_noise_levels(float val) { return setValue("uv_noise_levels", val); }
	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	float get_uv_noise_levels() const { return getFloat("uv_noise_levels"); }

	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	bool set_uv_noise_size(float val) { return setValue("uv_noise_size", val); }
	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	float get_uv_noise_size() const { return getFloat("uv_noise_size"); }

	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	bool set_un_noise_phase(float val) { return setValue("un_noise_phase", val); }
	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	float get_un_noise_phase() const { return getFloat("un_noise_phase"); }

	//! (description missing)
	bool set_center_color(const Plugin& texture) { return setValue("center_color", texture); }
	//! (description missing)
	bool set_center_color(const AColor& texture) { return setValue("center_color", texture); }
	//! (description missing)
	Value get_center_color() const { return getValue("center_color"); }

	//! (description missing)
	bool set_edge_color(const Plugin& texture) { return setValue("edge_color", texture); }
	//! (description missing)
	bool set_edge_color(const AColor& texture) { return setValue("edge_color", texture); }
	//! (description missing)
	Value get_edge_color() const { return getValue("edge_color"); }

	//! [UI Guides] displayName=Background Color
 	bool set_bg_color(const Plugin& texture) { return setValue("bg_color", texture); }
	//! [UI Guides] displayName=Background Color
 	bool set_bg_color(const AColor& texture) { return setValue("bg_color", texture); }
	//! [UI Guides] displayName=Background Color
 	Value get_bg_color() const { return getValue("bg_color"); }

	//! [UI Guides] minValue=0.001
 	//! [Default value] 0.2
	bool set_size(float val) { return setValue("size", val); }
	//! [UI Guides] minValue=0.001
 	//! [Default value] 0.2
	float get_size() const { return getFloat("size"); }

	//! [UI Guides] minValue=0.001
 	//! [Default value] 0.5
	bool set_spread(float val) { return setValue("spread", val); }
	//! [UI Guides] minValue=0.001
 	//! [Default value] 0.5
	float get_spread() const { return getFloat("spread"); }

	//! [UI Guides] minValue=0.0
 	//! [Default value] 0.25
	bool set_density(float val) { return setValue("density", val); }
	//! [UI Guides] minValue=0.0
 	//! [Default value] 0.25
	float get_density() const { return getFloat("density"); }

	//! 0 = dots; 1 = chips; 2 = cells; 3 = chess cells; 4 = plasma
 	//! [UI Guides] enum=0:Dots; 1:Chips; 2:Cells; 3:Chess cells; 4:Plasma
 	//! [Default value] 0
	bool set_type(int val) { return setValue("type", val); }
	//! 0 = dots; 1 = chips; 2 = cells; 3 = chess cells; 4 = plasma
 	//! [UI Guides] enum=0:Dots; 1:Chips; 2:Cells; 3:Chess cells; 4:Plasma
 	//! [Default value] 0
	int get_type() const { return getInt("type"); }

	//! Low threshold (for the bg color)
 	//! [UI Guides] enableIf: ?type=0; ?type=1, minValue=0, maxValue=1
 	//! [Default value] 0
	bool set_low(float val) { return setValue("low", val); }
	//! Low threshold (for the bg color)
 	//! [UI Guides] enableIf: ?type=0; ?type=1, minValue=0, maxValue=1
 	//! [Default value] 0
	float get_low() const { return getFloat("low"); }

	//! Middle threshold (for the edge color)
 	//! [UI Guides] enableIf: ?type=0; ?type=1, minValue=0, maxValue=1
 	//! [Default value] 0.5
	bool set_middle(float val) { return setValue("middle", val); }
	//! Middle threshold (for the edge color)
 	//! [UI Guides] enableIf: ?type=0; ?type=1, minValue=0, maxValue=1
 	//! [Default value] 0.5
	float get_middle() const { return getFloat("middle"); }

	//! High threshold (for the center color)
 	//! [UI Guides] enableIf: ?type=0; ?type=1, minValue=0, maxValue=1
 	//! [Default value] 1
	bool set_high(float val) { return setValue("high", val); }
	//! High threshold (for the center color)
 	//! [UI Guides] enableIf: ?type=0; ?type=1, minValue=0, maxValue=1
 	//! [Default value] 1
	float get_high() const { return getFloat("high"); }

	//! [UI Guides] enableIf: ?type=0; ?type=1
 	//! [Default value] false
	bool set_fractal(bool val) { return setValue("fractal", val); }
	//! [UI Guides] enableIf: ?type=0; ?type=1
 	//! [Default value] false
	bool get_fractal() const { return getBool("fractal"); }

	//! The number of fractal iterations
 	//! [UI Guides] enableIf: ?type=0; ?type=1, ?fractal=1, minValue=1, maxValue=100
 	//! [Default value] 3
	bool set_fractal_iterations(float val) { return setValue("fractal_iterations", val); }
	//! The number of fractal iterations
 	//! [UI Guides] enableIf: ?type=0; ?type=1, ?fractal=1, minValue=1, maxValue=100
 	//! [Default value] 3
	float get_fractal_iterations() const { return getFloat("fractal_iterations"); }

	//! The fractal roughness (0.0f is very rough; 1.0 is smooth - i.e. no fractal)
 	//! [UI Guides] enableIf: ?type=0; ?type=1, ?fractal=1, minValue=0, maxValue=1
 	//! [Default value] 0
	bool set_fractal_roughness(float val) { return setValue("fractal_roughness", val); }
	//! The fractal roughness (0.0f is very rough; 1.0 is smooth - i.e. no fractal)
 	//! [UI Guides] enableIf: ?type=0; ?type=1, ?fractal=1, minValue=0, maxValue=1
 	//! [Default value] 0
	float get_fractal_roughness() const { return getFloat("fractal_roughness"); }
};

class TexChecker : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexChecker"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	bool set_placement_type(int val) { return setValue("placement_type", val); }
	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	int get_placement_type() const { return getInt("placement_type"); }

	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_u(float val) { return setValue("u", val); }
	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_u() const { return getFloat("u"); }

	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_v(float val) { return setValue("v", val); }
	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_v() const { return getFloat("v"); }

	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_w(float val) { return setValue("w", val); }
	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_w() const { return getFloat("w"); }

	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_h(float val) { return setValue("h", val); }
	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_h() const { return getFloat("h"); }

	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	bool set_jitter(float val) { return setValue("jitter", val); }
	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	float get_jitter() const { return getFloat("jitter"); }

	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_u(bool val) { return setValue("tile_u", val); }
	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_u() const { return getBool("tile_u"); }

	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_v(bool val) { return setValue("tile_v", val); }
	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_v() const { return getBool("tile_v"); }

	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool set_uv_noise_on(bool val) { return setValue("uv_noise_on", val); }
	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool get_uv_noise_on() const { return getBool("uv_noise_on"); }

	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool set_uv_noise_animate(bool val) { return setValue("uv_noise_animate", val); }
	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool get_uv_noise_animate() const { return getBool("uv_noise_animate"); }

	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	bool set_uv_noise_amount(float val) { return setValue("uv_noise_amount", val); }
	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	float get_uv_noise_amount() const { return getFloat("uv_noise_amount"); }

	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	bool set_uv_noise_levels(float val) { return setValue("uv_noise_levels", val); }
	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	float get_uv_noise_levels() const { return getFloat("uv_noise_levels"); }

	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	bool set_uv_noise_size(float val) { return setValue("uv_noise_size", val); }
	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	float get_uv_noise_size() const { return getFloat("uv_noise_size"); }

	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	bool set_un_noise_phase(float val) { return setValue("un_noise_phase", val); }
	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	float get_un_noise_phase() const { return getFloat("un_noise_phase"); }

	//! The white checker color
 	bool set_white_color(const Plugin& texture) { return setValue("white_color", texture); }
	//! The white checker color
 	bool set_white_color(const AColor& texture) { return setValue("white_color", texture); }
	//! The white checker color
 	Value get_white_color() const { return getValue("white_color"); }

	//! The black checker color
 	bool set_black_color(const Plugin& texture) { return setValue("black_color", texture); }
	//! The black checker color
 	bool set_black_color(const AColor& texture) { return setValue("black_color", texture); }
	//! The black checker color
 	Value get_black_color() const { return getValue("black_color"); }

	//! Contrast value
 	//! [UI Guides] minValue=0, maxValue=1
 	bool set_contrast(const Plugin& texturefloat) { return setValue("contrast", texturefloat); }
	//! Contrast value
 	//! [UI Guides] minValue=0, maxValue=1
 	bool set_contrast(float texturefloat) { return setValue("contrast", texturefloat); }
	//! Contrast value
 	//! [UI Guides] minValue=0, maxValue=1
 	Value get_contrast() const { return getValue("contrast"); }
};

class TexClamp : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexClamp"; }

	//! (description missing)
	bool set_texture(const Plugin& texture) { return setValue("texture", texture); }
	//! (description missing)
	bool set_texture(const AColor& texture) { return setValue("texture", texture); }
	//! (description missing)
	Value get_texture() const { return getValue("texture"); }

	//! (description missing)
	bool set_min_color(const Plugin& texture) { return setValue("min_color", texture); }
	//! (description missing)
	bool set_min_color(const AColor& texture) { return setValue("min_color", texture); }
	//! (description missing)
	Value get_min_color() const { return getValue("min_color"); }

	//! (description missing)
	bool set_max_color(const Plugin& texture) { return setValue("max_color", texture); }
	//! (description missing)
	bool set_max_color(const AColor& texture) { return setValue("max_color", texture); }
	//! (description missing)
	Value get_max_color() const { return getValue("max_color"); }
};

class TexCloth : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexCloth"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	bool set_placement_type(int val) { return setValue("placement_type", val); }
	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	int get_placement_type() const { return getInt("placement_type"); }

	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_u(float val) { return setValue("u", val); }
	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_u() const { return getFloat("u"); }

	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_v(float val) { return setValue("v", val); }
	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_v() const { return getFloat("v"); }

	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_w(float val) { return setValue("w", val); }
	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_w() const { return getFloat("w"); }

	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_h(float val) { return setValue("h", val); }
	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_h() const { return getFloat("h"); }

	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	bool set_jitter(float val) { return setValue("jitter", val); }
	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	float get_jitter() const { return getFloat("jitter"); }

	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_u(bool val) { return setValue("tile_u", val); }
	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_u() const { return getBool("tile_u"); }

	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_v(bool val) { return setValue("tile_v", val); }
	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_v() const { return getBool("tile_v"); }

	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool set_uv_noise_on(bool val) { return setValue("uv_noise_on", val); }
	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool get_uv_noise_on() const { return getBool("uv_noise_on"); }

	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool set_uv_noise_animate(bool val) { return setValue("uv_noise_animate", val); }
	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool get_uv_noise_animate() const { return getBool("uv_noise_animate"); }

	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	bool set_uv_noise_amount(float val) { return setValue("uv_noise_amount", val); }
	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	float get_uv_noise_amount() const { return getFloat("uv_noise_amount"); }

	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	bool set_uv_noise_levels(float val) { return setValue("uv_noise_levels", val); }
	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	float get_uv_noise_levels() const { return getFloat("uv_noise_levels"); }

	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	bool set_uv_noise_size(float val) { return setValue("uv_noise_size", val); }
	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	float get_uv_noise_size() const { return getFloat("uv_noise_size"); }

	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	bool set_un_noise_phase(float val) { return setValue("un_noise_phase", val); }
	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	float get_un_noise_phase() const { return getFloat("un_noise_phase"); }

	//! (description missing)
	bool set_gap_color(const Plugin& texture) { return setValue("gap_color", texture); }
	//! (description missing)
	bool set_gap_color(const AColor& texture) { return setValue("gap_color", texture); }
	//! (description missing)
	Value get_gap_color() const { return getValue("gap_color"); }

	//! (description missing)
	bool set_u_color(const Plugin& texture) { return setValue("u_color", texture); }
	//! (description missing)
	bool set_u_color(const AColor& texture) { return setValue("u_color", texture); }
	//! (description missing)
	Value get_u_color() const { return getValue("u_color"); }

	//! (description missing)
	bool set_v_color(const Plugin& texture) { return setValue("v_color", texture); }
	//! (description missing)
	bool set_v_color(const AColor& texture) { return setValue("v_color", texture); }
	//! (description missing)
	Value get_v_color() const { return getValue("v_color"); }

	//! [UI Guides] minValue=0, maxValue=1
 	bool set_u_width(const Plugin& texturefloat) { return setValue("u_width", texturefloat); }
	//! [UI Guides] minValue=0, maxValue=1
 	bool set_u_width(float texturefloat) { return setValue("u_width", texturefloat); }
	//! [UI Guides] minValue=0, maxValue=1
 	Value get_u_width() const { return getValue("u_width"); }

	//! [UI Guides] minValue=0, maxValue=1
 	bool set_v_width(const Plugin& texturefloat) { return setValue("v_width", texturefloat); }
	//! [UI Guides] minValue=0, maxValue=1
 	bool set_v_width(float texturefloat) { return setValue("v_width", texturefloat); }
	//! [UI Guides] minValue=0, maxValue=1
 	Value get_v_width() const { return getValue("v_width"); }

	//! [UI Guides] minValue=0
 	bool set_u_wave(const Plugin& texturefloat) { return setValue("u_wave", texturefloat); }
	//! [UI Guides] minValue=0
 	bool set_u_wave(float texturefloat) { return setValue("u_wave", texturefloat); }
	//! [UI Guides] minValue=0
 	Value get_u_wave() const { return getValue("u_wave"); }

	//! [UI Guides] minValue=0
 	bool set_v_wave(const Plugin& texturefloat) { return setValue("v_wave", texturefloat); }
	//! [UI Guides] minValue=0
 	bool set_v_wave(float texturefloat) { return setValue("v_wave", texturefloat); }
	//! [UI Guides] minValue=0
 	Value get_v_wave() const { return getValue("v_wave"); }

	//! [UI Guides] minValue=0
 	bool set_randomness(const Plugin& texturefloat) { return setValue("randomness", texturefloat); }
	//! [UI Guides] minValue=0
 	bool set_randomness(float texturefloat) { return setValue("randomness", texturefloat); }
	//! [UI Guides] minValue=0
 	Value get_randomness() const { return getValue("randomness"); }

	//! [UI Guides] minValue=0, maxValue=1
 	bool set_width_spread(const Plugin& texturefloat) { return setValue("width_spread", texturefloat); }
	//! [UI Guides] minValue=0, maxValue=1
 	bool set_width_spread(float texturefloat) { return setValue("width_spread", texturefloat); }
	//! [UI Guides] minValue=0, maxValue=1
 	Value get_width_spread() const { return getValue("width_spread"); }

	//! [UI Guides] minValue=0, maxValue=1
 	bool set_bright_spread(const Plugin& texturefloat) { return setValue("bright_spread", texturefloat); }
	//! [UI Guides] minValue=0, maxValue=1
 	bool set_bright_spread(float texturefloat) { return setValue("bright_spread", texturefloat); }
	//! [UI Guides] minValue=0, maxValue=1
 	Value get_bright_spread() const { return getValue("bright_spread"); }
};

class TexColor2Scalar : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexColor2Scalar"; }

	//! Color texture, which intensity will be used
 	bool set_clr_txt(const Plugin& texture) { return setValue("clr_txt", texture); }
	//! Color texture, which intensity will be used
 	bool set_clr_txt(const AColor& texture) { return setValue("clr_txt", texture); }
	//! Color texture, which intensity will be used
 	Value get_clr_txt() const { return getValue("clr_txt"); }

	//! intensity multiplier
 	bool set_mult(const Plugin& texturefloat) { return setValue("mult", texturefloat); }
	//! intensity multiplier
 	bool set_mult(float texturefloat) { return setValue("mult", texturefloat); }
	//! intensity multiplier
 	Value get_mult() const { return getValue("mult"); }

	//! add alpha in the average calculation
 	//! [Default value] 0
	bool set_use_alpha(int val) { return setValue("use_alpha", val); }
	//! add alpha in the average calculation
 	//! [Default value] 0
	int get_use_alpha() const { return getInt("use_alpha"); }
};

class TexColor8Mix : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexColor8Mix"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! Defines the base (ambient) color to use while mixing
 	bool set_base_color(const Plugin& texture) { return setValue("base_color", texture); }
	//! Defines the base (ambient) color to use while mixing
 	bool set_base_color(const AColor& texture) { return setValue("base_color", texture); }
	//! Defines the base (ambient) color to use while mixing
 	Value get_base_color() const { return getValue("base_color"); }

	//! Defines the compositing color. When using a texture, this parameter is used to define the image.
 	bool set_color1(const Plugin& texture) { return setValue("color1", texture); }
	//! Defines the compositing color. When using a texture, this parameter is used to define the image.
 	bool set_color1(const AColor& texture) { return setValue("color1", texture); }
	//! Defines the compositing color. When using a texture, this parameter is used to define the image.
 	Value get_color1() const { return getValue("color1"); }

	//! Mix type: 0 (Mix), 1(RGB Intensity), 2(Hide/Reveal), 3(Add), 4(Add Compensate (Blend)), 5(Add Bound), 6(Lighter), 7(Darker), 8(Soft Light), 9(Hard Light), 10(Difference), 11(Hue Offset), 12(Screen)
 	//! [UI Guides] enum=0:Mix; 1:RGB Intensity; 2:Hide/Reveal; 3:Add; 4:Add Compensate Blend; 5:Add Bound; 6:Lighter; 7:Darker; 8:Soft Light; 9:Hard Light; 10:Difference; 11:Hue Offset; 12:Screen
 	//! [Default value] 0
	bool set_mode1(int val) { return setValue("mode1", val); }
	//! Mix type: 0 (Mix), 1(RGB Intensity), 2(Hide/Reveal), 3(Add), 4(Add Compensate (Blend)), 5(Add Bound), 6(Lighter), 7(Darker), 8(Soft Light), 9(Hard Light), 10(Difference), 11(Hue Offset), 12(Screen)
 	//! [UI Guides] enum=0:Mix; 1:RGB Intensity; 2:Hide/Reveal; 3:Add; 4:Add Compensate Blend; 5:Add Bound; 6:Lighter; 7:Darker; 8:Soft Light; 9:Hard Light; 10:Difference; 11:Hue Offset; 12:Screen
 	//! [Default value] 0
	int get_mode1() const { return getInt("mode1"); }

	//! Defines the mix layer's intensity in relation to the base color.
 	bool set_weight1(const Plugin& texture) { return setValue("weight1", texture); }
	//! Defines the mix layer's intensity in relation to the base color.
 	bool set_weight1(const AColor& texture) { return setValue("weight1", texture); }
	//! Defines the mix layer's intensity in relation to the base color.
 	Value get_weight1() const { return getValue("weight1"); }

	//! Multiply weight by Alpha
 	//! [Default value] false
	bool set_alpha1(bool val) { return setValue("alpha1", val); }
	//! Multiply weight by Alpha
 	//! [Default value] false
	bool get_alpha1() const { return getBool("alpha1"); }

	//! Computes this color, weight, and mixing mode.
 	//! [Default value] false
	bool set_inuse1(bool val) { return setValue("inuse1", val); }
	//! Computes this color, weight, and mixing mode.
 	//! [Default value] false
	bool get_inuse1() const { return getBool("inuse1"); }

	//! (description missing)
	bool set_color2(const Plugin& texture) { return setValue("color2", texture); }
	//! (description missing)
	bool set_color2(const AColor& texture) { return setValue("color2", texture); }
	//! (description missing)
	Value get_color2() const { return getValue("color2"); }

	//! Mix type: 0 (Mix), 1(RGB Intensity), 2(Hide/Reveal), 3(Add), 4(Add Compensate (Blend)), 5(Add Bound), 6(Lighter), 7(Darker), 8(Soft Light), 9(Hard Light), 10(Difference), 11(Hue Offset), 12(Screen)
 	//! [UI Guides] enum=0:Mix; 1:RGB Intensity; 2:Hide/Reveal; 3:Add; 4:Add Compensate Blend; 5:Add Bound; 6:Lighter; 7:Darker; 8:Soft Light; 9:Hard Light; 10:Difference; 11:Hue Offset; 12:Screen
 	//! [Default value] 0
	bool set_mode2(int val) { return setValue("mode2", val); }
	//! Mix type: 0 (Mix), 1(RGB Intensity), 2(Hide/Reveal), 3(Add), 4(Add Compensate (Blend)), 5(Add Bound), 6(Lighter), 7(Darker), 8(Soft Light), 9(Hard Light), 10(Difference), 11(Hue Offset), 12(Screen)
 	//! [UI Guides] enum=0:Mix; 1:RGB Intensity; 2:Hide/Reveal; 3:Add; 4:Add Compensate Blend; 5:Add Bound; 6:Lighter; 7:Darker; 8:Soft Light; 9:Hard Light; 10:Difference; 11:Hue Offset; 12:Screen
 	//! [Default value] 0
	int get_mode2() const { return getInt("mode2"); }

	//! (description missing)
	bool set_weight2(const Plugin& texture) { return setValue("weight2", texture); }
	//! (description missing)
	bool set_weight2(const AColor& texture) { return setValue("weight2", texture); }
	//! (description missing)
	Value get_weight2() const { return getValue("weight2"); }

	//! (description missing)
	//! [Default value] false
	bool set_alpha2(bool val) { return setValue("alpha2", val); }
	//! (description missing)
	//! [Default value] false
	bool get_alpha2() const { return getBool("alpha2"); }

	//! (description missing)
	//! [Default value] false
	bool set_inuse2(bool val) { return setValue("inuse2", val); }
	//! (description missing)
	//! [Default value] false
	bool get_inuse2() const { return getBool("inuse2"); }

	//! (description missing)
	bool set_color3(const Plugin& texture) { return setValue("color3", texture); }
	//! (description missing)
	bool set_color3(const AColor& texture) { return setValue("color3", texture); }
	//! (description missing)
	Value get_color3() const { return getValue("color3"); }

	//! Mix type: 0 (Mix), 1(RGB Intensity), 2(Hide/Reveal), 3(Add), 4(Add Compensate (Blend)), 5(Add Bound), 6(Lighter), 7(Darker), 8(Soft Light), 9(Hard Light), 10(Difference), 11(Hue Offset), 12(Screen)
 	//! [UI Guides] enum=0:Mix; 1:RGB Intensity; 2:Hide/Reveal; 3:Add; 4:Add Compensate Blend; 5:Add Bound; 6:Lighter; 7:Darker; 8:Soft Light; 9:Hard Light; 10:Difference; 11:Hue Offset; 12:Screen
 	//! [Default value] 0
	bool set_mode3(int val) { return setValue("mode3", val); }
	//! Mix type: 0 (Mix), 1(RGB Intensity), 2(Hide/Reveal), 3(Add), 4(Add Compensate (Blend)), 5(Add Bound), 6(Lighter), 7(Darker), 8(Soft Light), 9(Hard Light), 10(Difference), 11(Hue Offset), 12(Screen)
 	//! [UI Guides] enum=0:Mix; 1:RGB Intensity; 2:Hide/Reveal; 3:Add; 4:Add Compensate Blend; 5:Add Bound; 6:Lighter; 7:Darker; 8:Soft Light; 9:Hard Light; 10:Difference; 11:Hue Offset; 12:Screen
 	//! [Default value] 0
	int get_mode3() const { return getInt("mode3"); }

	//! (description missing)
	bool set_weight3(const Plugin& texture) { return setValue("weight3", texture); }
	//! (description missing)
	bool set_weight3(const AColor& texture) { return setValue("weight3", texture); }
	//! (description missing)
	Value get_weight3() const { return getValue("weight3"); }

	//! (description missing)
	//! [Default value] false
	bool set_alpha3(bool val) { return setValue("alpha3", val); }
	//! (description missing)
	//! [Default value] false
	bool get_alpha3() const { return getBool("alpha3"); }

	//! (description missing)
	//! [Default value] false
	bool set_inuse3(bool val) { return setValue("inuse3", val); }
	//! (description missing)
	//! [Default value] false
	bool get_inuse3() const { return getBool("inuse3"); }

	//! (description missing)
	bool set_color4(const Plugin& texture) { return setValue("color4", texture); }
	//! (description missing)
	bool set_color4(const AColor& texture) { return setValue("color4", texture); }
	//! (description missing)
	Value get_color4() const { return getValue("color4"); }

	//! Mix type: 0 (Mix), 1(RGB Intensity), 2(Hide/Reveal), 3(Add), 4(Add Compensate (Blend)), 5(Add Bound), 6(Lighter), 7(Darker), 8(Soft Light), 9(Hard Light), 10(Difference), 11(Hue Offset), 12(Screen)
 	//! [UI Guides] enum=0:Mix; 1:RGB Intensity; 2:Hide/Reveal; 3:Add; 4:Add Compensate Blend; 5:Add Bound; 6:Lighter; 7:Darker; 8:Soft Light; 9:Hard Light; 10:Difference; 11:Hue Offset; 12:Screen
 	//! [Default value] 0
	bool set_mode4(int val) { return setValue("mode4", val); }
	//! Mix type: 0 (Mix), 1(RGB Intensity), 2(Hide/Reveal), 3(Add), 4(Add Compensate (Blend)), 5(Add Bound), 6(Lighter), 7(Darker), 8(Soft Light), 9(Hard Light), 10(Difference), 11(Hue Offset), 12(Screen)
 	//! [UI Guides] enum=0:Mix; 1:RGB Intensity; 2:Hide/Reveal; 3:Add; 4:Add Compensate Blend; 5:Add Bound; 6:Lighter; 7:Darker; 8:Soft Light; 9:Hard Light; 10:Difference; 11:Hue Offset; 12:Screen
 	//! [Default value] 0
	int get_mode4() const { return getInt("mode4"); }

	//! (description missing)
	bool set_weight4(const Plugin& texture) { return setValue("weight4", texture); }
	//! (description missing)
	bool set_weight4(const AColor& texture) { return setValue("weight4", texture); }
	//! (description missing)
	Value get_weight4() const { return getValue("weight4"); }

	//! (description missing)
	//! [Default value] false
	bool set_alpha4(bool val) { return setValue("alpha4", val); }
	//! (description missing)
	//! [Default value] false
	bool get_alpha4() const { return getBool("alpha4"); }

	//! (description missing)
	//! [Default value] false
	bool set_inuse4(bool val) { return setValue("inuse4", val); }
	//! (description missing)
	//! [Default value] false
	bool get_inuse4() const { return getBool("inuse4"); }

	//! (description missing)
	bool set_color5(const Plugin& texture) { return setValue("color5", texture); }
	//! (description missing)
	bool set_color5(const AColor& texture) { return setValue("color5", texture); }
	//! (description missing)
	Value get_color5() const { return getValue("color5"); }

	//! Mix type: 0 (Mix), 1(RGB Intensity), 2(Hide/Reveal), 3(Add), 4(Add Compensate (Blend)), 5(Add Bound), 6(Lighter), 7(Darker), 8(Soft Light), 9(Hard Light), 10(Difference), 11(Hue Offset), 12(Screen)
 	//! [UI Guides] enum=0:Mix; 1:RGB Intensity; 2:Hide/Reveal; 3:Add; 4:Add Compensate Blend; 5:Add Bound; 6:Lighter; 7:Darker; 8:Soft Light; 9:Hard Light; 10:Difference; 11:Hue Offset; 12:Screen
 	//! [Default value] 0
	bool set_mode5(int val) { return setValue("mode5", val); }
	//! Mix type: 0 (Mix), 1(RGB Intensity), 2(Hide/Reveal), 3(Add), 4(Add Compensate (Blend)), 5(Add Bound), 6(Lighter), 7(Darker), 8(Soft Light), 9(Hard Light), 10(Difference), 11(Hue Offset), 12(Screen)
 	//! [UI Guides] enum=0:Mix; 1:RGB Intensity; 2:Hide/Reveal; 3:Add; 4:Add Compensate Blend; 5:Add Bound; 6:Lighter; 7:Darker; 8:Soft Light; 9:Hard Light; 10:Difference; 11:Hue Offset; 12:Screen
 	//! [Default value] 0
	int get_mode5() const { return getInt("mode5"); }

	//! (description missing)
	bool set_weight5(const Plugin& texture) { return setValue("weight5", texture); }
	//! (description missing)
	bool set_weight5(const AColor& texture) { return setValue("weight5", texture); }
	//! (description missing)
	Value get_weight5() const { return getValue("weight5"); }

	//! (description missing)
	//! [Default value] false
	bool set_alpha5(bool val) { return setValue("alpha5", val); }
	//! (description missing)
	//! [Default value] false
	bool get_alpha5() const { return getBool("alpha5"); }

	//! (description missing)
	//! [Default value] false
	bool set_inuse5(bool val) { return setValue("inuse5", val); }
	//! (description missing)
	//! [Default value] false
	bool get_inuse5() const { return getBool("inuse5"); }

	//! (description missing)
	bool set_color6(const Plugin& texture) { return setValue("color6", texture); }
	//! (description missing)
	bool set_color6(const AColor& texture) { return setValue("color6", texture); }
	//! (description missing)
	Value get_color6() const { return getValue("color6"); }

	//! Mix type: 0 (Mix), 1(RGB Intensity), 2(Hide/Reveal), 3(Add), 4(Add Compensate (Blend)), 5(Add Bound), 6(Lighter), 7(Darker), 8(Soft Light), 9(Hard Light), 10(Difference), 11(Hue Offset), 12(Screen)
 	//! [UI Guides] enum=0:Mix; 1:RGB Intensity; 2:Hide/Reveal; 3:Add; 4:Add Compensate Blend; 5:Add Bound; 6:Lighter; 7:Darker; 8:Soft Light; 9:Hard Light; 10:Difference; 11:Hue Offset; 12:Screen
 	//! [Default value] 0
	bool set_mode6(int val) { return setValue("mode6", val); }
	//! Mix type: 0 (Mix), 1(RGB Intensity), 2(Hide/Reveal), 3(Add), 4(Add Compensate (Blend)), 5(Add Bound), 6(Lighter), 7(Darker), 8(Soft Light), 9(Hard Light), 10(Difference), 11(Hue Offset), 12(Screen)
 	//! [UI Guides] enum=0:Mix; 1:RGB Intensity; 2:Hide/Reveal; 3:Add; 4:Add Compensate Blend; 5:Add Bound; 6:Lighter; 7:Darker; 8:Soft Light; 9:Hard Light; 10:Difference; 11:Hue Offset; 12:Screen
 	//! [Default value] 0
	int get_mode6() const { return getInt("mode6"); }

	//! (description missing)
	bool set_weight6(const Plugin& texture) { return setValue("weight6", texture); }
	//! (description missing)
	bool set_weight6(const AColor& texture) { return setValue("weight6", texture); }
	//! (description missing)
	Value get_weight6() const { return getValue("weight6"); }

	//! (description missing)
	//! [Default value] false
	bool set_alpha6(bool val) { return setValue("alpha6", val); }
	//! (description missing)
	//! [Default value] false
	bool get_alpha6() const { return getBool("alpha6"); }

	//! (description missing)
	//! [Default value] false
	bool set_inuse6(bool val) { return setValue("inuse6", val); }
	//! (description missing)
	//! [Default value] false
	bool get_inuse6() const { return getBool("inuse6"); }

	//! (description missing)
	bool set_color7(const Plugin& texture) { return setValue("color7", texture); }
	//! (description missing)
	bool set_color7(const AColor& texture) { return setValue("color7", texture); }
	//! (description missing)
	Value get_color7() const { return getValue("color7"); }

	//! Mix type: 0 (Mix), 1(RGB Intensity), 2(Hide/Reveal), 3(Add), 4(Add Compensate (Blend)), 5(Add Bound), 6(Lighter), 7(Darker), 8(Soft Light), 9(Hard Light), 10(Difference), 11(Hue Offset), 12(Screen)
 	//! [UI Guides] enum=0:Mix; 1:RGB Intensity; 2:Hide/Reveal; 3:Add; 4:Add Compensate Blend; 5:Add Bound; 6:Lighter; 7:Darker; 8:Soft Light; 9:Hard Light; 10:Difference; 11:Hue Offset; 12:Screen
 	//! [Default value] 0
	bool set_mode7(int val) { return setValue("mode7", val); }
	//! Mix type: 0 (Mix), 1(RGB Intensity), 2(Hide/Reveal), 3(Add), 4(Add Compensate (Blend)), 5(Add Bound), 6(Lighter), 7(Darker), 8(Soft Light), 9(Hard Light), 10(Difference), 11(Hue Offset), 12(Screen)
 	//! [UI Guides] enum=0:Mix; 1:RGB Intensity; 2:Hide/Reveal; 3:Add; 4:Add Compensate Blend; 5:Add Bound; 6:Lighter; 7:Darker; 8:Soft Light; 9:Hard Light; 10:Difference; 11:Hue Offset; 12:Screen
 	//! [Default value] 0
	int get_mode7() const { return getInt("mode7"); }

	//! (description missing)
	bool set_weight7(const Plugin& texture) { return setValue("weight7", texture); }
	//! (description missing)
	bool set_weight7(const AColor& texture) { return setValue("weight7", texture); }
	//! (description missing)
	Value get_weight7() const { return getValue("weight7"); }

	//! (description missing)
	//! [Default value] false
	bool set_alpha7(bool val) { return setValue("alpha7", val); }
	//! (description missing)
	//! [Default value] false
	bool get_alpha7() const { return getBool("alpha7"); }

	//! (description missing)
	//! [Default value] false
	bool set_inuse7(bool val) { return setValue("inuse7", val); }
	//! (description missing)
	//! [Default value] false
	bool get_inuse7() const { return getBool("inuse7"); }
};

class TexColorAndAlpha : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexColorAndAlpha"; }

	//! (description missing)
	bool set_color_input(const Plugin& texture) { return setValue("color_input", texture); }
	//! (description missing)
	bool set_color_input(const AColor& texture) { return setValue("color_input", texture); }
	//! (description missing)
	Value get_color_input() const { return getValue("color_input"); }

	//! (description missing)
	bool set_alpha_input(const Plugin& texturefloat) { return setValue("alpha_input", texturefloat); }
	//! (description missing)
	bool set_alpha_input(float texturefloat) { return setValue("alpha_input", texturefloat); }
	//! (description missing)
	Value get_alpha_input() const { return getValue("alpha_input"); }
};

class TexColorAverage : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexColorAverage"; }

	//! Input texture used to compute an intensity level
 	bool set_input(const Plugin& texture) { return setValue("input", texture); }
	//! Input texture used to compute an intensity level
 	bool set_input(const AColor& texture) { return setValue("input", texture); }
	//! Input texture used to compute an intensity level
 	Value get_input() const { return getValue("input"); }

	//! The intensity of the output
 	//! [Default value] 1
	bool set_factor(float val) { return setValue("factor", val); }
	//! The intensity of the output
 	//! [Default value] 1
	float get_factor() const { return getFloat("factor"); }
};

class TexColorCondition : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexColorCondition"; }

	//! (description missing)
	bool set_color_a(const Plugin& texture) { return setValue("color_a", texture); }
	//! (description missing)
	bool set_color_a(const AColor& texture) { return setValue("color_a", texture); }
	//! (description missing)
	Value get_color_a() const { return getValue("color_a"); }

	//! (description missing)
	bool set_alpha_a(const Plugin& texturefloat) { return setValue("alpha_a", texturefloat); }
	//! (description missing)
	bool set_alpha_a(float texturefloat) { return setValue("alpha_a", texturefloat); }
	//! (description missing)
	Value get_alpha_a() const { return getValue("alpha_a"); }

	//! (description missing)
	bool set_color_b(const Plugin& texture) { return setValue("color_b", texture); }
	//! (description missing)
	bool set_color_b(const AColor& texture) { return setValue("color_b", texture); }
	//! (description missing)
	Value get_color_b() const { return getValue("color_b"); }

	//! (description missing)
	bool set_alpha_b(const Plugin& texturefloat) { return setValue("alpha_b", texturefloat); }
	//! (description missing)
	bool set_alpha_b(float texturefloat) { return setValue("alpha_b", texturefloat); }
	//! (description missing)
	Value get_alpha_b() const { return getValue("alpha_b"); }

	//! (description missing)
	bool set_condition(const Plugin& texturefloat) { return setValue("condition", texturefloat); }
	//! (description missing)
	bool set_condition(float texturefloat) { return setValue("condition", texturefloat); }
	//! (description missing)
	Value get_condition() const { return getValue("condition"); }
};

class TexColorConstant : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexColorConstant"; }

	//! (description missing)
	bool set_color(const Plugin& texture) { return setValue("color", texture); }
	//! (description missing)
	bool set_color(const AColor& texture) { return setValue("color", texture); }
	//! (description missing)
	Value get_color() const { return getValue("color"); }

	//! (description missing)
	bool set_alpha(const Plugin& texturefloat) { return setValue("alpha", texturefloat); }
	//! (description missing)
	bool set_alpha(float texturefloat) { return setValue("alpha", texturefloat); }
	//! (description missing)
	Value get_alpha() const { return getValue("alpha"); }
};

class TexColorCorrect : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexColorCorrect"; }

	//! (description missing)
	bool set_in_color(const Plugin& texture) { return setValue("in_color", texture); }
	//! (description missing)
	bool set_in_color(const AColor& texture) { return setValue("in_color", texture); }
	//! (description missing)
	Value get_in_color() const { return getValue("in_color"); }

	//! (description missing)
	bool set_in_alpha(const Plugin& texturefloat) { return setValue("in_alpha", texturefloat); }
	//! (description missing)
	bool set_in_alpha(float texturefloat) { return setValue("in_alpha", texturefloat); }
	//! (description missing)
	Value get_in_alpha() const { return getValue("in_alpha"); }

	//! (description missing)
	bool set_unpremultiply_input(const Plugin& texturefloat) { return setValue("unpremultiply_input", texturefloat); }
	//! (description missing)
	bool set_unpremultiply_input(float texturefloat) { return setValue("unpremultiply_input", texturefloat); }
	//! (description missing)
	Value get_unpremultiply_input() const { return getValue("unpremultiply_input"); }

	//! (description missing)
	bool set_premultiply_result(const Plugin& texturefloat) { return setValue("premultiply_result", texturefloat); }
	//! (description missing)
	bool set_premultiply_result(float texturefloat) { return setValue("premultiply_result", texturefloat); }
	//! (description missing)
	Value get_premultiply_result() const { return getValue("premultiply_result"); }

	//! (description missing)
	bool set_hue_shift(const Plugin& texturefloat) { return setValue("hue_shift", texturefloat); }
	//! (description missing)
	bool set_hue_shift(float texturefloat) { return setValue("hue_shift", texturefloat); }
	//! (description missing)
	Value get_hue_shift() const { return getValue("hue_shift"); }

	//! (description missing)
	bool set_sat_gain(const Plugin& texturefloat) { return setValue("sat_gain", texturefloat); }
	//! (description missing)
	bool set_sat_gain(float texturefloat) { return setValue("sat_gain", texturefloat); }
	//! (description missing)
	Value get_sat_gain() const { return getValue("sat_gain"); }

	//! (description missing)
	bool set_val_gain(const Plugin& texturefloat) { return setValue("val_gain", texturefloat); }
	//! (description missing)
	bool set_val_gain(float texturefloat) { return setValue("val_gain", texturefloat); }
	//! (description missing)
	Value get_val_gain() const { return getValue("val_gain"); }

	//! (description missing)
	bool set_col_gain(const Plugin& texture) { return setValue("col_gain", texture); }
	//! (description missing)
	bool set_col_gain(const AColor& texture) { return setValue("col_gain", texture); }
	//! (description missing)
	Value get_col_gain() const { return getValue("col_gain"); }

	//! (description missing)
	bool set_col_offset(const Plugin& texture) { return setValue("col_offset", texture); }
	//! (description missing)
	bool set_col_offset(const AColor& texture) { return setValue("col_offset", texture); }
	//! (description missing)
	Value get_col_offset() const { return getValue("col_offset"); }

	//! (description missing)
	bool set_col_gamma(const Plugin& texture) { return setValue("col_gamma", texture); }
	//! (description missing)
	bool set_col_gamma(const AColor& texture) { return setValue("col_gamma", texture); }
	//! (description missing)
	Value get_col_gamma() const { return getValue("col_gamma"); }

	//! (description missing)
	bool set_col_clamp(const Plugin& texturefloat) { return setValue("col_clamp", texturefloat); }
	//! (description missing)
	bool set_col_clamp(float texturefloat) { return setValue("col_clamp", texturefloat); }
	//! (description missing)
	Value get_col_clamp() const { return getValue("col_clamp"); }

	//! (description missing)
	bool set_col_clamp_min(const Plugin& texture) { return setValue("col_clamp_min", texture); }
	//! (description missing)
	bool set_col_clamp_min(const AColor& texture) { return setValue("col_clamp_min", texture); }
	//! (description missing)
	Value get_col_clamp_min() const { return getValue("col_clamp_min"); }

	//! (description missing)
	bool set_col_clamp_max(const Plugin& texture) { return setValue("col_clamp_max", texture); }
	//! (description missing)
	bool set_col_clamp_max(const AColor& texture) { return setValue("col_clamp_max", texture); }
	//! (description missing)
	Value get_col_clamp_max() const { return getValue("col_clamp_max"); }

	//! (description missing)
	bool set_alpha_gain(const Plugin& texturefloat) { return setValue("alpha_gain", texturefloat); }
	//! (description missing)
	bool set_alpha_gain(float texturefloat) { return setValue("alpha_gain", texturefloat); }
	//! (description missing)
	Value get_alpha_gain() const { return getValue("alpha_gain"); }

	//! (description missing)
	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! (description missing)
	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! (description missing)
	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! (description missing)
	bool set_alpha_gamma(const Plugin& texturefloat) { return setValue("alpha_gamma", texturefloat); }
	//! (description missing)
	bool set_alpha_gamma(float texturefloat) { return setValue("alpha_gamma", texturefloat); }
	//! (description missing)
	Value get_alpha_gamma() const { return getValue("alpha_gamma"); }

	//! (description missing)
	bool set_alpha_clamp(const Plugin& texturefloat) { return setValue("alpha_clamp", texturefloat); }
	//! (description missing)
	bool set_alpha_clamp(float texturefloat) { return setValue("alpha_clamp", texturefloat); }
	//! (description missing)
	Value get_alpha_clamp() const { return getValue("alpha_clamp"); }

	//! (description missing)
	bool set_alpha_clamp_min(const Plugin& texturefloat) { return setValue("alpha_clamp_min", texturefloat); }
	//! (description missing)
	bool set_alpha_clamp_min(float texturefloat) { return setValue("alpha_clamp_min", texturefloat); }
	//! (description missing)
	Value get_alpha_clamp_min() const { return getValue("alpha_clamp_min"); }

	//! (description missing)
	bool set_alpha_clamp_max(const Plugin& texturefloat) { return setValue("alpha_clamp_max", texturefloat); }
	//! (description missing)
	bool set_alpha_clamp_max(float texturefloat) { return setValue("alpha_clamp_max", texturefloat); }
	//! (description missing)
	Value get_alpha_clamp_max() const { return getValue("alpha_clamp_max"); }
};

class TexColorCurve : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexColorCurve"; }

	//! The value from this texture is controlled by the profile curve.
 	bool set_input(const Plugin& texture) { return setValue("input", texture); }
	//! The value from this texture is controlled by the profile curve.
 	bool set_input(const AColor& texture) { return setValue("input", texture); }
	//! The value from this texture is controlled by the profile curve.
 	Value get_input() const { return getValue("input"); }

	//! If present input is ignored, and this is used instead.
 	bool set_inputScalar(const Plugin& texturefloat) { return setValue("inputScalar", texturefloat); }
	//! If present input is ignored, and this is used instead.
 	bool set_inputScalar(float texturefloat) { return setValue("inputScalar", texturefloat); }
	//! If present input is ignored, and this is used instead.
 	Value get_inputScalar() const { return getValue("inputScalar"); }

	//! Quadruplets of 2d vectors for each bezier segment for the red curve.
 	//! [Default value] 0
	bool set_rkeys(const FloatList& floatList) { return setValue("rkeys", floatList); }
	//! Quadruplets of 2d vectors for each bezier segment for the red curve.
 	//! [Default value] 0
	bool set_rkeys(const float* floats, size_t count) { return setArray("rkeys", floats, count); }
	//! Quadruplets of 2d vectors for each bezier segment for the red curve.
 	//! [Default value] 0
	template<size_t count> bool set_rkeys(const float (&floats)[count]) { return setArray("rkeys", floats, count); }
	//! Quadruplets of 2d vectors for each bezier segment for the red curve.
 	//! [Default value] 0
	FloatList get_rkeys() const { return getFloatList("rkeys"); }

	//! Quadruplets of 2d vectors for each bezier segment for the green curve.
 	//! [Default value] 0
	bool set_gkeys(const FloatList& floatList) { return setValue("gkeys", floatList); }
	//! Quadruplets of 2d vectors for each bezier segment for the green curve.
 	//! [Default value] 0
	bool set_gkeys(const float* floats, size_t count) { return setArray("gkeys", floats, count); }
	//! Quadruplets of 2d vectors for each bezier segment for the green curve.
 	//! [Default value] 0
	template<size_t count> bool set_gkeys(const float (&floats)[count]) { return setArray("gkeys", floats, count); }
	//! Quadruplets of 2d vectors for each bezier segment for the green curve.
 	//! [Default value] 0
	FloatList get_gkeys() const { return getFloatList("gkeys"); }

	//! Quadruplets of 2d vectors for each bezier segment for the blue curve.
 	//! [Default value] 0
	bool set_bkeys(const FloatList& floatList) { return setValue("bkeys", floatList); }
	//! Quadruplets of 2d vectors for each bezier segment for the blue curve.
 	//! [Default value] 0
	bool set_bkeys(const float* floats, size_t count) { return setArray("bkeys", floats, count); }
	//! Quadruplets of 2d vectors for each bezier segment for the blue curve.
 	//! [Default value] 0
	template<size_t count> bool set_bkeys(const float (&floats)[count]) { return setArray("bkeys", floats, count); }
	//! Quadruplets of 2d vectors for each bezier segment for the blue curve.
 	//! [Default value] 0
	FloatList get_bkeys() const { return getFloatList("bkeys"); }

	//! Get alpha from curve
 	//! [Default value] false
	bool set_use_alpha(bool val) { return setValue("use_alpha", val); }
	//! Get alpha from curve
 	//! [Default value] false
	bool get_use_alpha() const { return getBool("use_alpha"); }

	//! Quadruplets of 2d vectors for each bezier segment for the alpha curve.
 	//! [Default value] 0
	bool set_akeys(const FloatList& floatList) { return setValue("akeys", floatList); }
	//! Quadruplets of 2d vectors for each bezier segment for the alpha curve.
 	//! [Default value] 0
	bool set_akeys(const float* floats, size_t count) { return setArray("akeys", floats, count); }
	//! Quadruplets of 2d vectors for each bezier segment for the alpha curve.
 	//! [Default value] 0
	template<size_t count> bool set_akeys(const float (&floats)[count]) { return setArray("akeys", floats, count); }
	//! Quadruplets of 2d vectors for each bezier segment for the alpha curve.
 	//! [Default value] 0
	FloatList get_akeys() const { return getFloatList("akeys"); }
};

class TexColorExponential : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexColorExponential"; }

	//! The value used in the operation.
 	bool set_input(const Plugin& texture) { return setValue("input", texture); }
	//! The value used in the operation.
 	bool set_input(const AColor& texture) { return setValue("input", texture); }
	//! The value used in the operation.
 	Value get_input() const { return getValue("input"); }

	//! The factor to be used in the operation.
 	bool set_factor(const Plugin& texture) { return setValue("factor", texture); }
	//! The factor to be used in the operation.
 	bool set_factor(const AColor& texture) { return setValue("factor", texture); }
	//! The factor to be used in the operation.
 	Value get_factor() const { return getValue("factor"); }

	//! The operation: 0=Exponential, 1=Logarithm, 2=Bias, 3=Gain
 	//! [UI Guides] enum=0:Exponential; 1:Logarithm; 2:Bias; 3:Gain
 	//! [Default value] 0
	bool set_operation(int val) { return setValue("operation", val); }
	//! The operation: 0=Exponential, 1=Logarithm, 2=Bias, 3=Gain
 	//! [UI Guides] enum=0:Exponential; 1:Logarithm; 2:Bias; 3:Gain
 	//! [Default value] 0
	int get_operation() const { return getInt("operation"); }

	//! Apply operation to alpha channel
 	//! [Default value] false
	bool set_use_alpha(bool val) { return setValue("use_alpha", val); }
	//! Apply operation to alpha channel
 	//! [Default value] false
	bool get_use_alpha() const { return getBool("use_alpha"); }
};

class TexColorLogic : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexColorLogic"; }

	//! (description missing)
	bool set_color_a(const Plugin& texture) { return setValue("color_a", texture); }
	//! (description missing)
	bool set_color_a(const AColor& texture) { return setValue("color_a", texture); }
	//! (description missing)
	Value get_color_a() const { return getValue("color_a"); }

	//! (description missing)
	bool set_color_b(const Plugin& texture) { return setValue("color_b", texture); }
	//! (description missing)
	bool set_color_b(const AColor& texture) { return setValue("color_b", texture); }
	//! (description missing)
	Value get_color_b() const { return getValue("color_b"); }

	//! (description missing)
	//! [Default value] false
	bool set_operation(bool val) { return setValue("operation", val); }
	//! (description missing)
	//! [Default value] false
	bool get_operation() const { return getBool("operation"); }
};

class TexColorMask : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexColorMask"; }

	//! (description missing)
	bool set_in_color(const Plugin& texture) { return setValue("in_color", texture); }
	//! (description missing)
	bool set_in_color(const AColor& texture) { return setValue("in_color", texture); }
	//! (description missing)
	Value get_in_color() const { return getValue("in_color"); }

	//! (description missing)
	bool set_in_alpha(const Plugin& texturefloat) { return setValue("in_alpha", texturefloat); }
	//! (description missing)
	bool set_in_alpha(float texturefloat) { return setValue("in_alpha", texturefloat); }
	//! (description missing)
	Value get_in_alpha() const { return getValue("in_alpha"); }

	//! (description missing)
	bool set_preserve_color(const Plugin& texturefloat) { return setValue("preserve_color", texturefloat); }
	//! (description missing)
	bool set_preserve_color(float texturefloat) { return setValue("preserve_color", texturefloat); }
	//! (description missing)
	Value get_preserve_color() const { return getValue("preserve_color"); }

	//! (description missing)
	bool set_mask(const Plugin& texture) { return setValue("mask", texture); }
	//! (description missing)
	bool set_mask(const AColor& texture) { return setValue("mask", texture); }
	//! (description missing)
	Value get_mask() const { return getValue("mask"); }

	//! (description missing)
	bool set_mask_alpha(const Plugin& texturefloat) { return setValue("mask_alpha", texturefloat); }
	//! (description missing)
	bool set_mask_alpha(float texturefloat) { return setValue("mask_alpha", texturefloat); }
	//! (description missing)
	Value get_mask_alpha() const { return getValue("mask_alpha"); }

	//! (description missing)
	//! [Default value] 0
	bool set_mask_alpha_is_luminance(float val) { return setValue("mask_alpha_is_luminance", val); }
	//! (description missing)
	//! [Default value] 0
	float get_mask_alpha_is_luminance() const { return getFloat("mask_alpha_is_luminance"); }
};

class TexColorMathBasic : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexColorMathBasic"; }

	//! Operation: Add(), Subtract(), Multiply(), Divide(), Minimum(), Maximum()
 	//! [Default value] 0
	bool set_op(int val) { return setValue("op", val); }
	//! Operation: Add(), Subtract(), Multiply(), Divide(), Minimum(), Maximum()
 	//! [Default value] 0
	int get_op() const { return getInt("op"); }

	//! Use alpha in the calculations
 	//! [Default value] false
	bool set_alpha(bool val) { return setValue("alpha", val); }
	//! Use alpha in the calculations
 	//! [Default value] false
	bool get_alpha() const { return getBool("alpha"); }

	//! The first color input
 	bool set_input1(const Plugin& texture) { return setValue("input1", texture); }
	//! The first color input
 	bool set_input1(const AColor& texture) { return setValue("input1", texture); }
	//! The first color input
 	Value get_input1() const { return getValue("input1"); }

	//! The second color input
 	bool set_input2(const Plugin& texture) { return setValue("input2", texture); }
	//! The second color input
 	bool set_input2(const AColor& texture) { return setValue("input2", texture); }
	//! The second color input
 	Value get_input2() const { return getValue("input2"); }
};

class TexColorSwitch : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexColorSwitch"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! Default color to be used when the Switch value does not match the Value of any of the Cases
 	bool set_default_color(const Plugin& texture) { return setValue("default_color", texture); }
	//! Default color to be used when the Switch value does not match the Value of any of the Cases
 	bool set_default_color(const AColor& texture) { return setValue("default_color", texture); }
	//! Default color to be used when the Switch value does not match the Value of any of the Cases
 	Value get_default_color() const { return getValue("default_color"); }

	//! Accepts a varying set of integer values that control which Case's Input gets evaluated
 	bool set_switch_value(const Plugin& textureint) { return setValue("switch_value", textureint); }
	//! Accepts a varying set of integer values that control which Case's Input gets evaluated
 	bool set_switch_value(int textureint) { return setValue("switch_value", textureint); }
	//! Accepts a varying set of integer values that control which Case's Input gets evaluated
 	Value get_switch_value() const { return getValue("switch_value"); }

	//! (description missing)
	bool set_color0(const Plugin& texture) { return setValue("color0", texture); }
	//! (description missing)
	bool set_color0(const AColor& texture) { return setValue("color0", texture); }
	//! (description missing)
	Value get_color0() const { return getValue("color0"); }

	//! (description missing)
	//! [Default value] 0
	bool set_value0(int val) { return setValue("value0", val); }
	//! (description missing)
	//! [Default value] 0
	int get_value0() const { return getInt("value0"); }

	//! (description missing)
	bool set_color1(const Plugin& texture) { return setValue("color1", texture); }
	//! (description missing)
	bool set_color1(const AColor& texture) { return setValue("color1", texture); }
	//! (description missing)
	Value get_color1() const { return getValue("color1"); }

	//! (description missing)
	//! [Default value] 1
	bool set_value1(int val) { return setValue("value1", val); }
	//! (description missing)
	//! [Default value] 1
	int get_value1() const { return getInt("value1"); }

	//! (description missing)
	bool set_color2(const Plugin& texture) { return setValue("color2", texture); }
	//! (description missing)
	bool set_color2(const AColor& texture) { return setValue("color2", texture); }
	//! (description missing)
	Value get_color2() const { return getValue("color2"); }

	//! (description missing)
	//! [Default value] 2
	bool set_value2(int val) { return setValue("value2", val); }
	//! (description missing)
	//! [Default value] 2
	int get_value2() const { return getInt("value2"); }

	//! (description missing)
	bool set_color3(const Plugin& texture) { return setValue("color3", texture); }
	//! (description missing)
	bool set_color3(const AColor& texture) { return setValue("color3", texture); }
	//! (description missing)
	Value get_color3() const { return getValue("color3"); }

	//! (description missing)
	//! [Default value] 3
	bool set_value3(int val) { return setValue("value3", val); }
	//! (description missing)
	//! [Default value] 3
	int get_value3() const { return getInt("value3"); }

	//! (description missing)
	bool set_color4(const Plugin& texture) { return setValue("color4", texture); }
	//! (description missing)
	bool set_color4(const AColor& texture) { return setValue("color4", texture); }
	//! (description missing)
	Value get_color4() const { return getValue("color4"); }

	//! (description missing)
	//! [Default value] 4
	bool set_value4(int val) { return setValue("value4", val); }
	//! (description missing)
	//! [Default value] 4
	int get_value4() const { return getInt("value4"); }

	//! (description missing)
	bool set_color5(const Plugin& texture) { return setValue("color5", texture); }
	//! (description missing)
	bool set_color5(const AColor& texture) { return setValue("color5", texture); }
	//! (description missing)
	Value get_color5() const { return getValue("color5"); }

	//! (description missing)
	//! [Default value] 5
	bool set_value5(int val) { return setValue("value5", val); }
	//! (description missing)
	//! [Default value] 5
	int get_value5() const { return getInt("value5"); }

	//! (description missing)
	bool set_color6(const Plugin& texture) { return setValue("color6", texture); }
	//! (description missing)
	bool set_color6(const AColor& texture) { return setValue("color6", texture); }
	//! (description missing)
	Value get_color6() const { return getValue("color6"); }

	//! (description missing)
	//! [Default value] 6
	bool set_value6(int val) { return setValue("value6", val); }
	//! (description missing)
	//! [Default value] 6
	int get_value6() const { return getInt("value6"); }

	//! (description missing)
	bool set_color7(const Plugin& texture) { return setValue("color7", texture); }
	//! (description missing)
	bool set_color7(const AColor& texture) { return setValue("color7", texture); }
	//! (description missing)
	Value get_color7() const { return getValue("color7"); }

	//! (description missing)
	//! [Default value] 7
	bool set_value7(int val) { return setValue("value7", val); }
	//! (description missing)
	//! [Default value] 7
	int get_value7() const { return getInt("value7"); }
};

class TexColorToFloat : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexColorToFloat"; }

	//! The color value
 	bool set_input(const Plugin& texture) { return setValue("input", texture); }
	//! The color value
 	bool set_input(const AColor& texture) { return setValue("input", texture); }
	//! The color value
 	Value get_input() const { return getValue("input"); }
};

class TexCombineColor : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexCombineColor"; }

	//! The color value
 	//! [Default value] Color(0, 0, 0)
	bool set_color(const Color& color) { return setValue("color", color); }
	//! The color value
 	//! [Default value] Color(0, 0, 0)
	Color get_color() const { return getColor("color"); }

	//! The texture
 	bool set_texture(const Plugin& texture) { return setValue("texture", texture); }
	//! The texture
 	bool set_texture(const AColor& texture) { return setValue("texture", texture); }
	//! The texture
 	Value get_texture() const { return getValue("texture"); }

	//! The texture multiplier (blends between the value and the texture)
 	//! [Default value] 1
	bool set_texture_multiplier(float val) { return setValue("texture_multiplier", val); }
	//! The texture multiplier (blends between the value and the texture)
 	//! [Default value] 1
	float get_texture_multiplier() const { return getFloat("texture_multiplier"); }

	//! true to invert the result
 	//! [Default value] false
	bool set_result_invert(bool val) { return setValue("result_invert", val); }
	//! true to invert the result
 	//! [Default value] false
	bool get_result_invert() const { return getBool("result_invert"); }

	//! A multiplier for the resulit (after inversion, if result_invert is true)
 	//! [Default value] 1
	bool set_result_multiplier(float val) { return setValue("result_multiplier", val); }
	//! A multiplier for the resulit (after inversion, if result_invert is true)
 	//! [Default value] 1
	float get_result_multiplier() const { return getFloat("result_multiplier"); }
};

class TexCombineColorLightMtl : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexCombineColorLightMtl"; }

	//! The color value
 	//! [Default value] Color(0, 0, 0)
	bool set_color(const Color& color) { return setValue("color", color); }
	//! The color value
 	//! [Default value] Color(0, 0, 0)
	Color get_color() const { return getColor("color"); }

	//! The texture
 	bool set_texture(const Plugin& texture) { return setValue("texture", texture); }
	//! The texture
 	bool set_texture(const AColor& texture) { return setValue("texture", texture); }
	//! The texture
 	Value get_texture() const { return getValue("texture"); }

	//! A multiplier for the final result
 	//! [Default value] 1
	bool set_result_multiplier(float val) { return setValue("result_multiplier", val); }
	//! A multiplier for the final result
 	//! [Default value] 1
	float get_result_multiplier() const { return getFloat("result_multiplier"); }
};

class TexCombineFloat : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexCombineFloat"; }

	//! The scalar value
 	//! [Default value] 0
	bool set_value(float val) { return setValue("value", val); }
	//! The scalar value
 	//! [Default value] 0
	float get_value() const { return getFloat("value"); }

	//! The texture
 	bool set_texture(const Plugin& texture) { return setValue("texture", texture); }
	//! The texture
 	bool set_texture(const AColor& texture) { return setValue("texture", texture); }
	//! The texture
 	Value get_texture() const { return getValue("texture"); }

	//! The texture multiplier (blends between the value and the texture)
 	//! [Default value] 1
	bool set_texture_multiplier(float val) { return setValue("texture_multiplier", val); }
	//! The texture multiplier (blends between the value and the texture)
 	//! [Default value] 1
	float get_texture_multiplier() const { return getFloat("texture_multiplier"); }

	//! true if the texture should be clamped to 1 from above (it is always clamped to 0 from below)
 	//! [Default value] false
	bool set_texture_clamp(bool val) { return setValue("texture_clamp", val); }
	//! true if the texture should be clamped to 1 from above (it is always clamped to 0 from below)
 	//! [Default value] false
	bool get_texture_clamp() const { return getBool("texture_clamp"); }

	//! A multiplier for the resulit (after inversion, if result_invert is true)
 	//! [Default value] 1
	bool set_result_multiplier(float val) { return setValue("result_multiplier", val); }
	//! A multiplier for the resulit (after inversion, if result_invert is true)
 	//! [Default value] 1
	float get_result_multiplier() const { return getFloat("result_multiplier"); }
};

class TexCompMax : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexCompMax"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! Left hand side texture.
 	bool set_sourceA(const Plugin& texture) { return setValue("sourceA", texture); }
	//! Left hand side texture.
 	bool set_sourceA(const AColor& texture) { return setValue("sourceA", texture); }
	//! Left hand side texture.
 	Value get_sourceA() const { return getValue("sourceA"); }

	//! Right hand side texture.
 	bool set_sourceB(const Plugin& texture) { return setValue("sourceB", texture); }
	//! Right hand side texture.
 	bool set_sourceB(const AColor& texture) { return setValue("sourceB", texture); }
	//! Right hand side texture.
 	Value get_sourceB() const { return getValue("sourceB"); }

	//! 0:Add, 1:Subtract, 2:Difference, 3:Multiply, 4:Divide, 5:Minimum, 6:Maximum
 	//! [UI Guides] enum=0:Add; 1:Subtract; 2:Difference; 3:Multiply; 4:Divide; 5:Minimum; 6:Maximum
 	//! [Default value] 0
	bool set_operator(int val) { return setValue("operator", val); }
	//! 0:Add, 1:Subtract, 2:Difference, 3:Multiply, 4:Divide, 5:Minimum, 6:Maximum
 	//! [UI Guides] enum=0:Add; 1:Subtract; 2:Difference; 3:Multiply; 4:Divide; 5:Minimum; 6:Maximum
 	//! [Default value] 0
	int get_operator() const { return getInt("operator"); }
};

class TexComposite : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexComposite"; }

	//! (description missing)
	bool set_color_a(const Plugin& texture) { return setValue("color_a", texture); }
	//! (description missing)
	bool set_color_a(const AColor& texture) { return setValue("color_a", texture); }
	//! (description missing)
	Value get_color_a() const { return getValue("color_a"); }

	//! (description missing)
	bool set_alpha_a(const Plugin& texturefloat) { return setValue("alpha_a", texturefloat); }
	//! (description missing)
	bool set_alpha_a(float texturefloat) { return setValue("alpha_a", texturefloat); }
	//! (description missing)
	Value get_alpha_a() const { return getValue("alpha_a"); }

	//! (description missing)
	bool set_color_b(const Plugin& texture) { return setValue("color_b", texture); }
	//! (description missing)
	bool set_color_b(const AColor& texture) { return setValue("color_b", texture); }
	//! (description missing)
	Value get_color_b() const { return getValue("color_b"); }

	//! (description missing)
	bool set_alpha_b(const Plugin& texturefloat) { return setValue("alpha_b", texturefloat); }
	//! (description missing)
	bool set_alpha_b(float texturefloat) { return setValue("alpha_b", texturefloat); }
	//! (description missing)
	Value get_alpha_b() const { return getValue("alpha_b"); }

	//! (description missing)
	//! [Default value] 0
	bool set_operation(int val) { return setValue("operation", val); }
	//! (description missing)
	//! [Default value] 0
	int get_operation() const { return getInt("operation"); }

	//! (description missing)
	bool set_factor(const Plugin& texturefloat) { return setValue("factor", texturefloat); }
	//! (description missing)
	bool set_factor(float texturefloat) { return setValue("factor", texturefloat); }
	//! (description missing)
	Value get_factor() const { return getValue("factor"); }
};

class TexCondition : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexCondition"; }

	//! The condition check: 0 - equal, 1 - not equal, 2 - greater than, 3 - greater or equal, 4 - less than, 5 - less or equal
 	//! [UI Guides] enum=0:Equal;1:Not equal;2:Greater than;3:Greater or equal;4:Less than;5:Less or equal
 	bool set_operation(const Plugin& textureint) { return setValue("operation", textureint); }
	//! The condition check: 0 - equal, 1 - not equal, 2 - greater than, 3 - greater or equal, 4 - less than, 5 - less or equal
 	//! [UI Guides] enum=0:Equal;1:Not equal;2:Greater than;3:Greater or equal;4:Less than;5:Less or equal
 	bool set_operation(int textureint) { return setValue("operation", textureint); }
	//! The condition check: 0 - equal, 1 - not equal, 2 - greater than, 3 - greater or equal, 4 - less than, 5 - less or equal
 	//! [UI Guides] enum=0:Equal;1:Not equal;2:Greater than;3:Greater or equal;4:Less than;5:Less or equal
 	Value get_operation() const { return getValue("operation"); }

	//! The first number to compare
 	bool set_op_a(const Plugin& texturefloat) { return setValue("op_a", texturefloat); }
	//! The first number to compare
 	bool set_op_a(float texturefloat) { return setValue("op_a", texturefloat); }
	//! The first number to compare
 	Value get_op_a() const { return getValue("op_a"); }

	//! The second number to compare
 	bool set_op_b(const Plugin& texturefloat) { return setValue("op_b", texturefloat); }
	//! The second number to compare
 	bool set_op_b(float texturefloat) { return setValue("op_b", texturefloat); }
	//! The second number to compare
 	Value get_op_b() const { return getValue("op_b"); }

	//! The color to return if the condition is true
 	bool set_result_true(const Plugin& texture) { return setValue("result_true", texture); }
	//! The color to return if the condition is true
 	bool set_result_true(const AColor& texture) { return setValue("result_true", texture); }
	//! The color to return if the condition is true
 	Value get_result_true() const { return getValue("result_true"); }

	//! The color to return if the condition is false
 	bool set_result_false(const Plugin& texture) { return setValue("result_false", texture); }
	//! The color to return if the condition is false
 	bool set_result_false(const AColor& texture) { return setValue("result_false", texture); }
	//! The color to return if the condition is false
 	Value get_result_false() const { return getValue("result_false"); }
};

class TexCondition2 : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexCondition2"; }

	//! 0 : Equal; 1 : Not equal; 2 : Greater than; 3 : Greater or equal; 4 : Less than; 5 : Less or equal
 	//! [UI Guides] enum=0:Equal; 1:Not equal; 2:Greater than; 3:Greater or equal; 4:Less than; 5:Less or equal
 	//! [Default value] 0
	bool set_operation(int val) { return setValue("operation", val); }
	//! 0 : Equal; 1 : Not equal; 2 : Greater than; 3 : Greater or equal; 4 : Less than; 5 : Less or equal
 	//! [UI Guides] enum=0:Equal; 1:Not equal; 2:Greater than; 3:Greater or equal; 4:Less than; 5:Less or equal
 	//! [Default value] 0
	int get_operation() const { return getInt("operation"); }

	//! (description missing)
	bool set_first_term(const Plugin& texturefloat) { return setValue("first_term", texturefloat); }
	//! (description missing)
	bool set_first_term(float texturefloat) { return setValue("first_term", texturefloat); }
	//! (description missing)
	Value get_first_term() const { return getValue("first_term"); }

	//! (description missing)
	bool set_second_term(const Plugin& texturefloat) { return setValue("second_term", texturefloat); }
	//! (description missing)
	bool set_second_term(float texturefloat) { return setValue("second_term", texturefloat); }
	//! (description missing)
	Value get_second_term() const { return getValue("second_term"); }

	//! (description missing)
	bool set_color_if_true(const Plugin& texture) { return setValue("color_if_true", texture); }
	//! (description missing)
	bool set_color_if_true(const AColor& texture) { return setValue("color_if_true", texture); }
	//! (description missing)
	Value get_color_if_true() const { return getValue("color_if_true"); }

	//! (description missing)
	bool set_color_if_false(const Plugin& texture) { return setValue("color_if_false", texture); }
	//! (description missing)
	bool set_color_if_false(const AColor& texture) { return setValue("color_if_false", texture); }
	//! (description missing)
	Value get_color_if_false() const { return getValue("color_if_false"); }
};

class TexCurvature : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexCurvature"; }

	//! Number of sample to take when sampling normals around intersection (subdivs*subdivs)
 	//! [UI Guides] minValue=1, maxValue=128
 	//! [Default value] 8
	bool set_subdivs(int val) { return setValue("subdivs", val); }
	//! Number of sample to take when sampling normals around intersection (subdivs*subdivs)
 	//! [UI Guides] minValue=1, maxValue=128
 	//! [Default value] 8
	int get_subdivs() const { return getInt("subdivs"); }

	//! Sampling radius
 	//! [UI Guides] minValue=0, maxValue=1000
 	bool set_sample_spread(const Plugin& texturefloat) { return setValue("sample_spread", texturefloat); }
	//! Sampling radius
 	//! [UI Guides] minValue=0, maxValue=1000
 	bool set_sample_spread(float texturefloat) { return setValue("sample_spread", texturefloat); }
	//! Sampling radius
 	//! [UI Guides] minValue=0, maxValue=1000
 	Value get_sample_spread() const { return getValue("sample_spread"); }

	//! Output color min value
 	//! [UI Guides] minValue=0, maxValue=1
 	//! [Default value] 0
	bool set_out_color_min(float val) { return setValue("out_color_min", val); }
	//! Output color min value
 	//! [UI Guides] minValue=0, maxValue=1
 	//! [Default value] 0
	float get_out_color_min() const { return getFloat("out_color_min"); }

	//! Output color max value
 	//! [UI Guides] minValue=0, maxValue=1
 	//! [Default value] 1
	bool set_out_color_max(float val) { return setValue("out_color_max", val); }
	//! Output color max value
 	//! [UI Guides] minValue=0, maxValue=1
 	//! [Default value] 1
	float get_out_color_max() const { return getFloat("out_color_max"); }

	//! The scale relative to which the curvature is computed
 	//! [UI Guides] minValue=0.000001, maxValue=1000000
 	//! [Default value] 1
	bool set_scale(float val) { return setValue("scale", val); }
	//! The scale relative to which the curvature is computed
 	//! [UI Guides] minValue=0.000001, maxValue=1000000
 	//! [Default value] 1
	float get_scale() const { return getFloat("scale"); }

	//! The maximum distance to search for intersections. Bigger values will decrease the performance, but may produce more correct result.
 	//! [UI Guides] quantityType=distance, minValue=0
 	//! [Default value] 5
	bool set_trace_distance(float val) { return setValue("trace_distance", val); }
	//! The maximum distance to search for intersections. Bigger values will decrease the performance, but may produce more correct result.
 	//! [UI Guides] quantityType=distance, minValue=0
 	//! [Default value] 5
	float get_trace_distance() const { return getFloat("trace_distance"); }

	//! Curvature values below this threshold will be ignored.
 	//! [UI Guides] minValue=0.0, maxValue=1.0
 	//! [Default value] 0
	bool set_threshold(float val) { return setValue("threshold", val); }
	//! Curvature values below this threshold will be ignored.
 	//! [UI Guides] minValue=0.0, maxValue=1.0
 	//! [Default value] 0
	float get_threshold() const { return getFloat("threshold"); }
};

class TexCustomBitmap : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexCustomBitmap"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! 0: not tiling; 1: tile in UV; 2: tile in U; 3: tile in V; 4: tile in UV, but not filter tiling;
 	//! [UI Guides] enum=0:No tiling;1:Tile in UV;2:Tile in U;3:Tile in V;4:Tile in UV, but no filter tiling
 	//! [Default value] 1
	bool set_tile(int val) { return setValue("tile", val); }
	//! 0: not tiling; 1: tile in UV; 2: tile in U; 3: tile in V; 4: tile in UV, but not filter tiling;
 	//! [UI Guides] enum=0:No tiling;1:Tile in UV;2:Tile in U;3:Tile in V;4:Tile in UV, but no filter tiling
 	//! [Default value] 1
	int get_tile() const { return getInt("tile"); }

	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	bool set_placement_type(int val) { return setValue("placement_type", val); }
	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	int get_placement_type() const { return getInt("placement_type"); }

	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_u(float val) { return setValue("u", val); }
	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_u() const { return getFloat("u"); }

	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_v(float val) { return setValue("v", val); }
	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_v() const { return getFloat("v"); }

	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_w(float val) { return setValue("w", val); }
	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_w() const { return getFloat("w"); }

	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_h(float val) { return setValue("h", val); }
	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_h() const { return getFloat("h"); }

	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	bool set_jitter(float val) { return setValue("jitter", val); }
	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	float get_jitter() const { return getFloat("jitter"); }

	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_u(bool val) { return setValue("tile_u", val); }
	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_u() const { return getBool("tile_u"); }

	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_v(bool val) { return setValue("tile_v", val); }
	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_v() const { return getBool("tile_v"); }

	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool set_uv_noise_on(bool val) { return setValue("uv_noise_on", val); }
	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool get_uv_noise_on() const { return getBool("uv_noise_on"); }

	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool set_uv_noise_animate(bool val) { return setValue("uv_noise_animate", val); }
	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool get_uv_noise_animate() const { return getBool("uv_noise_animate"); }

	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	bool set_uv_noise_amount(float val) { return setValue("uv_noise_amount", val); }
	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	float get_uv_noise_amount() const { return getFloat("uv_noise_amount"); }

	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	bool set_uv_noise_levels(float val) { return setValue("uv_noise_levels", val); }
	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	float get_uv_noise_levels() const { return getFloat("uv_noise_levels"); }

	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	bool set_uv_noise_size(float val) { return setValue("uv_noise_size", val); }
	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	float get_uv_noise_size() const { return getFloat("uv_noise_size"); }

	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	bool set_un_noise_phase(float val) { return setValue("un_noise_phase", val); }
	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	float get_un_noise_phase() const { return getFloat("un_noise_phase"); }
};

class TexDirt : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexDirt"; }

	//! [UI Guides] displayName=Unoccluded Color
 	bool set_white_color(const Plugin& texture) { return setValue("white_color", texture); }
	//! [UI Guides] displayName=Unoccluded Color
 	bool set_white_color(const AColor& texture) { return setValue("white_color", texture); }
	//! [UI Guides] displayName=Unoccluded Color
 	Value get_white_color() const { return getValue("white_color"); }

	//! [UI Guides] displayName=Occluded Color
 	bool set_black_color(const Plugin& texture) { return setValue("black_color", texture); }
	//! [UI Guides] displayName=Occluded Color
 	bool set_black_color(const AColor& texture) { return setValue("black_color", texture); }
	//! [UI Guides] displayName=Occluded Color
 	Value get_black_color() const { return getValue("black_color"); }

	//! [UI Guides] quantityType=distance, minValue=0
 	bool set_radius(const Plugin& texturefloat) { return setValue("radius", texturefloat); }
	//! [UI Guides] quantityType=distance, minValue=0
 	bool set_radius(float texturefloat) { return setValue("radius", texturefloat); }
	//! [UI Guides] quantityType=distance, minValue=0
 	Value get_radius() const { return getValue("radius"); }

	//! [UI Guides] enableIf: ?mode==0
 	//! [Default value] 0
	bool set_distribution(float val) { return setValue("distribution", val); }
	//! [UI Guides] enableIf: ?mode==0
 	//! [Default value] 0
	float get_distribution() const { return getFloat("distribution"); }

	//! [UI Guides] minValue=0
 	//! [Default value] 0
	bool set_falloff(float val) { return setValue("falloff", val); }
	//! [UI Guides] minValue=0
 	//! [Default value] 0
	float get_falloff() const { return getFloat("falloff"); }

	//! [UI Guides] minValue=1, maxValue=1000
 	//! [Default value] 8
	bool set_subdivs(int val) { return setValue("subdivs", val); }
	//! [UI Guides] minValue=1, maxValue=1000
 	//! [Default value] 8
	int get_subdivs() const { return getInt("subdivs"); }

	//! (description missing)
	//! [Default value] 0
	bool set_bias_x(float val) { return setValue("bias_x", val); }
	//! (description missing)
	//! [Default value] 0
	float get_bias_x() const { return getFloat("bias_x"); }

	//! (description missing)
	//! [Default value] 0
	bool set_bias_y(float val) { return setValue("bias_y", val); }
	//! (description missing)
	//! [Default value] 0
	float get_bias_y() const { return getFloat("bias_y"); }

	//! (description missing)
	//! [Default value] 0
	bool set_bias_z(float val) { return setValue("bias_z", val); }
	//! (description missing)
	//! [Default value] 0
	float get_bias_z() const { return getFloat("bias_z"); }

	//! (description missing)
	//! [Default value] true
	bool set_ignore_for_gi(bool val) { return setValue("ignore_for_gi", val); }
	//! (description missing)
	//! [Default value] true
	bool get_ignore_for_gi() const { return getBool("ignore_for_gi"); }

	//! (description missing)
	//! [Default value] false
	bool set_consider_same_object_only(bool val) { return setValue("consider_same_object_only", val); }
	//! (description missing)
	//! [Default value] false
	bool get_consider_same_object_only() const { return getBool("consider_same_object_only"); }

	//! (description missing)
	//! [Default value] false
	bool set_invert_normal(bool val) { return setValue("invert_normal", val); }
	//! (description missing)
	//! [Default value] false
	bool get_invert_normal() const { return getBool("invert_normal"); }

	//! if true, the occlusion on both sides of the surface will be calculated
 	//! [Default value] false
	bool set_double_sided(bool val) { return setValue("double_sided", val); }
	//! if true, the occlusion on both sides of the surface will be calculated
 	//! [Default value] false
	bool get_double_sided() const { return getBool("double_sided"); }

	//! (description missing)
	//! [Default value] false
	bool set_work_with_transparency(bool val) { return setValue("work_with_transparency", val); }
	//! (description missing)
	//! [Default value] false
	bool get_work_with_transparency() const { return getBool("work_with_transparency"); }

	//! (description missing)
	//! [Default value] false
	bool set_ignore_self_occlusion(bool val) { return setValue("ignore_self_occlusion", val); }
	//! (description missing)
	//! [Default value] false
	bool get_ignore_self_occlusion() const { return getBool("ignore_self_occlusion"); }

	//! Mode (0 - ambient occlusion; 1 - Phong reflection occlusion; 2 - Blinn reflection occlusion; 3 - Ward reflection occlusion)
 	//! [UI Guides] enum=0:Ambient occlusion; 1:Phong reflection occlusion; 2:Blinn reflection occlusion; 3:Ward reflection occlusion
 	//! [Default value] 0
	bool set_mode(int val) { return setValue("mode", val); }
	//! Mode (0 - ambient occlusion; 1 - Phong reflection occlusion; 2 - Blinn reflection occlusion; 3 - Ward reflection occlusion)
 	//! [UI Guides] enum=0:Ambient occlusion; 1:Phong reflection occlusion; 2:Blinn reflection occlusion; 3:Ward reflection occlusion
 	//! [Default value] 0
	int get_mode() const { return getInt("mode"); }

	//! true to compute the environment for unoccluded samples
 	//! [Default value] false
	bool set_environment_occlusion(bool val) { return setValue("environment_occlusion", val); }
	//! true to compute the environment for unoccluded samples
 	//! [Default value] false
	bool get_environment_occlusion() const { return getBool("environment_occlusion"); }

	//! true to add the occlusion to reflection render elements when mode>0
 	//! [UI Guides] enableIf: ?mode>0
 	//! [Default value] false
	bool set_affect_reflection_elements(bool val) { return setValue("affect_reflection_elements", val); }
	//! true to add the occlusion to reflection render elements when mode>0
 	//! [UI Guides] enableIf: ?mode>0
 	//! [Default value] false
	bool get_affect_reflection_elements() const { return getBool("affect_reflection_elements"); }

	//! A texture for the glossiness when mode>0
 	//! [UI Guides] minValue=0, maxValue=1, enableIf: ?mode>0
 	bool set_glossiness(const Plugin& texturefloat) { return setValue("glossiness", texturefloat); }
	//! A texture for the glossiness when mode>0
 	//! [UI Guides] minValue=0, maxValue=1, enableIf: ?mode>0
 	bool set_glossiness(float texturefloat) { return setValue("glossiness", texturefloat); }
	//! A texture for the glossiness when mode>0
 	//! [UI Guides] minValue=0, maxValue=1, enableIf: ?mode>0
 	Value get_glossiness() const { return getValue("glossiness"); }

	//! Allows you to disable the calculation of the dirt map for specific objects. Excluded objects will not be shaded by the dirt map.
 	//! [UI Guides] attributes=objectSet, startRollout=, displayName=Exclude
 	bool set_render_nodes(const ValueList& pluginList) { return setValue("render_nodes", pluginList); }
	//! Allows you to disable the calculation of the dirt map for specific objects. Excluded objects will not be shaded by the dirt map.
 	//! [UI Guides] attributes=objectSet, startRollout=, displayName=Exclude
 	ValueList get_render_nodes() const { return getValueList("render_nodes"); }

	//! When enabled reverses the meaning of the Exclude list - only objects in the list will be shaded by the dirt map.
 	//! [UI Guides] displayName=As Inclusive list
 	//! [Default value] false
	bool set_render_nodes_inclusive(bool val) { return setValue("render_nodes_inclusive", val); }
	//! When enabled reverses the meaning of the Exclude list - only objects in the list will be shaded by the dirt map.
 	//! [UI Guides] displayName=As Inclusive list
 	//! [Default value] false
	bool get_render_nodes_inclusive() const { return getBool("render_nodes_inclusive"); }

	//! True to return the unoccluded color texture, if the object is excluded. Otherwise return (0,0,0,0)
 	//! [Default value] true
	bool set_use_texture_for_excluded(bool val) { return setValue("use_texture_for_excluded", val); }
	//! True to return the unoccluded color texture, if the object is excluded. Otherwise return (0,0,0,0)
 	//! [Default value] true
	bool get_use_texture_for_excluded() const { return getBool("use_texture_for_excluded"); }

	//! Specifies a list of objects which will affect the calculation of the dirt map. Excluded objects will be considered "invisible" for the calculations of the dirt map.
 	//! [UI Guides] attributes=objectSet, startRollout=, displayName=Result Affect
 	bool set_affect_result_nodes(const ValueList& pluginList) { return setValue("affect_result_nodes", pluginList); }
	//! Specifies a list of objects which will affect the calculation of the dirt map. Excluded objects will be considered "invisible" for the calculations of the dirt map.
 	//! [UI Guides] attributes=objectSet, startRollout=, displayName=Result Affect
 	ValueList get_affect_result_nodes() const { return getValueList("affect_result_nodes"); }

	//! This option controls the meaning of the Result Affect option. When on the Result Affect is considered as an "Include list" and when off the the Result Affect is considered as "Exclude list"
 	//! [UI Guides] displayName=As Inclusive list
 	//! [Default value] false
	bool set_affect_result_nodes_inclusive(bool val) { return setValue("affect_result_nodes_inclusive", val); }
	//! This option controls the meaning of the Result Affect option. When on the Result Affect is considered as an "Include list" and when off the the Result Affect is considered as "Exclude list"
 	//! [UI Guides] displayName=As Inclusive list
 	//! [Default value] false
	bool get_affect_result_nodes_inclusive() const { return getBool("affect_result_nodes_inclusive"); }

	//! true to make the subdivs independent of the image sampler quality.
 	//! [UI Guides] startRollout=
 	//! [Default value] false
	bool set_subdivs_as_samples(bool val) { return setValue("subdivs_as_samples", val); }
	//! true to make the subdivs independent of the image sampler quality.
 	//! [UI Guides] startRollout=
 	//! [Default value] false
	bool get_subdivs_as_samples() const { return getBool("subdivs_as_samples"); }
};

class TexDisplacacementRestrict : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexDisplacacementRestrict"; }

	//! Input Float Texture
 	bool set_input_tex(const Plugin& texturefloat) { return setValue("input_tex", texturefloat); }
	//! Input Float Texture
 	bool set_input_tex(float texturefloat) { return setValue("input_tex", texturefloat); }
	//! Input Float Texture
 	Value get_input_tex() const { return getValue("input_tex"); }

	//! Specifies the maximum displacement value.  If an input value is higher than the Max Displacement value, it will be clipped
 	//! [Default value] -1
	bool set_max_displacement(float val) { return setValue("max_displacement", val); }
	//! Specifies the maximum displacement value.  If an input value is higher than the Max Displacement value, it will be clipped
 	//! [Default value] -1
	float get_max_displacement() const { return getFloat("max_displacement"); }
};

class TexDistance : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexDistance"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! Specifies a radius outside of which all points will be given the far color.
 	//! [UI Guides] quantityType=distance, minValue=0.0
 	bool set_distance(const Plugin& texturefloat) { return setValue("distance", texturefloat); }
	//! Specifies a radius outside of which all points will be given the far color.
 	//! [UI Guides] quantityType=distance, minValue=0.0
 	bool set_distance(float texturefloat) { return setValue("distance", texturefloat); }
	//! Specifies a radius outside of which all points will be given the far color.
 	//! [UI Guides] quantityType=distance, minValue=0.0
 	Value get_distance() const { return getValue("distance"); }

	//! The color returned by the texture for points that are at a distance greater than the radius parameter from the specified objects.
 	//! [UI Guides] displayName=Far color, enableIf: ?inside_separate=0; ?outside_separate=0; ?inside_solid=0; ?outside_solid=0
 	bool set_far_tex(const Plugin& texture) { return setValue("far_tex", texture); }
	//! The color returned by the texture for points that are at a distance greater than the radius parameter from the specified objects.
 	//! [UI Guides] displayName=Far color, enableIf: ?inside_separate=0; ?outside_separate=0; ?inside_solid=0; ?outside_solid=0
 	bool set_far_tex(const AColor& texture) { return setValue("far_tex", texture); }
	//! The color returned by the texture for points that are at a distance greater than the radius parameter from the specified objects.
 	//! [UI Guides] displayName=Far color, enableIf: ?inside_separate=0; ?outside_separate=0; ?inside_solid=0; ?outside_solid=0
 	Value get_far_tex() const { return getValue("far_tex"); }

	//! The color returned by the texture for points that are right at the edges of the specified object(s).For points that are outside or inside the objects, but not exactly next to the them, the color will be determined by blending between the near color and the far color and the radius will serve as a falloff radius.
 	//! [UI Guides] displayName=Near color, enableIf: ?inside_separate=0; ?outside_separate=0
 	bool set_near_tex(const Plugin& texture) { return setValue("near_tex", texture); }
	//! The color returned by the texture for points that are right at the edges of the specified object(s).For points that are outside or inside the objects, but not exactly next to the them, the color will be determined by blending between the near color and the far color and the radius will serve as a falloff radius.
 	//! [UI Guides] displayName=Near color, enableIf: ?inside_separate=0; ?outside_separate=0
 	bool set_near_tex(const AColor& texture) { return setValue("near_tex", texture); }
	//! The color returned by the texture for points that are right at the edges of the specified object(s).For points that are outside or inside the objects, but not exactly next to the them, the color will be determined by blending between the near color and the far color and the radius will serve as a falloff radius.
 	//! [UI Guides] displayName=Near color, enableIf: ?inside_separate=0; ?outside_separate=0
 	Value get_near_tex() const { return getValue("near_tex"); }

	//! When this option is enabled, the near color value will be overridden by the inside color value for points that are inside the specified geometry.
 	//! [UI Guides] startRollout=
 	//! [Default value] true
	bool set_inside_separate(bool val) { return setValue("inside_separate", val); }
	//! When this option is enabled, the near color value will be overridden by the inside color value for points that are inside the specified geometry.
 	//! [UI Guides] startRollout=
 	//! [Default value] true
	bool get_inside_separate() const { return getBool("inside_separate"); }

	//! When this option is enabled, all the points inside the specified geometry are given the inside color value and no blending is performed.
 	//! [UI Guides] enableIf: ?inside_separate=1
 	//! [Default value] false
	bool set_inside_solid(bool val) { return setValue("inside_solid", val); }
	//! When this option is enabled, all the points inside the specified geometry are given the inside color value and no blending is performed.
 	//! [UI Guides] enableIf: ?inside_separate=1
 	//! [Default value] false
	bool get_inside_solid() const { return getBool("inside_solid"); }

	//! The color returned by the texture for points that are right inside the specified object(s). For points that are inside the objects, but not exactly next to them the color will be determined by blending between the inside color and the far color and the radius will serve as a falloff radius.
 	//! [UI Guides] displayName=Inside color, enableIf: ?inside_separate=1
 	bool set_inside_tex(const Plugin& texture) { return setValue("inside_tex", texture); }
	//! The color returned by the texture for points that are right inside the specified object(s). For points that are inside the objects, but not exactly next to them the color will be determined by blending between the inside color and the far color and the radius will serve as a falloff radius.
 	//! [UI Guides] displayName=Inside color, enableIf: ?inside_separate=1
 	bool set_inside_tex(const AColor& texture) { return setValue("inside_tex", texture); }
	//! The color returned by the texture for points that are right inside the specified object(s). For points that are inside the objects, but not exactly next to them the color will be determined by blending between the inside color and the far color and the radius will serve as a falloff radius.
 	//! [UI Guides] displayName=Inside color, enableIf: ?inside_separate=1
 	Value get_inside_tex() const { return getValue("inside_tex"); }

	//! When this option is enabled, the near color value will be overridden by the outside color value for points that are outside the specified geometry.
 	//! [UI Guides] startRollout=
 	//! [Default value] false
	bool set_outside_separate(bool val) { return setValue("outside_separate", val); }
	//! When this option is enabled, the near color value will be overridden by the outside color value for points that are outside the specified geometry.
 	//! [UI Guides] startRollout=
 	//! [Default value] false
	bool get_outside_separate() const { return getBool("outside_separate"); }

	//! When this option is enabled, all the points outside the specified geometry are given the outside color value and no blending is performed.
 	//! [UI Guides] enableIf: ?outside_separate=1
 	//! [Default value] false
	bool set_outside_solid(bool val) { return setValue("outside_solid", val); }
	//! When this option is enabled, all the points outside the specified geometry are given the outside color value and no blending is performed.
 	//! [UI Guides] enableIf: ?outside_separate=1
 	//! [Default value] false
	bool get_outside_solid() const { return getBool("outside_solid"); }

	//! The color returned by the texture for points that are right outside the specified object(s). For points that are outside the objects, but not exactly next to them, the color will be determined by blending between the outside color and the far color and the radius will serve as a falloff radius.
 	//! [UI Guides] displayName=Outside color, enableIf: ?outside_separate=1
 	bool set_outside_tex(const Plugin& texture) { return setValue("outside_tex", texture); }
	//! The color returned by the texture for points that are right outside the specified object(s). For points that are outside the objects, but not exactly next to them, the color will be determined by blending between the outside color and the far color and the radius will serve as a falloff radius.
 	//! [UI Guides] displayName=Outside color, enableIf: ?outside_separate=1
 	bool set_outside_tex(const AColor& texture) { return setValue("outside_tex", texture); }
	//! The color returned by the texture for points that are right outside the specified object(s). For points that are outside the objects, but not exactly next to them, the color will be determined by blending between the outside color and the far color and the radius will serve as a falloff radius.
 	//! [UI Guides] displayName=Outside color, enableIf: ?outside_separate=1
 	Value get_outside_tex() const { return getValue("outside_tex"); }

	//! List of nodes to measure distance to.
 	//! [UI Guides] attributes=objectSet, startRollout=
 	bool set_objects(const ValueList& pluginList) { return setValue("objects", pluginList); }
	//! List of nodes to measure distance to.
 	//! [UI Guides] attributes=objectSet, startRollout=
 	ValueList get_objects() const { return getValueList("objects"); }
};

class TexDistanceBetween : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexDistanceBetween"; }

	//! (description missing)
	bool set_point1(const Plugin& texture) { return setValue("point1", texture); }
	//! (description missing)
	bool set_point1(const AColor& texture) { return setValue("point1", texture); }
	//! (description missing)
	Value get_point1() const { return getValue("point1"); }

	//! (description missing)
	bool set_point2(const Plugin& texture) { return setValue("point2", texture); }
	//! (description missing)
	bool set_point2(const AColor& texture) { return setValue("point2", texture); }
	//! (description missing)
	Value get_point2() const { return getValue("point2"); }

	//! (description missing)
	bool set_transform1(const Plugin& texturetransform) { return setValue("transform1", texturetransform); }
	//! (description missing)
	bool set_transform1(const Transform& texturetransform) { return setValue("transform1", texturetransform); }
	//! (description missing)
	Value get_transform1() const { return getValue("transform1"); }

	//! (description missing)
	bool set_transform2(const Plugin& texturetransform) { return setValue("transform2", texturetransform); }
	//! (description missing)
	bool set_transform2(const Transform& texturetransform) { return setValue("transform2", texturetransform); }
	//! (description missing)
	Value get_transform2() const { return getValue("transform2"); }
};

class TexDistanceToObject : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexDistanceToObject"; }

	//! This parameter references an object that implements the EXT_WORLD_MATRIX interface.  Given such an object, the texture result is the distance between that object and the point currently being sampled.  Distance is measured in world units.  In case of error, texture yields zero.
 	bool set_object(const Plugin& plugin) { return setValue("object", plugin); }
	//! This parameter references an object that implements the EXT_WORLD_MATRIX interface.  Given such an object, the texture result is the distance between that object and the point currently being sampled.  Distance is measured in world units.  In case of error, texture yields zero.
 	Plugin get_object() const { return getPlugin("object"); }
};

class TexEdges : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexEdges"; }

	//! [UI Guides] displayName=Edges color
 	bool set_edges_tex(const Plugin& texture) { return setValue("edges_tex", texture); }
	//! [UI Guides] displayName=Edges color
 	bool set_edges_tex(const AColor& texture) { return setValue("edges_tex", texture); }
	//! [UI Guides] displayName=Edges color
 	Value get_edges_tex() const { return getValue("edges_tex"); }

	//! [UI Guides] displayName=Background color
 	bool set_bg_tex(const Plugin& texture) { return setValue("bg_tex", texture); }
	//! [UI Guides] displayName=Background color
 	bool set_bg_tex(const AColor& texture) { return setValue("bg_tex", texture); }
	//! [UI Guides] displayName=Background color
 	Value get_bg_tex() const { return getValue("bg_tex"); }

	//! [UI Guides] displayName=Show hidden edges
 	//! [Default value] false
	bool set_show_hidden_edges(bool val) { return setValue("show_hidden_edges", val); }
	//! [UI Guides] displayName=Show hidden edges
 	//! [Default value] false
	bool get_show_hidden_edges() const { return getBool("show_hidden_edges"); }

	//! 0 : World units, 1 : Pixels
 	//! [UI Guides] displayName=Width type, enum=0:World units;1:Pixels;
 	//! [Default value] 0
	bool set_width_type(int val) { return setValue("width_type", val); }
	//! 0 : World units, 1 : Pixels
 	//! [UI Guides] displayName=Width type, enum=0:World units;1:Pixels;
 	//! [Default value] 0
	int get_width_type() const { return getInt("width_type"); }

	//! [UI Guides] displayName=Pixel width, enableIf: ?width_type=1, minValue=0
 	bool set_pixel_width(const Plugin& texturefloat) { return setValue("pixel_width", texturefloat); }
	//! [UI Guides] displayName=Pixel width, enableIf: ?width_type=1, minValue=0
 	bool set_pixel_width(float texturefloat) { return setValue("pixel_width", texturefloat); }
	//! [UI Guides] displayName=Pixel width, enableIf: ?width_type=1, minValue=0
 	Value get_pixel_width() const { return getValue("pixel_width"); }

	//! [UI Guides] displayName=World width, quantityType=distance, enableIf: ?width_type=0, minValue=0
 	bool set_world_width(const Plugin& texturefloat) { return setValue("world_width", texturefloat); }
	//! [UI Guides] displayName=World width, quantityType=distance, enableIf: ?width_type=0, minValue=0
 	bool set_world_width(float texturefloat) { return setValue("world_width", texturefloat); }
	//! [UI Guides] displayName=World width, quantityType=distance, enableIf: ?width_type=0, minValue=0
 	Value get_world_width() const { return getValue("world_width"); }

	//! [UI Guides] displayName=Show sub-triangles
 	//! [Default value] false
	bool set_show_subtriangles(bool val) { return setValue("show_subtriangles", val); }
	//! [UI Guides] displayName=Show sub-triangles
 	//! [Default value] false
	bool get_show_subtriangles() const { return getBool("show_subtriangles"); }

	//! true to use raytracing to compute the rounded corners and false to use static mesh analysis.
 	//! [Default value] true
	bool set_raytraced(bool val) { return setValue("raytraced", val); }
	//! true to use raytracing to compute the rounded corners and false to use static mesh analysis.
 	//! [Default value] true
	bool get_raytraced() const { return getBool("raytraced"); }

	//! true to consider only corners on the same object, and false to consider other intersecting objects.
 	//! [UI Guides] displayName=Consider same object only, enableIf: ?raytraced=1
 	//! [Default value] true
	bool set_raytraced_consider_same_object_only(bool val) { return setValue("raytraced_consider_same_object_only", val); }
	//! true to consider only corners on the same object, and false to consider other intersecting objects.
 	//! [UI Guides] displayName=Consider same object only, enableIf: ?raytraced=1
 	//! [Default value] true
	bool get_raytraced_consider_same_object_only() const { return getBool("raytraced_consider_same_object_only"); }

	//! Which corners to smooth: 0 - both convex and concave; 1 - convex only; 2 - concave only.
 	//! [UI Guides] displayName=Mode, enableIf: ?raytraced=1, enum=0:Convex and Concave;1:Convex only;2:Concave only
 	//! [Default value] 0
	bool set_raytraced_mode(int val) { return setValue("raytraced_mode", val); }
	//! Which corners to smooth: 0 - both convex and concave; 1 - convex only; 2 - concave only.
 	//! [UI Guides] displayName=Mode, enableIf: ?raytraced=1, enum=0:Convex and Concave;1:Convex only;2:Concave only
 	//! [Default value] 0
	int get_raytraced_mode() const { return getInt("raytraced_mode"); }
};

class TexFalloff : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexFalloff"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! First color
 	bool set_color1(const Plugin& texture) { return setValue("color1", texture); }
	//! First color
 	bool set_color1(const AColor& texture) { return setValue("color1", texture); }
	//! First color
 	Value get_color1() const { return getValue("color1"); }

	//! Second color
 	bool set_color2(const Plugin& texture) { return setValue("color2", texture); }
	//! Second color
 	bool set_color2(const AColor& texture) { return setValue("color2", texture); }
	//! Second color
 	Value get_color2() const { return getValue("color2"); }

	//! Type (0 - towards/away, 1 - perpendicular/parallel, 2 - Fresnel, 3 - shadow/light, 4 - distance blend)
 	//! [UI Guides] enum=0:Towards / away; 1:Perpendicular / parallel; 2:Fresnel; 3:Shadow / light; 4:Distance blend
 	//! [Default value] 0
	bool set_type(int val) { return setValue("type", val); }
	//! Type (0 - towards/away, 1 - perpendicular/parallel, 2 - Fresnel, 3 - shadow/light, 4 - distance blend)
 	//! [UI Guides] enum=0:Towards / away; 1:Perpendicular / parallel; 2:Fresnel; 3:Shadow / light; 4:Distance blend
 	//! [Default value] 0
	int get_type() const { return getInt("type"); }

	//! Direction type (0 - viewZ, 1 - viewX, 2 - viewY, 3 - explicit, 4 - localX, 5 - localY, 6 - localZ, 7 - worldX, 8 - worldY, 9 - worldZ)
 	//! [UI Guides] enum=0:View Z; 1:View X; 2:View Y; 3:Explicit; 4:Local X; 5:Local Y; 6:Local Z; 7:World X; 8:World Y; 9:World Z, enableIf: ?type=0; ?type=1; ?type=2
 	//! [Default value] 0
	bool set_direction_type(int val) { return setValue("direction_type", val); }
	//! Direction type (0 - viewZ, 1 - viewX, 2 - viewY, 3 - explicit, 4 - localX, 5 - localY, 6 - localZ, 7 - worldX, 8 - worldY, 9 - worldZ)
 	//! [UI Guides] enum=0:View Z; 1:View X; 2:View Y; 3:Explicit; 4:Local X; 5:Local Y; 6:Local Z; 7:World X; 8:World Y; 9:World Z, enableIf: ?type=0; ?type=1; ?type=2
 	//! [Default value] 0
	int get_direction_type() const { return getInt("direction_type"); }

	//! IOR for the Fresnel falloff type
 	//! [UI Guides] displayName=Fresnel IOR, enableIf: ?type=2, minValue=0, maxValue=20
 	//! [Default value] 1.6
	bool set_fresnel_ior(float val) { return setValue("fresnel_ior", val); }
	//! IOR for the Fresnel falloff type
 	//! [UI Guides] displayName=Fresnel IOR, enableIf: ?type=2, minValue=0, maxValue=20
 	//! [Default value] 1.6
	float get_fresnel_ior() const { return getFloat("fresnel_ior"); }

	//! Extrapolate for the distance blend falloff type
 	//! [UI Guides] displayName=Distance Extrapolate, enableIf: ?type=4
 	//! [Default value] false
	bool set_dist_extrapolate(bool val) { return setValue("dist_extrapolate", val); }
	//! Extrapolate for the distance blend falloff type
 	//! [UI Guides] displayName=Distance Extrapolate, enableIf: ?type=4
 	//! [Default value] false
	bool get_dist_extrapolate() const { return getBool("dist_extrapolate"); }

	//! Near distance for the distance blend falloff type
 	//! [UI Guides] displayName=Distance Near, enableIf: ?type=4, quantityType=distance, minValue=0
 	//! [Default value] 0
	bool set_dist_near(float val) { return setValue("dist_near", val); }
	//! Near distance for the distance blend falloff type
 	//! [UI Guides] displayName=Distance Near, enableIf: ?type=4, quantityType=distance, minValue=0
 	//! [Default value] 0
	float get_dist_near() const { return getFloat("dist_near"); }

	//! Far distance for the distance blend falloff type
 	//! [UI Guides] displayName=Distance Far, enableIf: ?type=4, quantityType=distance, minValue=0
 	//! [Default value] 100
	bool set_dist_far(float val) { return setValue("dist_far", val); }
	//! Far distance for the distance blend falloff type
 	//! [UI Guides] displayName=Distance Far, enableIf: ?type=4, quantityType=distance, minValue=0
 	//! [Default value] 100
	float get_dist_far() const { return getFloat("dist_far"); }

	//! Direction for the explicit direction type
 	//! [UI Guides] displayName=Explicit Direction, enableIf: ?type!=3,?type!=4,?direction_type=3
 	//! [Default value] Vector(0, 0, 1)
	bool set_explicit_dir(const Vector& vector) { return setValue("explicit_dir", vector); }
	//! Direction for the explicit direction type
 	//! [UI Guides] displayName=Explicit Direction, enableIf: ?type!=3,?type!=4,?direction_type=3
 	//! [Default value] Vector(0, 0, 1)
	Vector get_explicit_dir() const { return getVector("explicit_dir"); }

	//! (description missing)
	//! [Default value] false
	bool set_use_blend_input(bool val) { return setValue("use_blend_input", val); }
	//! (description missing)
	//! [Default value] false
	bool get_use_blend_input() const { return getBool("use_blend_input"); }

	//! If specified and use_blend_input is true, the final blending amount will be taken from this texture
 	//! [UI Guides] enableIf: ?use_blend_input=1
 	bool set_blend_input(const Plugin& texturefloat) { return setValue("blend_input", texturefloat); }
	//! If specified and use_blend_input is true, the final blending amount will be taken from this texture
 	//! [UI Guides] enableIf: ?use_blend_input=1
 	bool set_blend_input(float texturefloat) { return setValue("blend_input", texturefloat); }
	//! If specified and use_blend_input is true, the final blending amount will be taken from this texture
 	//! [UI Guides] enableIf: ?use_blend_input=1
 	Value get_blend_input() const { return getValue("blend_input"); }
};

class TexFalloffASGVIS : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexFalloffASGVIS"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! First color
 	bool set_color1(const Plugin& texture) { return setValue("color1", texture); }
	//! First color
 	bool set_color1(const AColor& texture) { return setValue("color1", texture); }
	//! First color
 	Value get_color1() const { return getValue("color1"); }

	//! Second color
 	bool set_color2(const Plugin& texture) { return setValue("color2", texture); }
	//! Second color
 	bool set_color2(const AColor& texture) { return setValue("color2", texture); }
	//! Second color
 	Value get_color2() const { return getValue("color2"); }

	//! Type (0 - towards/away, 1 - perpendicular/parallel, 2 - Fresnel, 3 - shadow/light, 4 - distance blend) 5 - Angular blend
 	//! [Default value] 0
	bool set_type(int val) { return setValue("type", val); }
	//! Type (0 - towards/away, 1 - perpendicular/parallel, 2 - Fresnel, 3 - shadow/light, 4 - distance blend) 5 - Angular blend
 	//! [Default value] 0
	int get_type() const { return getInt("type"); }

	//! Direction type (0 - viewZ, 1 - viewX, 2 - viewY, 3 - explicit, 4 - localX, 5 - localY, 6 - localZ, 7 - worldX, 8 - worldY, 9 - worldZ)
 	//! [Default value] 0
	bool set_direction_type(int val) { return setValue("direction_type", val); }
	//! Direction type (0 - viewZ, 1 - viewX, 2 - viewY, 3 - explicit, 4 - localX, 5 - localY, 6 - localZ, 7 - worldX, 8 - worldY, 9 - worldZ)
 	//! [Default value] 0
	int get_direction_type() const { return getInt("direction_type"); }

	//! IOR for the Fresnel falloff type
 	//! [Default value] 1.6
	bool set_fresnel_ior(float val) { return setValue("fresnel_ior", val); }
	//! IOR for the Fresnel falloff type
 	//! [Default value] 1.6
	float get_fresnel_ior() const { return getFloat("fresnel_ior"); }

	//! Extrapolate for the distance blend falloff type
 	//! [Default value] false
	bool set_dist_extrapolate(bool val) { return setValue("dist_extrapolate", val); }
	//! Extrapolate for the distance blend falloff type
 	//! [Default value] false
	bool get_dist_extrapolate() const { return getBool("dist_extrapolate"); }

	//! Near distance for the distance blend falloff type
 	//! [Default value] 0
	bool set_dist_near(float val) { return setValue("dist_near", val); }
	//! Near distance for the distance blend falloff type
 	//! [Default value] 0
	float get_dist_near() const { return getFloat("dist_near"); }

	//! Far distance for the distance blend falloff type
 	//! [Default value] 100
	bool set_dist_far(float val) { return setValue("dist_far", val); }
	//! Far distance for the distance blend falloff type
 	//! [Default value] 100
	float get_dist_far() const { return getFloat("dist_far"); }

	//! Direction for the explicit direction type
 	//! [Default value] Vector(0, 0, 1)
	bool set_explicit_dir(const Vector& vector) { return setValue("explicit_dir", vector); }
	//! Direction for the explicit direction type
 	//! [Default value] Vector(0, 0, 1)
	Vector get_explicit_dir() const { return getVector("explicit_dir"); }

	//! (description missing)
	//! [Default value] false
	bool set_use_blend_input(bool val) { return setValue("use_blend_input", val); }
	//! (description missing)
	//! [Default value] false
	bool get_use_blend_input() const { return getBool("use_blend_input"); }

	//! If specified and use_blend_input is true, the final blending amount will be taken from this texture
 	bool set_blend_input(const Plugin& texturefloat) { return setValue("blend_input", texturefloat); }
	//! If specified and use_blend_input is true, the final blending amount will be taken from this texture
 	bool set_blend_input(float texturefloat) { return setValue("blend_input", texturefloat); }
	//! If specified and use_blend_input is true, the final blending amount will be taken from this texture
 	Value get_blend_input() const { return getValue("blend_input"); }

	//! Start angle, in degrees, for blend
 	//! [Default value] 30
	bool set_angle_start(float val) { return setValue("angle_start", val); }
	//! Start angle, in degrees, for blend
 	//! [Default value] 30
	float get_angle_start() const { return getFloat("angle_start"); }

	//! Stop angle, in degrees, for blend
 	//! [Default value] 75
	bool set_angle_stop(float val) { return setValue("angle_stop", val); }
	//! Stop angle, in degrees, for blend
 	//! [Default value] 75
	float get_angle_stop() const { return getFloat("angle_stop"); }
};

class TexFloat : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexFloat"; }

	//! input
 	bool set_input(const Plugin& texturefloat) { return setValue("input", texturefloat); }
	//! input
 	bool set_input(float texturefloat) { return setValue("input", texturefloat); }
	//! input
 	Value get_input() const { return getValue("input"); }
};

class TexFloatOp : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexFloatOp"; }

	//! The first number
 	bool set_float_a(const Plugin& texturefloat) { return setValue("float_a", texturefloat); }
	//! The first number
 	bool set_float_a(float texturefloat) { return setValue("float_a", texturefloat); }
	//! The first number
 	Value get_float_a() const { return getValue("float_a"); }

	//! The second number
 	bool set_float_b(const Plugin& texturefloat) { return setValue("float_b", texturefloat); }
	//! The second number
 	bool set_float_b(float texturefloat) { return setValue("float_b", texturefloat); }
	//! The second number
 	Value get_float_b() const { return getValue("float_b"); }

	//! Determines what output to use when no output parameter is specified. Useful if the type of the operation needs to be animatable.
 	//! [UI Guides] enum=0:Product;1:Ratio;2:Sum;3:Difference;4:Power;5:Sin;6:Cos;7:Min;8:Max;9:abs;10:ceil;11:exp;12:floor;13:log;14:log10;15:sqrt;16:fmod;17:average;18:tan;19:asin;20:acos;21:atan;22:atan2
 	//! [Default value] 2
	bool set_mode(int val) { return setValue("mode", val); }
	//! Determines what output to use when no output parameter is specified. Useful if the type of the operation needs to be animatable.
 	//! [UI Guides] enum=0:Product;1:Ratio;2:Sum;3:Difference;4:Power;5:Sin;6:Cos;7:Min;8:Max;9:abs;10:ceil;11:exp;12:floor;13:log;14:log10;15:sqrt;16:fmod;17:average;18:tan;19:asin;20:acos;21:atan;22:atan2
 	//! [Default value] 2
	int get_mode() const { return getInt("mode"); }
};

class TexFloatPerVertexHairSampler : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexFloatPerVertexHairSampler"; }

	//! Colors for each vertex the hair. Each values should match a vertex from the hair geometry.
 	//! [Default value] 0
	bool set_vertex_values(const FloatList& floatList) { return setValue("vertex_values", floatList); }
	//! Colors for each vertex the hair. Each values should match a vertex from the hair geometry.
 	//! [Default value] 0
	bool set_vertex_values(const float* floats, size_t count) { return setArray("vertex_values", floats, count); }
	//! Colors for each vertex the hair. Each values should match a vertex from the hair geometry.
 	//! [Default value] 0
	template<size_t count> bool set_vertex_values(const float (&floats)[count]) { return setArray("vertex_values", floats, count); }
	//! Colors for each vertex the hair. Each values should match a vertex from the hair geometry.
 	//! [Default value] 0
	FloatList get_vertex_values() const { return getFloatList("vertex_values"); }
};

class TexFloatToColor : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexFloatToColor"; }

	//! The float value
 	bool set_input(const Plugin& texturefloat) { return setValue("input", texturefloat); }
	//! The float value
 	bool set_input(float texturefloat) { return setValue("input", texturefloat); }
	//! The float value
 	Value get_input() const { return getValue("input"); }
};

class TexForestColor : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexForestColor"; }

	//! maps for shading the forest simulation
 	bool set_maps_list(const ValueList& textureList) { return setValue("maps_list", textureList); }
	//! maps for shading the forest simulation
 	ValueList get_maps_list() const { return getValueList("maps_list"); }

	//! probabilities for the used color maps
 	//! [Default value] 100
	bool set_probabilities_list(const FloatList& floatList) { return setValue("probabilities_list", floatList); }
	//! probabilities for the used color maps
 	//! [Default value] 100
	bool set_probabilities_list(const float* floats, size_t count) { return setArray("probabilities_list", floats, count); }
	//! probabilities for the used color maps
 	//! [Default value] 100
	template<size_t count> bool set_probabilities_list(const float (&floats)[count]) { return setArray("probabilities_list", floats, count); }
	//! probabilities for the used color maps
 	//! [Default value] 100
	FloatList get_probabilities_list() const { return getFloatList("probabilities_list"); }

	//! The default texture for the forest color plugin
 	bool set_default_color(const Plugin& texture) { return setValue("default_color", texture); }
	//! The default texture for the forest color plugin
 	bool set_default_color(const AColor& texture) { return setValue("default_color", texture); }
	//! The default texture for the forest color plugin
 	Value get_default_color() const { return getValue("default_color"); }

	//! Mode(0 - Item; 1 - Element
 	//! [UI Guides] enum = 0:Shade whole instance with one map; 1:Shade instnace's sub polygon elements with different maps
 	//! [Default value] 0
	bool set_map_id_mode(int val) { return setValue("map_id_mode", val); }
	//! Mode(0 - Item; 1 - Element
 	//! [UI Guides] enum = 0:Shade whole instance with one map; 1:Shade instnace's sub polygon elements with different maps
 	//! [Default value] 0
	int get_map_id_mode() const { return getInt("map_id_mode"); }

	//! The tint map
 	bool set_tint_color(const Plugin& texture) { return setValue("tint_color", texture); }
	//! The tint map
 	bool set_tint_color(const AColor& texture) { return setValue("tint_color", texture); }
	//! The tint map
 	Value get_tint_color() const { return getValue("tint_color"); }

	//! Override global tint option for the forest
 	//! [Default value] 0
	bool set_tint_override(int val) { return setValue("tint_override", val); }
	//! Override global tint option for the forest
 	//! [Default value] 0
	int get_tint_override() const { return getInt("tint_override"); }

	//! Tint minimum %
 	//! [Default value] 0
	bool set_tint_min(float val) { return setValue("tint_min", val); }
	//! Tint minimum %
 	//! [Default value] 0
	float get_tint_min() const { return getFloat("tint_min"); }

	//! Tint maximum %
 	//! [Default value] 0
	bool set_tint_max(float val) { return setValue("tint_max", val); }
	//! Tint maximum %
 	//! [Default value] 0
	float get_tint_max() const { return getFloat("tint_max"); }

	//! Mode(0 - Gradient; 1 - Texture
 	//! [UI Guides] enum = 0:Calculate Tint using gradient map; 1:Claculate Tint using texture
 	//! [Default value] 0
	bool set_tint_mode(int val) { return setValue("tint_mode", val); }
	//! Mode(0 - Gradient; 1 - Texture
 	//! [UI Guides] enum = 0:Calculate Tint using gradient map; 1:Claculate Tint using texture
 	//! [Default value] 0
	int get_tint_mode() const { return getInt("tint_mode"); }

	//! Mode(0 - Random; 1 - Texture
 	//! [UI Guides] enum = 0:Calculate Tint for random point of the Tint texture; 1:Claculate Tint using the whole Tint texture
 	//! [Default value] 0
	bool set_tint_map_mode(int val) { return setValue("tint_map_mode", val); }
	//! Mode(0 - Random; 1 - Texture
 	//! [UI Guides] enum = 0:Calculate Tint for random point of the Tint texture; 1:Claculate Tint using the whole Tint texture
 	//! [Default value] 0
	int get_tint_map_mode() const { return getInt("tint_map_mode"); }

	//! Mode(0 - Normal; 1 - Color; 2 - Additive; 3 - Average; 4 - Multiply;
 	//! [UI Guides] enum = 0:Use only the tint color; 1:RGBtoHSV blending Tint Color and Map Color; 2:Add Tint Color and Map Color; 3:Average addition of Tint Color and Map Color; 4:Multiply Tint Color and Map Color
 	//! [Default value] 0
	bool set_tint_mix_mode(int val) { return setValue("tint_mix_mode", val); }
	//! Mode(0 - Normal; 1 - Color; 2 - Additive; 3 - Average; 4 - Multiply;
 	//! [UI Guides] enum = 0:Use only the tint color; 1:RGBtoHSV blending Tint Color and Map Color; 2:Add Tint Color and Map Color; 3:Average addition of Tint Color and Map Color; 4:Multiply Tint Color and Map Color
 	//! [Default value] 0
	int get_tint_mix_mode() const { return getInt("tint_mix_mode"); }

	//! Shows how to apply Tint between simulation Items and elements
 	//! [Default value] 0
	bool set_tint_variation(float val) { return setValue("tint_variation", val); }
	//! Shows how to apply Tint between simulation Items and elements
 	//! [Default value] 0
	float get_tint_variation() const { return getFloat("tint_variation"); }

	//! The first color for tint gradient
 	//! [Default value] Color(0, 0, 0)
	bool set_tint_color_1(const Color& color) { return setValue("tint_color_1", color); }
	//! The first color for tint gradient
 	//! [Default value] Color(0, 0, 0)
	Color get_tint_color_1() const { return getColor("tint_color_1"); }

	//! The second color for tint gradient
 	//! [Default value] Color(0, 0, 0)
	bool set_tint_color_2(const Color& color) { return setValue("tint_color_2", color); }
	//! The second color for tint gradient
 	//! [Default value] Color(0, 0, 0)
	Color get_tint_color_2() const { return getColor("tint_color_2"); }

	//! Map channel index of the source GeomStaticMesh where the information for the Forest Color texture is stored
 	//! [Default value] -1
	bool set_source_geom_map_channel(int val) { return setValue("source_geom_map_channel", val); }
	//! Map channel index of the source GeomStaticMesh where the information for the Forest Color texture is stored
 	//! [Default value] -1
	int get_source_geom_map_channel() const { return getInt("source_geom_map_channel"); }
};

class TexFresnel : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexFresnel"; }

	//! Fresnel ior.
 	//! [UI Guides] minValue=0, maxValue=100
 	//! [Default value] 1.55
	bool set_fresnel_ior(float val) { return setValue("fresnel_ior", val); }
	//! Fresnel ior.
 	//! [UI Guides] minValue=0, maxValue=100
 	//! [Default value] 1.55
	float get_fresnel_ior() const { return getFloat("fresnel_ior"); }

	//! Refraction ior of the underlying surface; this is ignored if the surface has a volume shader (the volume IOR is used).
 	//! [UI Guides] minValue=0, maxValue=100
 	//! [Default value] 1.55
	bool set_refract_ior(float val) { return setValue("refract_ior", val); }
	//! Refraction ior of the underlying surface; this is ignored if the surface has a volume shader (the volume IOR is used).
 	//! [UI Guides] minValue=0, maxValue=100
 	//! [Default value] 1.55
	float get_refract_ior() const { return getFloat("refract_ior"); }

	//! Refraction (front) color
 	//! [UI Guides] displayName=Front Color
 	bool set_white_color(const Plugin& texture) { return setValue("white_color", texture); }
	//! Refraction (front) color
 	//! [UI Guides] displayName=Front Color
 	bool set_white_color(const AColor& texture) { return setValue("white_color", texture); }
	//! Refraction (front) color
 	//! [UI Guides] displayName=Front Color
 	Value get_white_color() const { return getValue("white_color"); }

	//! Reflection (side) color
 	//! [UI Guides] displayName=Side Color
 	bool set_black_color(const Plugin& texture) { return setValue("black_color", texture); }
	//! Reflection (side) color
 	//! [UI Guides] displayName=Side Color
 	bool set_black_color(const AColor& texture) { return setValue("black_color", texture); }
	//! Reflection (side) color
 	//! [UI Guides] displayName=Side Color
 	Value get_black_color() const { return getValue("black_color"); }

	//! (description missing)
	bool set_fresnel_ior_tex(const Plugin& texturefloat) { return setValue("fresnel_ior_tex", texturefloat); }
	//! (description missing)
	bool set_fresnel_ior_tex(float texturefloat) { return setValue("fresnel_ior_tex", texturefloat); }
	//! (description missing)
	Value get_fresnel_ior_tex() const { return getValue("fresnel_ior_tex"); }

	//! (description missing)
	bool set_refract_ior_tex(const Plugin& texturefloat) { return setValue("refract_ior_tex", texturefloat); }
	//! (description missing)
	bool set_refract_ior_tex(float texturefloat) { return setValue("refract_ior_tex", texturefloat); }
	//! (description missing)
	Value get_refract_ior_tex() const { return getValue("refract_ior_tex"); }

	//! Flag that allows the texture to contribute to the Fresnel IOR render element.
 	//! [Default value] false
	bool set_contribute_to_fresnel_ior_re(bool val) { return setValue("contribute_to_fresnel_ior_re", val); }
	//! Flag that allows the texture to contribute to the Fresnel IOR render element.
 	//! [Default value] false
	bool get_contribute_to_fresnel_ior_re() const { return getBool("contribute_to_fresnel_ior_re"); }
};

class TexFresnelASGVIS : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexFresnelASGVIS"; }

	//! Fresnel ior.
 	//! [Default value] 1.55
	bool set_fresnel_ior(float val) { return setValue("fresnel_ior", val); }
	//! Fresnel ior.
 	//! [Default value] 1.55
	float get_fresnel_ior() const { return getFloat("fresnel_ior"); }

	//! Fresnel ior texture
 	bool set_fresnel_ior_tex(const Plugin& texturefloat) { return setValue("fresnel_ior_tex", texturefloat); }
	//! Fresnel ior texture
 	bool set_fresnel_ior_tex(float texturefloat) { return setValue("fresnel_ior_tex", texturefloat); }
	//! Fresnel ior texture
 	Value get_fresnel_ior_tex() const { return getValue("fresnel_ior_tex"); }

	//! Fresnel ior texture mult
 	//! [Default value] 1
	bool set_fresnel_ior_tex_mult(float val) { return setValue("fresnel_ior_tex_mult", val); }
	//! Fresnel ior texture mult
 	//! [Default value] 1
	float get_fresnel_ior_tex_mult() const { return getFloat("fresnel_ior_tex_mult"); }

	//! Refraction ior of the underlying surface; this is ignored if the surface has a volume shader (the volume IOR is used).
 	//! [Default value] 1.55
	bool set_refract_ior(float val) { return setValue("refract_ior", val); }
	//! Refraction ior of the underlying surface; this is ignored if the surface has a volume shader (the volume IOR is used).
 	//! [Default value] 1.55
	float get_refract_ior() const { return getFloat("refract_ior"); }

	//! Refraction ior texture for the underlying surface; this is ignored if the surface has a volume shader (the volume IOR is used).
 	bool set_refract_ior_tex(const Plugin& texturefloat) { return setValue("refract_ior_tex", texturefloat); }
	//! Refraction ior texture for the underlying surface; this is ignored if the surface has a volume shader (the volume IOR is used).
 	bool set_refract_ior_tex(float texturefloat) { return setValue("refract_ior_tex", texturefloat); }
	//! Refraction ior texture for the underlying surface; this is ignored if the surface has a volume shader (the volume IOR is used).
 	Value get_refract_ior_tex() const { return getValue("refract_ior_tex"); }

	//! Refract ior texture mult
 	//! [Default value] 1
	bool set_refract_ior_tex_mult(float val) { return setValue("refract_ior_tex_mult", val); }
	//! Refract ior texture mult
 	//! [Default value] 1
	float get_refract_ior_tex_mult() const { return getFloat("refract_ior_tex_mult"); }

	//! Refraction color
 	//! [Default value] AColor(1, 1, 1, 1)
	bool set_white_color(const AColor& acolor) { return setValue("white_color", acolor); }
	//! Refraction color
 	//! [Default value] AColor(1, 1, 1, 1)
	AColor get_white_color() const { return getAColor("white_color"); }

	//! Refraction color texture
 	bool set_white_color_tex(const Plugin& texture) { return setValue("white_color_tex", texture); }
	//! Refraction color texture
 	bool set_white_color_tex(const AColor& texture) { return setValue("white_color_tex", texture); }
	//! Refraction color texture
 	Value get_white_color_tex() const { return getValue("white_color_tex"); }

	//! Refraction color texture mult
 	//! [Default value] 1
	bool set_white_color_tex_mult(float val) { return setValue("white_color_tex_mult", val); }
	//! Refraction color texture mult
 	//! [Default value] 1
	float get_white_color_tex_mult() const { return getFloat("white_color_tex_mult"); }

	//! Reflection color
 	//! [Default value] AColor(0, 0, 0, 1)
	bool set_black_color(const AColor& acolor) { return setValue("black_color", acolor); }
	//! Reflection color
 	//! [Default value] AColor(0, 0, 0, 1)
	AColor get_black_color() const { return getAColor("black_color"); }

	//! Reflection color texture
 	bool set_black_color_tex(const Plugin& texture) { return setValue("black_color_tex", texture); }
	//! Reflection color texture
 	bool set_black_color_tex(const AColor& texture) { return setValue("black_color_tex", texture); }
	//! Reflection color texture
 	Value get_black_color_tex() const { return getValue("black_color_tex"); }

	//! Reflection color texture mult
 	//! [Default value] 1
	bool set_black_color_tex_mult(float val) { return setValue("black_color_tex_mult", val); }
	//! Reflection color texture mult
 	//! [Default value] 1
	float get_black_color_tex_mult() const { return getFloat("black_color_tex_mult"); }

	//! In some cases we wanted to use the multiplier as an exponent ( final_color = pow( color, tex_mult ) ) - in other cases we just want a scalar multiplier ( final_color = color * tex_mult )
 	//! [Default value] false
	bool set_use_multiplier_as_exponent(bool val) { return setValue("use_multiplier_as_exponent", val); }
	//! In some cases we wanted to use the multiplier as an exponent ( final_color = pow( color, tex_mult ) ) - in other cases we just want a scalar multiplier ( final_color = color * tex_mult )
 	//! [Default value] false
	bool get_use_multiplier_as_exponent() const { return getBool("use_multiplier_as_exponent"); }

	//! Process the fresnel texture in the old way.
 	//! [Default value] false
	bool set_old_way(bool val) { return setValue("old_way", val); }
	//! Process the fresnel texture in the old way.
 	//! [Default value] false
	bool get_old_way() const { return getBool("old_way"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }
};

class TexGradRamp : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexGradRamp"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	bool set_placement_type(int val) { return setValue("placement_type", val); }
	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	int get_placement_type() const { return getInt("placement_type"); }

	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_u(float val) { return setValue("u", val); }
	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_u() const { return getFloat("u"); }

	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_v(float val) { return setValue("v", val); }
	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_v() const { return getFloat("v"); }

	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_w(float val) { return setValue("w", val); }
	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_w() const { return getFloat("w"); }

	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_h(float val) { return setValue("h", val); }
	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_h() const { return getFloat("h"); }

	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	bool set_jitter(float val) { return setValue("jitter", val); }
	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	float get_jitter() const { return getFloat("jitter"); }

	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_u(bool val) { return setValue("tile_u", val); }
	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_u() const { return getBool("tile_u"); }

	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_v(bool val) { return setValue("tile_v", val); }
	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_v() const { return getBool("tile_v"); }

	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool set_uv_noise_on(bool val) { return setValue("uv_noise_on", val); }
	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool get_uv_noise_on() const { return getBool("uv_noise_on"); }

	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool set_uv_noise_animate(bool val) { return setValue("uv_noise_animate", val); }
	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool get_uv_noise_animate() const { return getBool("uv_noise_animate"); }

	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	bool set_uv_noise_amount(float val) { return setValue("uv_noise_amount", val); }
	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	float get_uv_noise_amount() const { return getFloat("uv_noise_amount"); }

	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	bool set_uv_noise_levels(float val) { return setValue("uv_noise_levels", val); }
	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	float get_uv_noise_levels() const { return getFloat("uv_noise_levels"); }

	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	bool set_uv_noise_size(float val) { return setValue("uv_noise_size", val); }
	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	float get_uv_noise_size() const { return getFloat("uv_noise_size"); }

	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	bool set_un_noise_phase(float val) { return setValue("un_noise_phase", val); }
	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	float get_un_noise_phase() const { return getFloat("un_noise_phase"); }

	//! positions of the given colors
 	//! [Default value] 0.5
	bool set_positions(const FloatList& floatList) { return setValue("positions", floatList); }
	//! positions of the given colors
 	//! [Default value] 0.5
	bool set_positions(const float* floats, size_t count) { return setArray("positions", floats, count); }
	//! positions of the given colors
 	//! [Default value] 0.5
	template<size_t count> bool set_positions(const float (&floats)[count]) { return setArray("positions", floats, count); }
	//! positions of the given colors
 	//! [Default value] 0.5
	FloatList get_positions() const { return getFloatList("positions"); }

	//! the given colors
 	bool set_colors(const ValueList& textureList) { return setValue("colors", textureList); }
	//! the given colors
 	ValueList get_colors() const { return getValueList("colors"); }

	//! the texture used for mapped gradient ramp
 	bool set_texture_map(const Plugin& texture) { return setValue("texture_map", texture); }
	//! the texture used for mapped gradient ramp
 	bool set_texture_map(const AColor& texture) { return setValue("texture_map", texture); }
	//! the texture used for mapped gradient ramp
 	Value get_texture_map() const { return getValue("texture_map"); }

	//! 0:four corner, 1:box, 2:diagonal, 3:lighting, 4:linear, 5:mapped, 6:normal, 7:pong, 8:radial, 9:spiral, 10:sweep, 11:tartan
 	//! [UI Guides] enum=0:Four corner; 1:Box; 2:Diagonal; 3:Lighting; 4:Linear; 5:Mapped; 6:Normal; 7:Pong; 8:Radial; 9:Spiral; 10:Sweep; 11:Tartan
 	//! [Default value] 0
	bool set_gradient_type(int val) { return setValue("gradient_type", val); }
	//! 0:four corner, 1:box, 2:diagonal, 3:lighting, 4:linear, 5:mapped, 6:normal, 7:pong, 8:radial, 9:spiral, 10:sweep, 11:tartan
 	//! [UI Guides] enum=0:Four corner; 1:Box; 2:Diagonal; 3:Lighting; 4:Linear; 5:Mapped; 6:Normal; 7:Pong; 8:Radial; 9:Spiral; 10:Sweep; 11:Tartan
 	//! [Default value] 0
	int get_gradient_type() const { return getInt("gradient_type"); }

	//! 0:none, 1:linear, 2:expUp, 3:expDown, 4:smooth, 5:bump, 6:spike
 	//! [UI Guides] enum=0:None; 1:Linear; 2:ExpUp; 3:ExpDown; 4:Smooth; 5:Bump; 6:Spike
 	//! [Default value] 1
	bool set_interpolation(const IntList& intList) { return setValue("interpolation", intList); }
	//! 0:none, 1:linear, 2:expUp, 3:expDown, 4:smooth, 5:bump, 6:spike
 	//! [UI Guides] enum=0:None; 1:Linear; 2:ExpUp; 3:ExpDown; 4:Smooth; 5:Bump; 6:Spike
 	//! [Default value] 1
	bool set_interpolation(const int* ints, size_t count) { return setArray("interpolation", ints, count); }
	//! 0:none, 1:linear, 2:expUp, 3:expDown, 4:smooth, 5:bump, 6:spike
 	//! [UI Guides] enum=0:None; 1:Linear; 2:ExpUp; 3:ExpDown; 4:Smooth; 5:Bump; 6:Spike
 	//! [Default value] 1
	template<size_t count> bool set_interpolation(const int (&ints)[count]) { return setArray("interpolation", ints, count); }
	//! 0:none, 1:linear, 2:expUp, 3:expDown, 4:smooth, 5:bump, 6:spike
 	//! [UI Guides] enum=0:None; 1:Linear; 2:ExpUp; 3:ExpDown; 4:Smooth; 5:Bump; 6:Spike
 	//! [Default value] 1
	IntList get_interpolation() const { return getIntList("interpolation"); }

	//! Distortion noise amount
 	//! [Default value] 0
	bool set_noise_amount(float val) { return setValue("noise_amount", val); }
	//! Distortion noise amount
 	//! [Default value] 0
	float get_noise_amount() const { return getFloat("noise_amount"); }

	//! 0:regular, 1:fractal, 2:turbulence
 	//! [UI Guides] enum=0:Regular; 1:Fractal; 2:Turbulence
 	//! [Default value] 0
	bool set_noise_type(int val) { return setValue("noise_type", val); }
	//! 0:regular, 1:fractal, 2:turbulence
 	//! [UI Guides] enum=0:Regular; 1:Fractal; 2:Turbulence
 	//! [Default value] 0
	int get_noise_type() const { return getInt("noise_type"); }

	//! default = 1.0
 	//! [Default value] 1
	bool set_noise_size(float val) { return setValue("noise_size", val); }
	//! default = 1.0
 	//! [Default value] 1
	float get_noise_size() const { return getFloat("noise_size"); }

	//! default = 0.0
 	//! [Default value] 0
	bool set_noise_phase(float val) { return setValue("noise_phase", val); }
	//! default = 0.0
 	//! [Default value] 0
	float get_noise_phase() const { return getFloat("noise_phase"); }

	//! default = 4.0
 	//! [Default value] 4
	bool set_noise_levels(float val) { return setValue("noise_levels", val); }
	//! default = 4.0
 	//! [Default value] 4
	float get_noise_levels() const { return getFloat("noise_levels"); }

	//! default = 0.0f
 	//! [Default value] 0
	bool set_noise_treshold_low(float val) { return setValue("noise_treshold_low", val); }
	//! default = 0.0f
 	//! [Default value] 0
	float get_noise_treshold_low() const { return getFloat("noise_treshold_low"); }

	//! default = 1.0f
 	//! [Default value] 1
	bool set_noise_treshold_high(float val) { return setValue("noise_treshold_high", val); }
	//! default = 1.0f
 	//! [Default value] 1
	float get_noise_treshold_high() const { return getFloat("noise_treshold_high"); }

	//! default = 0.0f
 	//! [Default value] 0
	bool set_noise_smooth(float val) { return setValue("noise_smooth", val); }
	//! default = 0.0f
 	//! [Default value] 0
	float get_noise_smooth() const { return getFloat("noise_smooth"); }

	//! When 'gradient_type' is 'position' this will specify the position of color in gradient to return
 	bool set_gradient_position(const Plugin& texturefloat) { return setValue("gradient_position", texturefloat); }
	//! When 'gradient_type' is 'position' this will specify the position of color in gradient to return
 	bool set_gradient_position(float texturefloat) { return setValue("gradient_position", texturefloat); }
	//! When 'gradient_type' is 'position' this will specify the position of color in gradient to return
 	Value get_gradient_position() const { return getValue("gradient_position"); }
};

class TexGradient : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexGradient"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	bool set_placement_type(int val) { return setValue("placement_type", val); }
	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	int get_placement_type() const { return getInt("placement_type"); }

	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_u(float val) { return setValue("u", val); }
	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_u() const { return getFloat("u"); }

	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_v(float val) { return setValue("v", val); }
	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_v() const { return getFloat("v"); }

	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_w(float val) { return setValue("w", val); }
	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_w() const { return getFloat("w"); }

	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_h(float val) { return setValue("h", val); }
	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_h() const { return getFloat("h"); }

	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	bool set_jitter(float val) { return setValue("jitter", val); }
	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	float get_jitter() const { return getFloat("jitter"); }

	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_u(bool val) { return setValue("tile_u", val); }
	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_u() const { return getBool("tile_u"); }

	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_v(bool val) { return setValue("tile_v", val); }
	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_v() const { return getBool("tile_v"); }

	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool set_uv_noise_on(bool val) { return setValue("uv_noise_on", val); }
	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool get_uv_noise_on() const { return getBool("uv_noise_on"); }

	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool set_uv_noise_animate(bool val) { return setValue("uv_noise_animate", val); }
	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool get_uv_noise_animate() const { return getBool("uv_noise_animate"); }

	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	bool set_uv_noise_amount(float val) { return setValue("uv_noise_amount", val); }
	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	float get_uv_noise_amount() const { return getFloat("uv_noise_amount"); }

	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	bool set_uv_noise_levels(float val) { return setValue("uv_noise_levels", val); }
	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	float get_uv_noise_levels() const { return getFloat("uv_noise_levels"); }

	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	bool set_uv_noise_size(float val) { return setValue("uv_noise_size", val); }
	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	float get_uv_noise_size() const { return getFloat("uv_noise_size"); }

	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	bool set_un_noise_phase(float val) { return setValue("un_noise_phase", val); }
	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	float get_un_noise_phase() const { return getFloat("un_noise_phase"); }

	//! First color
 	bool set_color1(const Plugin& texture) { return setValue("color1", texture); }
	//! First color
 	bool set_color1(const AColor& texture) { return setValue("color1", texture); }
	//! First color
 	Value get_color1() const { return getValue("color1"); }

	//! Middle color
 	bool set_color2(const Plugin& texture) { return setValue("color2", texture); }
	//! Middle color
 	bool set_color2(const AColor& texture) { return setValue("color2", texture); }
	//! Middle color
 	Value get_color2() const { return getValue("color2"); }

	//! End color
 	bool set_color3(const Plugin& texture) { return setValue("color3", texture); }
	//! End color
 	bool set_color3(const AColor& texture) { return setValue("color3", texture); }
	//! End color
 	Value get_color3() const { return getValue("color3"); }

	//! This affects bump mapping, following a peculiarity in the 3ds Max implementation
 	//! [Default value] false
	bool set_has_textures(bool val) { return setValue("has_textures", val); }
	//! This affects bump mapping, following a peculiarity in the 3ds Max implementation
 	//! [Default value] false
	bool get_has_textures() const { return getBool("has_textures"); }

	//! Middle color position
 	//! [Default value] 0.5
	bool set_middle(float val) { return setValue("middle", val); }
	//! Middle color position
 	//! [Default value] 0.5
	float get_middle() const { return getFloat("middle"); }

	//! Gradient type (0 - linear, 1 - radial)
 	//! [UI Guides] enum=0:Linear; 1:Radial
 	//! [Default value] 0
	bool set_type(int val) { return setValue("type", val); }
	//! Gradient type (0 - linear, 1 - radial)
 	//! [UI Guides] enum=0:Linear; 1:Radial
 	//! [Default value] 0
	int get_type() const { return getInt("type"); }

	//! Noise amount
 	//! [Default value] 0
	bool set_noise_amount(float val) { return setValue("noise_amount", val); }
	//! Noise amount
 	//! [Default value] 0
	float get_noise_amount() const { return getFloat("noise_amount"); }

	//! Noise size
 	//! [Default value] 1
	bool set_noise_size(float val) { return setValue("noise_size", val); }
	//! Noise size
 	//! [Default value] 1
	float get_noise_size() const { return getFloat("noise_size"); }

	//! Noise type (0 - regular, 1 - fractal, 2 - turbulence)
 	//! [UI Guides] enum=0:Regular; 1:Fractal; 2:Turbulence
 	//! [Default value] 0
	bool set_noise_type(int val) { return setValue("noise_type", val); }
	//! Noise type (0 - regular, 1 - fractal, 2 - turbulence)
 	//! [UI Guides] enum=0:Regular; 1:Fractal; 2:Turbulence
 	//! [Default value] 0
	int get_noise_type() const { return getInt("noise_type"); }

	//! Noise iterations
 	//! [Default value] 4
	bool set_noise_iterations(float val) { return setValue("noise_iterations", val); }
	//! Noise iterations
 	//! [Default value] 4
	float get_noise_iterations() const { return getFloat("noise_iterations"); }

	//! Noise phase
 	//! [Default value] 0
	bool set_noise_phase(float val) { return setValue("noise_phase", val); }
	//! Noise phase
 	//! [Default value] 0
	float get_noise_phase() const { return getFloat("noise_phase"); }

	//! Noise low threshold
 	//! [Default value] 0
	bool set_noise_low(float val) { return setValue("noise_low", val); }
	//! Noise low threshold
 	//! [Default value] 0
	float get_noise_low() const { return getFloat("noise_low"); }

	//! Noise high threshold
 	//! [Default value] 1
	bool set_noise_high(float val) { return setValue("noise_high", val); }
	//! Noise high threshold
 	//! [Default value] 1
	float get_noise_high() const { return getFloat("noise_high"); }

	//! Threshold smoothing
 	//! [Default value] 0
	bool set_noise_smooth(float val) { return setValue("noise_smooth", val); }
	//! Threshold smoothing
 	//! [Default value] 0
	float get_noise_smooth() const { return getFloat("noise_smooth"); }
};

class TexGranite : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexGranite"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! (description missing)
	//! [Default value] false
	bool set_use_3d_mapping(bool val) { return setValue("use_3d_mapping", val); }
	//! (description missing)
	//! [Default value] false
	bool get_use_3d_mapping() const { return getBool("use_3d_mapping"); }

	//! (description missing)
	//! [Default value] true
	bool set_wrap(bool val) { return setValue("wrap", val); }
	//! (description missing)
	//! [Default value] true
	bool get_wrap() const { return getBool("wrap"); }

	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	bool set_placement_type(int val) { return setValue("placement_type", val); }
	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	int get_placement_type() const { return getInt("placement_type"); }

	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_u(float val) { return setValue("u", val); }
	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_u() const { return getFloat("u"); }

	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_v(float val) { return setValue("v", val); }
	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_v() const { return getFloat("v"); }

	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_w(float val) { return setValue("w", val); }
	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_w() const { return getFloat("w"); }

	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_h(float val) { return setValue("h", val); }
	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_h() const { return getFloat("h"); }

	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	bool set_jitter(float val) { return setValue("jitter", val); }
	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	float get_jitter() const { return getFloat("jitter"); }

	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_u(bool val) { return setValue("tile_u", val); }
	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_u() const { return getBool("tile_u"); }

	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_v(bool val) { return setValue("tile_v", val); }
	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_v() const { return getBool("tile_v"); }

	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool set_uv_noise_on(bool val) { return setValue("uv_noise_on", val); }
	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool get_uv_noise_on() const { return getBool("uv_noise_on"); }

	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool set_uv_noise_animate(bool val) { return setValue("uv_noise_animate", val); }
	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool get_uv_noise_animate() const { return getBool("uv_noise_animate"); }

	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	bool set_uv_noise_amount(float val) { return setValue("uv_noise_amount", val); }
	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	float get_uv_noise_amount() const { return getFloat("uv_noise_amount"); }

	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	bool set_uv_noise_levels(float val) { return setValue("uv_noise_levels", val); }
	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	float get_uv_noise_levels() const { return getFloat("uv_noise_levels"); }

	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	bool set_uv_noise_size(float val) { return setValue("uv_noise_size", val); }
	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	float get_uv_noise_size() const { return getFloat("uv_noise_size"); }

	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	bool set_un_noise_phase(float val) { return setValue("un_noise_phase", val); }
	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	float get_un_noise_phase() const { return getFloat("un_noise_phase"); }

	//! [UI Guides] displayName=Color 1
 	bool set_color1_tex(const Plugin& texture) { return setValue("color1_tex", texture); }
	//! [UI Guides] displayName=Color 1
 	bool set_color1_tex(const AColor& texture) { return setValue("color1_tex", texture); }
	//! [UI Guides] displayName=Color 1
 	Value get_color1_tex() const { return getValue("color1_tex"); }

	//! [UI Guides] displayName=Color 2
 	bool set_color2_tex(const Plugin& texture) { return setValue("color2_tex", texture); }
	//! [UI Guides] displayName=Color 2
 	bool set_color2_tex(const AColor& texture) { return setValue("color2_tex", texture); }
	//! [UI Guides] displayName=Color 2
 	Value get_color2_tex() const { return getValue("color2_tex"); }

	//! [UI Guides] displayName=Color 3
 	bool set_color3_tex(const Plugin& texture) { return setValue("color3_tex", texture); }
	//! [UI Guides] displayName=Color 3
 	bool set_color3_tex(const AColor& texture) { return setValue("color3_tex", texture); }
	//! [UI Guides] displayName=Color 3
 	Value get_color3_tex() const { return getValue("color3_tex"); }

	//! [UI Guides] displayName=Filler Color
 	bool set_filler_color_tex(const Plugin& texture) { return setValue("filler_color_tex", texture); }
	//! [UI Guides] displayName=Filler Color
 	bool set_filler_color_tex(const AColor& texture) { return setValue("filler_color_tex", texture); }
	//! [UI Guides] displayName=Filler Color
 	Value get_filler_color_tex() const { return getValue("filler_color_tex"); }

	//! [UI Guides] minValue=0
 	bool set_cell_size(const Plugin& texturefloat) { return setValue("cell_size", texturefloat); }
	//! [UI Guides] minValue=0
 	bool set_cell_size(float texturefloat) { return setValue("cell_size", texturefloat); }
	//! [UI Guides] minValue=0
 	Value get_cell_size() const { return getValue("cell_size"); }

	//! [UI Guides] minValue=0
 	bool set_density(const Plugin& texturefloat) { return setValue("density", texturefloat); }
	//! [UI Guides] minValue=0
 	bool set_density(float texturefloat) { return setValue("density", texturefloat); }
	//! [UI Guides] minValue=0
 	Value get_density() const { return getValue("density"); }

	//! [UI Guides] minValue=0, maxValue=1
 	bool set_mix_ratio(const Plugin& texturefloat) { return setValue("mix_ratio", texturefloat); }
	//! [UI Guides] minValue=0, maxValue=1
 	bool set_mix_ratio(float texturefloat) { return setValue("mix_ratio", texturefloat); }
	//! [UI Guides] minValue=0, maxValue=1
 	Value get_mix_ratio() const { return getValue("mix_ratio"); }

	//! [UI Guides] displayName=Spottiness, minValue=0
 	bool set_spottyness(const Plugin& texturefloat) { return setValue("spottyness", texturefloat); }
	//! [UI Guides] displayName=Spottiness, minValue=0
 	bool set_spottyness(float texturefloat) { return setValue("spottyness", texturefloat); }
	//! [UI Guides] displayName=Spottiness, minValue=0
 	Value get_spottyness() const { return getValue("spottyness"); }

	//! [UI Guides] minValue=0
 	bool set_randomness(const Plugin& texturefloat) { return setValue("randomness", texturefloat); }
	//! [UI Guides] minValue=0
 	bool set_randomness(float texturefloat) { return setValue("randomness", texturefloat); }
	//! [UI Guides] minValue=0
 	Value get_randomness() const { return getValue("randomness"); }

	//! [UI Guides] minValue=0
 	bool set_threshold(const Plugin& texturefloat) { return setValue("threshold", texturefloat); }
	//! [UI Guides] minValue=0
 	bool set_threshold(float texturefloat) { return setValue("threshold", texturefloat); }
	//! [UI Guides] minValue=0
 	Value get_threshold() const { return getValue("threshold"); }

	//! (description missing)
	//! [Default value] true
	bool set_creases(bool val) { return setValue("creases", val); }
	//! (description missing)
	//! [Default value] true
	bool get_creases() const { return getBool("creases"); }
};

class TexGrid : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexGrid"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	bool set_placement_type(int val) { return setValue("placement_type", val); }
	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	int get_placement_type() const { return getInt("placement_type"); }

	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_u(float val) { return setValue("u", val); }
	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_u() const { return getFloat("u"); }

	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_v(float val) { return setValue("v", val); }
	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_v() const { return getFloat("v"); }

	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_w(float val) { return setValue("w", val); }
	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_w() const { return getFloat("w"); }

	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_h(float val) { return setValue("h", val); }
	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_h() const { return getFloat("h"); }

	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	bool set_jitter(float val) { return setValue("jitter", val); }
	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	float get_jitter() const { return getFloat("jitter"); }

	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_u(bool val) { return setValue("tile_u", val); }
	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_u() const { return getBool("tile_u"); }

	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_v(bool val) { return setValue("tile_v", val); }
	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_v() const { return getBool("tile_v"); }

	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool set_uv_noise_on(bool val) { return setValue("uv_noise_on", val); }
	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool get_uv_noise_on() const { return getBool("uv_noise_on"); }

	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool set_uv_noise_animate(bool val) { return setValue("uv_noise_animate", val); }
	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool get_uv_noise_animate() const { return getBool("uv_noise_animate"); }

	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	bool set_uv_noise_amount(float val) { return setValue("uv_noise_amount", val); }
	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	float get_uv_noise_amount() const { return getFloat("uv_noise_amount"); }

	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	bool set_uv_noise_levels(float val) { return setValue("uv_noise_levels", val); }
	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	float get_uv_noise_levels() const { return getFloat("uv_noise_levels"); }

	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	bool set_uv_noise_size(float val) { return setValue("uv_noise_size", val); }
	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	float get_uv_noise_size() const { return getFloat("uv_noise_size"); }

	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	bool set_un_noise_phase(float val) { return setValue("un_noise_phase", val); }
	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	float get_un_noise_phase() const { return getFloat("un_noise_phase"); }

	//! (description missing)
	bool set_line_color(const Plugin& texture) { return setValue("line_color", texture); }
	//! (description missing)
	bool set_line_color(const AColor& texture) { return setValue("line_color", texture); }
	//! (description missing)
	Value get_line_color() const { return getValue("line_color"); }

	//! (description missing)
	bool set_fill_color(const Plugin& texture) { return setValue("fill_color", texture); }
	//! (description missing)
	bool set_fill_color(const AColor& texture) { return setValue("fill_color", texture); }
	//! (description missing)
	Value get_fill_color() const { return getValue("fill_color"); }

	//! U Width
 	//! [UI Guides] minValue=0, maxValue=1
 	bool set_u_width(const Plugin& texturefloat) { return setValue("u_width", texturefloat); }
	//! U Width
 	//! [UI Guides] minValue=0, maxValue=1
 	bool set_u_width(float texturefloat) { return setValue("u_width", texturefloat); }
	//! U Width
 	//! [UI Guides] minValue=0, maxValue=1
 	Value get_u_width() const { return getValue("u_width"); }

	//! V Width
 	//! [UI Guides] minValue=0, maxValue=1
 	bool set_v_width(const Plugin& texturefloat) { return setValue("v_width", texturefloat); }
	//! V Width
 	//! [UI Guides] minValue=0, maxValue=1
 	bool set_v_width(float texturefloat) { return setValue("v_width", texturefloat); }
	//! V Width
 	//! [UI Guides] minValue=0, maxValue=1
 	Value get_v_width() const { return getValue("v_width"); }
};

class TexHSVToRGB : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexHSVToRGB"; }

	//! (description missing)
	bool set_inHsv(const Plugin& texture) { return setValue("inHsv", texture); }
	//! (description missing)
	bool set_inHsv(const AColor& texture) { return setValue("inHsv", texture); }
	//! (description missing)
	Value get_inHsv() const { return getValue("inHsv"); }
};

class TexHairRootSampler : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexHairRootSampler"; }

	//! The colors at the root of each hair strand.
 	//! [Default value] Color(0, 0, 0)
	bool set_root_values(const ColorList& colorList) { return setValue("root_values", colorList); }
	//! The colors at the root of each hair strand.
 	//! [Default value] Color(0, 0, 0)
	bool set_root_values(const Color* colors, size_t count) { return setArray("root_values", colors, count); }
	//! The colors at the root of each hair strand.
 	//! [Default value] Color(0, 0, 0)
	template<size_t count> bool set_root_values(const Color (&colors)[count]) { return setArray("root_values", colors, count); }
	//! The colors at the root of each hair strand.
 	//! [Default value] Color(0, 0, 0)
	ColorList get_root_values() const { return getColorList("root_values"); }
};

class TexHairSampler : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexHairSampler"; }
};

class TexICC : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexICC"; }

	//! (description missing)
	bool set_basemap(const Plugin& texture) { return setValue("basemap", texture); }
	//! (description missing)
	bool set_basemap(const AColor& texture) { return setValue("basemap", texture); }
	//! (description missing)
	Value get_basemap() const { return getValue("basemap"); }

	//! [UI Guides] fileAsset=icc
 	bool set_file(const char* str) { return setValue("file", str); }
	//! [UI Guides] fileAsset=icc
 	bool set_file(const std::string& str) { return setValue("file", str); }
	//! [UI Guides] fileAsset=icc
 	std::string get_file() const { return getString("file"); }

	//! (description missing)
	//! [Default value] 0
	bool set_render_intent(int val) { return setValue("render_intent", val); }
	//! (description missing)
	//! [Default value] 0
	int get_render_intent() const { return getInt("render_intent"); }

	//! (description missing)
	//! [Default value] false
	bool set_blackpoint(bool val) { return setValue("blackpoint", val); }
	//! (description missing)
	//! [Default value] false
	bool get_blackpoint() const { return getBool("blackpoint"); }
};

class TexIDIntegerMap : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexIDIntegerMap"; }

	//! This texture will suply the IDs
 	bool set_id_tex(const Plugin& textureint) { return setValue("id_tex", textureint); }
	//! This texture will suply the IDs
 	bool set_id_tex(int textureint) { return setValue("id_tex", textureint); }
	//! This texture will suply the IDs
 	Value get_id_tex() const { return getValue("id_tex"); }

	//! List of ids
 	//! [Default value] 0
	bool set_ids(const IntList& intList) { return setValue("ids", intList); }
	//! List of ids
 	//! [Default value] 0
	bool set_ids(const int* ints, size_t count) { return setArray("ids", ints, count); }
	//! List of ids
 	//! [Default value] 0
	template<size_t count> bool set_ids(const int (&ints)[count]) { return setArray("ids", ints, count); }
	//! List of ids
 	//! [Default value] 0
	IntList get_ids() const { return getIntList("ids"); }

	//! List of values for each id in "ids"
 	//! [Default value] 0
	bool set_values(const IntList& intList) { return setValue("values", intList); }
	//! List of values for each id in "ids"
 	//! [Default value] 0
	bool set_values(const int* ints, size_t count) { return setArray("values", ints, count); }
	//! List of values for each id in "ids"
 	//! [Default value] 0
	template<size_t count> bool set_values(const int (&ints)[count]) { return setArray("values", ints, count); }
	//! List of values for each id in "ids"
 	//! [Default value] 0
	IntList get_values() const { return getIntList("values"); }

	//! Default value. Returned when no matching id is found.
 	//! [Default value] 0
	bool set_default(int val) { return setValue("default", val); }
	//! Default value. Returned when no matching id is found.
 	//! [Default value] 0
	int get_default() const { return getInt("default"); }

	//! The number of samples of the underlying geometry plugin. If not supplied, global nsamples will be used
 	//! [Default value] 0
	bool set_nsamples(int val) { return setValue("nsamples", val); }
	//! The number of samples of the underlying geometry plugin. If not supplied, global nsamples will be used
 	//! [Default value] 0
	int get_nsamples() const { return getInt("nsamples"); }
};

class TexInt : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexInt"; }

	//! input
 	bool set_input(const Plugin& textureint) { return setValue("input", textureint); }
	//! input
 	bool set_input(int textureint) { return setValue("input", textureint); }
	//! input
 	Value get_input() const { return getValue("input"); }
};

class TexIntToFloat : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexIntToFloat"; }

	//! The integer value
 	bool set_input(const Plugin& textureint) { return setValue("input", textureint); }
	//! The integer value
 	bool set_input(int textureint) { return setValue("input", textureint); }
	//! The integer value
 	Value get_input() const { return getValue("input"); }
};

class TexInterpLinear : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexInterpLinear"; }

	//! scalar value to be remapped
 	bool set_input(const Plugin& texturefloat) { return setValue("input", texturefloat); }
	//! scalar value to be remapped
 	bool set_input(float texturefloat) { return setValue("input", texturefloat); }
	//! scalar value to be remapped
 	Value get_input() const { return getValue("input"); }

	//! start of the current range of values
 	bool set_oldrange_min(const Plugin& texturefloat) { return setValue("oldrange_min", texturefloat); }
	//! start of the current range of values
 	bool set_oldrange_min(float texturefloat) { return setValue("oldrange_min", texturefloat); }
	//! start of the current range of values
 	Value get_oldrange_min() const { return getValue("oldrange_min"); }

	//! end of the current range of values
 	bool set_oldrange_max(const Plugin& texturefloat) { return setValue("oldrange_max", texturefloat); }
	//! end of the current range of values
 	bool set_oldrange_max(float texturefloat) { return setValue("oldrange_max", texturefloat); }
	//! end of the current range of values
 	Value get_oldrange_max() const { return getValue("oldrange_max"); }

	//! start of the new range of values
 	bool set_newrange_min(const Plugin& texturefloat) { return setValue("newrange_min", texturefloat); }
	//! start of the new range of values
 	bool set_newrange_min(float texturefloat) { return setValue("newrange_min", texturefloat); }
	//! start of the new range of values
 	Value get_newrange_min() const { return getValue("newrange_min"); }

	//! end of the new range of values
 	bool set_newrange_max(const Plugin& texturefloat) { return setValue("newrange_max", texturefloat); }
	//! end of the new range of values
 	bool set_newrange_max(float texturefloat) { return setValue("newrange_max", texturefloat); }
	//! end of the new range of values
 	Value get_newrange_max() const { return getValue("newrange_max"); }
};

class TexInvert : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexInvert"; }

	//! The texture to be inverted
 	bool set_texture(const Plugin& texture) { return setValue("texture", texture); }
	//! The texture to be inverted
 	bool set_texture(const AColor& texture) { return setValue("texture", texture); }
	//! The texture to be inverted
 	Value get_texture() const { return getValue("texture"); }

	//! (description missing)
	//! [Default value] false
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! (description missing)
	//! [Default value] false
	bool get_invert_alpha() const { return getBool("invert_alpha"); }
};

class TexInvertFloat : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexInvertFloat"; }

	//! The texture to be inverted
 	bool set_texture(const Plugin& texturefloat) { return setValue("texture", texturefloat); }
	//! The texture to be inverted
 	bool set_texture(float texturefloat) { return setValue("texture", texturefloat); }
	//! The texture to be inverted
 	Value get_texture() const { return getValue("texture"); }
};

class TexLayered : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexLayered"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! (description missing)
	bool set_textures(const ValueList& pluginList) { return setValue("textures", pluginList); }
	//! (description missing)
	ValueList get_textures() const { return getValueList("textures"); }

	//! 0:None, 1:Over, 2:In, 3:Out, 4:Add, 5:Subtract, 6:Multiply, 7:Difference, 8:Lighten, 9:Darken, 10:Saturate, 11:Desaturate, 12:Illuminate
 	//! [UI Guides] enum=0:None; 1:Over; 2:In; 3:Out; 4:Add; 5:Subtract; 6:Multiply; 7:Difference; 8:Lighten; 9:Darken; 10:Saturate; 11:Desaturate; 12:Illuminate
 	//! [Default value] 1
	bool set_blend_modes(const IntList& intList) { return setValue("blend_modes", intList); }
	//! 0:None, 1:Over, 2:In, 3:Out, 4:Add, 5:Subtract, 6:Multiply, 7:Difference, 8:Lighten, 9:Darken, 10:Saturate, 11:Desaturate, 12:Illuminate
 	//! [UI Guides] enum=0:None; 1:Over; 2:In; 3:Out; 4:Add; 5:Subtract; 6:Multiply; 7:Difference; 8:Lighten; 9:Darken; 10:Saturate; 11:Desaturate; 12:Illuminate
 	//! [Default value] 1
	bool set_blend_modes(const int* ints, size_t count) { return setArray("blend_modes", ints, count); }
	//! 0:None, 1:Over, 2:In, 3:Out, 4:Add, 5:Subtract, 6:Multiply, 7:Difference, 8:Lighten, 9:Darken, 10:Saturate, 11:Desaturate, 12:Illuminate
 	//! [UI Guides] enum=0:None; 1:Over; 2:In; 3:Out; 4:Add; 5:Subtract; 6:Multiply; 7:Difference; 8:Lighten; 9:Darken; 10:Saturate; 11:Desaturate; 12:Illuminate
 	//! [Default value] 1
	template<size_t count> bool set_blend_modes(const int (&ints)[count]) { return setArray("blend_modes", ints, count); }
	//! 0:None, 1:Over, 2:In, 3:Out, 4:Add, 5:Subtract, 6:Multiply, 7:Difference, 8:Lighten, 9:Darken, 10:Saturate, 11:Desaturate, 12:Illuminate
 	//! [UI Guides] enum=0:None; 1:Over; 2:In; 3:Out; 4:Add; 5:Subtract; 6:Multiply; 7:Difference; 8:Lighten; 9:Darken; 10:Saturate; 11:Desaturate; 12:Illuminate
 	//! [Default value] 1
	IntList get_blend_modes() const { return getIntList("blend_modes"); }

	//! (description missing)
	bool set_alpha(const Plugin& texturefloat) { return setValue("alpha", texturefloat); }
	//! (description missing)
	bool set_alpha(float texturefloat) { return setValue("alpha", texturefloat); }
	//! (description missing)
	Value get_alpha() const { return getValue("alpha"); }
};

class TexLayeredMax : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexLayeredMax"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! (description missing)
	bool set_textures(const ValueList& pluginList) { return setValue("textures", pluginList); }
	//! (description missing)
	ValueList get_textures() const { return getValueList("textures"); }

	//! (description missing)
	bool set_masks(const ValueList& pluginList) { return setValue("masks", pluginList); }
	//! (description missing)
	ValueList get_masks() const { return getValueList("masks"); }

	//! 0:Normal, 1:Average, 2:Add, 3:Subtract, 4:Darken, 5:Multiply, 6:Color burn, 7:Linear burn, 8:Lighten, 9:Screen, 10:Color Dodge, 11:Linear Dodge, 12:Spotlite, 13:Spotlite blend, 14:Overlay, 15:Softlight, 16:Hardlight, 17:Pinlight, 18:Hardmix, 19:Difference, 20:Exclusion, 21:Hue, 22:Saturation, 23:Color, 24:Value
 	//! [UI Guides] enum=0:Normal; 1:Average; 2:Add; 3:Subtract; 4:Darken; 5:Multiply; 6:Color burn; 7:Linear burn; 8:Lighten; 9:Screen; 10:Color Dodge; 11:Linear Dodge; 12:Spotlite; 13:Spotlite blend; 14:Overlay; 15:Softlight; 16:Hardlight; 17:Pinlight; 18:Hardmix; 19:Difference; 20:Exclusion; 21:Hue; 22:Saturation; 23:Color; 24:Value
 	//! [Default value] 1
	bool set_blend_modes(const IntList& intList) { return setValue("blend_modes", intList); }
	//! 0:Normal, 1:Average, 2:Add, 3:Subtract, 4:Darken, 5:Multiply, 6:Color burn, 7:Linear burn, 8:Lighten, 9:Screen, 10:Color Dodge, 11:Linear Dodge, 12:Spotlite, 13:Spotlite blend, 14:Overlay, 15:Softlight, 16:Hardlight, 17:Pinlight, 18:Hardmix, 19:Difference, 20:Exclusion, 21:Hue, 22:Saturation, 23:Color, 24:Value
 	//! [UI Guides] enum=0:Normal; 1:Average; 2:Add; 3:Subtract; 4:Darken; 5:Multiply; 6:Color burn; 7:Linear burn; 8:Lighten; 9:Screen; 10:Color Dodge; 11:Linear Dodge; 12:Spotlite; 13:Spotlite blend; 14:Overlay; 15:Softlight; 16:Hardlight; 17:Pinlight; 18:Hardmix; 19:Difference; 20:Exclusion; 21:Hue; 22:Saturation; 23:Color; 24:Value
 	//! [Default value] 1
	bool set_blend_modes(const int* ints, size_t count) { return setArray("blend_modes", ints, count); }
	//! 0:Normal, 1:Average, 2:Add, 3:Subtract, 4:Darken, 5:Multiply, 6:Color burn, 7:Linear burn, 8:Lighten, 9:Screen, 10:Color Dodge, 11:Linear Dodge, 12:Spotlite, 13:Spotlite blend, 14:Overlay, 15:Softlight, 16:Hardlight, 17:Pinlight, 18:Hardmix, 19:Difference, 20:Exclusion, 21:Hue, 22:Saturation, 23:Color, 24:Value
 	//! [UI Guides] enum=0:Normal; 1:Average; 2:Add; 3:Subtract; 4:Darken; 5:Multiply; 6:Color burn; 7:Linear burn; 8:Lighten; 9:Screen; 10:Color Dodge; 11:Linear Dodge; 12:Spotlite; 13:Spotlite blend; 14:Overlay; 15:Softlight; 16:Hardlight; 17:Pinlight; 18:Hardmix; 19:Difference; 20:Exclusion; 21:Hue; 22:Saturation; 23:Color; 24:Value
 	//! [Default value] 1
	template<size_t count> bool set_blend_modes(const int (&ints)[count]) { return setArray("blend_modes", ints, count); }
	//! 0:Normal, 1:Average, 2:Add, 3:Subtract, 4:Darken, 5:Multiply, 6:Color burn, 7:Linear burn, 8:Lighten, 9:Screen, 10:Color Dodge, 11:Linear Dodge, 12:Spotlite, 13:Spotlite blend, 14:Overlay, 15:Softlight, 16:Hardlight, 17:Pinlight, 18:Hardmix, 19:Difference, 20:Exclusion, 21:Hue, 22:Saturation, 23:Color, 24:Value
 	//! [UI Guides] enum=0:Normal; 1:Average; 2:Add; 3:Subtract; 4:Darken; 5:Multiply; 6:Color burn; 7:Linear burn; 8:Lighten; 9:Screen; 10:Color Dodge; 11:Linear Dodge; 12:Spotlite; 13:Spotlite blend; 14:Overlay; 15:Softlight; 16:Hardlight; 17:Pinlight; 18:Hardmix; 19:Difference; 20:Exclusion; 21:Hue; 22:Saturation; 23:Color; 24:Value
 	//! [Default value] 1
	IntList get_blend_modes() const { return getIntList("blend_modes"); }

	//! The opacity of each texture
 	//! [Default value] 1
	bool set_opacities(const FloatList& floatList) { return setValue("opacities", floatList); }
	//! The opacity of each texture
 	//! [Default value] 1
	bool set_opacities(const float* floats, size_t count) { return setArray("opacities", floats, count); }
	//! The opacity of each texture
 	//! [Default value] 1
	template<size_t count> bool set_opacities(const float (&floats)[count]) { return setArray("opacities", floats, count); }
	//! The opacity of each texture
 	//! [Default value] 1
	FloatList get_opacities() const { return getFloatList("opacities"); }

	//! (description missing)
	bool set_alpha(const Plugin& texturefloat) { return setValue("alpha", texturefloat); }
	//! (description missing)
	bool set_alpha(float texturefloat) { return setValue("alpha", texturefloat); }
	//! (description missing)
	Value get_alpha() const { return getValue("alpha"); }
};

class TexLayeredNuke : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexLayeredNuke"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! (description missing)
	bool set_textures(const ValueList& pluginList) { return setValue("textures", pluginList); }
	//! (description missing)
	ValueList get_textures() const { return getValueList("textures"); }

	//! (description missing)
	bool set_masks(const ValueList& pluginList) { return setValue("masks", pluginList); }
	//! (description missing)
	ValueList get_masks() const { return getValueList("masks"); }

	//! 0:atop, 1:average, 2:color-burn, 3:color-dodge, 4:conjoint-over, 5:copy, 6:difference, 7:disjoint-over, 8:divide, 9:exclusion, 10:from, 11:geometric, 12:hard-light, 13:hypot, 14:in, 15:mask, 16:matte, 17:max, 18:min, 19:minus, 20:multiply, 21:out, 22:over, 23:overlay, 24:plus, 25:screen, 26:soft-light, 27:stencil, 28:under, 29:xor
 	//! [UI Guides] enum=0:atop; 1:average; 2:color-burn; 3:color-dodge; 4:conjoint-over; 5:copy; 6:difference; 7:disjoint-over; 8:divide; 9:exclusion; 10:from; 11:geometric; 12:hard-light; 13:hypot; 14:in; 15:mask; 16:matte; 17:max; 18:min; 19:minus; 20:multiply; 21:out; 22:over; 23:overlay; 24:plus; 25:screen; 26:soft-light; 27:stencil; 28:under; 29:xor
 	//! [Default value] 1
	bool set_blend_modes(const IntList& intList) { return setValue("blend_modes", intList); }
	//! 0:atop, 1:average, 2:color-burn, 3:color-dodge, 4:conjoint-over, 5:copy, 6:difference, 7:disjoint-over, 8:divide, 9:exclusion, 10:from, 11:geometric, 12:hard-light, 13:hypot, 14:in, 15:mask, 16:matte, 17:max, 18:min, 19:minus, 20:multiply, 21:out, 22:over, 23:overlay, 24:plus, 25:screen, 26:soft-light, 27:stencil, 28:under, 29:xor
 	//! [UI Guides] enum=0:atop; 1:average; 2:color-burn; 3:color-dodge; 4:conjoint-over; 5:copy; 6:difference; 7:disjoint-over; 8:divide; 9:exclusion; 10:from; 11:geometric; 12:hard-light; 13:hypot; 14:in; 15:mask; 16:matte; 17:max; 18:min; 19:minus; 20:multiply; 21:out; 22:over; 23:overlay; 24:plus; 25:screen; 26:soft-light; 27:stencil; 28:under; 29:xor
 	//! [Default value] 1
	bool set_blend_modes(const int* ints, size_t count) { return setArray("blend_modes", ints, count); }
	//! 0:atop, 1:average, 2:color-burn, 3:color-dodge, 4:conjoint-over, 5:copy, 6:difference, 7:disjoint-over, 8:divide, 9:exclusion, 10:from, 11:geometric, 12:hard-light, 13:hypot, 14:in, 15:mask, 16:matte, 17:max, 18:min, 19:minus, 20:multiply, 21:out, 22:over, 23:overlay, 24:plus, 25:screen, 26:soft-light, 27:stencil, 28:under, 29:xor
 	//! [UI Guides] enum=0:atop; 1:average; 2:color-burn; 3:color-dodge; 4:conjoint-over; 5:copy; 6:difference; 7:disjoint-over; 8:divide; 9:exclusion; 10:from; 11:geometric; 12:hard-light; 13:hypot; 14:in; 15:mask; 16:matte; 17:max; 18:min; 19:minus; 20:multiply; 21:out; 22:over; 23:overlay; 24:plus; 25:screen; 26:soft-light; 27:stencil; 28:under; 29:xor
 	//! [Default value] 1
	template<size_t count> bool set_blend_modes(const int (&ints)[count]) { return setArray("blend_modes", ints, count); }
	//! 0:atop, 1:average, 2:color-burn, 3:color-dodge, 4:conjoint-over, 5:copy, 6:difference, 7:disjoint-over, 8:divide, 9:exclusion, 10:from, 11:geometric, 12:hard-light, 13:hypot, 14:in, 15:mask, 16:matte, 17:max, 18:min, 19:minus, 20:multiply, 21:out, 22:over, 23:overlay, 24:plus, 25:screen, 26:soft-light, 27:stencil, 28:under, 29:xor
 	//! [UI Guides] enum=0:atop; 1:average; 2:color-burn; 3:color-dodge; 4:conjoint-over; 5:copy; 6:difference; 7:disjoint-over; 8:divide; 9:exclusion; 10:from; 11:geometric; 12:hard-light; 13:hypot; 14:in; 15:mask; 16:matte; 17:max; 18:min; 19:minus; 20:multiply; 21:out; 22:over; 23:overlay; 24:plus; 25:screen; 26:soft-light; 27:stencil; 28:under; 29:xor
 	//! [Default value] 1
	IntList get_blend_modes() const { return getIntList("blend_modes"); }

	//! The opacity of each texture
 	//! [Default value] 1
	bool set_opacities(const FloatList& floatList) { return setValue("opacities", floatList); }
	//! The opacity of each texture
 	//! [Default value] 1
	bool set_opacities(const float* floats, size_t count) { return setArray("opacities", floats, count); }
	//! The opacity of each texture
 	//! [Default value] 1
	template<size_t count> bool set_opacities(const float (&floats)[count]) { return setArray("opacities", floats, count); }
	//! The opacity of each texture
 	//! [Default value] 1
	FloatList get_opacities() const { return getFloatList("opacities"); }
};

class TexLeather : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexLeather"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! (description missing)
	//! [Default value] true
	bool set_wrap(bool val) { return setValue("wrap", val); }
	//! (description missing)
	//! [Default value] true
	bool get_wrap() const { return getBool("wrap"); }

	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	bool set_placement_type(int val) { return setValue("placement_type", val); }
	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	int get_placement_type() const { return getInt("placement_type"); }

	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_u(float val) { return setValue("u", val); }
	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_u() const { return getFloat("u"); }

	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_v(float val) { return setValue("v", val); }
	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_v() const { return getFloat("v"); }

	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_w(float val) { return setValue("w", val); }
	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_w() const { return getFloat("w"); }

	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_h(float val) { return setValue("h", val); }
	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_h() const { return getFloat("h"); }

	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	bool set_jitter(float val) { return setValue("jitter", val); }
	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	float get_jitter() const { return getFloat("jitter"); }

	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_u(bool val) { return setValue("tile_u", val); }
	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_u() const { return getBool("tile_u"); }

	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_v(bool val) { return setValue("tile_v", val); }
	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_v() const { return getBool("tile_v"); }

	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool set_uv_noise_on(bool val) { return setValue("uv_noise_on", val); }
	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool get_uv_noise_on() const { return getBool("uv_noise_on"); }

	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool set_uv_noise_animate(bool val) { return setValue("uv_noise_animate", val); }
	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool get_uv_noise_animate() const { return getBool("uv_noise_animate"); }

	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	bool set_uv_noise_amount(float val) { return setValue("uv_noise_amount", val); }
	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	float get_uv_noise_amount() const { return getFloat("uv_noise_amount"); }

	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	bool set_uv_noise_levels(float val) { return setValue("uv_noise_levels", val); }
	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	float get_uv_noise_levels() const { return getFloat("uv_noise_levels"); }

	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	bool set_uv_noise_size(float val) { return setValue("uv_noise_size", val); }
	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	float get_uv_noise_size() const { return getFloat("uv_noise_size"); }

	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	bool set_un_noise_phase(float val) { return setValue("un_noise_phase", val); }
	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	float get_un_noise_phase() const { return getFloat("un_noise_phase"); }

	//! [UI Guides] displayName=Cell Color
 	bool set_cell_color_tex(const Plugin& texture) { return setValue("cell_color_tex", texture); }
	//! [UI Guides] displayName=Cell Color
 	bool set_cell_color_tex(const AColor& texture) { return setValue("cell_color_tex", texture); }
	//! [UI Guides] displayName=Cell Color
 	Value get_cell_color_tex() const { return getValue("cell_color_tex"); }

	//! [UI Guides] displayName=Crease Color
 	bool set_crease_color_tex(const Plugin& texture) { return setValue("crease_color_tex", texture); }
	//! [UI Guides] displayName=Crease Color
 	bool set_crease_color_tex(const AColor& texture) { return setValue("crease_color_tex", texture); }
	//! [UI Guides] displayName=Crease Color
 	Value get_crease_color_tex() const { return getValue("crease_color_tex"); }

	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	bool set_cell_color(const Color& color) { return setValue("cell_color", color); }
	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	Color get_cell_color() const { return getColor("cell_color"); }

	//! (description missing)
	//! [Default value] Color(0, 0, 0)
	bool set_crease_color(const Color& color) { return setValue("crease_color", color); }
	//! (description missing)
	//! [Default value] Color(0, 0, 0)
	Color get_crease_color() const { return getColor("crease_color"); }

	//! (description missing)
	//! [Default value] 1
	bool set_cell_color_tex_mult(float val) { return setValue("cell_color_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_cell_color_tex_mult() const { return getFloat("cell_color_tex_mult"); }

	//! (description missing)
	//! [Default value] 1
	bool set_crease_color_tex_mult(float val) { return setValue("crease_color_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_crease_color_tex_mult() const { return getFloat("crease_color_tex_mult"); }

	//! [UI Guides] minValue=0
 	bool set_size(const Plugin& texturefloat) { return setValue("size", texturefloat); }
	//! [UI Guides] minValue=0
 	bool set_size(float texturefloat) { return setValue("size", texturefloat); }
	//! [UI Guides] minValue=0
 	Value get_size() const { return getValue("size"); }

	//! [UI Guides] minValue=0
 	bool set_density(const Plugin& texturefloat) { return setValue("density", texturefloat); }
	//! [UI Guides] minValue=0
 	bool set_density(float texturefloat) { return setValue("density", texturefloat); }
	//! [UI Guides] minValue=0
 	Value get_density() const { return getValue("density"); }

	//! [UI Guides] minValue=0
 	bool set_spottyness(const Plugin& texturefloat) { return setValue("spottyness", texturefloat); }
	//! [UI Guides] minValue=0
 	bool set_spottyness(float texturefloat) { return setValue("spottyness", texturefloat); }
	//! [UI Guides] minValue=0
 	Value get_spottyness() const { return getValue("spottyness"); }

	//! [UI Guides] minValue=0
 	bool set_randomness(const Plugin& texturefloat) { return setValue("randomness", texturefloat); }
	//! [UI Guides] minValue=0
 	bool set_randomness(float texturefloat) { return setValue("randomness", texturefloat); }
	//! [UI Guides] minValue=0
 	Value get_randomness() const { return getValue("randomness"); }

	//! [UI Guides] minValue=0
 	bool set_threshold(const Plugin& texturefloat) { return setValue("threshold", texturefloat); }
	//! [UI Guides] minValue=0
 	bool set_threshold(float texturefloat) { return setValue("threshold", texturefloat); }
	//! [UI Guides] minValue=0
 	Value get_threshold() const { return getValue("threshold"); }

	//! (description missing)
	//! [Default value] true
	bool set_creases(bool val) { return setValue("creases", val); }
	//! (description missing)
	//! [Default value] true
	bool get_creases() const { return getBool("creases"); }
};

class TexLuminance : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexLuminance"; }

	//! (description missing)
	bool set_input(const Plugin& texture) { return setValue("input", texture); }
	//! (description missing)
	bool set_input(const AColor& texture) { return setValue("input", texture); }
	//! (description missing)
	Value get_input() const { return getValue("input"); }
};

class TexLut : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexLut"; }

	//! (description missing)
	bool set_basemap(const Plugin& texture) { return setValue("basemap", texture); }
	//! (description missing)
	bool set_basemap(const AColor& texture) { return setValue("basemap", texture); }
	//! (description missing)
	Value get_basemap() const { return getValue("basemap"); }

	//! [UI Guides] fileAsset=cube
 	bool set_file(const char* str) { return setValue("file", str); }
	//! [UI Guides] fileAsset=cube
 	bool set_file(const std::string& str) { return setValue("file", str); }
	//! [UI Guides] fileAsset=cube
 	std::string get_file() const { return getString("file"); }

	//! (description missing)
	//! [Default value] 1
	bool set_use_logspace(int val) { return setValue("use_logspace", val); }
	//! (description missing)
	//! [Default value] 1
	int get_use_logspace() const { return getInt("use_logspace"); }
};

class TexMarble : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexMarble"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! (description missing)
	//! [Default value] false
	bool set_use_3d_mapping(bool val) { return setValue("use_3d_mapping", val); }
	//! (description missing)
	//! [Default value] false
	bool get_use_3d_mapping() const { return getBool("use_3d_mapping"); }

	//! (description missing)
	//! [Default value] true
	bool set_wrap(bool val) { return setValue("wrap", val); }
	//! (description missing)
	//! [Default value] true
	bool get_wrap() const { return getBool("wrap"); }

	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	bool set_placement_type(int val) { return setValue("placement_type", val); }
	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	int get_placement_type() const { return getInt("placement_type"); }

	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_u(float val) { return setValue("u", val); }
	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_u() const { return getFloat("u"); }

	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_v(float val) { return setValue("v", val); }
	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_v() const { return getFloat("v"); }

	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_w(float val) { return setValue("w", val); }
	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_w() const { return getFloat("w"); }

	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_h(float val) { return setValue("h", val); }
	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_h() const { return getFloat("h"); }

	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	bool set_jitter(float val) { return setValue("jitter", val); }
	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	float get_jitter() const { return getFloat("jitter"); }

	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_u(bool val) { return setValue("tile_u", val); }
	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_u() const { return getBool("tile_u"); }

	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_v(bool val) { return setValue("tile_v", val); }
	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_v() const { return getBool("tile_v"); }

	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool set_uv_noise_on(bool val) { return setValue("uv_noise_on", val); }
	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool get_uv_noise_on() const { return getBool("uv_noise_on"); }

	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool set_uv_noise_animate(bool val) { return setValue("uv_noise_animate", val); }
	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool get_uv_noise_animate() const { return getBool("uv_noise_animate"); }

	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	bool set_uv_noise_amount(float val) { return setValue("uv_noise_amount", val); }
	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	float get_uv_noise_amount() const { return getFloat("uv_noise_amount"); }

	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	bool set_uv_noise_levels(float val) { return setValue("uv_noise_levels", val); }
	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	float get_uv_noise_levels() const { return getFloat("uv_noise_levels"); }

	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	bool set_uv_noise_size(float val) { return setValue("uv_noise_size", val); }
	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	float get_uv_noise_size() const { return getFloat("uv_noise_size"); }

	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	bool set_un_noise_phase(float val) { return setValue("un_noise_phase", val); }
	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	float get_un_noise_phase() const { return getFloat("un_noise_phase"); }

	//! [UI Guides] displayName=Filler Color
 	bool set_filler_color_tex(const Plugin& texture) { return setValue("filler_color_tex", texture); }
	//! [UI Guides] displayName=Filler Color
 	bool set_filler_color_tex(const AColor& texture) { return setValue("filler_color_tex", texture); }
	//! [UI Guides] displayName=Filler Color
 	Value get_filler_color_tex() const { return getValue("filler_color_tex"); }

	//! [UI Guides] displayName=Vein Color
 	bool set_vein_color_tex(const Plugin& texture) { return setValue("vein_color_tex", texture); }
	//! [UI Guides] displayName=Vein Color
 	bool set_vein_color_tex(const AColor& texture) { return setValue("vein_color_tex", texture); }
	//! [UI Guides] displayName=Vein Color
 	Value get_vein_color_tex() const { return getValue("vein_color_tex"); }

	//! [UI Guides] minValue=0
 	bool set_vein_width(const Plugin& texturefloat) { return setValue("vein_width", texturefloat); }
	//! [UI Guides] minValue=0
 	bool set_vein_width(float texturefloat) { return setValue("vein_width", texturefloat); }
	//! [UI Guides] minValue=0
 	Value get_vein_width() const { return getValue("vein_width"); }

	//! (description missing)
	bool set_diffusion(const Plugin& texturefloat) { return setValue("diffusion", texturefloat); }
	//! (description missing)
	bool set_diffusion(float texturefloat) { return setValue("diffusion", texturefloat); }
	//! (description missing)
	Value get_diffusion() const { return getValue("diffusion"); }

	//! (description missing)
	bool set_contrast(const Plugin& texturefloat) { return setValue("contrast", texturefloat); }
	//! (description missing)
	bool set_contrast(float texturefloat) { return setValue("contrast", texturefloat); }
	//! (description missing)
	Value get_contrast() const { return getValue("contrast"); }

	//! [UI Guides] minValue=0
 	bool set_amplitude(const Plugin& texturefloat) { return setValue("amplitude", texturefloat); }
	//! [UI Guides] minValue=0
 	bool set_amplitude(float texturefloat) { return setValue("amplitude", texturefloat); }
	//! [UI Guides] minValue=0
 	Value get_amplitude() const { return getValue("amplitude"); }

	//! [UI Guides] minValue=0, maxValue=1
 	bool set_ratio(const Plugin& texturefloat) { return setValue("ratio", texturefloat); }
	//! [UI Guides] minValue=0, maxValue=1
 	bool set_ratio(float texturefloat) { return setValue("ratio", texturefloat); }
	//! [UI Guides] minValue=0, maxValue=1
 	Value get_ratio() const { return getValue("ratio"); }

	//! (description missing)
	bool set_ripples(const Plugin& texture) { return setValue("ripples", texture); }
	//! (description missing)
	bool set_ripples(const AColor& texture) { return setValue("ripples", texture); }
	//! (description missing)
	Value get_ripples() const { return getValue("ripples"); }

	//! [UI Guides] minValue=0
 	bool set_depth_min(const Plugin& texturefloat) { return setValue("depth_min", texturefloat); }
	//! [UI Guides] minValue=0
 	bool set_depth_min(float texturefloat) { return setValue("depth_min", texturefloat); }
	//! [UI Guides] minValue=0
 	Value get_depth_min() const { return getValue("depth_min"); }

	//! [UI Guides] minValue=0
 	bool set_depth_max(const Plugin& texturefloat) { return setValue("depth_max", texturefloat); }
	//! [UI Guides] minValue=0
 	bool set_depth_max(float texturefloat) { return setValue("depth_max", texturefloat); }
	//! [UI Guides] minValue=0
 	Value get_depth_max() const { return getValue("depth_max"); }
};

class TexMarbleMax : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexMarbleMax"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! (description missing)
	//! [Default value] false
	bool set_use_3d_mapping(bool val) { return setValue("use_3d_mapping", val); }
	//! (description missing)
	//! [Default value] false
	bool get_use_3d_mapping() const { return getBool("use_3d_mapping"); }

	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	bool set_placement_type(int val) { return setValue("placement_type", val); }
	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	int get_placement_type() const { return getInt("placement_type"); }

	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_u(float val) { return setValue("u", val); }
	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_u() const { return getFloat("u"); }

	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_v(float val) { return setValue("v", val); }
	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_v() const { return getFloat("v"); }

	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_w(float val) { return setValue("w", val); }
	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_w() const { return getFloat("w"); }

	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_h(float val) { return setValue("h", val); }
	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_h() const { return getFloat("h"); }

	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	bool set_jitter(float val) { return setValue("jitter", val); }
	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	float get_jitter() const { return getFloat("jitter"); }

	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_u(bool val) { return setValue("tile_u", val); }
	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_u() const { return getBool("tile_u"); }

	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_v(bool val) { return setValue("tile_v", val); }
	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_v() const { return getBool("tile_v"); }

	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool set_uv_noise_on(bool val) { return setValue("uv_noise_on", val); }
	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool get_uv_noise_on() const { return getBool("uv_noise_on"); }

	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool set_uv_noise_animate(bool val) { return setValue("uv_noise_animate", val); }
	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool get_uv_noise_animate() const { return getBool("uv_noise_animate"); }

	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	bool set_uv_noise_amount(float val) { return setValue("uv_noise_amount", val); }
	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	float get_uv_noise_amount() const { return getFloat("uv_noise_amount"); }

	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	bool set_uv_noise_levels(float val) { return setValue("uv_noise_levels", val); }
	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	float get_uv_noise_levels() const { return getFloat("uv_noise_levels"); }

	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	bool set_uv_noise_size(float val) { return setValue("uv_noise_size", val); }
	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	float get_uv_noise_size() const { return getFloat("uv_noise_size"); }

	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	bool set_un_noise_phase(float val) { return setValue("un_noise_phase", val); }
	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	float get_un_noise_phase() const { return getFloat("un_noise_phase"); }

	//! First color
 	bool set_color1(const Plugin& texture) { return setValue("color1", texture); }
	//! First color
 	bool set_color1(const AColor& texture) { return setValue("color1", texture); }
	//! First color
 	Value get_color1() const { return getValue("color1"); }

	//! Second color
 	bool set_color2(const Plugin& texture) { return setValue("color2", texture); }
	//! Second color
 	bool set_color2(const AColor& texture) { return setValue("color2", texture); }
	//! Second color
 	Value get_color2() const { return getValue("color2"); }

	//! Size
 	//! [Default value] 70
	bool set_size(float val) { return setValue("size", val); }
	//! Size
 	//! [Default value] 70
	float get_size() const { return getFloat("size"); }

	//! Vein width
 	//! [Default value] 0.02
	bool set_vein_width(float val) { return setValue("vein_width", val); }
	//! Vein width
 	//! [Default value] 0.02
	float get_vein_width() const { return getFloat("vein_width"); }
};

class TexMaskMax : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexMaskMax"; }

	//! The base texture
 	bool set_texture(const Plugin& texture) { return setValue("texture", texture); }
	//! The base texture
 	bool set_texture(const AColor& texture) { return setValue("texture", texture); }
	//! The base texture
 	Value get_texture() const { return getValue("texture"); }

	//! The mask texture
 	bool set_mask(const Plugin& texture) { return setValue("mask", texture); }
	//! The mask texture
 	bool set_mask(const AColor& texture) { return setValue("mask", texture); }
	//! The mask texture
 	Value get_mask() const { return getValue("mask"); }

	//! true to invert the mask
 	//! [Default value] false
	bool set_invert_mask(bool val) { return setValue("invert_mask", val); }
	//! true to invert the mask
 	//! [Default value] false
	bool get_invert_mask() const { return getBool("invert_mask"); }
};

class TexMaxGamma : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexMaxGamma"; }

	//! The input texture
 	bool set_input(const Plugin& texture) { return setValue("input", texture); }
	//! The input texture
 	bool set_input(const AColor& texture) { return setValue("input", texture); }
	//! The input texture
 	Value get_input() const { return getValue("input"); }

	//! The texture multiplier
 	//! [Default value] 1
	bool set_multiplier(float val) { return setValue("multiplier", val); }
	//! The texture multiplier
 	//! [Default value] 1
	float get_multiplier() const { return getFloat("multiplier"); }

	//! The color space (0 - linear; 1 - inverse gamma; 2 - sRGB)
 	//! [UI Guides] enum=0:Linear; 1:Inverse gamma; 2:sRGB
 	//! [Default value] 0
	bool set_color_space(int val) { return setValue("color_space", val); }
	//! The color space (0 - linear; 1 - inverse gamma; 2 - sRGB)
 	//! [UI Guides] enum=0:Linear; 1:Inverse gamma; 2:sRGB
 	//! [Default value] 0
	int get_color_space() const { return getInt("color_space"); }

	//! The gamma value of the texture
 	//! [Default value] 1
	bool set_gamma(float val) { return setValue("gamma", val); }
	//! The gamma value of the texture
 	//! [Default value] 1
	float get_gamma() const { return getFloat("gamma"); }
};

class TexMaxHairInfo : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexMaxHairInfo"; }

	//! Specifies the way of blending between the two input color textures. The value means : 0 - position along strand, 1 - random by strand id,2 - Hair color, 3 - Hair opacity, 4 - Hair transparency, 5 - Hair incandescence
 	//! [UI Guides] enum=0:Position along strand;1:Random by strand index;2:Hair Color;3:Hair opacity;4:Hair transparency;5:Hair incandescence
 	//! [Default value] 0
	bool set_output(int val) { return setValue("output", val); }
	//! Specifies the way of blending between the two input color textures. The value means : 0 - position along strand, 1 - random by strand id,2 - Hair color, 3 - Hair opacity, 4 - Hair transparency, 5 - Hair incandescence
 	//! [UI Guides] enum=0:Position along strand;1:Random by strand index;2:Hair Color;3:Hair opacity;4:Hair transparency;5:Hair incandescence
 	//! [Default value] 0
	int get_output() const { return getInt("output"); }

	//! Seed offset
 	//! [Default value] 1
	bool set_seed_offset(int val) { return setValue("seed_offset", val); }
	//! Seed offset
 	//! [Default value] 1
	int get_seed_offset() const { return getInt("seed_offset"); }

	//! Color A
 	bool set_color_a(const Plugin& texture) { return setValue("color_a", texture); }
	//! Color A
 	bool set_color_a(const AColor& texture) { return setValue("color_a", texture); }
	//! Color A
 	Value get_color_a() const { return getValue("color_a"); }

	//! Color B
 	bool set_color_b(const Plugin& texture) { return setValue("color_b", texture); }
	//! Color B
 	bool set_color_b(const AColor& texture) { return setValue("color_b", texture); }
	//! Color B
 	Value get_color_b() const { return getValue("color_b"); }

	//! Bias
 	bool set_bias(const Plugin& texturefloat) { return setValue("bias", texturefloat); }
	//! Bias
 	bool set_bias(float texturefloat) { return setValue("bias", texturefloat); }
	//! Bias
 	Value get_bias() const { return getValue("bias"); }
};

class TexMayaContrast : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexMayaContrast"; }

	//! (description missing)
	bool set_value(const Plugin& texture) { return setValue("value", texture); }
	//! (description missing)
	bool set_value(const AColor& texture) { return setValue("value", texture); }
	//! (description missing)
	Value get_value() const { return getValue("value"); }

	//! (description missing)
	bool set_contrast(const Plugin& texture) { return setValue("contrast", texture); }
	//! (description missing)
	bool set_contrast(const AColor& texture) { return setValue("contrast", texture); }
	//! (description missing)
	Value get_contrast() const { return getValue("contrast"); }

	//! (description missing)
	bool set_bias(const Plugin& texture) { return setValue("bias", texture); }
	//! (description missing)
	bool set_bias(const AColor& texture) { return setValue("bias", texture); }
	//! (description missing)
	Value get_bias() const { return getValue("bias"); }
};

class TexMayaConversion : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexMayaConversion"; }

	//! (description missing)
	bool set_input(const Plugin& texturefloat) { return setValue("input", texturefloat); }
	//! (description missing)
	bool set_input(float texturefloat) { return setValue("input", texturefloat); }
	//! (description missing)
	Value get_input() const { return getValue("input"); }

	//! (description missing)
	//! [Default value] 1
	bool set_conversion_factor(float val) { return setValue("conversion_factor", val); }
	//! (description missing)
	//! [Default value] 1
	float get_conversion_factor() const { return getFloat("conversion_factor"); }
};

class TexMayaFluid : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexMayaFluid"; }

	//! The number of voxels in the x dimension.
 	//! [Default value] 1
	bool set_size_x(int val) { return setValue("size_x", val); }
	//! The number of voxels in the x dimension.
 	//! [Default value] 1
	int get_size_x() const { return getInt("size_x"); }

	//! The number of voxels in the y dimension.
 	//! [Default value] 1
	bool set_size_y(int val) { return setValue("size_y", val); }
	//! The number of voxels in the y dimension.
 	//! [Default value] 1
	int get_size_y() const { return getInt("size_y"); }

	//! The number of voxels in the z dimension.
 	//! [Default value] 1
	bool set_size_z(int val) { return setValue("size_z", val); }
	//! The number of voxels in the z dimension.
 	//! [Default value] 1
	int get_size_z() const { return getInt("size_z"); }

	//! The float grid data, an index into this is computed as follows : idx = size_x*size_y*zidx + size_x*yidx + xidx
 	//! [Default value] 1
	bool set_values(const FloatList& floatList) { return setValue("values", floatList); }
	//! The float grid data, an index into this is computed as follows : idx = size_x*size_y*zidx + size_x*yidx + xidx
 	//! [Default value] 1
	bool set_values(const float* floats, size_t count) { return setArray("values", floats, count); }
	//! The float grid data, an index into this is computed as follows : idx = size_x*size_y*zidx + size_x*yidx + xidx
 	//! [Default value] 1
	template<size_t count> bool set_values(const float (&floats)[count]) { return setArray("values", floats, count); }
	//! The float grid data, an index into this is computed as follows : idx = size_x*size_y*zidx + size_x*yidx + xidx
 	//! [Default value] 1
	FloatList get_values() const { return getFloatList("values"); }

	//! The color grid data, an index into this is computed as follows : idx = size_x*size_y*zidx + size_x*yidx + xidx
 	//! [Default value] Color(1, 1, 1)
	bool set_color_values(const ColorList& colorList) { return setValue("color_values", colorList); }
	//! The color grid data, an index into this is computed as follows : idx = size_x*size_y*zidx + size_x*yidx + xidx
 	//! [Default value] Color(1, 1, 1)
	bool set_color_values(const Color* colors, size_t count) { return setArray("color_values", colors, count); }
	//! The color grid data, an index into this is computed as follows : idx = size_x*size_y*zidx + size_x*yidx + xidx
 	//! [Default value] Color(1, 1, 1)
	template<size_t count> bool set_color_values(const Color (&colors)[count]) { return setArray("color_values", colors, count); }
	//! The color grid data, an index into this is computed as follows : idx = size_x*size_y*zidx + size_x*yidx + xidx
 	//! [Default value] Color(1, 1, 1)
	ColorList get_color_values() const { return getColorList("color_values"); }

	//! 0 : linear(8 samples, faster, but voxel borders may be visible),1 : quadratic(27 samples, slower, but voxel borders are much less likely to be visible
 	//! [Default value] 0
	bool set_interpolation_type(int val) { return setValue("interpolation_type", val); }
	//! 0 : linear(8 samples, faster, but voxel borders may be visible),1 : quadratic(27 samples, slower, but voxel borders are much less likely to be visible
 	//! [Default value] 0
	int get_interpolation_type() const { return getInt("interpolation_type"); }

	//! Velocity texture for the first frame. Used to calculate the motion blur. 
 	bool set_velocity(const Plugin& plugin) { return setValue("velocity", plugin); }
	//! Velocity texture for the first frame. Used to calculate the motion blur. 
 	Plugin get_velocity() const { return getPlugin("velocity"); }

	//! The x dynamic offset of the fluid container.
 	//! [Default value] 0
	bool set_dynamic_offset_x(float val) { return setValue("dynamic_offset_x", val); }
	//! The x dynamic offset of the fluid container.
 	//! [Default value] 0
	float get_dynamic_offset_x() const { return getFloat("dynamic_offset_x"); }

	//! The y dynamic offset of the fluid container.
 	//! [Default value] 0
	bool set_dynamic_offset_y(float val) { return setValue("dynamic_offset_y", val); }
	//! The y dynamic offset of the fluid container.
 	//! [Default value] 0
	float get_dynamic_offset_y() const { return getFloat("dynamic_offset_y"); }

	//! The z dynamic offset of the fluid container.
 	//! [Default value] 0
	bool set_dynamic_offset_z(float val) { return setValue("dynamic_offset_z", val); }
	//! The z dynamic offset of the fluid container.
 	//! [Default value] 0
	float get_dynamic_offset_z() const { return getFloat("dynamic_offset_z"); }

	//! Cell size in the 3 axis
 	//! [Default value] 1
	bool set_cell_size(const FloatList& floatList) { return setValue("cell_size", floatList); }
	//! Cell size in the 3 axis
 	//! [Default value] 1
	bool set_cell_size(const float* floats, size_t count) { return setArray("cell_size", floats, count); }
	//! Cell size in the 3 axis
 	//! [Default value] 1
	template<size_t count> bool set_cell_size(const float (&floats)[count]) { return setArray("cell_size", floats, count); }
	//! Cell size in the 3 axis
 	//! [Default value] 1
	FloatList get_cell_size() const { return getFloatList("cell_size"); }

	//! Motion blur type, 0-Disabled, 1-Blend, 2-Velocity, 3-Velocity+Blend
 	//! [UI Guides] enum=0:Disabled; 1:Blend; 2:Velocity; 3:Velocity+Blend
 	//! [Default value] 0
	bool set_mb_type(int val) { return setValue("mb_type", val); }
	//! Motion blur type, 0-Disabled, 1-Blend, 2-Velocity, 3-Velocity+Blend
 	//! [UI Guides] enum=0:Disabled; 1:Blend; 2:Velocity; 3:Velocity+Blend
 	//! [Default value] 0
	int get_mb_type() const { return getInt("mb_type"); }

	//! The frame duration in sec.
 	//! [Default value] 0.0416667
	bool set_frame_duration(float val) { return setValue("frame_duration", val); }
	//! The frame duration in sec.
 	//! [Default value] 0.0416667
	float get_frame_duration() const { return getFloat("frame_duration"); }

	//! Converts the current frame number to cache frame number.
 	//! [Default value] 0
	bool set_cache_frame(float val) { return setValue("cache_frame", val); }
	//! Converts the current frame number to cache frame number.
 	//! [Default value] 0
	float get_cache_frame() const { return getFloat("cache_frame"); }
};

class TexMayaFluidCombined : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexMayaFluidCombined"; }

	//! The first texture. Should support the EXT_MAYA_FLUID_TEXTURE interface.
 	bool set_tex1(const Plugin& plugin) { return setValue("tex1", plugin); }
	//! The first texture. Should support the EXT_MAYA_FLUID_TEXTURE interface.
 	Plugin get_tex1() const { return getPlugin("tex1"); }

	//! The second texture. Should support the EXT_MAYA_FLUID_TEXTURE interface.
 	bool set_tex2(const Plugin& plugin) { return setValue("tex2", plugin); }
	//! The second texture. Should support the EXT_MAYA_FLUID_TEXTURE interface.
 	Plugin get_tex2() const { return getPlugin("tex2"); }
};

class TexMayaFluidProcedural : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexMayaFluidProcedural"; }

	//! 0 : constant(1.0); 1 : X gradient; 2 : Y gradient; 3 : Z gradient; 4 : center gradient; 5 : -X gradient; 6 : -Y gradient; 7 : -Z gradient; 8 : sphere; 9 : cube; 10 : cone; 11 : double cone;
 	//! [UI Guides] enum=0:Constant1.0; 1:X gradient; 2:Y gradient; 3:Z gradient; 4:Center gradient; 5:-X gradient; 6:-Y gradient; 7:-Z gradient; 8:Sphere; 9:Cube; 10:Cone; 11:Double cone;
 	//! [Default value] 1
	bool set_type(int val) { return setValue("type", val); }
	//! 0 : constant(1.0); 1 : X gradient; 2 : Y gradient; 3 : Z gradient; 4 : center gradient; 5 : -X gradient; 6 : -Y gradient; 7 : -Z gradient; 8 : sphere; 9 : cube; 10 : cone; 11 : double cone;
 	//! [UI Guides] enum=0:Constant1.0; 1:X gradient; 2:Y gradient; 3:Z gradient; 4:Center gradient; 5:-X gradient; 6:-Y gradient; 7:-Z gradient; 8:Sphere; 9:Cube; 10:Cone; 11:Double cone;
 	//! [Default value] 1
	int get_type() const { return getInt("type"); }

	//! Since the cube drop-off shape is computed a little differently, we need this here for this particular case.
 	//! [Default value] 0
	bool set_edge_fade_out(float val) { return setValue("edge_fade_out", val); }
	//! Since the cube drop-off shape is computed a little differently, we need this here for this particular case.
 	//! [Default value] 0
	float get_edge_fade_out() const { return getFloat("edge_fade_out"); }
};

class TexMayaFluidTransformed : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexMayaFluidTransformed"; }

	//! The transformation from object(texture) space to world space.
 	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	bool set_object_to_world(const Transform& transform) { return setValue("object_to_world", transform); }
	//! The transformation from object(texture) space to world space.
 	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	Transform get_object_to_world() const { return getTransform("object_to_world"); }

	//! The transformation from object(texture) space to world space excluding the dynamic offset from auto-resize.
 	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	bool set_object_to_world_autosize(const Transform& transform) { return setValue("object_to_world_autosize", transform); }
	//! The transformation from object(texture) space to world space excluding the dynamic offset from auto-resize.
 	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	Transform get_object_to_world_autosize() const { return getTransform("object_to_world_autosize"); }

	//! The base texture. Should support the EXT_MAYA_FLUID_TEXTURE interface.
 	bool set_fluid_tex(const Plugin& plugin) { return setValue("fluid_tex", plugin); }
	//! The base texture. Should support the EXT_MAYA_FLUID_TEXTURE interface.
 	Plugin get_fluid_tex() const { return getPlugin("fluid_tex"); }

	//! Multiplier for the value taken from fluid_tex.
 	//! [Default value] 1
	bool set_fluid_value_scale(float val) { return setValue("fluid_value_scale", val); }
	//! Multiplier for the value taken from fluid_tex.
 	//! [Default value] 1
	float get_fluid_value_scale() const { return getFloat("fluid_value_scale"); }

	//! Is the built-in noise enabled ?
 	//! [Default value] false
	bool set_noise_tex_on(bool val) { return setValue("noise_tex_on", val); }
	//! Is the built-in noise enabled ?
 	//! [Default value] false
	bool get_noise_tex_on() const { return getBool("noise_tex_on"); }

	//! The fluid's built-in noise.
 	bool set_noise_tex(const Plugin& texture) { return setValue("noise_tex", texture); }
	//! The fluid's built-in noise.
 	bool set_noise_tex(const AColor& texture) { return setValue("noise_tex", texture); }
	//! The fluid's built-in noise.
 	Value get_noise_tex() const { return getValue("noise_tex"); }

	//! Tells how much of the noise should be blended with the grid/gradient values.
 	bool set_noise_gain(const Plugin& texturefloat) { return setValue("noise_gain", texturefloat); }
	//! Tells how much of the noise should be blended with the grid/gradient values.
 	bool set_noise_gain(float texturefloat) { return setValue("noise_gain", texturefloat); }
	//! Tells how much of the noise should be blended with the grid/gradient values.
 	Value get_noise_gain() const { return getValue("noise_gain"); }

	//! The size of the fluid container used for noise calculation. In Maya it's the real size scaled by 0.2
 	//! [Default value] 1
	bool set_noise_size(const FloatList& floatList) { return setValue("noise_size", floatList); }
	//! The size of the fluid container used for noise calculation. In Maya it's the real size scaled by 0.2
 	//! [Default value] 1
	bool set_noise_size(const float* floats, size_t count) { return setArray("noise_size", floats, count); }
	//! The size of the fluid container used for noise calculation. In Maya it's the real size scaled by 0.2
 	//! [Default value] 1
	template<size_t count> bool set_noise_size(const float (&floats)[count]) { return setArray("noise_size", floats, count); }
	//! The size of the fluid container used for noise calculation. In Maya it's the real size scaled by 0.2
 	//! [Default value] 1
	FloatList get_noise_size() const { return getFloatList("noise_size"); }

	//! The x dynamic offset of the fluid container.
 	//! [Default value] 0
	bool set_dynamic_offset_x(float val) { return setValue("dynamic_offset_x", val); }
	//! The x dynamic offset of the fluid container.
 	//! [Default value] 0
	float get_dynamic_offset_x() const { return getFloat("dynamic_offset_x"); }

	//! The y dynamic offset of the fluid container.
 	//! [Default value] 0
	bool set_dynamic_offset_y(float val) { return setValue("dynamic_offset_y", val); }
	//! The y dynamic offset of the fluid container.
 	//! [Default value] 0
	float get_dynamic_offset_y() const { return getFloat("dynamic_offset_y"); }

	//! The z dynamic offset of the fluid container.
 	//! [Default value] 0
	bool set_dynamic_offset_z(float val) { return setValue("dynamic_offset_z", val); }
	//! The z dynamic offset of the fluid container.
 	//! [Default value] 0
	float get_dynamic_offset_z() const { return getFloat("dynamic_offset_z"); }
};

class TexMayaHairColor : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexMayaHairColor"; }
};

class TexMayaHairIncandescence : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexMayaHairIncandescence"; }
};

class TexMayaHairTransparency : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexMayaHairTransparency"; }
};

class TexMeshVertexColor : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexMeshVertexColor"; }

	//! (description missing)
	//! [Default value] Color(0, 0, 0)
	bool set_colors(const ColorList& colorList) { return setValue("colors", colorList); }
	//! (description missing)
	//! [Default value] Color(0, 0, 0)
	bool set_colors(const Color* colors, size_t count) { return setArray("colors", colors, count); }
	//! (description missing)
	//! [Default value] Color(0, 0, 0)
	template<size_t count> bool set_colors(const Color (&colors)[count]) { return setArray("colors", colors, count); }
	//! (description missing)
	//! [Default value] Color(0, 0, 0)
	ColorList get_colors() const { return getColorList("colors"); }

	//! (description missing)
	//! [Default value] 1
	bool set_alphas(const FloatList& floatList) { return setValue("alphas", floatList); }
	//! (description missing)
	//! [Default value] 1
	bool set_alphas(const float* floats, size_t count) { return setArray("alphas", floats, count); }
	//! (description missing)
	//! [Default value] 1
	template<size_t count> bool set_alphas(const float (&floats)[count]) { return setArray("alphas", floats, count); }
	//! (description missing)
	//! [Default value] 1
	FloatList get_alphas() const { return getFloatList("alphas"); }

	//! (description missing)
	//! [Default value] 0
	bool set_faces(const IntList& intList) { return setValue("faces", intList); }
	//! (description missing)
	//! [Default value] 0
	bool set_faces(const int* ints, size_t count) { return setArray("faces", ints, count); }
	//! (description missing)
	//! [Default value] 0
	template<size_t count> bool set_faces(const int (&ints)[count]) { return setArray("faces", ints, count); }
	//! (description missing)
	//! [Default value] 0
	IntList get_faces() const { return getIntList("faces"); }
};

class TexMeshVertexColorChannel : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexMeshVertexColorChannel"; }

	//! (description missing)
	//! [Default value] 0
	bool set_channelIndex(int val) { return setValue("channelIndex", val); }
	//! (description missing)
	//! [Default value] 0
	int get_channelIndex() const { return getInt("channelIndex"); }

	//! Name of the channel to use (it will match one of the channels in GeomStaticMesh::map_channels_names)
 	bool set_channel_name(const char* str) { return setValue("channel_name", str); }
	//! Name of the channel to use (it will match one of the channels in GeomStaticMesh::map_channels_names)
 	bool set_channel_name(const std::string& str) { return setValue("channel_name", str); }
	//! Name of the channel to use (it will match one of the channels in GeomStaticMesh::map_channels_names)
 	std::string get_channel_name() const { return getString("channel_name"); }

	//! (description missing)
	bool set_default_color(const Plugin& texture) { return setValue("default_color", texture); }
	//! (description missing)
	bool set_default_color(const AColor& texture) { return setValue("default_color", texture); }
	//! (description missing)
	Value get_default_color() const { return getValue("default_color"); }
};

class TexMeshVertexColorWithDefault : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexMeshVertexColorWithDefault"; }

	//! (description missing)
	bool set_vertex_color(const Plugin& texture) { return setValue("vertex_color", texture); }
	//! (description missing)
	bool set_vertex_color(const AColor& texture) { return setValue("vertex_color", texture); }
	//! (description missing)
	Value get_vertex_color() const { return getValue("vertex_color"); }

	//! (description missing)
	bool set_default_color(const Plugin& texture) { return setValue("default_color", texture); }
	//! (description missing)
	bool set_default_color(const AColor& texture) { return setValue("default_color", texture); }
	//! (description missing)
	Value get_default_color() const { return getValue("default_color"); }
};

class TexMix : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexMix"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! First color
 	bool set_color1(const Plugin& texture) { return setValue("color1", texture); }
	//! First color
 	bool set_color1(const AColor& texture) { return setValue("color1", texture); }
	//! First color
 	Value get_color1() const { return getValue("color1"); }

	//! Second color
 	bool set_color2(const Plugin& texture) { return setValue("color2", texture); }
	//! Second color
 	bool set_color2(const AColor& texture) { return setValue("color2", texture); }
	//! Second color
 	Value get_color2() const { return getValue("color2"); }

	//! Mix amount texture
 	bool set_mix_map(const Plugin& texture) { return setValue("mix_map", texture); }
	//! Mix amount texture
 	bool set_mix_map(const AColor& texture) { return setValue("mix_map", texture); }
	//! Mix amount texture
 	Value get_mix_map() const { return getValue("mix_map"); }

	//! Mix amount
 	//! [Default value] 0
	bool set_mix_amount(float val) { return setValue("mix_amount", val); }
	//! Mix amount
 	//! [Default value] 0
	float get_mix_amount() const { return getFloat("mix_amount"); }

	//! Transition zone - upper
 	//! [Default value] 0.7
	bool set_transition_upper(float val) { return setValue("transition_upper", val); }
	//! Transition zone - upper
 	//! [Default value] 0.7
	float get_transition_upper() const { return getFloat("transition_upper"); }

	//! Transition zone - lower
 	//! [Default value] 0.3
	bool set_transition_lower(float val) { return setValue("transition_lower", val); }
	//! Transition zone - lower
 	//! [Default value] 0.3
	float get_transition_lower() const { return getFloat("transition_lower"); }

	//! If true the blend curve is used
 	//! [Default value] 0
	bool set_use_curve(int val) { return setValue("use_curve", val); }
	//! If true the blend curve is used
 	//! [Default value] 0
	int get_use_curve() const { return getInt("use_curve"); }
};

class TexModoBlendLayersColor : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexModoBlendLayersColor"; }

	//! The opacity for the foreground layer.
 	//! [Default value] 1
	bool set_opacity(float val) { return setValue("opacity", val); }
	//! The opacity for the foreground layer.
 	//! [Default value] 1
	float get_opacity() const { return getFloat("opacity"); }

	//! Opacity mask for the foreground layer. This is multiplied by the opacity parameter but can be a texture.
 	bool set_mask(const Plugin& texturefloat) { return setValue("mask", texturefloat); }
	//! Opacity mask for the foreground layer. This is multiplied by the opacity parameter but can be a texture.
 	bool set_mask(float texturefloat) { return setValue("mask", texturefloat); }
	//! Opacity mask for the foreground layer. This is multiplied by the opacity parameter but can be a texture.
 	Value get_mask() const { return getValue("mask"); }

	//! 0:Normal, 1:Average, 2:Add, 3:Subtract, 4:Darken, 5:Multiply, 6:Color burn, 7:Linear burn, 8:Lighten, 9:Screen, 10:Color Dodge, 11:Linear Dodge, 12:Spotlite, 13:Spotlite blend, 14:Overlay, 15:Softlight, 16:Hardlight, 17:Pinlight, 18:Hardmix, 19:Difference, 20:Exclusion, 21:Hue, 22:Saturation, 23:Color, 24:Value
 	//! [UI Guides] enum=0:Normal; 1:Average; 2:Add; 3:Subtract; 4:Darken; 5:Multiply; 6:Color burn; 7:Linear burn; 8:Lighten; 9:Screen; 10:Color Dodge; 11:Linear Dodge; 12:Spotlite; 13:Spotlite blend; 14:Overlay; 15:Softlight; 16:Hardlight; 17:Pinlight; 18:Hardmix; 19:Difference; 20:Exclusion; 21:Hue; 22:Saturation; 23:Color; 24:Value
 	//! [Default value] 0
	bool set_blend_mode(int val) { return setValue("blend_mode", val); }
	//! 0:Normal, 1:Average, 2:Add, 3:Subtract, 4:Darken, 5:Multiply, 6:Color burn, 7:Linear burn, 8:Lighten, 9:Screen, 10:Color Dodge, 11:Linear Dodge, 12:Spotlite, 13:Spotlite blend, 14:Overlay, 15:Softlight, 16:Hardlight, 17:Pinlight, 18:Hardmix, 19:Difference, 20:Exclusion, 21:Hue, 22:Saturation, 23:Color, 24:Value
 	//! [UI Guides] enum=0:Normal; 1:Average; 2:Add; 3:Subtract; 4:Darken; 5:Multiply; 6:Color burn; 7:Linear burn; 8:Lighten; 9:Screen; 10:Color Dodge; 11:Linear Dodge; 12:Spotlite; 13:Spotlite blend; 14:Overlay; 15:Softlight; 16:Hardlight; 17:Pinlight; 18:Hardmix; 19:Difference; 20:Exclusion; 21:Hue; 22:Saturation; 23:Color; 24:Value
 	//! [Default value] 0
	int get_blend_mode() const { return getInt("blend_mode"); }

	//! (description missing)
	bool set_background(const Plugin& texture) { return setValue("background", texture); }
	//! (description missing)
	bool set_background(const AColor& texture) { return setValue("background", texture); }
	//! (description missing)
	Value get_background() const { return getValue("background"); }

	//! (description missing)
	bool set_foreground(const Plugin& texture) { return setValue("foreground", texture); }
	//! (description missing)
	bool set_foreground(const AColor& texture) { return setValue("foreground", texture); }
	//! (description missing)
	Value get_foreground() const { return getValue("foreground"); }
};

class TexModoBlendLayersScalar : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexModoBlendLayersScalar"; }

	//! The opacity for the foreground layer.
 	//! [Default value] 1
	bool set_opacity(float val) { return setValue("opacity", val); }
	//! The opacity for the foreground layer.
 	//! [Default value] 1
	float get_opacity() const { return getFloat("opacity"); }

	//! Opacity mask for the foreground layer. This is multiplied by the opacity parameter but can be a texture.
 	bool set_mask(const Plugin& texturefloat) { return setValue("mask", texturefloat); }
	//! Opacity mask for the foreground layer. This is multiplied by the opacity parameter but can be a texture.
 	bool set_mask(float texturefloat) { return setValue("mask", texturefloat); }
	//! Opacity mask for the foreground layer. This is multiplied by the opacity parameter but can be a texture.
 	Value get_mask() const { return getValue("mask"); }

	//! 0:Normal, 1:Average, 2:Add, 3:Subtract, 4:Darken, 5:Multiply, 6:Color burn, 7:Linear burn, 8:Lighten, 9:Screen, 10:Color Dodge, 11:Linear Dodge, 12:Spotlite, 13:Spotlite blend, 14:Overlay, 15:Softlight, 16:Hardlight, 17:Pinlight, 18:Hardmix, 19:Difference, 20:Exclusion, 21:Hue, 22:Saturation, 23:Color, 24:Value
 	//! [UI Guides] enum=0:Normal; 1:Average; 2:Add; 3:Subtract; 4:Darken; 5:Multiply; 6:Color burn; 7:Linear burn; 8:Lighten; 9:Screen; 10:Color Dodge; 11:Linear Dodge; 12:Spotlite; 13:Spotlite blend; 14:Overlay; 15:Softlight; 16:Hardlight; 17:Pinlight; 18:Hardmix; 19:Difference; 20:Exclusion; 21:Hue; 22:Saturation; 23:Color; 24:Value
 	//! [Default value] 0
	bool set_blend_mode(int val) { return setValue("blend_mode", val); }
	//! 0:Normal, 1:Average, 2:Add, 3:Subtract, 4:Darken, 5:Multiply, 6:Color burn, 7:Linear burn, 8:Lighten, 9:Screen, 10:Color Dodge, 11:Linear Dodge, 12:Spotlite, 13:Spotlite blend, 14:Overlay, 15:Softlight, 16:Hardlight, 17:Pinlight, 18:Hardmix, 19:Difference, 20:Exclusion, 21:Hue, 22:Saturation, 23:Color, 24:Value
 	//! [UI Guides] enum=0:Normal; 1:Average; 2:Add; 3:Subtract; 4:Darken; 5:Multiply; 6:Color burn; 7:Linear burn; 8:Lighten; 9:Screen; 10:Color Dodge; 11:Linear Dodge; 12:Spotlite; 13:Spotlite blend; 14:Overlay; 15:Softlight; 16:Hardlight; 17:Pinlight; 18:Hardmix; 19:Difference; 20:Exclusion; 21:Hue; 22:Saturation; 23:Color; 24:Value
 	//! [Default value] 0
	int get_blend_mode() const { return getInt("blend_mode"); }

	//! (description missing)
	bool set_background(const Plugin& texturefloat) { return setValue("background", texturefloat); }
	//! (description missing)
	bool set_background(float texturefloat) { return setValue("background", texturefloat); }
	//! (description missing)
	Value get_background() const { return getValue("background"); }

	//! (description missing)
	bool set_foreground(const Plugin& texturefloat) { return setValue("foreground", texturefloat); }
	//! (description missing)
	bool set_foreground(float texturefloat) { return setValue("foreground", texturefloat); }
	//! (description missing)
	Value get_foreground() const { return getValue("foreground"); }

	//! If this parameter is not NULL it will be used instead of the 'foreground' parameter.The luminance of the returned color will be used, together with the alpha as a mask.
 	bool set_foreground_color(const Plugin& texture) { return setValue("foreground_color", texture); }
	//! If this parameter is not NULL it will be used instead of the 'foreground' parameter.The luminance of the returned color will be used, together with the alpha as a mask.
 	bool set_foreground_color(const AColor& texture) { return setValue("foreground_color", texture); }
	//! If this parameter is not NULL it will be used instead of the 'foreground' parameter.The luminance of the returned color will be used, together with the alpha as a mask.
 	Value get_foreground_color() const { return getValue("foreground_color"); }
};

class TexModoChanModColorCorrect : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexModoChanModColorCorrect"; }

	//! The input color
 	bool set_input_color(const Plugin& texture) { return setValue("input_color", texture); }
	//! The input color
 	bool set_input_color(const AColor& texture) { return setValue("input_color", texture); }
	//! The input color
 	Value get_input_color() const { return getValue("input_color"); }

	//! (description missing)
	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! (description missing)
	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! The hue adjustment. This is in degrees.
 	//! [UI Guides] minValue=-180.0f, maxValue=180.0f
 	bool set_hue(const Plugin& texturefloat) { return setValue("hue", texturefloat); }
	//! The hue adjustment. This is in degrees.
 	//! [UI Guides] minValue=-180.0f, maxValue=180.0f
 	bool set_hue(float texturefloat) { return setValue("hue", texturefloat); }
	//! The hue adjustment. This is in degrees.
 	//! [UI Guides] minValue=-180.0f, maxValue=180.0f
 	Value get_hue() const { return getValue("hue"); }

	//! The saturation adjustment.
 	//! [UI Guides] minValue=-1.0f, maxValue=1.0f
 	bool set_saturation(const Plugin& texturefloat) { return setValue("saturation", texturefloat); }
	//! The saturation adjustment.
 	//! [UI Guides] minValue=-1.0f, maxValue=1.0f
 	bool set_saturation(float texturefloat) { return setValue("saturation", texturefloat); }
	//! The saturation adjustment.
 	//! [UI Guides] minValue=-1.0f, maxValue=1.0f
 	Value get_saturation() const { return getValue("saturation"); }

	//! The value adjustment.
 	//! [UI Guides] minValue=-1.0f, maxValue=1.0f
 	bool set_value(const Plugin& texturefloat) { return setValue("value", texturefloat); }
	//! The value adjustment.
 	//! [UI Guides] minValue=-1.0f, maxValue=1.0f
 	bool set_value(float texturefloat) { return setValue("value", texturefloat); }
	//! The value adjustment.
 	//! [UI Guides] minValue=-1.0f, maxValue=1.0f
 	Value get_value() const { return getValue("value"); }

	//! The color balance adjustment.
 	bool set_color_balance(const Plugin& texture) { return setValue("color_balance", texture); }
	//! The color balance adjustment.
 	bool set_color_balance(const AColor& texture) { return setValue("color_balance", texture); }
	//! The color balance adjustment.
 	Value get_color_balance() const { return getValue("color_balance"); }

	//! The curve adjustment - must support the EXT_REMAP_FLOAT_TO_FLOAT interface.
 	bool set_curve(const Plugin& plugin) { return setValue("curve", plugin); }
	//! The curve adjustment - must support the EXT_REMAP_FLOAT_TO_FLOAT interface.
 	Plugin get_curve() const { return getPlugin("curve"); }
};

class TexModoChanModLogic : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexModoChanModLogic"; }

	//! [UI Guides] enum=0:Equal;1:Not equal;2:Greater than;3:Less than;4:Greater than or equal;5:Less than or equal;6:And;7:Or
 	//! [Default value] 0
	bool set_op(int val) { return setValue("op", val); }
	//! [UI Guides] enum=0:Equal;1:Not equal;2:Greater than;3:Less than;4:Greater than or equal;5:Less than or equal;6:And;7:Or
 	//! [Default value] 0
	int get_op() const { return getInt("op"); }

	//! Determines what value to return when the result of the operation is 'true'
 	//! [UI Guides] enum=0:input1;1:intpu2;2:value_true
 	//! [Default value] 0
	bool set_option_true(int val) { return setValue("option_true", val); }
	//! Determines what value to return when the result of the operation is 'true'
 	//! [UI Guides] enum=0:input1;1:intpu2;2:value_true
 	//! [Default value] 0
	int get_option_true() const { return getInt("option_true"); }

	//! Determines what value to return when the result of the operation is 'false'
 	//! [UI Guides] enum=0:input1;1:intpu2;2:value_false
 	//! [Default value] 0
	bool set_option_false(int val) { return setValue("option_false", val); }
	//! Determines what value to return when the result of the operation is 'false'
 	//! [UI Guides] enum=0:input1;1:intpu2;2:value_false
 	//! [Default value] 0
	int get_option_false() const { return getInt("option_false"); }

	//! (description missing)
	bool set_input1(const Plugin& texturefloat) { return setValue("input1", texturefloat); }
	//! (description missing)
	bool set_input1(float texturefloat) { return setValue("input1", texturefloat); }
	//! (description missing)
	Value get_input1() const { return getValue("input1"); }

	//! (description missing)
	bool set_input2(const Plugin& texturefloat) { return setValue("input2", texturefloat); }
	//! (description missing)
	bool set_input2(float texturefloat) { return setValue("input2", texturefloat); }
	//! (description missing)
	Value get_input2() const { return getValue("input2"); }

	//! (description missing)
	bool set_value_true(const Plugin& texturefloat) { return setValue("value_true", texturefloat); }
	//! (description missing)
	bool set_value_true(float texturefloat) { return setValue("value_true", texturefloat); }
	//! (description missing)
	Value get_value_true() const { return getValue("value_true"); }

	//! (description missing)
	bool set_value_false(const Plugin& texturefloat) { return setValue("value_false", texturefloat); }
	//! (description missing)
	bool set_value_false(float texturefloat) { return setValue("value_false", texturefloat); }
	//! (description missing)
	Value get_value_false() const { return getValue("value_false"); }
};

class TexModoDiffuseRoughness : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexModoDiffuseRoughness"; }

	//! (description missing)
	bool set_modo_diffuse_roughness(const Plugin& texturefloat) { return setValue("modo_diffuse_roughness", texturefloat); }
	//! (description missing)
	bool set_modo_diffuse_roughness(float texturefloat) { return setValue("modo_diffuse_roughness", texturefloat); }
	//! (description missing)
	Value get_modo_diffuse_roughness() const { return getValue("modo_diffuse_roughness"); }
};

class TexModoEnvironmentColor : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexModoEnvironmentColor"; }

	//! 0 : Constant, 1 : 2 Color Gradient, 2 : 4 Color Gradient, 3 : CIE Overcast Sky, 4 : Physically-based Daylight
 	//! [UI Guides] enum=0:Constant; 1:2 Color Gradient; 2:4 Color Gradient; 3:CIE Overcast Sky; 4:Physically-based Daylight;
 	//! [Default value] 2
	bool set_type(int val) { return setValue("type", val); }
	//! 0 : Constant, 1 : 2 Color Gradient, 2 : 4 Color Gradient, 3 : CIE Overcast Sky, 4 : Physically-based Daylight
 	//! [UI Guides] enum=0:Constant; 1:2 Color Gradient; 2:4 Color Gradient; 3:CIE Overcast Sky; 4:Physically-based Daylight;
 	//! [Default value] 2
	int get_type() const { return getInt("type"); }

	//! (description missing)
	//! [Default value] Color(0.9, 0.9, 0.9)
	bool set_zenith_color(const Color& color) { return setValue("zenith_color", color); }
	//! (description missing)
	//! [Default value] Color(0.9, 0.9, 0.9)
	Color get_zenith_color() const { return getColor("zenith_color"); }

	//! (description missing)
	//! [Default value] Color(0.34, 0.34, 0.34)
	bool set_sky_color(const Color& color) { return setValue("sky_color", color); }
	//! (description missing)
	//! [Default value] Color(0.34, 0.34, 0.34)
	Color get_sky_color() const { return getColor("sky_color"); }

	//! (description missing)
	//! [Default value] Color(0.34, 0.34, 0.34)
	bool set_ground_color(const Color& color) { return setValue("ground_color", color); }
	//! (description missing)
	//! [Default value] Color(0.34, 0.34, 0.34)
	Color get_ground_color() const { return getColor("ground_color"); }

	//! (description missing)
	//! [Default value] Color(0.03, 0.03, 0.03)
	bool set_nadir_color(const Color& color) { return setValue("nadir_color", color); }
	//! (description missing)
	//! [Default value] Color(0.03, 0.03, 0.03)
	Color get_nadir_color() const { return getColor("nadir_color"); }

	//! (description missing)
	//! [Default value] 4
	bool set_sky_exponent(float val) { return setValue("sky_exponent", val); }
	//! (description missing)
	//! [Default value] 4
	float get_sky_exponent() const { return getFloat("sky_exponent"); }

	//! (description missing)
	//! [Default value] 4
	bool set_ground_exponent(float val) { return setValue("ground_exponent", val); }
	//! (description missing)
	//! [Default value] 4
	float get_ground_exponent() const { return getFloat("ground_exponent"); }

	//! Used when type is 4 (physically-based daylight). Should point to a texture plug-in of type TexSky.
 	bool set_sky_tex(const Plugin& texture) { return setValue("sky_tex", texture); }
	//! Used when type is 4 (physically-based daylight). Should point to a texture plug-in of type TexSky.
 	bool set_sky_tex(const AColor& texture) { return setValue("sky_tex", texture); }
	//! Used when type is 4 (physically-based daylight). Should point to a texture plug-in of type TexSky.
 	Value get_sky_tex() const { return getValue("sky_tex"); }

	//! True to clamp the physical sky brightness.
 	//! [Default value] false
	bool set_sky_clamp_brightness(bool val) { return setValue("sky_clamp_brightness", val); }
	//! True to clamp the physical sky brightness.
 	//! [Default value] false
	bool get_sky_clamp_brightness() const { return getBool("sky_clamp_brightness"); }
};

class TexModoExtractAlpha : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexModoExtractAlpha"; }

	//! (description missing)
	bool set_texture(const Plugin& texture) { return setValue("texture", texture); }
	//! (description missing)
	bool set_texture(const AColor& texture) { return setValue("texture", texture); }
	//! (description missing)
	Value get_texture() const { return getValue("texture"); }
};

class TexModoExtractColor : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexModoExtractColor"; }

	//! (description missing)
	bool set_texture(const Plugin& texture) { return setValue("texture", texture); }
	//! (description missing)
	bool set_texture(const AColor& texture) { return setValue("texture", texture); }
	//! (description missing)
	Value get_texture() const { return getValue("texture"); }
};

class TexModoFresnelSchlick : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexModoFresnelSchlick"; }

	//! Amount of reflection when the viewing and normal vectors are the same.
 	//! [UI Guides] enableIf: ?use_ior=0
 	bool set_reflectivity_at_normal(const Plugin& texturefloat) { return setValue("reflectivity_at_normal", texturefloat); }
	//! Amount of reflection when the viewing and normal vectors are the same.
 	//! [UI Guides] enableIf: ?use_ior=0
 	bool set_reflectivity_at_normal(float texturefloat) { return setValue("reflectivity_at_normal", texturefloat); }
	//! Amount of reflection when the viewing and normal vectors are the same.
 	//! [UI Guides] enableIf: ?use_ior=0
 	Value get_reflectivity_at_normal() const { return getValue("reflectivity_at_normal"); }

	//! How much the Schlick fresnel approximation affects the result. At 0.0, reflectivity_at_normal will be returned for all viewing directions.
 	bool set_fresnel_power(const Plugin& texturefloat) { return setValue("fresnel_power", texturefloat); }
	//! How much the Schlick fresnel approximation affects the result. At 0.0, reflectivity_at_normal will be returned for all viewing directions.
 	bool set_fresnel_power(float texturefloat) { return setValue("fresnel_power", texturefloat); }
	//! How much the Schlick fresnel approximation affects the result. At 0.0, reflectivity_at_normal will be returned for all viewing directions.
 	Value get_fresnel_power() const { return getValue("fresnel_power"); }

	//! If true, the ior paameter will be used to determine the reflectivity when the viewing and normal vectors are the same. In this case the reflectivity_at_normal parameter is ignored.
 	//! [Default value] false
	bool set_use_ior(bool val) { return setValue("use_ior", val); }
	//! If true, the ior paameter will be used to determine the reflectivity when the viewing and normal vectors are the same. In this case the reflectivity_at_normal parameter is ignored.
 	//! [Default value] false
	bool get_use_ior() const { return getBool("use_ior"); }

	//! Used to compute the reflectivity when use_ior is enabled.
 	//! [UI Guides] enableIf: ?use_ior=1
 	//! [Default value] 1
	bool set_ior(float val) { return setValue("ior", val); }
	//! Used to compute the reflectivity when use_ior is enabled.
 	//! [UI Guides] enableIf: ?use_ior=1
 	//! [Default value] 1
	float get_ior() const { return getFloat("ior"); }
};

class TexModoInvert : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexModoInvert"; }

	//! The texture to be inverted.
 	bool set_texture(const Plugin& texture) { return setValue("texture", texture); }
	//! The texture to be inverted.
 	bool set_texture(const AColor& texture) { return setValue("texture", texture); }
	//! The texture to be inverted.
 	Value get_texture() const { return getValue("texture"); }

	//! Parameter that enables the inverting to be animated.
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! Parameter that enables the inverting to be animated.
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }
};

class TexModoInvertChannels : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexModoInvertChannels"; }

	//! (description missing)
	bool set_texture(const Plugin& texture) { return setValue("texture", texture); }
	//! (description missing)
	bool set_texture(const AColor& texture) { return setValue("texture", texture); }
	//! (description missing)
	Value get_texture() const { return getValue("texture"); }

	//! (description missing)
	//! [Default value] false
	bool set_invert_red(bool val) { return setValue("invert_red", val); }
	//! (description missing)
	//! [Default value] false
	bool get_invert_red() const { return getBool("invert_red"); }

	//! (description missing)
	//! [Default value] false
	bool set_invert_green(bool val) { return setValue("invert_green", val); }
	//! (description missing)
	//! [Default value] false
	bool get_invert_green() const { return getBool("invert_green"); }

	//! (description missing)
	//! [Default value] false
	bool set_invert_blue(bool val) { return setValue("invert_blue", val); }
	//! (description missing)
	//! [Default value] false
	bool get_invert_blue() const { return getBool("invert_blue"); }
};

class TexModoInvertFloat : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexModoInvertFloat"; }

	//! The texture to be inverted.
 	bool set_texture(const Plugin& texturefloat) { return setValue("texture", texturefloat); }
	//! The texture to be inverted.
 	bool set_texture(float texturefloat) { return setValue("texture", texturefloat); }
	//! The texture to be inverted.
 	Value get_texture() const { return getValue("texture"); }

	//! Parameter that enables the inverting to be animated.
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! Parameter that enables the inverting to be animated.
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }
};

class TexModoLowHigh : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexModoLowHigh"; }

	//! The texture to be remapped. The texture's alpha is unaffected by the remapping.
 	bool set_texture(const Plugin& texture) { return setValue("texture", texture); }
	//! The texture to be remapped. The texture's alpha is unaffected by the remapping.
 	bool set_texture(const AColor& texture) { return setValue("texture", texture); }
	//! The texture to be remapped. The texture's alpha is unaffected by the remapping.
 	Value get_texture() const { return getValue("texture"); }

	//! The new value for texture samples equal to 0.
 	//! [Default value] 0
	bool set_low(float val) { return setValue("low", val); }
	//! The new value for texture samples equal to 0.
 	//! [Default value] 0
	float get_low() const { return getFloat("low"); }

	//! The new value for texture samples equal to 1.
 	//! [Default value] 1
	bool set_high(float val) { return setValue("high", val); }
	//! The new value for texture samples equal to 1.
 	//! [Default value] 1
	float get_high() const { return getFloat("high"); }
};

class TexModoMaxColorComponent : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexModoMaxColorComponent"; }

	//! (description missing)
	bool set_color1(const Plugin& texture) { return setValue("color1", texture); }
	//! (description missing)
	bool set_color1(const AColor& texture) { return setValue("color1", texture); }
	//! (description missing)
	Value get_color1() const { return getValue("color1"); }

	//! (description missing)
	bool set_color2(const Plugin& texture) { return setValue("color2", texture); }
	//! (description missing)
	bool set_color2(const AColor& texture) { return setValue("color2", texture); }
	//! (description missing)
	Value get_color2() const { return getValue("color2"); }
};

class TexModoOpacityToVRayWeight : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexModoOpacityToVRayWeight"; }

	//! (description missing)
	//! [Default value] 1
	bool set_opacity(float val) { return setValue("opacity", val); }
	//! (description missing)
	//! [Default value] 1
	float get_opacity() const { return getFloat("opacity"); }

	//! (description missing)
	bool set_layer_mask(const Plugin& texturefloat) { return setValue("layer_mask", texturefloat); }
	//! (description missing)
	bool set_layer_mask(float texturefloat) { return setValue("layer_mask", texturefloat); }
	//! (description missing)
	Value get_layer_mask() const { return getValue("layer_mask"); }
};

class TexModoProcess : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexModoProcess"; }

	//! (description missing)
	bool set_base_texture(const Plugin& texture) { return setValue("base_texture", texture); }
	//! (description missing)
	bool set_base_texture(const AColor& texture) { return setValue("base_texture", texture); }
	//! (description missing)
	Value get_base_texture() const { return getValue("base_texture"); }

	//! (description missing)
	//! [Default value] 0.5
	bool set_bias(float val) { return setValue("bias", val); }
	//! (description missing)
	//! [Default value] 0.5
	float get_bias() const { return getFloat("bias"); }

	//! (description missing)
	//! [Default value] 0.5
	bool set_gain(float val) { return setValue("gain", val); }
	//! (description missing)
	//! [Default value] 0.5
	float get_gain() const { return getFloat("gain"); }

	//! (description missing)
	//! [Default value] 0
	bool set_hue(float val) { return setValue("hue", val); }
	//! (description missing)
	//! [Default value] 0
	float get_hue() const { return getFloat("hue"); }

	//! (description missing)
	//! [Default value] 0
	bool set_hueShift(float val) { return setValue("hueShift", val); }
	//! (description missing)
	//! [Default value] 0
	float get_hueShift() const { return getFloat("hueShift"); }

	//! (description missing)
	//! [Default value] 0
	bool set_sat(float val) { return setValue("sat", val); }
	//! (description missing)
	//! [Default value] 0
	float get_sat() const { return getFloat("sat"); }

	//! (description missing)
	//! [Default value] 0
	bool set_val(float val) { return setValue("val", val); }
	//! (description missing)
	//! [Default value] 0
	float get_val() const { return getFloat("val"); }
};

class TexModoProcessFloat : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexModoProcessFloat"; }

	//! (description missing)
	bool set_base_texture(const Plugin& texturefloat) { return setValue("base_texture", texturefloat); }
	//! (description missing)
	bool set_base_texture(float texturefloat) { return setValue("base_texture", texturefloat); }
	//! (description missing)
	Value get_base_texture() const { return getValue("base_texture"); }

	//! (description missing)
	//! [Default value] 0.5
	bool set_bias(float val) { return setValue("bias", val); }
	//! (description missing)
	//! [Default value] 0.5
	float get_bias() const { return getFloat("bias"); }

	//! (description missing)
	//! [Default value] 0.5
	bool set_gain(float val) { return setValue("gain", val); }
	//! (description missing)
	//! [Default value] 0.5
	float get_gain() const { return getFloat("gain"); }
};

class TexModoRayType : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexModoRayType"; }
};

class TexModoReflectionRoughness : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexModoReflectionRoughness"; }

	//! (description missing)
	//! [Default value] false
	bool set_blurry_reflections(bool val) { return setValue("blurry_reflections", val); }
	//! (description missing)
	//! [Default value] false
	bool get_blurry_reflections() const { return getBool("blurry_reflections"); }

	//! (description missing)
	bool set_modo_reflection_roughness(const Plugin& texturefloat) { return setValue("modo_reflection_roughness", texturefloat); }
	//! (description missing)
	bool set_modo_reflection_roughness(float texturefloat) { return setValue("modo_reflection_roughness", texturefloat); }
	//! (description missing)
	Value get_modo_reflection_roughness() const { return getValue("modo_reflection_roughness"); }
};

class TexModoRefractionRoughness : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexModoRefractionRoughness"; }

	//! (description missing)
	bool set_modo_refraction_roughness(const Plugin& texturefloat) { return setValue("modo_refraction_roughness", texturefloat); }
	//! (description missing)
	bool set_modo_refraction_roughness(float texturefloat) { return setValue("modo_refraction_roughness", texturefloat); }
	//! (description missing)
	Value get_modo_refraction_roughness() const { return getValue("modo_refraction_roughness"); }
};

class TexModoSampler : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexModoSampler"; }

	//! Locator transformation.
 	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	bool set_locatorTransform(const Transform& transform) { return setValue("locatorTransform", transform); }
	//! Locator transformation.
 	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	Transform get_locatorTransform() const { return getTransform("locatorTransform"); }

	//! (description missing)
	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! (description missing)
	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }
};

class TexModoSpecularRoughness : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexModoSpecularRoughness"; }

	//! (description missing)
	bool set_modo_specular_roughness(const Plugin& texturefloat) { return setValue("modo_specular_roughness", texturefloat); }
	//! (description missing)
	bool set_modo_specular_roughness(float texturefloat) { return setValue("modo_specular_roughness", texturefloat); }
	//! (description missing)
	Value get_modo_specular_roughness() const { return getValue("modo_specular_roughness"); }
};

class TexModoStencil : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexModoStencil"; }

	//! The base texture.
 	bool set_base_tex(const Plugin& texturefloat) { return setValue("base_tex", texturefloat); }
	//! The base texture.
 	bool set_base_tex(float texturefloat) { return setValue("base_tex", texturefloat); }
	//! The base texture.
 	Value get_base_tex() const { return getValue("base_tex"); }

	//! The stencil texture. Where stencil_tex is < 0.5 the result color is taken from base_tex, where stencil_tex is >= 0.5 the result is taken from stenciled_value.
 	bool set_stencil_tex(const Plugin& texturefloat) { return setValue("stencil_tex", texturefloat); }
	//! The stencil texture. Where stencil_tex is < 0.5 the result color is taken from base_tex, where stencil_tex is >= 0.5 the result is taken from stenciled_value.
 	bool set_stencil_tex(float texturefloat) { return setValue("stencil_tex", texturefloat); }
	//! The stencil texture. Where stencil_tex is < 0.5 the result color is taken from base_tex, where stencil_tex is >= 0.5 the result is taken from stenciled_value.
 	Value get_stencil_tex() const { return getValue("stencil_tex"); }

	//! The result where stencil_tex is >= 0.5 .
 	//! [Default value] 0
	bool set_stenciled_value(float val) { return setValue("stenciled_value", val); }
	//! The result where stencil_tex is >= 0.5 .
 	//! [Default value] 0
	float get_stenciled_value() const { return getFloat("stenciled_value"); }
};

class TexModoSwizzle : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexModoSwizzle"; }

	//! The texture to be swizzled.
 	bool set_texture(const Plugin& texture) { return setValue("texture", texture); }
	//! The texture to be swizzled.
 	bool set_texture(const AColor& texture) { return setValue("texture", texture); }
	//! The texture to be swizzled.
 	Value get_texture() const { return getValue("texture"); }

	//! The swizzling mode. 0 - (RRR1), 1 - (GGG1), 2 - (BBB1), 3 - (AAA1)
 	//! [UI Guides] displayName=Swizzling mode, enum=0:Red;1:Green;2:Blue;3:Alpha
 	//! [Default value] 0
	bool set_mode(int val) { return setValue("mode", val); }
	//! The swizzling mode. 0 - (RRR1), 1 - (GGG1), 2 - (BBB1), 3 - (AAA1)
 	//! [UI Guides] displayName=Swizzling mode, enum=0:Red;1:Green;2:Blue;3:Alpha
 	//! [Default value] 0
	int get_mode() const { return getInt("mode"); }
};

class TexModoUVResetAndFalloff : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexModoUVResetAndFalloff"; }

	//! (description missing)
	bool set_texture(const Plugin& texture) { return setValue("texture", texture); }
	//! (description missing)
	bool set_texture(const AColor& texture) { return setValue("texture", texture); }
	//! (description missing)
	Value get_texture() const { return getValue("texture"); }

	//! This must be the same uvw generator used by 'texture'.
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! This must be the same uvw generator used by 'texture'.
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! (description missing)
	//! [Default value] false
	bool set_reset_u(bool val) { return setValue("reset_u", val); }
	//! (description missing)
	//! [Default value] false
	bool get_reset_u() const { return getBool("reset_u"); }

	//! (description missing)
	//! [Default value] false
	bool set_reset_v(bool val) { return setValue("reset_v", val); }
	//! (description missing)
	//! [Default value] false
	bool get_reset_v() const { return getBool("reset_v"); }
};

class TexMotionOcclusion : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexMotionOcclusion"; }

	//! Determines what to output as default texture: 0 - backward occlusion, 1 - forward occlusion
 	//! [Default value] 0
	bool set_type(int val) { return setValue("type", val); }
	//! Determines what to output as default texture: 0 - backward occlusion, 1 - forward occlusion
 	//! [Default value] 0
	int get_type() const { return getInt("type"); }

	//! Occlusion hits closer than this distance will be ignored for backward and forward motion occlusion
 	//! [Default value] 1
	bool set_near_threshold(float val) { return setValue("near_threshold", val); }
	//! Occlusion hits closer than this distance will be ignored for backward and forward motion occlusion
 	//! [Default value] 1
	float get_near_threshold() const { return getFloat("near_threshold"); }

	//! Occlusion hits farther than this distance will be fully considered for backward and forward motion occlusion
 	//! [Default value] 2
	bool set_far_threshold(float val) { return setValue("far_threshold", val); }
	//! Occlusion hits farther than this distance will be fully considered for backward and forward motion occlusion
 	//! [Default value] 2
	float get_far_threshold() const { return getFloat("far_threshold"); }
};

class TexMulti : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexMulti"; }

	//! A list of the sub-textures.
 	bool set_textures_list(const ValueList& pluginList) { return setValue("textures_list", pluginList); }
	//! A list of the sub-textures.
 	ValueList get_textures_list() const { return getValueList("textures_list"); }

	//! A list of material/object IDs
 	//! [Default value] 0
	bool set_ids_list(const IntList& intList) { return setValue("ids_list", intList); }
	//! A list of material/object IDs
 	//! [Default value] 0
	bool set_ids_list(const int* ints, size_t count) { return setArray("ids_list", ints, count); }
	//! A list of material/object IDs
 	//! [Default value] 0
	template<size_t count> bool set_ids_list(const int (&ints)[count]) { return setArray("ids_list", ints, count); }
	//! A list of material/object IDs
 	//! [Default value] 0
	IntList get_ids_list() const { return getIntList("ids_list"); }

	//! The mode for the texture (0 - use face material ID, 1 - use object ID, 2 - random by node handle, 3 - random by render id, 4 - random by node name, 6 - random by instance ID, 30 - the ID is taken from the ID generator texture(id_gen_tex))
 	//! [UI Guides] enum=0:Face material ID; 1:Object ID; 2:Random by node handle; 3:Random by render ID; 4:Random by node name; 6:Random by instance ID; 30: Use ID Generator texture
 	//! [Default value] 0
	bool set_mode(int val) { return setValue("mode", val); }
	//! The mode for the texture (0 - use face material ID, 1 - use object ID, 2 - random by node handle, 3 - random by render id, 4 - random by node name, 6 - random by instance ID, 30 - the ID is taken from the ID generator texture(id_gen_tex))
 	//! [UI Guides] enum=0:Face material ID; 1:Object ID; 2:Random by node handle; 3:Random by render ID; 4:Random by node name; 6:Random by instance ID; 30: Use ID Generator texture
 	//! [Default value] 0
	int get_mode() const { return getInt("mode"); }

	//! The default texture color
 	bool set_default_texture(const Plugin& texture) { return setValue("default_texture", texture); }
	//! The default texture color
 	bool set_default_texture(const AColor& texture) { return setValue("default_texture", texture); }
	//! The default texture color
 	Value get_default_texture() const { return getValue("default_texture"); }

	//! Used when mode is "Use ID Generator texture"(30)
 	//! [UI Guides] displayName=ID Generator texture, enableIf: ?mode=30
 	bool set_id_gen_tex(const Plugin& texturefloat) { return setValue("id_gen_tex", texturefloat); }
	//! Used when mode is "Use ID Generator texture"(30)
 	//! [UI Guides] displayName=ID Generator texture, enableIf: ?mode=30
 	bool set_id_gen_tex(float texturefloat) { return setValue("id_gen_tex", texturefloat); }
	//! Used when mode is "Use ID Generator texture"(30)
 	//! [UI Guides] displayName=ID Generator texture, enableIf: ?mode=30
 	Value get_id_gen_tex() const { return getValue("id_gen_tex"); }

	//! Used when mode is "Use ID Generator texture"(30)
 	//! [UI Guides] enableIf: ?mode=30
 	//! [Default value] false
	bool set_interpolate(bool val) { return setValue("interpolate", val); }
	//! Used when mode is "Use ID Generator texture"(30)
 	//! [UI Guides] enableIf: ?mode=30
 	//! [Default value] false
	bool get_interpolate() const { return getBool("interpolate"); }
};

class TexMultiFloat : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexMultiFloat"; }

	//! A list of the sub-float-textures.
 	bool set_textures_list(const ValueList& pluginList) { return setValue("textures_list", pluginList); }
	//! A list of the sub-float-textures.
 	ValueList get_textures_list() const { return getValueList("textures_list"); }

	//! A list of material/object IDs
 	//! [Default value] 0
	bool set_ids_list(const IntList& intList) { return setValue("ids_list", intList); }
	//! A list of material/object IDs
 	//! [Default value] 0
	bool set_ids_list(const int* ints, size_t count) { return setArray("ids_list", ints, count); }
	//! A list of material/object IDs
 	//! [Default value] 0
	template<size_t count> bool set_ids_list(const int (&ints)[count]) { return setArray("ids_list", ints, count); }
	//! A list of material/object IDs
 	//! [Default value] 0
	IntList get_ids_list() const { return getIntList("ids_list"); }

	//! The mode for the texture (0 - use face material ID, 1 - use object ID, 2 - random by node handle, 3 - random by render id, 4 - random by node name, 6 - random by instance ID, 30 - the ID is taken from the ID generator texture(id_gen_tex))
 	//! [UI Guides] enum=0:Face material ID; 1:Object ID; 2:Random by node handle; 3:Random by render ID; 4:Random by node name; 6:Random by instance ID; 30: Use ID Generator texture
 	//! [Default value] 0
	bool set_mode(int val) { return setValue("mode", val); }
	//! The mode for the texture (0 - use face material ID, 1 - use object ID, 2 - random by node handle, 3 - random by render id, 4 - random by node name, 6 - random by instance ID, 30 - the ID is taken from the ID generator texture(id_gen_tex))
 	//! [UI Guides] enum=0:Face material ID; 1:Object ID; 2:Random by node handle; 3:Random by render ID; 4:Random by node name; 6:Random by instance ID; 30: Use ID Generator texture
 	//! [Default value] 0
	int get_mode() const { return getInt("mode"); }

	//! The default float texture color
 	bool set_default_texture(const Plugin& texturefloat) { return setValue("default_texture", texturefloat); }
	//! The default float texture color
 	bool set_default_texture(float texturefloat) { return setValue("default_texture", texturefloat); }
	//! The default float texture color
 	Value get_default_texture() const { return getValue("default_texture"); }

	//! Used when mode is "Use ID Generator texture"(30)
 	//! [UI Guides] displayName=ID Generator texture, enableIf: ?mode=30
 	bool set_id_gen_tex(const Plugin& texturefloat) { return setValue("id_gen_tex", texturefloat); }
	//! Used when mode is "Use ID Generator texture"(30)
 	//! [UI Guides] displayName=ID Generator texture, enableIf: ?mode=30
 	bool set_id_gen_tex(float texturefloat) { return setValue("id_gen_tex", texturefloat); }
	//! Used when mode is "Use ID Generator texture"(30)
 	//! [UI Guides] displayName=ID Generator texture, enableIf: ?mode=30
 	Value get_id_gen_tex() const { return getValue("id_gen_tex"); }

	//! Used when mode is "Use ID Generator texture"(30)
 	//! [UI Guides] enableIf: ?mode=30
 	//! [Default value] false
	bool set_interpolate(bool val) { return setValue("interpolate", val); }
	//! Used when mode is "Use ID Generator texture"(30)
 	//! [UI Guides] enableIf: ?mode=30
 	//! [Default value] false
	bool get_interpolate() const { return getBool("interpolate"); }
};

class TexMultiProjection : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexMultiProjection"; }

	//! The spherical projection textures; must be TexProjection
 	bool set_color_textures(const ValueList& textureList) { return setValue("color_textures", textureList); }
	//! The spherical projection textures; must be TexProjection
 	ValueList get_color_textures() const { return getValueList("color_textures"); }

	//! An offset for the zdepth value to avoid numeric errors
 	//! [Default value] 0.01
	bool set_zdepth_offset(float val) { return setValue("zdepth_offset", val); }
	//! An offset for the zdepth value to avoid numeric errors
 	//! [Default value] 0.01
	float get_zdepth_offset() const { return getFloat("zdepth_offset"); }

	//! The z-depth projection textures
 	bool set_zdepth_textures(const ValueList& textureList) { return setValue("zdepth_textures", textureList); }
	//! The z-depth projection textures
 	ValueList get_zdepth_textures() const { return getValueList("zdepth_textures"); }
};

class TexMultiX : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexMultiX"; }

	//! A list of the sub-textures.
 	bool set_textures_list(const ValueList& pluginList) { return setValue("textures_list", pluginList); }
	//! A list of the sub-textures.
 	ValueList get_textures_list() const { return getValueList("textures_list"); }

	//! A list of probabilities for the sub-textures.
 	//! [Default value] 0
	bool set_probs_list(const IntList& intList) { return setValue("probs_list", intList); }
	//! A list of probabilities for the sub-textures.
 	//! [Default value] 0
	bool set_probs_list(const int* ints, size_t count) { return setArray("probs_list", ints, count); }
	//! A list of probabilities for the sub-textures.
 	//! [Default value] 0
	template<size_t count> bool set_probs_list(const int (&ints)[count]) { return setArray("probs_list", ints, count); }
	//! A list of probabilities for the sub-textures.
 	//! [Default value] 0
	IntList get_probs_list() const { return getIntList("probs_list"); }

	//! Type of randomization
 	//! [Default value] 0
	bool set_rnd_by(int val) { return setValue("rnd_by", val); }
	//! Type of randomization
 	//! [Default value] 0
	int get_rnd_by() const { return getInt("rnd_by"); }

	//! Seed for the randomization
 	//! [Default value] 0
	bool set_rnd_seed(int val) { return setValue("rnd_seed", val); }
	//! Seed for the randomization
 	//! [Default value] 0
	int get_rnd_seed() const { return getInt("rnd_seed"); }

	//! Whether to use textures list or the flat color
 	//! [Default value] 0
	bool set_use_color(int val) { return setValue("use_color", val); }
	//! Whether to use textures list or the flat color
 	//! [Default value] 0
	int get_use_color() const { return getInt("use_color"); }

	//! Inverse of gamma, applied in all points
 	//! [Default value] 0
	bool set_all_gamma(float val) { return setValue("all_gamma", val); }
	//! Inverse of gamma, applied in all points
 	//! [Default value] 0
	float get_all_gamma() const { return getFloat("all_gamma"); }

	//! Hue applied in all points
 	//! [Default value] 0
	bool set_all_hue(float val) { return setValue("all_hue", val); }
	//! Hue applied in all points
 	//! [Default value] 0
	float get_all_hue() const { return getFloat("all_hue"); }

	//! Saturation applied in all points
 	//! [Default value] 0
	bool set_all_sat(float val) { return setValue("all_sat", val); }
	//! Saturation applied in all points
 	//! [Default value] 0
	float get_all_sat() const { return getFloat("all_sat"); }

	//! Inverse of gamma, applied randomly
 	//! [Default value] 0
	bool set_rnd_gamma(float val) { return setValue("rnd_gamma", val); }
	//! Inverse of gamma, applied randomly
 	//! [Default value] 0
	float get_rnd_gamma() const { return getFloat("rnd_gamma"); }

	//! Hue, applied randomly
 	//! [Default value] 0
	bool set_rnd_hue(float val) { return setValue("rnd_hue", val); }
	//! Hue, applied randomly
 	//! [Default value] 0
	float get_rnd_hue() const { return getFloat("rnd_hue"); }

	//! Saturation, applied randomly
 	//! [Default value] 0
	bool set_rnd_sat(float val) { return setValue("rnd_sat", val); }
	//! Saturation, applied randomly
 	//! [Default value] 0
	float get_rnd_sat() const { return getFloat("rnd_sat"); }

	//! Inverse of gamma, applied randomly
 	//! [Default value] 0
	bool set_occ_gamma(float val) { return setValue("occ_gamma", val); }
	//! Inverse of gamma, applied randomly
 	//! [Default value] 0
	float get_occ_gamma() const { return getFloat("occ_gamma"); }

	//! Hue, applied randomly
 	//! [Default value] 0
	bool set_occ_hue(float val) { return setValue("occ_hue", val); }
	//! Hue, applied randomly
 	//! [Default value] 0
	float get_occ_hue() const { return getFloat("occ_hue"); }

	//! Saturation, applied randomly
 	//! [Default value] 0
	bool set_occ_sat(float val) { return setValue("occ_sat", val); }
	//! Saturation, applied randomly
 	//! [Default value] 0
	float get_occ_sat() const { return getFloat("occ_sat"); }

	//! Color used for variations instead of textures
 	//! [Default value] Color(0, 0, 1)
	bool set_def_color(const Color& color) { return setValue("def_color", color); }
	//! Color used for variations instead of textures
 	//! [Default value] Color(0, 0, 1)
	Color get_def_color() const { return getColor("def_color"); }
};

class TexNoise : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexNoise"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! (description missing)
	//! [Default value] false
	bool set_use_3d_mapping(bool val) { return setValue("use_3d_mapping", val); }
	//! (description missing)
	//! [Default value] false
	bool get_use_3d_mapping() const { return getBool("use_3d_mapping"); }

	//! (description missing)
	//! [Default value] true
	bool set_wrap(bool val) { return setValue("wrap", val); }
	//! (description missing)
	//! [Default value] true
	bool get_wrap() const { return getBool("wrap"); }

	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	bool set_placement_type(int val) { return setValue("placement_type", val); }
	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	int get_placement_type() const { return getInt("placement_type"); }

	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_u(float val) { return setValue("u", val); }
	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_u() const { return getFloat("u"); }

	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_v(float val) { return setValue("v", val); }
	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_v() const { return getFloat("v"); }

	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_w(float val) { return setValue("w", val); }
	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_w() const { return getFloat("w"); }

	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_h(float val) { return setValue("h", val); }
	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_h() const { return getFloat("h"); }

	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	bool set_jitter(float val) { return setValue("jitter", val); }
	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	float get_jitter() const { return getFloat("jitter"); }

	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_u(bool val) { return setValue("tile_u", val); }
	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_u() const { return getBool("tile_u"); }

	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_v(bool val) { return setValue("tile_v", val); }
	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_v() const { return getBool("tile_v"); }

	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool set_uv_noise_on(bool val) { return setValue("uv_noise_on", val); }
	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool get_uv_noise_on() const { return getBool("uv_noise_on"); }

	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool set_uv_noise_animate(bool val) { return setValue("uv_noise_animate", val); }
	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool get_uv_noise_animate() const { return getBool("uv_noise_animate"); }

	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	bool set_uv_noise_amount(float val) { return setValue("uv_noise_amount", val); }
	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	float get_uv_noise_amount() const { return getFloat("uv_noise_amount"); }

	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	bool set_uv_noise_levels(float val) { return setValue("uv_noise_levels", val); }
	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	float get_uv_noise_levels() const { return getFloat("uv_noise_levels"); }

	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	bool set_uv_noise_size(float val) { return setValue("uv_noise_size", val); }
	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	float get_uv_noise_size() const { return getFloat("uv_noise_size"); }

	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	bool set_un_noise_phase(float val) { return setValue("un_noise_phase", val); }
	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	float get_un_noise_phase() const { return getFloat("un_noise_phase"); }

	//! amplitude(i+1) = amplitude(i) / persistence
 	//! [Default value] 1
	bool set_persistence(float val) { return setValue("persistence", val); }
	//! amplitude(i+1) = amplitude(i) / persistence
 	//! [Default value] 1
	float get_persistence() const { return getFloat("persistence"); }

	//! amplitude(i+1) = amplitude(i) * amplitude_ratio
 	//! [Default value] 1
	bool set_amplitude_ratio(float val) { return setValue("amplitude_ratio", val); }
	//! amplitude(i+1) = amplitude(i) * amplitude_ratio
 	//! [Default value] 1
	float get_amplitude_ratio() const { return getFloat("amplitude_ratio"); }

	//! frequency(i+1) = frequency(i) * frequency_ratio
 	//! [Default value] 2
	bool set_frequency_ratio(float val) { return setValue("frequency_ratio", val); }
	//! frequency(i+1) = frequency(i) * frequency_ratio
 	//! [Default value] 2
	float get_frequency_ratio() const { return getFloat("frequency_ratio"); }

	//! The starting frequency
 	//! [Default value] 1
	bool set_frequency1(float val) { return setValue("frequency1", val); }
	//! The starting frequency
 	//! [Default value] 1
	float get_frequency1() const { return getFloat("frequency1"); }

	//! The starting amplitude
 	//! [Default value] 1
	bool set_amplitude1(float val) { return setValue("amplitude1", val); }
	//! The starting amplitude
 	//! [Default value] 1
	float get_amplitude1() const { return getFloat("amplitude1"); }

	//! (description missing)
	//! [Default value] 3
	bool set_octaves(int val) { return setValue("octaves", val); }
	//! (description missing)
	//! [Default value] 3
	int get_octaves() const { return getInt("octaves"); }

	//! 0: just noise(), 1: Perlin noise, 2: inflected Perlin noise, 3: marble (with Perlin)
 	//! [UI Guides] enum=0:Just noise; 1:Perlin noise; 2:Inflected Perlin noise; 3:Marble with Perlin
 	//! [Default value] 0
	bool set_noiseType(int val) { return setValue("noiseType", val); }
	//! 0: just noise(), 1: Perlin noise, 2: inflected Perlin noise, 3: marble (with Perlin)
 	//! [UI Guides] enum=0:Just noise; 1:Perlin noise; 2:Inflected Perlin noise; 3:Marble with Perlin
 	//! [Default value] 0
	int get_noiseType() const { return getInt("noiseType"); }

	//! (description missing)
	//! [Default value] 1
	bool set_frequency_mult(float val) { return setValue("frequency_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_frequency_mult() const { return getFloat("frequency_mult"); }

	//! (description missing)
	//! [Default value] 1
	bool set_amplitude_mult(float val) { return setValue("amplitude_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_amplitude_mult() const { return getFloat("amplitude_mult"); }

	//! 1: inflected, 0: not inflected
 	//! [Default value] 0
	bool set_inflection(int val) { return setValue("inflection", val); }
	//! 1: inflected, 0: not inflected
 	//! [Default value] 0
	int get_inflection() const { return getInt("inflection"); }

	//! (description missing)
	//! [Default value] Color(0, 0, 0)
	bool set_color1(const Color& color) { return setValue("color1", color); }
	//! (description missing)
	//! [Default value] Color(0, 0, 0)
	Color get_color1() const { return getColor("color1"); }

	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	bool set_color2(const Color& color) { return setValue("color2", color); }
	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	Color get_color2() const { return getColor("color2"); }

	//! (description missing)
	bool set_color1_tex(const Plugin& texture) { return setValue("color1_tex", texture); }
	//! (description missing)
	bool set_color1_tex(const AColor& texture) { return setValue("color1_tex", texture); }
	//! (description missing)
	Value get_color1_tex() const { return getValue("color1_tex"); }

	//! (description missing)
	bool set_color2_tex(const Plugin& texture) { return setValue("color2_tex", texture); }
	//! (description missing)
	bool set_color2_tex(const AColor& texture) { return setValue("color2_tex", texture); }
	//! (description missing)
	Value get_color2_tex() const { return getValue("color2_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_color1_tex_mult(float val) { return setValue("color1_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_color1_tex_mult() const { return getFloat("color1_tex_mult"); }

	//! (description missing)
	//! [Default value] 1
	bool set_color2_tex_mult(float val) { return setValue("color2_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_color2_tex_mult() const { return getFloat("color2_tex_mult"); }

	//! (description missing)
	//! [Default value] true
	bool set_clamp(bool val) { return setValue("clamp", val); }
	//! (description missing)
	//! [Default value] true
	bool get_clamp() const { return getBool("clamp"); }

	//! Two or Three dimensional noise
 	//! [Default value] 3
	bool set_dimensions(int val) { return setValue("dimensions", val); }
	//! Two or Three dimensional noise
 	//! [Default value] 3
	int get_dimensions() const { return getInt("dimensions"); }

	//! The time of the noise, this will act as a third or fourth dimension to the noise generating function
 	//! [Default value] 0
	bool set_time(float val) { return setValue("time", val); }
	//! The time of the noise, this will act as a third or fourth dimension to the noise generating function
 	//! [Default value] 0
	float get_time() const { return getFloat("time"); }

	//! Value added to the noise function, noise function values above 1.0 are clamped.
 	bool set_threshold(const Plugin& texturefloat) { return setValue("threshold", texturefloat); }
	//! Value added to the noise function, noise function values above 1.0 are clamped.
 	bool set_threshold(float texturefloat) { return setValue("threshold", texturefloat); }
	//! Value added to the noise function, noise function values above 1.0 are clamped.
 	Value get_threshold() const { return getValue("threshold"); }

	//! Scale for the noise UVW coordinates.
 	bool set_scale(const Plugin& texture) { return setValue("scale", texture); }
	//! Scale for the noise UVW coordinates.
 	bool set_scale(const AColor& texture) { return setValue("scale", texture); }
	//! Scale for the noise UVW coordinates.
 	Value get_scale() const { return getValue("scale"); }

	//! Translation for the noise UVW coordinates.
 	bool set_origin(const Plugin& texture) { return setValue("origin", texture); }
	//! Translation for the noise UVW coordinates.
 	bool set_origin(const AColor& texture) { return setValue("origin", texture); }
	//! Translation for the noise UVW coordinates.
 	Value get_origin() const { return getValue("origin"); }

	//! Amount of implode performed on the UVW coordinates.
 	bool set_implode(const Plugin& texturefloat) { return setValue("implode", texturefloat); }
	//! Amount of implode performed on the UVW coordinates.
 	bool set_implode(float texturefloat) { return setValue("implode", texturefloat); }
	//! Amount of implode performed on the UVW coordinates.
 	Value get_implode() const { return getValue("implode"); }

	//! The center of the implode effect
 	bool set_implode_center(const Plugin& texture) { return setValue("implode_center", texture); }
	//! The center of the implode effect
 	bool set_implode_center(const AColor& texture) { return setValue("implode_center", texture); }
	//! The center of the implode effect
 	Value get_implode_center() const { return getValue("implode_center"); }
};

class TexNoiseASGVIS : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexNoiseASGVIS"; }

	//! (description missing)
	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! (description missing)
	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! amplitude(i+1) = amplitude(i) / persistence
 	//! [Default value] 1
	bool set_persistence(float val) { return setValue("persistence", val); }
	//! amplitude(i+1) = amplitude(i) / persistence
 	//! [Default value] 1
	float get_persistence() const { return getFloat("persistence"); }

	//! amplitude(i+1) = amplitude(i) * amplitude_ratio
 	//! [Default value] 1
	bool set_amplitude_ratio(float val) { return setValue("amplitude_ratio", val); }
	//! amplitude(i+1) = amplitude(i) * amplitude_ratio
 	//! [Default value] 1
	float get_amplitude_ratio() const { return getFloat("amplitude_ratio"); }

	//! frequency(i+1) = frequency(i) * frequency_ratio
 	//! [Default value] 2
	bool set_frequency_ratio(float val) { return setValue("frequency_ratio", val); }
	//! frequency(i+1) = frequency(i) * frequency_ratio
 	//! [Default value] 2
	float get_frequency_ratio() const { return getFloat("frequency_ratio"); }

	//! The starting frequency (just like size)
 	//! [Default value] 1
	bool set_frequency1(float val) { return setValue("frequency1", val); }
	//! The starting frequency (just like size)
 	//! [Default value] 1
	float get_frequency1() const { return getFloat("frequency1"); }

	//! The starting amplitude
 	//! [Default value] 1
	bool set_amplitude1(float val) { return setValue("amplitude1", val); }
	//! The starting amplitude
 	//! [Default value] 1
	float get_amplitude1() const { return getFloat("amplitude1"); }

	//! (description missing)
	//! [Default value] 3
	bool set_octaves(int val) { return setValue("octaves", val); }
	//! (description missing)
	//! [Default value] 3
	int get_octaves() const { return getInt("octaves"); }

	//! 0: just noise(), 1: Perlin noise, 2: inflected Perlin noise, 3: marble (with Perlin)
 	//! [Default value] 0
	bool set_noiseType(int val) { return setValue("noiseType", val); }
	//! 0: just noise(), 1: Perlin noise, 2: inflected Perlin noise, 3: marble (with Perlin)
 	//! [Default value] 0
	int get_noiseType() const { return getInt("noiseType"); }

	//! scale
 	//! [Default value] 1
	bool set_size(float val) { return setValue("size", val); }
	//! scale
 	//! [Default value] 1
	float get_size() const { return getFloat("size"); }

	//! 1: inflected, 0: not inflected
 	//! [Default value] 0
	bool set_inflection(int val) { return setValue("inflection", val); }
	//! 1: inflected, 0: not inflected
 	//! [Default value] 0
	int get_inflection() const { return getInt("inflection"); }

	//! 0: color1 only, 1: color2 only, 0.5(def.): 50%-50%
 	//! [Default value] 0.5
	bool set_mix_ratio(float val) { return setValue("mix_ratio", val); }
	//! 0: color1 only, 1: color2 only, 0.5(def.): 50%-50%
 	//! [Default value] 0.5
	float get_mix_ratio() const { return getFloat("mix_ratio"); }

	//! similiar to contrast
 	//! [Default value] 0
	bool set_bias(float val) { return setValue("bias", val); }
	//! similiar to contrast
 	//! [Default value] 0
	float get_bias() const { return getFloat("bias"); }

	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	bool set_color1(const Color& color) { return setValue("color1", color); }
	//! (description missing)
	//! [Default value] Color(1, 1, 1)
	Color get_color1() const { return getColor("color1"); }

	//! (description missing)
	//! [Default value] Color(0, 0, 0)
	bool set_color2(const Color& color) { return setValue("color2", color); }
	//! (description missing)
	//! [Default value] Color(0, 0, 0)
	Color get_color2() const { return getColor("color2"); }

	//! (description missing)
	bool set_color1_tex(const Plugin& texture) { return setValue("color1_tex", texture); }
	//! (description missing)
	bool set_color1_tex(const AColor& texture) { return setValue("color1_tex", texture); }
	//! (description missing)
	Value get_color1_tex() const { return getValue("color1_tex"); }

	//! (description missing)
	bool set_color2_tex(const Plugin& texture) { return setValue("color2_tex", texture); }
	//! (description missing)
	bool set_color2_tex(const AColor& texture) { return setValue("color2_tex", texture); }
	//! (description missing)
	Value get_color2_tex() const { return getValue("color2_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_color1_tex_mult(float val) { return setValue("color1_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_color1_tex_mult() const { return getFloat("color1_tex_mult"); }

	//! (description missing)
	//! [Default value] 1
	bool set_color2_tex_mult(float val) { return setValue("color2_tex_mult", val); }
	//! (description missing)
	//! [Default value] 1
	float get_color2_tex_mult() const { return getFloat("color2_tex_mult"); }

	//! (description missing)
	//! [Default value] true
	bool set_use_3d_mapping(bool val) { return setValue("use_3d_mapping", val); }
	//! (description missing)
	//! [Default value] true
	bool get_use_3d_mapping() const { return getBool("use_3d_mapping"); }
};

class TexNoiseMax : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexNoiseMax"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! (description missing)
	//! [Default value] false
	bool set_use_3d_mapping(bool val) { return setValue("use_3d_mapping", val); }
	//! (description missing)
	//! [Default value] false
	bool get_use_3d_mapping() const { return getBool("use_3d_mapping"); }

	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	bool set_placement_type(int val) { return setValue("placement_type", val); }
	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	int get_placement_type() const { return getInt("placement_type"); }

	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_u(float val) { return setValue("u", val); }
	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_u() const { return getFloat("u"); }

	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_v(float val) { return setValue("v", val); }
	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_v() const { return getFloat("v"); }

	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_w(float val) { return setValue("w", val); }
	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_w() const { return getFloat("w"); }

	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_h(float val) { return setValue("h", val); }
	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_h() const { return getFloat("h"); }

	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	bool set_jitter(float val) { return setValue("jitter", val); }
	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	float get_jitter() const { return getFloat("jitter"); }

	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_u(bool val) { return setValue("tile_u", val); }
	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_u() const { return getBool("tile_u"); }

	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_v(bool val) { return setValue("tile_v", val); }
	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_v() const { return getBool("tile_v"); }

	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool set_uv_noise_on(bool val) { return setValue("uv_noise_on", val); }
	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool get_uv_noise_on() const { return getBool("uv_noise_on"); }

	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool set_uv_noise_animate(bool val) { return setValue("uv_noise_animate", val); }
	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool get_uv_noise_animate() const { return getBool("uv_noise_animate"); }

	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	bool set_uv_noise_amount(float val) { return setValue("uv_noise_amount", val); }
	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	float get_uv_noise_amount() const { return getFloat("uv_noise_amount"); }

	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	bool set_uv_noise_levels(float val) { return setValue("uv_noise_levels", val); }
	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	float get_uv_noise_levels() const { return getFloat("uv_noise_levels"); }

	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	bool set_uv_noise_size(float val) { return setValue("uv_noise_size", val); }
	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	float get_uv_noise_size() const { return getFloat("uv_noise_size"); }

	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	bool set_un_noise_phase(float val) { return setValue("un_noise_phase", val); }
	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	float get_un_noise_phase() const { return getFloat("un_noise_phase"); }

	//! First color
 	bool set_color1(const Plugin& texture) { return setValue("color1", texture); }
	//! First color
 	bool set_color1(const AColor& texture) { return setValue("color1", texture); }
	//! First color
 	Value get_color1() const { return getValue("color1"); }

	//! Second color
 	bool set_color2(const Plugin& texture) { return setValue("color2", texture); }
	//! Second color
 	bool set_color2(const AColor& texture) { return setValue("color2", texture); }
	//! Second color
 	Value get_color2() const { return getValue("color2"); }

	//! Size
 	//! [UI Guides] minValue=0.001
 	bool set_size(const Plugin& texturefloat) { return setValue("size", texturefloat); }
	//! Size
 	//! [UI Guides] minValue=0.001
 	bool set_size(float texturefloat) { return setValue("size", texturefloat); }
	//! Size
 	//! [UI Guides] minValue=0.001
 	Value get_size() const { return getValue("size"); }

	//! Phase
 	bool set_phase(const Plugin& texturefloat) { return setValue("phase", texturefloat); }
	//! Phase
 	bool set_phase(float texturefloat) { return setValue("phase", texturefloat); }
	//! Phase
 	Value get_phase() const { return getValue("phase"); }

	//! Number of iterations for the fractal generator
 	//! [UI Guides] enableIf: ?type=1; ?type=2, minValue=1, maxValue=20
 	bool set_iterations(const Plugin& texturefloat) { return setValue("iterations", texturefloat); }
	//! Number of iterations for the fractal generator
 	//! [UI Guides] enableIf: ?type=1; ?type=2, minValue=1, maxValue=20
 	bool set_iterations(float texturefloat) { return setValue("iterations", texturefloat); }
	//! Number of iterations for the fractal generator
 	//! [UI Guides] enableIf: ?type=1; ?type=2, minValue=1, maxValue=20
 	Value get_iterations() const { return getValue("iterations"); }

	//! Low threshold
 	//! [UI Guides] minValue=0, maxValue=1
 	bool set_low(const Plugin& texturefloat) { return setValue("low", texturefloat); }
	//! Low threshold
 	//! [UI Guides] minValue=0, maxValue=1
 	bool set_low(float texturefloat) { return setValue("low", texturefloat); }
	//! Low threshold
 	//! [UI Guides] minValue=0, maxValue=1
 	Value get_low() const { return getValue("low"); }

	//! High threshold
 	//! [UI Guides] minValue=0, maxValue=1
 	bool set_high(const Plugin& texturefloat) { return setValue("high", texturefloat); }
	//! High threshold
 	//! [UI Guides] minValue=0, maxValue=1
 	bool set_high(float texturefloat) { return setValue("high", texturefloat); }
	//! High threshold
 	//! [UI Guides] minValue=0, maxValue=1
 	Value get_high() const { return getValue("high"); }

	//! Type (0 - regular, 1 - fractal, 2 - turbulence)
 	//! [UI Guides] enum=0:Regular; 1:Fractal; 2:Turbulence
 	//! [Default value] 0
	bool set_type(int val) { return setValue("type", val); }
	//! Type (0 - regular, 1 - fractal, 2 - turbulence)
 	//! [UI Guides] enum=0:Regular; 1:Fractal; 2:Turbulence
 	//! [Default value] 0
	int get_type() const { return getInt("type"); }
};

class TexNoiseMaya : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexNoiseMaya"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! (description missing)
	//! [Default value] false
	bool set_use_3d_mapping(bool val) { return setValue("use_3d_mapping", val); }
	//! (description missing)
	//! [Default value] false
	bool get_use_3d_mapping() const { return getBool("use_3d_mapping"); }

	//! (description missing)
	//! [Default value] true
	bool set_wrap(bool val) { return setValue("wrap", val); }
	//! (description missing)
	//! [Default value] true
	bool get_wrap() const { return getBool("wrap"); }

	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	bool set_placement_type(int val) { return setValue("placement_type", val); }
	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	int get_placement_type() const { return getInt("placement_type"); }

	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_u(float val) { return setValue("u", val); }
	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_u() const { return getFloat("u"); }

	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_v(float val) { return setValue("v", val); }
	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_v() const { return getFloat("v"); }

	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_w(float val) { return setValue("w", val); }
	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_w() const { return getFloat("w"); }

	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_h(float val) { return setValue("h", val); }
	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_h() const { return getFloat("h"); }

	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	bool set_jitter(float val) { return setValue("jitter", val); }
	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	float get_jitter() const { return getFloat("jitter"); }

	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_u(bool val) { return setValue("tile_u", val); }
	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_u() const { return getBool("tile_u"); }

	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_v(bool val) { return setValue("tile_v", val); }
	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_v() const { return getBool("tile_v"); }

	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool set_uv_noise_on(bool val) { return setValue("uv_noise_on", val); }
	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool get_uv_noise_on() const { return getBool("uv_noise_on"); }

	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool set_uv_noise_animate(bool val) { return setValue("uv_noise_animate", val); }
	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool get_uv_noise_animate() const { return getBool("uv_noise_animate"); }

	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	bool set_uv_noise_amount(float val) { return setValue("uv_noise_amount", val); }
	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	float get_uv_noise_amount() const { return getFloat("uv_noise_amount"); }

	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	bool set_uv_noise_levels(float val) { return setValue("uv_noise_levels", val); }
	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	float get_uv_noise_levels() const { return getFloat("uv_noise_levels"); }

	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	bool set_uv_noise_size(float val) { return setValue("uv_noise_size", val); }
	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	float get_uv_noise_size() const { return getFloat("uv_noise_size"); }

	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	bool set_un_noise_phase(float val) { return setValue("un_noise_phase", val); }
	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	float get_un_noise_phase() const { return getFloat("un_noise_phase"); }

	//! First color
 	//! [Default value] Color(0, 0, 0)
	bool set_color1(const Color& color) { return setValue("color1", color); }
	//! First color
 	//! [Default value] Color(0, 0, 0)
	Color get_color1() const { return getColor("color1"); }

	//! Second color
 	//! [Default value] Color(1, 1, 1)
	bool set_color2(const Color& color) { return setValue("color2", color); }
	//! Second color
 	//! [Default value] Color(1, 1, 1)
	Color get_color2() const { return getColor("color2"); }

	//! Texture for the first color
 	bool set_color1_tex(const Plugin& texture) { return setValue("color1_tex", texture); }
	//! Texture for the first color
 	bool set_color1_tex(const AColor& texture) { return setValue("color1_tex", texture); }
	//! Texture for the first color
 	Value get_color1_tex() const { return getValue("color1_tex"); }

	//! Texture for the second color
 	bool set_color2_tex(const Plugin& texture) { return setValue("color2_tex", texture); }
	//! Texture for the second color
 	bool set_color2_tex(const AColor& texture) { return setValue("color2_tex", texture); }
	//! Texture for the second color
 	Value get_color2_tex() const { return getValue("color2_tex"); }

	//! Texture multiplier for the first color
 	//! [Default value] 1
	bool set_color1_tex_mult(float val) { return setValue("color1_tex_mult", val); }
	//! Texture multiplier for the first color
 	//! [Default value] 1
	float get_color1_tex_mult() const { return getFloat("color1_tex_mult"); }

	//! Texture multiplier for the second color
 	//! [Default value] 1
	bool set_color2_tex_mult(float val) { return setValue("color2_tex_mult", val); }
	//! Texture multiplier for the second color
 	//! [Default value] 1
	float get_color2_tex_mult() const { return getFloat("color2_tex_mult"); }

	//! Two or Three dimensional noise
 	//! [Default value] 3
	bool set_dimensions(int val) { return setValue("dimensions", val); }
	//! Two or Three dimensional noise
 	//! [Default value] 3
	int get_dimensions() const { return getInt("dimensions"); }

	//! Amplitude is a scaling factor applied to all the values in the texture, centered around the texture's average value.  This means that when you increase Amplitude, the light areas get lighter and the dark areas get darker. If the Noise is being used as a bump map, then increasing Amplitude will make the bumps higher and the valleys deeper. If you set Amplitude to a value greater than 1.0, then those parts of the texture that scale out of range will be clipped. On a bump map, this will show up as plateau regions.
 	bool set_amplitude(const Plugin& texturefloat) { return setValue("amplitude", texturefloat); }
	//! Amplitude is a scaling factor applied to all the values in the texture, centered around the texture's average value.  This means that when you increase Amplitude, the light areas get lighter and the dark areas get darker. If the Noise is being used as a bump map, then increasing Amplitude will make the bumps higher and the valleys deeper. If you set Amplitude to a value greater than 1.0, then those parts of the texture that scale out of range will be clipped. On a bump map, this will show up as plateau regions.
 	bool set_amplitude(float texturefloat) { return setValue("amplitude", texturefloat); }
	//! Amplitude is a scaling factor applied to all the values in the texture, centered around the texture's average value.  This means that when you increase Amplitude, the light areas get lighter and the dark areas get darker. If the Noise is being used as a bump map, then increasing Amplitude will make the bumps higher and the valleys deeper. If you set Amplitude to a value greater than 1.0, then those parts of the texture that scale out of range will be clipped. On a bump map, this will show up as plateau regions.
 	Value get_amplitude() const { return getValue("amplitude"); }

	//! Controls the frequency of the fractal noise.  Increase this value to increase the fineness of detail in the fractal.
 	bool set_ratio(const Plugin& texturefloat) { return setValue("ratio", texturefloat); }
	//! Controls the frequency of the fractal noise.  Increase this value to increase the fineness of detail in the fractal.
 	bool set_ratio(float texturefloat) { return setValue("ratio", texturefloat); }
	//! Controls the frequency of the fractal noise.  Increase this value to increase the fineness of detail in the fractal.
 	Value get_ratio() const { return getValue("ratio"); }

	//! Threshold is a number that is added to the whole fractal, making it uniformly brighter.  If some parts of the fractal are pushed up out of range (greater than 1.0), then they will be clipped to 1.0.  If the Noise is being used as a bump map, this will show up as plateau regions. 
 	bool set_threshold(const Plugin& texturefloat) { return setValue("threshold", texturefloat); }
	//! Threshold is a number that is added to the whole fractal, making it uniformly brighter.  If some parts of the fractal are pushed up out of range (greater than 1.0), then they will be clipped to 1.0.  If the Noise is being used as a bump map, this will show up as plateau regions. 
 	bool set_threshold(float texturefloat) { return setValue("threshold", texturefloat); }
	//! Threshold is a number that is added to the whole fractal, making it uniformly brighter.  If some parts of the fractal are pushed up out of range (greater than 1.0), then they will be clipped to 1.0.  If the Noise is being used as a bump map, this will show up as plateau regions. 
 	Value get_threshold() const { return getValue("threshold"); }

	//! Controls how much calculation is done by the Noise texture
 	//! [Default value] 3
	bool set_depth_max(int val) { return setValue("depth_max", val); }
	//! Controls how much calculation is done by the Noise texture
 	//! [Default value] 3
	int get_depth_max() const { return getInt("depth_max"); }

	//! Determines the fundamental frequency for the noise. As this value increases the noise becomes more detailed. It has the inverse effect of the scale parameter.
 	bool set_frequency(const Plugin& texturefloat) { return setValue("frequency", texturefloat); }
	//! Determines the fundamental frequency for the noise. As this value increases the noise becomes more detailed. It has the inverse effect of the scale parameter.
 	bool set_frequency(float texturefloat) { return setValue("frequency", texturefloat); }
	//! Determines the fundamental frequency for the noise. As this value increases the noise becomes more detailed. It has the inverse effect of the scale parameter.
 	Value get_frequency() const { return getValue("frequency"); }

	//! Determines the relative spacial scale of the noise frequencies. If this ratio is not a whole integer then the fractal will not repeat  at the integer uv boundaries.
 	bool set_frequency_ratio(const Plugin& texturefloat) { return setValue("frequency_ratio", texturefloat); }
	//! Determines the relative spacial scale of the noise frequencies. If this ratio is not a whole integer then the fractal will not repeat  at the integer uv boundaries.
 	bool set_frequency_ratio(float texturefloat) { return setValue("frequency_ratio", texturefloat); }
	//! Determines the relative spacial scale of the noise frequencies. If this ratio is not a whole integer then the fractal will not repeat  at the integer uv boundaries.
 	Value get_frequency_ratio() const { return getValue("frequency_ratio"); }

	//! If true applies a kink in the noise function. This is useful for creating puffy or bumpy effects. It is equivalent to abs(noise) * 2 - 1
 	//! [Default value] false
	bool set_inflection(bool val) { return setValue("inflection", val); }
	//! If true applies a kink in the noise function. This is useful for creating puffy or bumpy effects. It is equivalent to abs(noise) * 2 - 1
 	//! [Default value] false
	bool get_inflection() const { return getBool("inflection"); }

	//! Animate the Noise texture. Control the rate and amount of change of the texture.
 	//! [Default value] 0
	bool set_time(float val) { return setValue("time", val); }
	//! Animate the Noise texture. Control the rate and amount of change of the texture.
 	//! [Default value] 0
	float get_time() const { return getFloat("time"); }

	//!  0 - Perlin Noise; 1 - Billow; 2 - Wave; 3 - Wispy. Determines which noise to use during the fractal iteration.
 	//! [UI Guides] enum=0:Perlin Noise; 1:Billow; 2:Wave; 3:Wispy
 	//! [Default value] 1
	bool set_noise_type(int val) { return setValue("noise_type", val); }
	//!  0 - Perlin Noise; 1 - Billow; 2 - Wave; 3 - Wispy. Determines which noise to use during the fractal iteration.
 	//! [UI Guides] enum=0:Perlin Noise; 1:Billow; 2:Wave; 3:Wispy
 	//! [Default value] 1
	int get_noise_type() const { return getInt("noise_type"); }

	//! Controls how many cells there are imbedded in the medium used by the Billow noise type. At 1.0, the medium is completely packed with cells. Reduce this value to make the cells more sparse. If the texture is being used as a bump map, then low values for Density will make it look like a smooth surface with occasional bumps on it.
 	bool set_density(const Plugin& texturefloat) { return setValue("density", texturefloat); }
	//! Controls how many cells there are imbedded in the medium used by the Billow noise type. At 1.0, the medium is completely packed with cells. Reduce this value to make the cells more sparse. If the texture is being used as a bump map, then low values for Density will make it look like a smooth surface with occasional bumps on it.
 	bool set_density(float texturefloat) { return setValue("density", texturefloat); }
	//! Controls how many cells there are imbedded in the medium used by the Billow noise type. At 1.0, the medium is completely packed with cells. Reduce this value to make the cells more sparse. If the texture is being used as a bump map, then low values for Density will make it look like a smooth surface with occasional bumps on it.
 	Value get_density() const { return getValue("density"); }

	//! Controls the randomization of the density	of the individual cells used by the Billow noise type. When Spottyness is close to 0, all the cells will be the same density.  As you increase Spottyness, some cells will be denser or thinner than others, in a random fashion.
 	bool set_spottyness(const Plugin& texturefloat) { return setValue("spottyness", texturefloat); }
	//! Controls the randomization of the density	of the individual cells used by the Billow noise type. When Spottyness is close to 0, all the cells will be the same density.  As you increase Spottyness, some cells will be denser or thinner than others, in a random fashion.
 	bool set_spottyness(float texturefloat) { return setValue("spottyness", texturefloat); }
	//! Controls the randomization of the density	of the individual cells used by the Billow noise type. When Spottyness is close to 0, all the cells will be the same density.  As you increase Spottyness, some cells will be denser or thinner than others, in a random fashion.
 	Value get_spottyness() const { return getValue("spottyness"); }

	//! Controls the randomization of the size of the individual blobs used by the Billow noise type. When it is close to 0, all the cells will be the same size.  As you increase size_rand, some cells will be smaller than others,	in a random fashion.
 	bool set_size_rand(const Plugin& texturefloat) { return setValue("size_rand", texturefloat); }
	//! Controls the randomization of the size of the individual blobs used by the Billow noise type. When it is close to 0, all the cells will be the same size.  As you increase size_rand, some cells will be smaller than others,	in a random fashion.
 	bool set_size_rand(float texturefloat) { return setValue("size_rand", texturefloat); }
	//! Controls the randomization of the size of the individual blobs used by the Billow noise type. When it is close to 0, all the cells will be the same size.  As you increase size_rand, some cells will be smaller than others,	in a random fashion.
 	Value get_size_rand() const { return getValue("size_rand"); }

	//! Controls how the cells for the Billow noise type are arranged relative to one another. Set randomness to 1.0 to get a realistic random distribution of cells, as would be found in nature. If you set Randomness to 0, all the spots are laid out in a completely regular pattern.  This can provide interesting effects when used as a bump map;  you can make things like insect eyes, or machine-tooled raspy surfaces.
 	bool set_randomness(const Plugin& texturefloat) { return setValue("randomness", texturefloat); }
	//! Controls how the cells for the Billow noise type are arranged relative to one another. Set randomness to 1.0 to get a realistic random distribution of cells, as would be found in nature. If you set Randomness to 0, all the spots are laid out in a completely regular pattern.  This can provide interesting effects when used as a bump map;  you can make things like insect eyes, or machine-tooled raspy surfaces.
 	bool set_randomness(float texturefloat) { return setValue("randomness", texturefloat); }
	//! Controls how the cells for the Billow noise type are arranged relative to one another. Set randomness to 1.0 to get a realistic random distribution of cells, as would be found in nature. If you set Randomness to 0, all the spots are laid out in a completely regular pattern.  This can provide interesting effects when used as a bump map;  you can make things like insect eyes, or machine-tooled raspy surfaces.
 	Value get_randomness() const { return getValue("randomness"); }

	//! 0 - Linear; 1 - Smooth; 2 - Fast; 3 - Bubble Controls the way intensity falls off for individual blobs for the Billow noise type. Linear is a uniform falloff from the center to a value of zero at the edges of the blobs. Smooth is more natural looking, using a gaussian falloff. Fast focuses the intensity more towards the center of the blobs. Bubble uses a reverse falloff, fading to zero at the blob center.
 	//! [UI Guides] enum=0:Linear; 1:Smooth; 2:Fast; 3:Bubble
 	//! [Default value] 2
	bool set_falloff(int val) { return setValue("falloff", val); }
	//! 0 - Linear; 1 - Smooth; 2 - Fast; 3 - Bubble Controls the way intensity falls off for individual blobs for the Billow noise type. Linear is a uniform falloff from the center to a value of zero at the edges of the blobs. Smooth is more natural looking, using a gaussian falloff. Fast focuses the intensity more towards the center of the blobs. Bubble uses a reverse falloff, fading to zero at the blob center.
 	//! [UI Guides] enum=0:Linear; 1:Smooth; 2:Fast; 3:Bubble
 	//! [Default value] 2
	int get_falloff() const { return getInt("falloff"); }

	//! Determines how many waves to generate for the Wave noise type. The larger this number the more random looking and slower the texture.
 	//! [Default value] 5
	bool set_num_waves(int val) { return setValue("num_waves", val); }
	//! Determines how many waves to generate for the Wave noise type. The larger this number the more random looking and slower the texture.
 	//! [Default value] 5
	int get_num_waves() const { return getInt("num_waves"); }

	//! Implode warps the noise function in a concentric fashion about a point defined by the implode_center. At a value of zero there is no effect, while at a value of 1.0 it is a spherical projection of the noise function, creating a starburst effect. Negative values can be used to skew the noise outward instead of inward.
 	bool set_implode(const Plugin& texturefloat) { return setValue("implode", texturefloat); }
	//! Implode warps the noise function in a concentric fashion about a point defined by the implode_center. At a value of zero there is no effect, while at a value of 1.0 it is a spherical projection of the noise function, creating a starburst effect. Negative values can be used to skew the noise outward instead of inward.
 	bool set_implode(float texturefloat) { return setValue("implode", texturefloat); }
	//! Implode warps the noise function in a concentric fashion about a point defined by the implode_center. At a value of zero there is no effect, while at a value of 1.0 it is a spherical projection of the noise function, creating a starburst effect. Negative values can be used to skew the noise outward instead of inward.
 	Value get_implode() const { return getValue("implode"); }

	//! Implode center in UVW coordinates.
 	bool set_implode_center(const Plugin& texture) { return setValue("implode_center", texture); }
	//! Implode center in UVW coordinates.
 	bool set_implode_center(const AColor& texture) { return setValue("implode_center", texture); }
	//! Implode center in UVW coordinates.
 	Value get_implode_center() const { return getValue("implode_center"); }

	//! Scale for the noise UVW coordinates.
 	bool set_scale(const Plugin& texture) { return setValue("scale", texture); }
	//! Scale for the noise UVW coordinates.
 	bool set_scale(const AColor& texture) { return setValue("scale", texture); }
	//! Scale for the noise UVW coordinates.
 	Value get_scale() const { return getValue("scale"); }

	//! Translation for the noise UVW coordinates.
 	bool set_origin(const Plugin& texture) { return setValue("origin", texture); }
	//! Translation for the noise UVW coordinates.
 	bool set_origin(const AColor& texture) { return setValue("origin", texture); }
	//! Translation for the noise UVW coordinates.
 	Value get_origin() const { return getValue("origin"); }
};

class TexNormalMapFlip : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexNormalMapFlip"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! The texture
 	bool set_texmap(const Plugin& texture) { return setValue("texmap", texture); }
	//! The texture
 	bool set_texmap(const AColor& texture) { return setValue("texmap", texture); }
	//! The texture
 	Value get_texmap() const { return getValue("texmap"); }

	//! true to flip the texture red channel
 	//! [Default value] false
	bool set_flip_red(bool val) { return setValue("flip_red", val); }
	//! true to flip the texture red channel
 	//! [Default value] false
	bool get_flip_red() const { return getBool("flip_red"); }

	//! true to flip the texture green channel
 	//! [Default value] false
	bool set_flip_green(bool val) { return setValue("flip_green", val); }
	//! true to flip the texture green channel
 	//! [Default value] false
	bool get_flip_green() const { return getBool("flip_green"); }

	//! true to swap the red and green channels
 	//! [Default value] false
	bool set_swap_redgreen(bool val) { return setValue("swap_redgreen", val); }
	//! true to swap the red and green channels
 	//! [Default value] false
	bool get_swap_redgreen() const { return getBool("swap_redgreen"); }
};

class TexOCIO : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexOCIO"; }

	//! (description missing)
	bool set_basemap(const Plugin& texture) { return setValue("basemap", texture); }
	//! (description missing)
	bool set_basemap(const AColor& texture) { return setValue("basemap", texture); }
	//! (description missing)
	Value get_basemap() const { return getValue("basemap"); }

	//! Operation mode (0 - ColorSpace, 1 - CDL Transform, 2 - File Transform, 3 - LogConvert, 4 - Display, 5 - Look)
 	//! [UI Guides] enum=0:ColorSpace; 1:CDL Transform; 2:File Transform; 3:LogConvert; 4:Display; 5:Look
 	//! [Default value] 0
	bool set_mode(int val) { return setValue("mode", val); }
	//! Operation mode (0 - ColorSpace, 1 - CDL Transform, 2 - File Transform, 3 - LogConvert, 4 - Display, 5 - Look)
 	//! [UI Guides] enum=0:ColorSpace; 1:CDL Transform; 2:File Transform; 3:LogConvert; 4:Display; 5:Look
 	//! [Default value] 0
	int get_mode() const { return getInt("mode"); }

	//! OCIO configuration file (*.ocio)
 	//! [UI Guides] fileAsset=ocio
 	bool set_config_file(const char* str) { return setValue("config_file", str); }
	//! OCIO configuration file (*.ocio)
 	//! [UI Guides] fileAsset=ocio
 	bool set_config_file(const std::string& str) { return setValue("config_file", str); }
	//! OCIO configuration file (*.ocio)
 	//! [UI Guides] fileAsset=ocio
 	std::string get_config_file() const { return getString("config_file"); }

	//! stored OCIO environment config for slave renders (*.ocio)
 	//! [UI Guides] stored OCIO environment config for slave renders *.ocio
 	bool set_ocio_stored_env(const char* str) { return setValue("ocio_stored_env", str); }
	//! stored OCIO environment config for slave renders (*.ocio)
 	//! [UI Guides] stored OCIO environment config for slave renders *.ocio
 	bool set_ocio_stored_env(const std::string& str) { return setValue("ocio_stored_env", str); }
	//! stored OCIO environment config for slave renders (*.ocio)
 	//! [UI Guides] stored OCIO environment config for slave renders *.ocio
 	std::string get_ocio_stored_env() const { return getString("ocio_stored_env"); }

	//! Config source: 0 - auto (env, stored env for slaves, file, internal), 1 - environment, 2 - file, 3 - internal
 	//! [UI Guides] enum=0:Auto; 1:Environment; 2:File; 3:Internal
 	//! [Default value] 0
	bool set_config_src(int val) { return setValue("config_src", val); }
	//! Config source: 0 - auto (env, stored env for slaves, file, internal), 1 - environment, 2 - file, 3 - internal
 	//! [UI Guides] enum=0:Auto; 1:Environment; 2:File; 3:Internal
 	//! [Default value] 0
	int get_config_src() const { return getInt("config_src"); }

	//! ColorSpace: input colorspace/role
 	bool set_colorspace_in(const char* str) { return setValue("colorspace_in", str); }
	//! ColorSpace: input colorspace/role
 	bool set_colorspace_in(const std::string& str) { return setValue("colorspace_in", str); }
	//! ColorSpace: input colorspace/role
 	std::string get_colorspace_in() const { return getString("colorspace_in"); }

	//! ColorSpace: output colorspace/role
 	bool set_colorspace_out(const char* str) { return setValue("colorspace_out", str); }
	//! ColorSpace: output colorspace/role
 	bool set_colorspace_out(const std::string& str) { return setValue("colorspace_out", str); }
	//! ColorSpace: output colorspace/role
 	std::string get_colorspace_out() const { return getString("colorspace_out"); }

	//! CDLTransform: slope
 	//! [Default value] Color(1, 1, 1)
	bool set_cdl_slope(const Color& color) { return setValue("cdl_slope", color); }
	//! CDLTransform: slope
 	//! [Default value] Color(1, 1, 1)
	Color get_cdl_slope() const { return getColor("cdl_slope"); }

	//! CDLTransform: offset
 	//! [Default value] Color(0, 0, 0)
	bool set_cdl_offset(const Color& color) { return setValue("cdl_offset", color); }
	//! CDLTransform: offset
 	//! [Default value] Color(0, 0, 0)
	Color get_cdl_offset() const { return getColor("cdl_offset"); }

	//! CDLTransform: power
 	//! [Default value] Color(1, 1, 1)
	bool set_cdl_power(const Color& color) { return setValue("cdl_power", color); }
	//! CDLTransform: power
 	//! [Default value] Color(1, 1, 1)
	Color get_cdl_power() const { return getColor("cdl_power"); }

	//! CDLTransform: saturation
 	//! [Default value] 1
	bool set_cdl_saturation(float val) { return setValue("cdl_saturation", val); }
	//! CDLTransform: saturation
 	//! [Default value] 1
	float get_cdl_saturation() const { return getFloat("cdl_saturation"); }

	//! CDLTransform: direction (0 - forward, 1 - inverse)
 	//! [UI Guides] enum=0:Forward; 1:Inverse
 	//! [Default value] 0
	bool set_cdl_direction(int val) { return setValue("cdl_direction", val); }
	//! CDLTransform: direction (0 - forward, 1 - inverse)
 	//! [UI Guides] enum=0:Forward; 1:Inverse
 	//! [Default value] 0
	int get_cdl_direction() const { return getInt("cdl_direction"); }

	//! CDLTransform: true - get slope, offset, power and saturation from the specified file
 	//! [Default value] false
	bool set_cdl_use_file(bool val) { return setValue("cdl_use_file", val); }
	//! CDLTransform: true - get slope, offset, power and saturation from the specified file
 	//! [Default value] false
	bool get_cdl_use_file() const { return getBool("cdl_use_file"); }

	//! CDLTransform: file (.cc or .ccc)
 	//! [UI Guides] fileAsset=cc;ccc
 	bool set_cdl_file(const char* str) { return setValue("cdl_file", str); }
	//! CDLTransform: file (.cc or .ccc)
 	//! [UI Guides] fileAsset=cc;ccc
 	bool set_cdl_file(const std::string& str) { return setValue("cdl_file", str); }
	//! CDLTransform: file (.cc or .ccc)
 	//! [UI Guides] fileAsset=cc;ccc
 	std::string get_cdl_file() const { return getString("cdl_file"); }

	//! CDLTransform: cccid (if needed)
 	bool set_cdl_cccid(const char* str) { return setValue("cdl_cccid", str); }
	//! CDLTransform: cccid (if needed)
 	bool set_cdl_cccid(const std::string& str) { return setValue("cdl_cccid", str); }
	//! CDLTransform: cccid (if needed)
 	std::string get_cdl_cccid() const { return getString("cdl_cccid"); }

	//! FileTransform: color correction file
 	//! [UI Guides] fileAsset=3dl;ccc;cc;csp;lut;itx;cube;mga;spi1d;spi3d;spimtx;cub;vf
 	bool set_filetr_file(const char* str) { return setValue("filetr_file", str); }
	//! FileTransform: color correction file
 	//! [UI Guides] fileAsset=3dl;ccc;cc;csp;lut;itx;cube;mga;spi1d;spi3d;spimtx;cub;vf
 	bool set_filetr_file(const std::string& str) { return setValue("filetr_file", str); }
	//! FileTransform: color correction file
 	//! [UI Guides] fileAsset=3dl;ccc;cc;csp;lut;itx;cube;mga;spi1d;spi3d;spimtx;cub;vf
 	std::string get_filetr_file() const { return getString("filetr_file"); }

	//! FileTransform: cccid (if needed)
 	bool set_filetr_cccid(const char* str) { return setValue("filetr_cccid", str); }
	//! FileTransform: cccid (if needed)
 	bool set_filetr_cccid(const std::string& str) { return setValue("filetr_cccid", str); }
	//! FileTransform: cccid (if needed)
 	std::string get_filetr_cccid() const { return getString("filetr_cccid"); }

	//! FileTransform: direction (0 - forward, 1 - inverse)
 	//! [UI Guides] enum=0:Forward; 1:Inverse
 	//! [Default value] 0
	bool set_filetr_direction(int val) { return setValue("filetr_direction", val); }
	//! FileTransform: direction (0 - forward, 1 - inverse)
 	//! [UI Guides] enum=0:Forward; 1:Inverse
 	//! [Default value] 0
	int get_filetr_direction() const { return getInt("filetr_direction"); }

	//! FileTransform: interpolation (0 - nearest, 1 - linear, 2 - tetrahedral, 3 - best)
 	//! [UI Guides] enum=0:Nearest; 1:Linear; 2:Tetrahedral; 3:Best
 	//! [Default value] 0
	bool set_filetr_interpolation(int val) { return setValue("filetr_interpolation", val); }
	//! FileTransform: interpolation (0 - nearest, 1 - linear, 2 - tetrahedral, 3 - best)
 	//! [UI Guides] enum=0:Nearest; 1:Linear; 2:Tetrahedral; 3:Best
 	//! [Default value] 0
	int get_filetr_interpolation() const { return getInt("filetr_interpolation"); }

	//! LogConvert: operation (0 - log to lin, 1 - lin to log)
 	//! [UI Guides] enum=0:Log to lin; 1:Lin to log
 	//! [Default value] 0
	bool set_logconvert_operation(int val) { return setValue("logconvert_operation", val); }
	//! LogConvert: operation (0 - log to lin, 1 - lin to log)
 	//! [UI Guides] enum=0:Log to lin; 1:Lin to log
 	//! [Default value] 0
	int get_logconvert_operation() const { return getInt("logconvert_operation"); }

	//! Display: input colorspace/role
 	bool set_disp_input_colorspace(const char* str) { return setValue("disp_input_colorspace", str); }
	//! Display: input colorspace/role
 	bool set_disp_input_colorspace(const std::string& str) { return setValue("disp_input_colorspace", str); }
	//! Display: input colorspace/role
 	std::string get_disp_input_colorspace() const { return getString("disp_input_colorspace"); }

	//! Display: device
 	bool set_disp_display_device(const char* str) { return setValue("disp_display_device", str); }
	//! Display: device
 	bool set_disp_display_device(const std::string& str) { return setValue("disp_display_device", str); }
	//! Display: device
 	std::string get_disp_display_device() const { return getString("disp_display_device"); }

	//! Display: view transform
 	bool set_disp_view_transform(const char* str) { return setValue("disp_view_transform", str); }
	//! Display: view transform
 	bool set_disp_view_transform(const std::string& str) { return setValue("disp_view_transform", str); }
	//! Display: view transform
 	std::string get_disp_view_transform() const { return getString("disp_view_transform"); }

	//! Look: input colorspace/role
 	bool set_look_input_colorspace(const char* str) { return setValue("look_input_colorspace", str); }
	//! Look: input colorspace/role
 	bool set_look_input_colorspace(const std::string& str) { return setValue("look_input_colorspace", str); }
	//! Look: input colorspace/role
 	std::string get_look_input_colorspace() const { return getString("look_input_colorspace"); }

	//! Look: looks
 	bool set_look_looks(const char* str) { return setValue("look_looks", str); }
	//! Look: looks
 	bool set_look_looks(const std::string& str) { return setValue("look_looks", str); }
	//! Look: looks
 	std::string get_look_looks() const { return getString("look_looks"); }

	//! Look: output colorspace/role
 	bool set_look_output_colorspace(const char* str) { return setValue("look_output_colorspace", str); }
	//! Look: output colorspace/role
 	bool set_look_output_colorspace(const std::string& str) { return setValue("look_output_colorspace", str); }
	//! Look: output colorspace/role
 	std::string get_look_output_colorspace() const { return getString("look_output_colorspace"); }

	//! Look: direction (0 - forward, 1 - inverse)
 	//! [UI Guides] enum=0:Forward; 1:Inverse
 	//! [Default value] 0
	bool set_look_direction(int val) { return setValue("look_direction", val); }
	//! Look: direction (0 - forward, 1 - inverse)
 	//! [UI Guides] enum=0:Forward; 1:Inverse
 	//! [Default value] 0
	int get_look_direction() const { return getInt("look_direction"); }

	//! Look: ignore errors
 	//! [Default value] 0
	bool set_look_ignore_errors(int val) { return setValue("look_ignore_errors", val); }
	//! Look: ignore errors
 	//! [Default value] 0
	int get_look_ignore_errors() const { return getInt("look_ignore_errors"); }

	//! List of context key names
 	bool set_context_keys(const ValueList& stringList) { return setValue("context_keys", stringList); }
	//! List of context key names
 	ValueList get_context_keys() const { return getValueList("context_keys"); }

	//! List of context values
 	bool set_context_values(const ValueList& stringList) { return setValue("context_values", stringList); }
	//! List of context values
 	ValueList get_context_values() const { return getValueList("context_values"); }

	//! This parameter is currently ignored. Input/Output type: 0 - use colorspaces, 1 - use roles
 	//! [UI Guides] enum=0:Colorspaces; 1:Roles
 	//! [Default value] 0
	bool set_inout_type(int val) { return setValue("inout_type", val); }
	//! This parameter is currently ignored. Input/Output type: 0 - use colorspaces, 1 - use roles
 	//! [UI Guides] enum=0:Colorspaces; 1:Roles
 	//! [Default value] 0
	int get_inout_type() const { return getInt("inout_type"); }
};

class TexOSL : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexOSL"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	bool set_placement_type(int val) { return setValue("placement_type", val); }
	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	int get_placement_type() const { return getInt("placement_type"); }

	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_u(float val) { return setValue("u", val); }
	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_u() const { return getFloat("u"); }

	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_v(float val) { return setValue("v", val); }
	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_v() const { return getFloat("v"); }

	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_w(float val) { return setValue("w", val); }
	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_w() const { return getFloat("w"); }

	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_h(float val) { return setValue("h", val); }
	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_h() const { return getFloat("h"); }

	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	bool set_jitter(float val) { return setValue("jitter", val); }
	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	float get_jitter() const { return getFloat("jitter"); }

	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_u(bool val) { return setValue("tile_u", val); }
	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_u() const { return getBool("tile_u"); }

	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_v(bool val) { return setValue("tile_v", val); }
	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_v() const { return getBool("tile_v"); }

	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool set_uv_noise_on(bool val) { return setValue("uv_noise_on", val); }
	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool get_uv_noise_on() const { return getBool("uv_noise_on"); }

	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool set_uv_noise_animate(bool val) { return setValue("uv_noise_animate", val); }
	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool get_uv_noise_animate() const { return getBool("uv_noise_animate"); }

	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	bool set_uv_noise_amount(float val) { return setValue("uv_noise_amount", val); }
	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	float get_uv_noise_amount() const { return getFloat("uv_noise_amount"); }

	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	bool set_uv_noise_levels(float val) { return setValue("uv_noise_levels", val); }
	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	float get_uv_noise_levels() const { return getFloat("uv_noise_levels"); }

	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	bool set_uv_noise_size(float val) { return setValue("uv_noise_size", val); }
	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	float get_uv_noise_size() const { return getFloat("uv_noise_size"); }

	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	bool set_un_noise_phase(float val) { return setValue("un_noise_phase", val); }
	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	float get_un_noise_phase() const { return getFloat("un_noise_phase"); }

	//! Path to a *.oso file
 	//! [UI Guides] fileAsset=oso;osl
 	bool set_shader_file(const char* str) { return setValue("shader_file", str); }
	//! Path to a *.oso file
 	//! [UI Guides] fileAsset=oso;osl
 	bool set_shader_file(const std::string& str) { return setValue("shader_file", str); }
	//! Path to a *.oso file
 	//! [UI Guides] fileAsset=oso;osl
 	std::string get_shader_file() const { return getString("shader_file"); }

	//! Input parameter values in the order and type declared by the osl shader
 	bool set_input_parameters(const ValueList& list) { return setValue("input_parameters", list); }
	//! Input parameter values in the order and type declared by the osl shader
 	ValueList get_input_parameters() const { return getValueList("input_parameters"); }

	//! Name of the color output parameter as declared in the osl shader
 	bool set_output_color(const char* str) { return setValue("output_color", str); }
	//! Name of the color output parameter as declared in the osl shader
 	bool set_output_color(const std::string& str) { return setValue("output_color", str); }
	//! Name of the color output parameter as declared in the osl shader
 	std::string get_output_color() const { return getString("output_color"); }

	//! Name of the alpha output parameter as declared in the osl shader
 	bool set_output_alpha(const char* str) { return setValue("output_alpha", str); }
	//! Name of the alpha output parameter as declared in the osl shader
 	bool set_output_alpha(const std::string& str) { return setValue("output_alpha", str); }
	//! Name of the alpha output parameter as declared in the osl shader
 	std::string get_output_alpha() const { return getString("output_alpha"); }
};

class TexOpenVDB : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexOpenVDB"; }

	//! The path to the OpenVDB file
 	//! [UI Guides] fileAsset=vdb.
 	bool set_file(const char* str) { return setValue("file", str); }
	//! The path to the OpenVDB file
 	//! [UI Guides] fileAsset=vdb.
 	bool set_file(const std::string& str) { return setValue("file", str); }
	//! The path to the OpenVDB file
 	//! [UI Guides] fileAsset=vdb.
 	std::string get_file() const { return getString("file"); }

	//! If "file" is missing, read the vdb data from a memory stream.
 	//! [Default value] 0
	bool set_stream(const IntList& intList) { return setValue("stream", intList); }
	//! If "file" is missing, read the vdb data from a memory stream.
 	//! [Default value] 0
	bool set_stream(const int* ints, size_t count) { return setArray("stream", ints, count); }
	//! If "file" is missing, read the vdb data from a memory stream.
 	//! [Default value] 0
	template<size_t count> bool set_stream(const int (&ints)[count]) { return setArray("stream", ints, count); }
	//! If "file" is missing, read the vdb data from a memory stream.
 	//! [Default value] 0
	IntList get_stream() const { return getIntList("stream"); }

	//! The name of the OpenVDB grid to render.
 	bool set_render_grid(const char* str) { return setValue("render_grid", str); }
	//! The name of the OpenVDB grid to render.
 	bool set_render_grid(const std::string& str) { return setValue("render_grid", str); }
	//! The name of the OpenVDB grid to render.
 	std::string get_render_grid() const { return getString("render_grid"); }

	//! The name of the OpenVDB velocity grid to use for motion blur.
 	bool set_velocity_grid(const char* str) { return setValue("velocity_grid", str); }
	//! The name of the OpenVDB velocity grid to use for motion blur.
 	bool set_velocity_grid(const std::string& str) { return setValue("velocity_grid", str); }
	//! The name of the OpenVDB velocity grid to use for motion blur.
 	std::string get_velocity_grid() const { return getString("velocity_grid"); }

	//! If true, delay load the OpenVDB voxels until requested.
 	//! [Default value] true
	bool set_delay_load(bool val) { return setValue("delay_load", val); }
	//! If true, delay load the OpenVDB voxels until requested.
 	//! [Default value] true
	bool get_delay_load() const { return getBool("delay_load"); }

	//! The grid interpolation sampler (0:linear, 1:quadratic: 2:none).
 	//! [UI Guides] enum=0:Linear;1:Quadratic;2:None
 	//! [Default value] 1
	bool set_interpolation(int val) { return setValue("interpolation", val); }
	//! The grid interpolation sampler (0:linear, 1:quadratic: 2:none).
 	//! [UI Guides] enum=0:Linear;1:Quadratic;2:None
 	//! [Default value] 1
	int get_interpolation() const { return getInt("interpolation"); }

	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! whther to ignore the uvw generator and use world mapping.
 	//! [Default value] false
	bool set_use_3d_mapping(bool val) { return setValue("use_3d_mapping", val); }
	//! whther to ignore the uvw generator and use world mapping.
 	//! [Default value] false
	bool get_use_3d_mapping() const { return getBool("use_3d_mapping"); }

	//! Texture multiplier for float data.
 	//! [Default value] 1
	bool set_float_mult(float val) { return setValue("float_mult", val); }
	//! Texture multiplier for float data.
 	//! [Default value] 1
	float get_float_mult() const { return getFloat("float_mult"); }

	//! Texture multiplier for vector data.
 	//! [Default value] AColor(1, 1, 1, 1)
	bool set_vector_mult(const AColor& acolor) { return setValue("vector_mult", acolor); }
	//! Texture multiplier for vector data.
 	//! [Default value] AColor(1, 1, 1, 1)
	AColor get_vector_mult() const { return getAColor("vector_mult"); }
};

class TexOutput : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexOutput"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! The texture
 	bool set_texmap(const Plugin& texture) { return setValue("texmap", texture); }
	//! The texture
 	bool set_texmap(const AColor& texture) { return setValue("texmap", texture); }
	//! The texture
 	Value get_texmap() const { return getValue("texmap"); }

	//! Bump amount if the texture is used for bump mapping
 	//! [Default value] 1
	bool set_bump_amount(float val) { return setValue("bump_amount", val); }
	//! Bump amount if the texture is used for bump mapping
 	//! [Default value] 1
	float get_bump_amount() const { return getFloat("bump_amount"); }

	//! A multiplier for the output AColor
 	bool set_output_mult(const Plugin& texture) { return setValue("output_mult", texture); }
	//! A multiplier for the output AColor
 	bool set_output_mult(const AColor& texture) { return setValue("output_mult", texture); }
	//! A multiplier for the output AColor
 	Value get_output_mult() const { return getValue("output_mult"); }

	//! Clamp the output in [0.0,1.0] range
 	//! [Default value] false
	bool set_output_clamp(bool val) { return setValue("output_clamp", val); }
	//! Clamp the output in [0.0,1.0] range
 	//! [Default value] false
	bool get_output_clamp() const { return getBool("output_clamp"); }
};

class TexParticleDiffuse : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexParticleDiffuse"; }
};

class TexParticleId : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexParticleId"; }
};

class TexParticleSampler : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexParticleSampler"; }

	//! (description missing)
	bool set_def_color_tex(const Plugin& texture) { return setValue("def_color_tex", texture); }
	//! (description missing)
	bool set_def_color_tex(const AColor& texture) { return setValue("def_color_tex", texture); }
	//! (description missing)
	Value get_def_color_tex() const { return getValue("def_color_tex"); }
};

class TexParticleShape : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexParticleShape"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	bool set_placement_type(int val) { return setValue("placement_type", val); }
	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	int get_placement_type() const { return getInt("placement_type"); }

	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_u(float val) { return setValue("u", val); }
	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_u() const { return getFloat("u"); }

	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_v(float val) { return setValue("v", val); }
	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_v() const { return getFloat("v"); }

	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_w(float val) { return setValue("w", val); }
	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_w() const { return getFloat("w"); }

	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_h(float val) { return setValue("h", val); }
	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_h() const { return getFloat("h"); }

	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	bool set_jitter(float val) { return setValue("jitter", val); }
	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	float get_jitter() const { return getFloat("jitter"); }

	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_u(bool val) { return setValue("tile_u", val); }
	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_u() const { return getBool("tile_u"); }

	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_v(bool val) { return setValue("tile_v", val); }
	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_v() const { return getBool("tile_v"); }

	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool set_uv_noise_on(bool val) { return setValue("uv_noise_on", val); }
	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool get_uv_noise_on() const { return getBool("uv_noise_on"); }

	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool set_uv_noise_animate(bool val) { return setValue("uv_noise_animate", val); }
	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool get_uv_noise_animate() const { return getBool("uv_noise_animate"); }

	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	bool set_uv_noise_amount(float val) { return setValue("uv_noise_amount", val); }
	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	float get_uv_noise_amount() const { return getFloat("uv_noise_amount"); }

	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	bool set_uv_noise_levels(float val) { return setValue("uv_noise_levels", val); }
	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	float get_uv_noise_levels() const { return getFloat("uv_noise_levels"); }

	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	bool set_uv_noise_size(float val) { return setValue("uv_noise_size", val); }
	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	float get_uv_noise_size() const { return getFloat("uv_noise_size"); }

	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	bool set_un_noise_phase(float val) { return setValue("un_noise_phase", val); }
	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	float get_un_noise_phase() const { return getFloat("un_noise_phase"); }

	//! Color texture, the particles'color
 	bool set_clr_txt(const Plugin& texture) { return setValue("clr_txt", texture); }
	//! Color texture, the particles'color
 	bool set_clr_txt(const AColor& texture) { return setValue("clr_txt", texture); }
	//! Color texture, the particles'color
 	Value get_clr_txt() const { return getValue("clr_txt"); }

	//! Falloff Type - None(0), Linear(1), Square(2), Smooth(3), Cubic(4), Gaussian(5), User-defined(6)
 	//! [UI Guides] enum=0:None; 1:Linear; 2:Square; 3:Smooth; 4:Cubic; 5:Gaussian; 6:User-defined
 	//! [Default value] 0
	bool set_Falloff(int val) { return setValue("Falloff", val); }
	//! Falloff Type - None(0), Linear(1), Square(2), Smooth(3), Cubic(4), Gaussian(5), User-defined(6)
 	//! [UI Guides] enum=0:None; 1:Linear; 2:Square; 3:Smooth; 4:Cubic; 5:Gaussian; 6:User-defined
 	//! [Default value] 0
	int get_Falloff() const { return getInt("Falloff"); }

	//! (description missing)
	//! [Default value] 0.5
	bool set_FalloffX(float val) { return setValue("FalloffX", val); }
	//! (description missing)
	//! [Default value] 0.5
	float get_FalloffX() const { return getFloat("FalloffX"); }

	//! (description missing)
	//! [Default value] 0.5
	bool set_FalloffY(float val) { return setValue("FalloffY", val); }
	//! (description missing)
	//! [Default value] 0.5
	float get_FalloffY() const { return getFloat("FalloffY"); }

	//! (description missing)
	//! [Default value] 0
	bool set_FalloffRGB(int val) { return setValue("FalloffRGB", val); }
	//! (description missing)
	//! [Default value] 0
	int get_FalloffRGB() const { return getInt("FalloffRGB"); }

	//! (description missing)
	//! [Default value] 1
	bool set_FalloffAlpha(int val) { return setValue("FalloffAlpha", val); }
	//! (description missing)
	//! [Default value] 1
	int get_FalloffAlpha() const { return getInt("FalloffAlpha"); }

	//! (description missing)
	//! [Default value] 0
	bool set_FalloffRGBInvert(int val) { return setValue("FalloffRGBInvert", val); }
	//! (description missing)
	//! [Default value] 0
	int get_FalloffRGBInvert() const { return getInt("FalloffRGBInvert"); }

	//! (description missing)
	//! [Default value] 0
	bool set_FalloffAlphaInvert(int val) { return setValue("FalloffAlphaInvert", val); }
	//! (description missing)
	//! [Default value] 0
	int get_FalloffAlphaInvert() const { return getInt("FalloffAlphaInvert"); }

	//! (description missing)
	//! [Default value] 0
	bool set_FalloffStart(float val) { return setValue("FalloffStart", val); }
	//! (description missing)
	//! [Default value] 0
	float get_FalloffStart() const { return getFloat("FalloffStart"); }

	//! (description missing)
	//! [Default value] 1
	bool set_FalloffEnd(float val) { return setValue("FalloffEnd", val); }
	//! (description missing)
	//! [Default value] 1
	float get_FalloffEnd() const { return getFloat("FalloffEnd"); }

	//! (description missing)
	//! [Default value] 3
	bool set_Exponent(float val) { return setValue("Exponent", val); }
	//! (description missing)
	//! [Default value] 3
	float get_Exponent() const { return getFloat("Exponent"); }

	//! (description missing)
	//! [Default value] 1
	bool set_GaussRate(float val) { return setValue("GaussRate", val); }
	//! (description missing)
	//! [Default value] 1
	float get_GaussRate() const { return getFloat("GaussRate"); }

	//! Shape - None(0), Step(1), Sine(2), Star3), Beam(4), Symmetry(5), Noise(6), Turbulence(7), Fractal(8)
 	//! [UI Guides] enum=0:None; 1:Step; 2:Sine; 3:Star; 4:Beam; 5:Symmetry; 6:Noise; 7:Turbulence; 8:Fractal
 	//! [Default value] 0
	bool set_Shape(int val) { return setValue("Shape", val); }
	//! Shape - None(0), Step(1), Sine(2), Star3), Beam(4), Symmetry(5), Noise(6), Turbulence(7), Fractal(8)
 	//! [UI Guides] enum=0:None; 1:Step; 2:Sine; 3:Star; 4:Beam; 5:Symmetry; 6:Noise; 7:Turbulence; 8:Fractal
 	//! [Default value] 0
	int get_Shape() const { return getInt("Shape"); }

	//! (description missing)
	//! [Default value] 0.5
	bool set_ShapeX(float val) { return setValue("ShapeX", val); }
	//! (description missing)
	//! [Default value] 0.5
	float get_ShapeX() const { return getFloat("ShapeX"); }

	//! (description missing)
	//! [Default value] 0.5
	bool set_ShapeY(float val) { return setValue("ShapeY", val); }
	//! (description missing)
	//! [Default value] 0.5
	float get_ShapeY() const { return getFloat("ShapeY"); }

	//! (description missing)
	//! [Default value] 0
	bool set_ShapeRGB(int val) { return setValue("ShapeRGB", val); }
	//! (description missing)
	//! [Default value] 0
	int get_ShapeRGB() const { return getInt("ShapeRGB"); }

	//! (description missing)
	//! [Default value] 1
	bool set_ShapeAlpha(int val) { return setValue("ShapeAlpha", val); }
	//! (description missing)
	//! [Default value] 1
	int get_ShapeAlpha() const { return getInt("ShapeAlpha"); }

	//! (description missing)
	//! [Default value] 0
	bool set_ShapeRGBInvert(int val) { return setValue("ShapeRGBInvert", val); }
	//! (description missing)
	//! [Default value] 0
	int get_ShapeRGBInvert() const { return getInt("ShapeRGBInvert"); }

	//! (description missing)
	//! [Default value] 0
	bool set_ShapeAlphaInvert(int val) { return setValue("ShapeAlphaInvert", val); }
	//! (description missing)
	//! [Default value] 0
	int get_ShapeAlphaInvert() const { return getInt("ShapeAlphaInvert"); }

	//! (description missing)
	//! [Default value] 0.4
	bool set_StepWidth(float val) { return setValue("StepWidth", val); }
	//! (description missing)
	//! [Default value] 0.4
	float get_StepWidth() const { return getFloat("StepWidth"); }

	//! (description missing)
	//! [Default value] 11
	bool set_SineScale(float val) { return setValue("SineScale", val); }
	//! (description missing)
	//! [Default value] 11
	float get_SineScale() const { return getFloat("SineScale"); }

	//! (description missing)
	//! [Default value] 4
	bool set_StarBranches(float val) { return setValue("StarBranches", val); }
	//! (description missing)
	//! [Default value] 4
	float get_StarBranches() const { return getFloat("StarBranches"); }

	//! (description missing)
	//! [Default value] 0.02
	bool set_BeamWidth(float val) { return setValue("BeamWidth", val); }
	//! (description missing)
	//! [Default value] 0.02
	float get_BeamWidth() const { return getFloat("BeamWidth"); }

	//! (description missing)
	//! [Default value] 0.2
	bool set_SymmetryWidth(float val) { return setValue("SymmetryWidth", val); }
	//! (description missing)
	//! [Default value] 0.2
	float get_SymmetryWidth() const { return getFloat("SymmetryWidth"); }

	//! (description missing)
	//! [Default value] 0
	bool set_NoiseTime(float val) { return setValue("NoiseTime", val); }
	//! (description missing)
	//! [Default value] 0
	float get_NoiseTime() const { return getFloat("NoiseTime"); }

	//! (description missing)
	//! [Default value] 1
	bool set_NoiseScale(float val) { return setValue("NoiseScale", val); }
	//! (description missing)
	//! [Default value] 1
	float get_NoiseScale() const { return getFloat("NoiseScale"); }

	//! (description missing)
	//! [Default value] 0
	bool set_TurbTime(float val) { return setValue("TurbTime", val); }
	//! (description missing)
	//! [Default value] 0
	float get_TurbTime() const { return getFloat("TurbTime"); }

	//! (description missing)
	//! [Default value] 1
	bool set_TurbScale(float val) { return setValue("TurbScale", val); }
	//! (description missing)
	//! [Default value] 1
	float get_TurbScale() const { return getFloat("TurbScale"); }

	//! (description missing)
	//! [Default value] 1
	bool set_TurbLoFreq(float val) { return setValue("TurbLoFreq", val); }
	//! (description missing)
	//! [Default value] 1
	float get_TurbLoFreq() const { return getFloat("TurbLoFreq"); }

	//! (description missing)
	//! [Default value] 4
	bool set_TurbHiFreq(float val) { return setValue("TurbHiFreq", val); }
	//! (description missing)
	//! [Default value] 4
	float get_TurbHiFreq() const { return getFloat("TurbHiFreq"); }

	//! (description missing)
	//! [Default value] 0
	bool set_FracTime(float val) { return setValue("FracTime", val); }
	//! (description missing)
	//! [Default value] 0
	float get_FracTime() const { return getFloat("FracTime"); }

	//! (description missing)
	//! [Default value] 0.4
	bool set_FracScale(float val) { return setValue("FracScale", val); }
	//! (description missing)
	//! [Default value] 0.4
	float get_FracScale() const { return getFloat("FracScale"); }

	//! (description missing)
	//! [Default value] 0.5
	bool set_FracWeight(float val) { return setValue("FracWeight", val); }
	//! (description missing)
	//! [Default value] 0.5
	float get_FracWeight() const { return getFloat("FracWeight"); }

	//! (description missing)
	//! [Default value] 1
	bool set_FracGranular(float val) { return setValue("FracGranular", val); }
	//! (description missing)
	//! [Default value] 1
	float get_FracGranular() const { return getFloat("FracGranular"); }

	//! (description missing)
	//! [Default value] 4
	bool set_FracOctave(int val) { return setValue("FracOctave", val); }
	//! (description missing)
	//! [Default value] 4
	int get_FracOctave() const { return getInt("FracOctave"); }
};

class TexPerVertexHairSampler : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexPerVertexHairSampler"; }

	//! Colors for each vertex the hair. Each values should match a vertex from the hair geometry.
 	//! [Default value] Color(0, 0, 0)
	bool set_vertex_values(const ColorList& colorList) { return setValue("vertex_values", colorList); }
	//! Colors for each vertex the hair. Each values should match a vertex from the hair geometry.
 	//! [Default value] Color(0, 0, 0)
	bool set_vertex_values(const Color* colors, size_t count) { return setArray("vertex_values", colors, count); }
	//! Colors for each vertex the hair. Each values should match a vertex from the hair geometry.
 	//! [Default value] Color(0, 0, 0)
	template<size_t count> bool set_vertex_values(const Color (&colors)[count]) { return setArray("vertex_values", colors, count); }
	//! Colors for each vertex the hair. Each values should match a vertex from the hair geometry.
 	//! [Default value] Color(0, 0, 0)
	ColorList get_vertex_values() const { return getColorList("vertex_values"); }
};

class TexPlusMinusAverage : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexPlusMinusAverage"; }

	//! 0 - No operation; 1 - Sum; 2 - Subtract from first; 3 - Average
 	//! [UI Guides] enum=0:No operation; 1:Sum; 2:Subtract from first; 3:Average
 	//! [Default value] 1
	bool set_operation(int val) { return setValue("operation", val); }
	//! 0 - No operation; 1 - Sum; 2 - Subtract from first; 3 - Average
 	//! [UI Guides] enum=0:No operation; 1:Sum; 2:Subtract from first; 3:Average
 	//! [Default value] 1
	int get_operation() const { return getInt("operation"); }

	//! (description missing)
	bool set_input1D(const ValueList& pluginList) { return setValue("input1D", pluginList); }
	//! (description missing)
	ValueList get_input1D() const { return getValueList("input1D"); }

	//! (description missing)
	bool set_input2D(const ValueList& pluginList) { return setValue("input2D", pluginList); }
	//! (description missing)
	ValueList get_input2D() const { return getValueList("input2D"); }

	//! (description missing)
	bool set_input3D(const ValueList& pluginList) { return setValue("input3D", pluginList); }
	//! (description missing)
	ValueList get_input3D() const { return getValueList("input3D"); }
};

class TexPtex : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexPtex"; }

	//! The Ptex texture file
 	//! [UI Guides] fileAsset=ptx;
 	bool set_ptex_file(const char* str) { return setValue("ptex_file", str); }
	//! The Ptex texture file
 	//! [UI Guides] fileAsset=ptx;
 	bool set_ptex_file(const std::string& str) { return setValue("ptex_file", str); }
	//! The Ptex texture file
 	//! [UI Guides] fileAsset=ptx;
 	std::string get_ptex_file() const { return getString("ptex_file"); }

	//! (description missing)
	//! [Default value] false
	bool set_use_image_sequence(bool val) { return setValue("use_image_sequence", val); }
	//! (description missing)
	//! [Default value] false
	bool get_use_image_sequence() const { return getBool("use_image_sequence"); }

	//! [UI Guides] enableIf: ?use_image_sequence=1
 	//! [Default value] 0
	bool set_image_number(int val) { return setValue("image_number", val); }
	//! [UI Guides] enableIf: ?use_image_sequence=1
 	//! [Default value] 0
	int get_image_number() const { return getInt("image_number"); }

	//! [UI Guides] enableIf: ?use_image_sequence=1
 	//! [Default value] 0
	bool set_image_offset(int val) { return setValue("image_offset", val); }
	//! [UI Guides] enableIf: ?use_image_sequence=1
 	//! [Default value] 0
	int get_image_offset() const { return getInt("image_offset"); }

	//! (description missing)
	//! [Default value] 0
	bool set_ifl_start_frame(int val) { return setValue("ifl_start_frame", val); }
	//! (description missing)
	//! [Default value] 0
	int get_ifl_start_frame() const { return getInt("ifl_start_frame"); }

	//! [UI Guides] minValue=0
 	//! [Default value] 1
	bool set_ifl_playback_rate(float val) { return setValue("ifl_playback_rate", val); }
	//! [UI Guides] minValue=0
 	//! [Default value] 1
	float get_ifl_playback_rate() const { return getFloat("ifl_playback_rate"); }

	//! Image file list (IFL) end condition: 0 - Loop; 1 - Ping Pong; 2 - Hold;
 	//! [UI Guides] enum=0:Loop;1:Ping Pong;2:Hold
 	//! [Default value] 0
	bool set_ifl_end_condition(int val) { return setValue("ifl_end_condition", val); }
	//! Image file list (IFL) end condition: 0 - Loop; 1 - Ping Pong; 2 - Hold;
 	//! [UI Guides] enum=0:Loop;1:Ping Pong;2:Hold
 	//! [Default value] 0
	int get_ifl_end_condition() const { return getInt("ifl_end_condition"); }

	//! Type of filter used for the texture
 	//! [UI Guides] enum=0:No filtering;1:Bi-linear;2:Box;3:Gaussian;4:Bicubic;5:B-Splice;6:Catmull-Rom;7:Mitchell
 	//! [Default value] 0
	bool set_filter_type(int val) { return setValue("filter_type", val); }
	//! Type of filter used for the texture
 	//! [UI Guides] enum=0:No filtering;1:Bi-linear;2:Box;3:Gaussian;4:Bicubic;5:B-Splice;6:Catmull-Rom;7:Mitchell
 	//! [Default value] 0
	int get_filter_type() const { return getInt("filter_type"); }

	//! width parameter used for filtering
 	//! [UI Guides] enableIf: ?filter_type!=0, minValue=0
 	//! [Default value] 1
	bool set_width(float val) { return setValue("width", val); }
	//! width parameter used for filtering
 	//! [UI Guides] enableIf: ?filter_type!=0, minValue=0
 	//! [Default value] 1
	float get_width() const { return getFloat("width"); }

	//! blur parameter used for filtering
 	//! [UI Guides] enableIf: ?filter_type!=0, minValue=0, maxValue=1
 	//! [Default value] 0
	bool set_blur(float val) { return setValue("blur", val); }
	//! blur parameter used for filtering
 	//! [UI Guides] enableIf: ?filter_type!=0, minValue=0, maxValue=1
 	//! [Default value] 0
	float get_blur() const { return getFloat("blur"); }

	//! Sharpness parameter for the general bicubic filter
 	//! [UI Guides] enableIf: ?filter_type==4, minValue=0
 	//! [Default value] 0
	bool set_sharpness(float val) { return setValue("sharpness", val); }
	//! Sharpness parameter for the general bicubic filter
 	//! [UI Guides] enableIf: ?filter_type==4, minValue=0
 	//! [Default value] 0
	float get_sharpness() const { return getFloat("sharpness"); }

	//! Interpolation between mipmap levels
 	//! [UI Guides] displayName=Interpolation between mipmap levels, enableIf: ?filter_type!=0
 	//! [Default value] false
	bool set_lerp(bool val) { return setValue("lerp", val); }
	//! Interpolation between mipmap levels
 	//! [UI Guides] displayName=Interpolation between mipmap levels, enableIf: ?filter_type!=0
 	//! [Default value] false
	bool get_lerp() const { return getBool("lerp"); }

	//! Allow anisotropic texture filtering
 	//! [UI Guides] enableIf: ?filter_type!=0
 	//! [Default value] true
	bool set_anisotropic_filtering(bool val) { return setValue("anisotropic_filtering", val); }
	//! Allow anisotropic texture filtering
 	//! [UI Guides] enableIf: ?filter_type!=0
 	//! [Default value] true
	bool get_anisotropic_filtering() const { return getBool("anisotropic_filtering"); }

	//! Reverses the order of vertices
 	//! [UI Guides] displayName=Reverse vertex order
 	//! [Default value] false
	bool set_reverse_vertices(bool val) { return setValue("reverse_vertices", val); }
	//! Reverses the order of vertices
 	//! [UI Guides] displayName=Reverse vertex order
 	//! [Default value] false
	bool get_reverse_vertices() const { return getBool("reverse_vertices"); }

	//! The size of the texture cache(in MB)
 	//! [UI Guides] displayName=Cache sizeMBs, minValue=1
 	//! [Default value] 50
	bool set_cache_size(int val) { return setValue("cache_size", val); }
	//! The size of the texture cache(in MB)
 	//! [UI Guides] displayName=Cache sizeMBs, minValue=1
 	//! [Default value] 50
	int get_cache_size() const { return getInt("cache_size"); }

	//! Use automatic color channel selection.
 	//! [UI Guides] displayName=Auto select color channels
 	//! [Default value] true
	bool set_auto_color(bool val) { return setValue("auto_color", val); }
	//! Use automatic color channel selection.
 	//! [UI Guides] displayName=Auto select color channels
 	//! [Default value] true
	bool get_auto_color() const { return getBool("auto_color"); }

	//! The index of the channel which will be used as a red channel.
 	//! [UI Guides] enableIf: ?auto_color=0, minValue=0
 	//! [Default value] 0
	bool set_r_channel(int val) { return setValue("r_channel", val); }
	//! The index of the channel which will be used as a red channel.
 	//! [UI Guides] enableIf: ?auto_color=0, minValue=0
 	//! [Default value] 0
	int get_r_channel() const { return getInt("r_channel"); }

	//! The index of the channel which will be used as a green channel.
 	//! [UI Guides] enableIf: ?auto_color=0, minValue=0
 	//! [Default value] 1
	bool set_g_channel(int val) { return setValue("g_channel", val); }
	//! The index of the channel which will be used as a green channel.
 	//! [UI Guides] enableIf: ?auto_color=0, minValue=0
 	//! [Default value] 1
	int get_g_channel() const { return getInt("g_channel"); }

	//! The index of the channel which will be used as a blue channel.
 	//! [UI Guides] enableIf: ?auto_color=0, minValue=0
 	//! [Default value] 2
	bool set_b_channel(int val) { return setValue("b_channel", val); }
	//! The index of the channel which will be used as a blue channel.
 	//! [UI Guides] enableIf: ?auto_color=0, minValue=0
 	//! [Default value] 2
	int get_b_channel() const { return getInt("b_channel"); }

	//! Use automatic alpha channel selection.
 	//! [UI Guides] displayName=Auto select alpha channel
 	//! [Default value] true
	bool set_auto_alpha(bool val) { return setValue("auto_alpha", val); }
	//! Use automatic alpha channel selection.
 	//! [UI Guides] displayName=Auto select alpha channel
 	//! [Default value] true
	bool get_auto_alpha() const { return getBool("auto_alpha"); }

	//! The index of the channel which will be used as a alpha channel.
 	//! [UI Guides] enableIf: ?auto_alpha=0, minValue=0
 	//! [Default value] -1
	bool set_a_channel(int val) { return setValue("a_channel", val); }
	//! The index of the channel which will be used as a alpha channel.
 	//! [UI Guides] enableIf: ?auto_alpha=0, minValue=0
 	//! [Default value] -1
	int get_a_channel() const { return getInt("a_channel"); }

	//! Where to take the alpha from.
 	//! [UI Guides] enum=0:Solid;1:Alpha from texture;2:Alpha from luminance
 	//! [Default value] -1
	bool set_alpha_type(int val) { return setValue("alpha_type", val); }
	//! Where to take the alpha from.
 	//! [UI Guides] enum=0:Solid;1:Alpha from texture;2:Alpha from luminance
 	//! [Default value] -1
	int get_alpha_type() const { return getInt("alpha_type"); }

	//! 0 - linear, 1 - gamma corrected, 2 - sRGB
 	//! [UI Guides] enum=0:Linear;1:Gamma corrected;2:sRGB
 	//! [Default value] 1
	bool set_color_space(int val) { return setValue("color_space", val); }
	//! 0 - linear, 1 - gamma corrected, 2 - sRGB
 	//! [UI Guides] enum=0:Linear;1:Gamma corrected;2:sRGB
 	//! [Default value] 1
	int get_color_space() const { return getInt("color_space"); }

	//! [UI Guides] enableIf: ?color_space=1, minValue=0.05, maxValue=20
 	//! [Default value] 1
	bool set_gamma(float val) { return setValue("gamma", val); }
	//! [UI Guides] enableIf: ?color_space=1, minValue=0.05, maxValue=20
 	//! [Default value] 1
	float get_gamma() const { return getFloat("gamma"); }

	//! (description missing)
	bool set_vertices(const VectorList& vectorList) { return setValue("vertices", vectorList); }
	//! (description missing)
	bool set_vertices(const Vector* vectors, size_t count) { return setArray("vertices", vectors, count); }
	//! (description missing)
	template<size_t count> bool set_vertices(const Vector (&vectors)[count]) { return setArray("vertices", vectors, count); }
	//! (description missing)
	VectorList get_vertices() const { return getVectorList("vertices"); }

	//! (description missing)
	bool set_origFaces(const IntList& intList) { return setValue("origFaces", intList); }
	//! (description missing)
	bool set_origFaces(const int* ints, size_t count) { return setArray("origFaces", ints, count); }
	//! (description missing)
	template<size_t count> bool set_origFaces(const int (&ints)[count]) { return setArray("origFaces", ints, count); }
	//! (description missing)
	IntList get_origFaces() const { return getIntList("origFaces"); }

	//! (description missing)
	bool set_faces(const IntList& intList) { return setValue("faces", intList); }
	//! (description missing)
	bool set_faces(const int* ints, size_t count) { return setArray("faces", ints, count); }
	//! (description missing)
	template<size_t count> bool set_faces(const int (&ints)[count]) { return setArray("faces", ints, count); }
	//! (description missing)
	IntList get_faces() const { return getIntList("faces"); }

	//! (description missing)
	bool set_origFacesDegree(const IntList& intList) { return setValue("origFacesDegree", intList); }
	//! (description missing)
	bool set_origFacesDegree(const int* ints, size_t count) { return setArray("origFacesDegree", ints, count); }
	//! (description missing)
	template<size_t count> bool set_origFacesDegree(const int (&ints)[count]) { return setArray("origFacesDegree", ints, count); }
	//! (description missing)
	IntList get_origFacesDegree() const { return getIntList("origFacesDegree"); }

	//! A multiplier for the texture color
 	bool set_color_gain(const Plugin& texture) { return setValue("color_gain", texture); }
	//! A multiplier for the texture color
 	bool set_color_gain(const AColor& texture) { return setValue("color_gain", texture); }
	//! A multiplier for the texture color
 	Value get_color_gain() const { return getValue("color_gain"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }
};

class TexRGBMultiplyMax : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexRGBMultiplyMax"; }

	//! The first texture
 	bool set_color_a(const Plugin& texture) { return setValue("color_a", texture); }
	//! The first texture
 	bool set_color_a(const AColor& texture) { return setValue("color_a", texture); }
	//! The first texture
 	Value get_color_a() const { return getValue("color_a"); }

	//! The second texture
 	bool set_color_b(const Plugin& texture) { return setValue("color_b", texture); }
	//! The second texture
 	bool set_color_b(const AColor& texture) { return setValue("color_b", texture); }
	//! The second texture
 	Value get_color_b() const { return getValue("color_b"); }

	//! Alpha mode (0 - from color_a, 1 - from color_b, 2 - multiply
 	//! [UI Guides] enum=0:From color_a; 1:From color_b; 2:Multiply
 	//! [Default value] 2
	bool set_alpha_mode(int val) { return setValue("alpha_mode", val); }
	//! Alpha mode (0 - from color_a, 1 - from color_b, 2 - multiply
 	//! [UI Guides] enum=0:From color_a; 1:From color_b; 2:Multiply
 	//! [Default value] 2
	int get_alpha_mode() const { return getInt("alpha_mode"); }
};

class TexRGBTintMax : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexRGBTintMax"; }

	//! The texture
 	bool set_texture(const Plugin& texture) { return setValue("texture", texture); }
	//! The texture
 	bool set_texture(const AColor& texture) { return setValue("texture", texture); }
	//! The texture
 	Value get_texture() const { return getValue("texture"); }

	//! The red color
 	//! [Default value] Color(1, 0, 0)
	bool set_red(const Color& color) { return setValue("red", color); }
	//! The red color
 	//! [Default value] Color(1, 0, 0)
	Color get_red() const { return getColor("red"); }

	//! The green color
 	//! [Default value] Color(0, 1, 0)
	bool set_green(const Color& color) { return setValue("green", color); }
	//! The green color
 	//! [Default value] Color(0, 1, 0)
	Color get_green() const { return getColor("green"); }

	//! The blue color
 	//! [Default value] Color(0, 0, 1)
	bool set_blue(const Color& color) { return setValue("blue", color); }
	//! The blue color
 	//! [Default value] Color(0, 0, 1)
	Color get_blue() const { return getColor("blue"); }
};

class TexRGBToHSV : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexRGBToHSV"; }

	//! (description missing)
	bool set_inRgb(const Plugin& texture) { return setValue("inRgb", texture); }
	//! (description missing)
	bool set_inRgb(const AColor& texture) { return setValue("inRgb", texture); }
	//! (description missing)
	Value get_inRgb() const { return getValue("inRgb"); }
};

class TexRamp : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexRamp"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	bool set_placement_type(int val) { return setValue("placement_type", val); }
	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	int get_placement_type() const { return getInt("placement_type"); }

	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_u(float val) { return setValue("u", val); }
	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_u() const { return getFloat("u"); }

	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_v(float val) { return setValue("v", val); }
	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_v() const { return getFloat("v"); }

	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_w(float val) { return setValue("w", val); }
	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_w() const { return getFloat("w"); }

	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_h(float val) { return setValue("h", val); }
	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_h() const { return getFloat("h"); }

	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	bool set_jitter(float val) { return setValue("jitter", val); }
	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	float get_jitter() const { return getFloat("jitter"); }

	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_u(bool val) { return setValue("tile_u", val); }
	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_u() const { return getBool("tile_u"); }

	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_v(bool val) { return setValue("tile_v", val); }
	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_v() const { return getBool("tile_v"); }

	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool set_uv_noise_on(bool val) { return setValue("uv_noise_on", val); }
	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool get_uv_noise_on() const { return getBool("uv_noise_on"); }

	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool set_uv_noise_animate(bool val) { return setValue("uv_noise_animate", val); }
	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool get_uv_noise_animate() const { return getBool("uv_noise_animate"); }

	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	bool set_uv_noise_amount(float val) { return setValue("uv_noise_amount", val); }
	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	float get_uv_noise_amount() const { return getFloat("uv_noise_amount"); }

	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	bool set_uv_noise_levels(float val) { return setValue("uv_noise_levels", val); }
	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	float get_uv_noise_levels() const { return getFloat("uv_noise_levels"); }

	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	bool set_uv_noise_size(float val) { return setValue("uv_noise_size", val); }
	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	float get_uv_noise_size() const { return getFloat("uv_noise_size"); }

	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	bool set_un_noise_phase(float val) { return setValue("un_noise_phase", val); }
	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	float get_un_noise_phase() const { return getFloat("un_noise_phase"); }

	//! positions of the given colors
 	bool set_positions(const ValueList& texturefloatList) { return setValue("positions", texturefloatList); }
	//! positions of the given colors
 	ValueList get_positions() const { return getValueList("positions"); }

	//! the given colors
 	bool set_colors(const ValueList& textureList) { return setValue("colors", textureList); }
	//! the given colors
 	ValueList get_colors() const { return getValueList("colors"); }

	//! 0:V, 1:U, 2:(U+V)/2, 3:radial, 4:circular, 5:box, 6:UV, 7:four corner, 8:tartan
 	//! [UI Guides] enum=0:V; 1:U; 2:U+V/2; 3:Radial; 4:Circular; 5:Box; 6:UV; 7:Four corner; 8:Tartan
 	//! [Default value] 0
	bool set_type(int val) { return setValue("type", val); }
	//! 0:V, 1:U, 2:(U+V)/2, 3:radial, 4:circular, 5:box, 6:UV, 7:four corner, 8:tartan
 	//! [UI Guides] enum=0:V; 1:U; 2:U+V/2; 3:Radial; 4:Circular; 5:Box; 6:UV; 7:Four corner; 8:Tartan
 	//! [Default value] 0
	int get_type() const { return getInt("type"); }

	//! 0:none, 1:linear, 2:expUp, 3:expDown, 4:smooth, 5:bump, 6:spike
 	//! [UI Guides] enum=0:None; 1:Linear; 2:Exponent Up; 3:Exponent Down; 4:Smooth; 5:Bump; 6:Stroke
 	//! [Default value] 1
	bool set_interpolation(int val) { return setValue("interpolation", val); }
	//! 0:none, 1:linear, 2:expUp, 3:expDown, 4:smooth, 5:bump, 6:spike
 	//! [UI Guides] enum=0:None; 1:Linear; 2:Exponent Up; 3:Exponent Down; 4:Smooth; 5:Bump; 6:Stroke
 	//! [Default value] 1
	int get_interpolation() const { return getInt("interpolation"); }

	//! Sine wave offset in the u direction
 	//! [Default value] 0
	bool set_u_wave(float val) { return setValue("u_wave", val); }
	//! Sine wave offset in the u direction
 	//! [Default value] 0
	float get_u_wave() const { return getFloat("u_wave"); }

	//! Sine wave offset in the v direction
 	//! [Default value] 0
	bool set_v_wave(float val) { return setValue("v_wave", val); }
	//! Sine wave offset in the v direction
 	//! [Default value] 0
	float get_v_wave() const { return getFloat("v_wave"); }

	//! Distortion noise amount
 	//! [Default value] 0
	bool set_noise_amount(float val) { return setValue("noise_amount", val); }
	//! Distortion noise amount
 	//! [Default value] 0
	float get_noise_amount() const { return getFloat("noise_amount"); }

	//! Distortion noise frequency
 	//! [Default value] 0.5
	bool set_noise_frequency(float val) { return setValue("noise_frequency", val); }
	//! Distortion noise frequency
 	//! [Default value] 0.5
	float get_noise_frequency() const { return getFloat("noise_frequency"); }

	//! Hue noise amount
 	//! [Default value] 0
	bool set_hue_noise_amount(float val) { return setValue("hue_noise_amount", val); }
	//! Hue noise amount
 	//! [Default value] 0
	float get_hue_noise_amount() const { return getFloat("hue_noise_amount"); }

	//! Hue noise frequency
 	//! [Default value] 0.5
	bool set_hue_noise_frequency(float val) { return setValue("hue_noise_frequency", val); }
	//! Hue noise frequency
 	//! [Default value] 0.5
	float get_hue_noise_frequency() const { return getFloat("hue_noise_frequency"); }

	//! Saturation noise amount
 	//! [Default value] 0
	bool set_saturation_noise_amount(float val) { return setValue("saturation_noise_amount", val); }
	//! Saturation noise amount
 	//! [Default value] 0
	float get_saturation_noise_amount() const { return getFloat("saturation_noise_amount"); }

	//! Saturation noise frequency
 	//! [Default value] 0.5
	bool set_saturation_noise_frequency(float val) { return setValue("saturation_noise_frequency", val); }
	//! Saturation noise frequency
 	//! [Default value] 0.5
	float get_saturation_noise_frequency() const { return getFloat("saturation_noise_frequency"); }

	//! Value noise amount
 	//! [Default value] 0
	bool set_value_noise_amount(float val) { return setValue("value_noise_amount", val); }
	//! Value noise amount
 	//! [Default value] 0
	float get_value_noise_amount() const { return getFloat("value_noise_amount"); }

	//! Value noise frequency
 	//! [Default value] 0.5
	bool set_value_noise_frequency(float val) { return setValue("value_noise_frequency", val); }
	//! Value noise frequency
 	//! [Default value] 0.5
	float get_value_noise_frequency() const { return getFloat("value_noise_frequency"); }
};

class TexRaySwitch : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexRaySwitch"; }

	//! This texture is used if texture is not set for specific ray type or if the ray type is unknown.
 	//! [UI Guides] displayName=Default tex
 	bool set_default_texture(const Plugin& texture) { return setValue("default_texture", texture); }
	//! This texture is used if texture is not set for specific ray type or if the ray type is unknown.
 	//! [UI Guides] displayName=Default tex
 	bool set_default_texture(const AColor& texture) { return setValue("default_texture", texture); }
	//! This texture is used if texture is not set for specific ray type or if the ray type is unknown.
 	//! [UI Guides] displayName=Default tex
 	Value get_default_texture() const { return getValue("default_texture"); }

	//! This texture is used for shadow rays.
 	//! [UI Guides] displayName=Shadow rays tex
 	bool set_shadow_ray_texture(const Plugin& texture) { return setValue("shadow_ray_texture", texture); }
	//! This texture is used for shadow rays.
 	//! [UI Guides] displayName=Shadow rays tex
 	bool set_shadow_ray_texture(const AColor& texture) { return setValue("shadow_ray_texture", texture); }
	//! This texture is used for shadow rays.
 	//! [UI Guides] displayName=Shadow rays tex
 	Value get_shadow_ray_texture() const { return getValue("shadow_ray_texture"); }

	//! This texture is used for GI rays.
 	//! [UI Guides] displayName=GI rays tex
 	bool set_gi_ray_texture(const Plugin& texture) { return setValue("gi_ray_texture", texture); }
	//! This texture is used for GI rays.
 	//! [UI Guides] displayName=GI rays tex
 	bool set_gi_ray_texture(const AColor& texture) { return setValue("gi_ray_texture", texture); }
	//! This texture is used for GI rays.
 	//! [UI Guides] displayName=GI rays tex
 	Value get_gi_ray_texture() const { return getValue("gi_ray_texture"); }

	//! This texture is used for reflection rays.
 	//! [UI Guides] displayName=Reflection rays tex
 	bool set_reflect_ray_texture(const Plugin& texture) { return setValue("reflect_ray_texture", texture); }
	//! This texture is used for reflection rays.
 	//! [UI Guides] displayName=Reflection rays tex
 	bool set_reflect_ray_texture(const AColor& texture) { return setValue("reflect_ray_texture", texture); }
	//! This texture is used for reflection rays.
 	//! [UI Guides] displayName=Reflection rays tex
 	Value get_reflect_ray_texture() const { return getValue("reflect_ray_texture"); }

	//! This texture is used for refraction rays.
 	//! [UI Guides] displayName=Refraction rays tex
 	bool set_refract_ray_texture(const Plugin& texture) { return setValue("refract_ray_texture", texture); }
	//! This texture is used for refraction rays.
 	//! [UI Guides] displayName=Refraction rays tex
 	bool set_refract_ray_texture(const AColor& texture) { return setValue("refract_ray_texture", texture); }
	//! This texture is used for refraction rays.
 	//! [UI Guides] displayName=Refraction rays tex
 	Value get_refract_ray_texture() const { return getValue("refract_ray_texture"); }
};

class TexRemap : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexRemap"; }

	//! type of conversion: 0:RemapValue, 1:RemapColor, 2:RemapHSV.
 	//! [UI Guides] enum=0:RemapValue; 1:RemapColor; 2:RemapHSV
 	//! [Default value] 0
	bool set_type(int val) { return setValue("type", val); }
	//! type of conversion: 0:RemapValue, 1:RemapColor, 2:RemapHSV.
 	//! [UI Guides] enum=0:RemapValue; 1:RemapColor; 2:RemapHSV
 	//! [Default value] 0
	int get_type() const { return getInt("type"); }

	//! (description missing)
	bool set_input_value(const Plugin& texturefloat) { return setValue("input_value", texturefloat); }
	//! (description missing)
	bool set_input_value(float texturefloat) { return setValue("input_value", texturefloat); }
	//! (description missing)
	Value get_input_value() const { return getValue("input_value"); }

	//! (description missing)
	bool set_input_color(const Plugin& texture) { return setValue("input_color", texture); }
	//! (description missing)
	bool set_input_color(const AColor& texture) { return setValue("input_color", texture); }
	//! (description missing)
	Value get_input_color() const { return getValue("input_color"); }

	//! (description missing)
	//! [Default value] 0
	bool set_input_bias(float val) { return setValue("input_bias", val); }
	//! (description missing)
	//! [Default value] 0
	float get_input_bias() const { return getFloat("input_bias"); }

	//! (description missing)
	bool set_input_bias_tex(const Plugin& texturefloat) { return setValue("input_bias_tex", texturefloat); }
	//! (description missing)
	bool set_input_bias_tex(float texturefloat) { return setValue("input_bias_tex", texturefloat); }
	//! (description missing)
	Value get_input_bias_tex() const { return getValue("input_bias_tex"); }

	//! (description missing)
	//! [Default value] 0
	bool set_input_min(float val) { return setValue("input_min", val); }
	//! (description missing)
	//! [Default value] 0
	float get_input_min() const { return getFloat("input_min"); }

	//! (description missing)
	bool set_input_min_tex(const Plugin& texturefloat) { return setValue("input_min_tex", texturefloat); }
	//! (description missing)
	bool set_input_min_tex(float texturefloat) { return setValue("input_min_tex", texturefloat); }
	//! (description missing)
	Value get_input_min_tex() const { return getValue("input_min_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_input_max(float val) { return setValue("input_max", val); }
	//! (description missing)
	//! [Default value] 1
	float get_input_max() const { return getFloat("input_max"); }

	//! (description missing)
	bool set_input_max_tex(const Plugin& texturefloat) { return setValue("input_max_tex", texturefloat); }
	//! (description missing)
	bool set_input_max_tex(float texturefloat) { return setValue("input_max_tex", texturefloat); }
	//! (description missing)
	Value get_input_max_tex() const { return getValue("input_max_tex"); }

	//! (description missing)
	//! [Default value] 0
	bool set_output_min(float val) { return setValue("output_min", val); }
	//! (description missing)
	//! [Default value] 0
	float get_output_min() const { return getFloat("output_min"); }

	//! (description missing)
	//! [Default value] 1
	bool set_output_max(float val) { return setValue("output_max", val); }
	//! (description missing)
	//! [Default value] 1
	float get_output_max() const { return getFloat("output_max"); }

	//! positions of the given float values
 	bool set_float_positions(const ValueList& texturefloatList) { return setValue("float_positions", texturefloatList); }
	//! positions of the given float values
 	ValueList get_float_positions() const { return getValueList("float_positions"); }

	//! the given float values
 	bool set_float_values(const ValueList& texturefloatList) { return setValue("float_values", texturefloatList); }
	//! the given float values
 	ValueList get_float_values() const { return getValueList("float_values"); }

	//! interpolation types for the floats (None - 0; Linear - 1; Smooth - 2; Spline - 3)
 	//! [UI Guides] enum=0:None; 1:Linear; 2:Smooth; 3:Spline
 	//! [Default value] 0
	bool set_float_types(const IntList& intList) { return setValue("float_types", intList); }
	//! interpolation types for the floats (None - 0; Linear - 1; Smooth - 2; Spline - 3)
 	//! [UI Guides] enum=0:None; 1:Linear; 2:Smooth; 3:Spline
 	//! [Default value] 0
	bool set_float_types(const int* ints, size_t count) { return setArray("float_types", ints, count); }
	//! interpolation types for the floats (None - 0; Linear - 1; Smooth - 2; Spline - 3)
 	//! [UI Guides] enum=0:None; 1:Linear; 2:Smooth; 3:Spline
 	//! [Default value] 0
	template<size_t count> bool set_float_types(const int (&ints)[count]) { return setArray("float_types", ints, count); }
	//! interpolation types for the floats (None - 0; Linear - 1; Smooth - 2; Spline - 3)
 	//! [UI Guides] enum=0:None; 1:Linear; 2:Smooth; 3:Spline
 	//! [Default value] 0
	IntList get_float_types() const { return getIntList("float_types"); }

	//! the given float values
 	bool set_color_positions(const ValueList& texturefloatList) { return setValue("color_positions", texturefloatList); }
	//! the given float values
 	ValueList get_color_positions() const { return getValueList("color_positions"); }

	//! the given colors
 	bool set_color_colors(const ValueList& textureList) { return setValue("color_colors", textureList); }
	//! the given colors
 	ValueList get_color_colors() const { return getValueList("color_colors"); }

	//! interpolation types for the colors (None - 0; Linear - 1; Smooth - 2; Spline - 3)
 	//! [UI Guides] enum=0:None; 1:Linear; 2:Smooth; 3:Spline
 	//! [Default value] 0
	bool set_color_types(const IntList& intList) { return setValue("color_types", intList); }
	//! interpolation types for the colors (None - 0; Linear - 1; Smooth - 2; Spline - 3)
 	//! [UI Guides] enum=0:None; 1:Linear; 2:Smooth; 3:Spline
 	//! [Default value] 0
	bool set_color_types(const int* ints, size_t count) { return setArray("color_types", ints, count); }
	//! interpolation types for the colors (None - 0; Linear - 1; Smooth - 2; Spline - 3)
 	//! [UI Guides] enum=0:None; 1:Linear; 2:Smooth; 3:Spline
 	//! [Default value] 0
	template<size_t count> bool set_color_types(const int (&ints)[count]) { return setArray("color_types", ints, count); }
	//! interpolation types for the colors (None - 0; Linear - 1; Smooth - 2; Spline - 3)
 	//! [UI Guides] enum=0:None; 1:Linear; 2:Smooth; 3:Spline
 	//! [Default value] 0
	IntList get_color_types() const { return getIntList("color_types"); }

	//! positions of the given values for the red channel
 	bool set_red_positions(const ValueList& texturefloatList) { return setValue("red_positions", texturefloatList); }
	//! positions of the given values for the red channel
 	ValueList get_red_positions() const { return getValueList("red_positions"); }

	//! the given values for the red channel
 	bool set_red_values(const ValueList& texturefloatList) { return setValue("red_values", texturefloatList); }
	//! the given values for the red channel
 	ValueList get_red_values() const { return getValueList("red_values"); }

	//! interpolation types for the red channel (None - 0; Linear - 1; Smooth - 2; Spline - 3)
 	//! [UI Guides] enum=0:None; 1:Linear; 2:Smooth; 3:Spline
 	//! [Default value] 0
	bool set_red_types(const IntList& intList) { return setValue("red_types", intList); }
	//! interpolation types for the red channel (None - 0; Linear - 1; Smooth - 2; Spline - 3)
 	//! [UI Guides] enum=0:None; 1:Linear; 2:Smooth; 3:Spline
 	//! [Default value] 0
	bool set_red_types(const int* ints, size_t count) { return setArray("red_types", ints, count); }
	//! interpolation types for the red channel (None - 0; Linear - 1; Smooth - 2; Spline - 3)
 	//! [UI Guides] enum=0:None; 1:Linear; 2:Smooth; 3:Spline
 	//! [Default value] 0
	template<size_t count> bool set_red_types(const int (&ints)[count]) { return setArray("red_types", ints, count); }
	//! interpolation types for the red channel (None - 0; Linear - 1; Smooth - 2; Spline - 3)
 	//! [UI Guides] enum=0:None; 1:Linear; 2:Smooth; 3:Spline
 	//! [Default value] 0
	IntList get_red_types() const { return getIntList("red_types"); }

	//! positions of the given values for the green channel
 	bool set_green_positions(const ValueList& texturefloatList) { return setValue("green_positions", texturefloatList); }
	//! positions of the given values for the green channel
 	ValueList get_green_positions() const { return getValueList("green_positions"); }

	//! the given values for the green channel
 	bool set_green_values(const ValueList& texturefloatList) { return setValue("green_values", texturefloatList); }
	//! the given values for the green channel
 	ValueList get_green_values() const { return getValueList("green_values"); }

	//! interpolation types for the green channel (None - 0; Linear - 1; Smooth - 2; Spline - 3)
 	//! [UI Guides] enum=0:None; 1:Linear; 2:Smooth; 3:Spline
 	//! [Default value] 0
	bool set_green_types(const IntList& intList) { return setValue("green_types", intList); }
	//! interpolation types for the green channel (None - 0; Linear - 1; Smooth - 2; Spline - 3)
 	//! [UI Guides] enum=0:None; 1:Linear; 2:Smooth; 3:Spline
 	//! [Default value] 0
	bool set_green_types(const int* ints, size_t count) { return setArray("green_types", ints, count); }
	//! interpolation types for the green channel (None - 0; Linear - 1; Smooth - 2; Spline - 3)
 	//! [UI Guides] enum=0:None; 1:Linear; 2:Smooth; 3:Spline
 	//! [Default value] 0
	template<size_t count> bool set_green_types(const int (&ints)[count]) { return setArray("green_types", ints, count); }
	//! interpolation types for the green channel (None - 0; Linear - 1; Smooth - 2; Spline - 3)
 	//! [UI Guides] enum=0:None; 1:Linear; 2:Smooth; 3:Spline
 	//! [Default value] 0
	IntList get_green_types() const { return getIntList("green_types"); }

	//! positions of the given values for the blue channel
 	bool set_blue_positions(const ValueList& texturefloatList) { return setValue("blue_positions", texturefloatList); }
	//! positions of the given values for the blue channel
 	ValueList get_blue_positions() const { return getValueList("blue_positions"); }

	//! the given values for the blue channel
 	bool set_blue_values(const ValueList& texturefloatList) { return setValue("blue_values", texturefloatList); }
	//! the given values for the blue channel
 	ValueList get_blue_values() const { return getValueList("blue_values"); }

	//! interpolation types for the blue channel (None - 0; Linear - 1; Smooth - 2; Spline - 3)
 	//! [UI Guides] enum=0:None; 1:Linear; 2:Smooth; 3:Spline
 	//! [Default value] 0
	bool set_blue_types(const IntList& intList) { return setValue("blue_types", intList); }
	//! interpolation types for the blue channel (None - 0; Linear - 1; Smooth - 2; Spline - 3)
 	//! [UI Guides] enum=0:None; 1:Linear; 2:Smooth; 3:Spline
 	//! [Default value] 0
	bool set_blue_types(const int* ints, size_t count) { return setArray("blue_types", ints, count); }
	//! interpolation types for the blue channel (None - 0; Linear - 1; Smooth - 2; Spline - 3)
 	//! [UI Guides] enum=0:None; 1:Linear; 2:Smooth; 3:Spline
 	//! [Default value] 0
	template<size_t count> bool set_blue_types(const int (&ints)[count]) { return setArray("blue_types", ints, count); }
	//! interpolation types for the blue channel (None - 0; Linear - 1; Smooth - 2; Spline - 3)
 	//! [UI Guides] enum=0:None; 1:Linear; 2:Smooth; 3:Spline
 	//! [Default value] 0
	IntList get_blue_types() const { return getIntList("blue_types"); }

	//! positions of the given values for the hue channel
 	bool set_hue_positions(const ValueList& texturefloatList) { return setValue("hue_positions", texturefloatList); }
	//! positions of the given values for the hue channel
 	ValueList get_hue_positions() const { return getValueList("hue_positions"); }

	//! the given values for the hue channel
 	bool set_hue_values(const ValueList& texturefloatList) { return setValue("hue_values", texturefloatList); }
	//! the given values for the hue channel
 	ValueList get_hue_values() const { return getValueList("hue_values"); }

	//! interpolation types for the hue channel (None - 0; Linear - 1; Smooth - 2; Spline - 3)
 	//! [UI Guides] enum=0:None; 1:Linear; 2:Smooth; 3:Spline
 	//! [Default value] 0
	bool set_hue_types(const IntList& intList) { return setValue("hue_types", intList); }
	//! interpolation types for the hue channel (None - 0; Linear - 1; Smooth - 2; Spline - 3)
 	//! [UI Guides] enum=0:None; 1:Linear; 2:Smooth; 3:Spline
 	//! [Default value] 0
	bool set_hue_types(const int* ints, size_t count) { return setArray("hue_types", ints, count); }
	//! interpolation types for the hue channel (None - 0; Linear - 1; Smooth - 2; Spline - 3)
 	//! [UI Guides] enum=0:None; 1:Linear; 2:Smooth; 3:Spline
 	//! [Default value] 0
	template<size_t count> bool set_hue_types(const int (&ints)[count]) { return setArray("hue_types", ints, count); }
	//! interpolation types for the hue channel (None - 0; Linear - 1; Smooth - 2; Spline - 3)
 	//! [UI Guides] enum=0:None; 1:Linear; 2:Smooth; 3:Spline
 	//! [Default value] 0
	IntList get_hue_types() const { return getIntList("hue_types"); }

	//! positions of the given values for the saturation channel
 	bool set_saturation_positions(const ValueList& texturefloatList) { return setValue("saturation_positions", texturefloatList); }
	//! positions of the given values for the saturation channel
 	ValueList get_saturation_positions() const { return getValueList("saturation_positions"); }

	//! the given values for the saturation channel
 	bool set_saturation_values(const ValueList& texturefloatList) { return setValue("saturation_values", texturefloatList); }
	//! the given values for the saturation channel
 	ValueList get_saturation_values() const { return getValueList("saturation_values"); }

	//! interpolation types for the saturation channel (None - 0; Linear - 1; Smooth - 2; Spline - 3)
 	//! [UI Guides] enum=0:None; 1:Linear; 2:Smooth; 3:Spline
 	//! [Default value] 0
	bool set_saturation_types(const IntList& intList) { return setValue("saturation_types", intList); }
	//! interpolation types for the saturation channel (None - 0; Linear - 1; Smooth - 2; Spline - 3)
 	//! [UI Guides] enum=0:None; 1:Linear; 2:Smooth; 3:Spline
 	//! [Default value] 0
	bool set_saturation_types(const int* ints, size_t count) { return setArray("saturation_types", ints, count); }
	//! interpolation types for the saturation channel (None - 0; Linear - 1; Smooth - 2; Spline - 3)
 	//! [UI Guides] enum=0:None; 1:Linear; 2:Smooth; 3:Spline
 	//! [Default value] 0
	template<size_t count> bool set_saturation_types(const int (&ints)[count]) { return setArray("saturation_types", ints, count); }
	//! interpolation types for the saturation channel (None - 0; Linear - 1; Smooth - 2; Spline - 3)
 	//! [UI Guides] enum=0:None; 1:Linear; 2:Smooth; 3:Spline
 	//! [Default value] 0
	IntList get_saturation_types() const { return getIntList("saturation_types"); }

	//! positions of the given values for the value channel
 	bool set_value_positions(const ValueList& texturefloatList) { return setValue("value_positions", texturefloatList); }
	//! positions of the given values for the value channel
 	ValueList get_value_positions() const { return getValueList("value_positions"); }

	//! the given values for the value channel
 	bool set_value_values(const ValueList& texturefloatList) { return setValue("value_values", texturefloatList); }
	//! the given values for the value channel
 	ValueList get_value_values() const { return getValueList("value_values"); }

	//! interpolation types for the value channel (None - 0; Linear - 1; Smooth - 2; Spline - 3)
 	//! [UI Guides] enum=0:None; 1:Linear; 2:Smooth; 3:Spline
 	//! [Default value] 0
	bool set_value_types(const IntList& intList) { return setValue("value_types", intList); }
	//! interpolation types for the value channel (None - 0; Linear - 1; Smooth - 2; Spline - 3)
 	//! [UI Guides] enum=0:None; 1:Linear; 2:Smooth; 3:Spline
 	//! [Default value] 0
	bool set_value_types(const int* ints, size_t count) { return setArray("value_types", ints, count); }
	//! interpolation types for the value channel (None - 0; Linear - 1; Smooth - 2; Spline - 3)
 	//! [UI Guides] enum=0:None; 1:Linear; 2:Smooth; 3:Spline
 	//! [Default value] 0
	template<size_t count> bool set_value_types(const int (&ints)[count]) { return setArray("value_types", ints, count); }
	//! interpolation types for the value channel (None - 0; Linear - 1; Smooth - 2; Spline - 3)
 	//! [UI Guides] enum=0:None; 1:Linear; 2:Smooth; 3:Spline
 	//! [Default value] 0
	IntList get_value_types() const { return getIntList("value_types"); }

	//! If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the colors
 	//! [Default value] false
	bool set_alpha_from_intensity(bool val) { return setValue("alpha_from_intensity", val); }
	//! If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the colors
 	//! [Default value] false
	bool get_alpha_from_intensity() const { return getBool("alpha_from_intensity"); }
};

class TexRemapFloat : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexRemapFloat"; }

	//! Value to remap
 	bool set_value(const Plugin& texturefloat) { return setValue("value", texturefloat); }
	//! Value to remap
 	bool set_value(float texturefloat) { return setValue("value", texturefloat); }
	//! Value to remap
 	Value get_value() const { return getValue("value"); }

	//! Low boundary
 	//! [Default value] 0
	bool set_low(float val) { return setValue("low", val); }
	//! Low boundary
 	//! [Default value] 0
	float get_low() const { return getFloat("low"); }

	//! High boundary
 	//! [Default value] 1
	bool set_high(float val) { return setValue("high", val); }
	//! High boundary
 	//! [Default value] 1
	float get_high() const { return getFloat("high"); }
};

class TexRgbaCombine : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexRgbaCombine"; }

	//! Red channel input
 	bool set_red(const Plugin& texturefloat) { return setValue("red", texturefloat); }
	//! Red channel input
 	bool set_red(float texturefloat) { return setValue("red", texturefloat); }
	//! Red channel input
 	Value get_red() const { return getValue("red"); }

	//! Green channel input
 	bool set_green(const Plugin& texturefloat) { return setValue("green", texturefloat); }
	//! Green channel input
 	bool set_green(float texturefloat) { return setValue("green", texturefloat); }
	//! Green channel input
 	Value get_green() const { return getValue("green"); }

	//! Blue channel input
 	bool set_blue(const Plugin& texturefloat) { return setValue("blue", texturefloat); }
	//! Blue channel input
 	bool set_blue(float texturefloat) { return setValue("blue", texturefloat); }
	//! Blue channel input
 	Value get_blue() const { return getValue("blue"); }

	//! Alpha channel input
 	bool set_alpha(const Plugin& texturefloat) { return setValue("alpha", texturefloat); }
	//! Alpha channel input
 	bool set_alpha(float texturefloat) { return setValue("alpha", texturefloat); }
	//! Alpha channel input
 	Value get_alpha() const { return getValue("alpha"); }
};

class TexRgbaSplit : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexRgbaSplit"; }

	//! Color RGBA input texture
 	bool set_input(const Plugin& texture) { return setValue("input", texture); }
	//! Color RGBA input texture
 	bool set_input(const AColor& texture) { return setValue("input", texture); }
	//! Color RGBA input texture
 	Value get_input() const { return getValue("input"); }
};

class TexRock : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexRock"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! (description missing)
	//! [Default value] false
	bool set_use_3d_mapping(bool val) { return setValue("use_3d_mapping", val); }
	//! (description missing)
	//! [Default value] false
	bool get_use_3d_mapping() const { return getBool("use_3d_mapping"); }

	//! (description missing)
	//! [Default value] true
	bool set_wrap(bool val) { return setValue("wrap", val); }
	//! (description missing)
	//! [Default value] true
	bool get_wrap() const { return getBool("wrap"); }

	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	bool set_placement_type(int val) { return setValue("placement_type", val); }
	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	int get_placement_type() const { return getInt("placement_type"); }

	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_u(float val) { return setValue("u", val); }
	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_u() const { return getFloat("u"); }

	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_v(float val) { return setValue("v", val); }
	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_v() const { return getFloat("v"); }

	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_w(float val) { return setValue("w", val); }
	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_w() const { return getFloat("w"); }

	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_h(float val) { return setValue("h", val); }
	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_h() const { return getFloat("h"); }

	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	bool set_jitter(float val) { return setValue("jitter", val); }
	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	float get_jitter() const { return getFloat("jitter"); }

	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_u(bool val) { return setValue("tile_u", val); }
	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_u() const { return getBool("tile_u"); }

	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_v(bool val) { return setValue("tile_v", val); }
	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_v() const { return getBool("tile_v"); }

	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool set_uv_noise_on(bool val) { return setValue("uv_noise_on", val); }
	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool get_uv_noise_on() const { return getBool("uv_noise_on"); }

	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool set_uv_noise_animate(bool val) { return setValue("uv_noise_animate", val); }
	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool get_uv_noise_animate() const { return getBool("uv_noise_animate"); }

	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	bool set_uv_noise_amount(float val) { return setValue("uv_noise_amount", val); }
	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	float get_uv_noise_amount() const { return getFloat("uv_noise_amount"); }

	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	bool set_uv_noise_levels(float val) { return setValue("uv_noise_levels", val); }
	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	float get_uv_noise_levels() const { return getFloat("uv_noise_levels"); }

	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	bool set_uv_noise_size(float val) { return setValue("uv_noise_size", val); }
	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	float get_uv_noise_size() const { return getFloat("uv_noise_size"); }

	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	bool set_un_noise_phase(float val) { return setValue("un_noise_phase", val); }
	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	float get_un_noise_phase() const { return getFloat("un_noise_phase"); }

	//! [UI Guides] displayName=Color 1
 	bool set_color1_tex(const Plugin& texture) { return setValue("color1_tex", texture); }
	//! [UI Guides] displayName=Color 1
 	bool set_color1_tex(const AColor& texture) { return setValue("color1_tex", texture); }
	//! [UI Guides] displayName=Color 1
 	Value get_color1_tex() const { return getValue("color1_tex"); }

	//! [UI Guides] displayName=Color 2
 	bool set_color2_tex(const Plugin& texture) { return setValue("color2_tex", texture); }
	//! [UI Guides] displayName=Color 2
 	bool set_color2_tex(const AColor& texture) { return setValue("color2_tex", texture); }
	//! [UI Guides] displayName=Color 2
 	Value get_color2_tex() const { return getValue("color2_tex"); }

	//! [UI Guides] minValue=0
 	//! [Default value] 0.01
	bool set_grain_size(float val) { return setValue("grain_size", val); }
	//! [UI Guides] minValue=0
 	//! [Default value] 0.01
	float get_grain_size() const { return getFloat("grain_size"); }

	//! [UI Guides] minValue=0
 	//! [Default value] 1
	bool set_diffusion(float val) { return setValue("diffusion", val); }
	//! [UI Guides] minValue=0
 	//! [Default value] 1
	float get_diffusion() const { return getFloat("diffusion"); }

	//! [UI Guides] minValue=0
 	//! [Default value] 0.5
	bool set_mix_ratio(float val) { return setValue("mix_ratio", val); }
	//! [UI Guides] minValue=0
 	//! [Default value] 0.5
	float get_mix_ratio() const { return getFloat("mix_ratio"); }
};

class TexSampler : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexSampler"; }

	//! The name of the uv channel that should be used.
 	bool set_uv_set_name(const char* str) { return setValue("uv_set_name", str); }
	//! The name of the uv channel that should be used.
 	bool set_uv_set_name(const std::string& str) { return setValue("uv_set_name", str); }
	//! The name of the uv channel that should be used.
 	std::string get_uv_set_name() const { return getString("uv_set_name"); }

	//! The index of the uv channel that should be used in case there is no uv set name
 	//! [Default value] -1
	bool set_uv_index(int val) { return setValue("uv_index", val); }
	//! The index of the uv channel that should be used in case there is no uv set name
 	//! [Default value] -1
	int get_uv_index() const { return getInt("uv_index"); }
};

class TexScalarCurve : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexScalarCurve"; }

	//! The value from this texture is controlled by the profile curve.
 	bool set_input(const Plugin& texturefloat) { return setValue("input", texturefloat); }
	//! The value from this texture is controlled by the profile curve.
 	bool set_input(float texturefloat) { return setValue("input", texturefloat); }
	//! The value from this texture is controlled by the profile curve.
 	Value get_input() const { return getValue("input"); }

	//! Quadruplets of 2d vectors (two floats) for each bezier segment.
 	//! [Default value] 0
	bool set_keys(const FloatList& floatList) { return setValue("keys", floatList); }
	//! Quadruplets of 2d vectors (two floats) for each bezier segment.
 	//! [Default value] 0
	bool set_keys(const float* floats, size_t count) { return setArray("keys", floats, count); }
	//! Quadruplets of 2d vectors (two floats) for each bezier segment.
 	//! [Default value] 0
	template<size_t count> bool set_keys(const float (&floats)[count]) { return setArray("keys", floats, count); }
	//! Quadruplets of 2d vectors (two floats) for each bezier segment.
 	//! [Default value] 0
	FloatList get_keys() const { return getFloatList("keys"); }
};

class TexScalarExponential : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexScalarExponential"; }

	//! The value used in the operation.
 	bool set_input(const Plugin& texturefloat) { return setValue("input", texturefloat); }
	//! The value used in the operation.
 	bool set_input(float texturefloat) { return setValue("input", texturefloat); }
	//! The value used in the operation.
 	Value get_input() const { return getValue("input"); }

	//! The factor to be used in the operation.
 	bool set_factor(const Plugin& texturefloat) { return setValue("factor", texturefloat); }
	//! The factor to be used in the operation.
 	bool set_factor(float texturefloat) { return setValue("factor", texturefloat); }
	//! The factor to be used in the operation.
 	Value get_factor() const { return getValue("factor"); }

	//! The operation: 0=Exponential, 1=Logarithm, 2=Bias, 3=Gain
 	//! [UI Guides] enum=0:Exponential; 1:Logarithm; 2:Bias; 3:Gain
 	//! [Default value] 0
	bool set_operation(int val) { return setValue("operation", val); }
	//! The operation: 0=Exponential, 1=Logarithm, 2=Bias, 3=Gain
 	//! [UI Guides] enum=0:Exponential; 1:Logarithm; 2:Bias; 3:Gain
 	//! [Default value] 0
	int get_operation() const { return getInt("operation"); }
};

class TexScalarHairRootSampler : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexScalarHairRootSampler"; }

	//! The scalars at the root of each hair strand.
 	//! [Default value] 0
	bool set_root_values(const FloatList& floatList) { return setValue("root_values", floatList); }
	//! The scalars at the root of each hair strand.
 	//! [Default value] 0
	bool set_root_values(const float* floats, size_t count) { return setArray("root_values", floats, count); }
	//! The scalars at the root of each hair strand.
 	//! [Default value] 0
	template<size_t count> bool set_root_values(const float (&floats)[count]) { return setArray("root_values", floats, count); }
	//! The scalars at the root of each hair strand.
 	//! [Default value] 0
	FloatList get_root_values() const { return getFloatList("root_values"); }
};

class TexScalarMathBasic : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexScalarMathBasic"; }

	//! Operation: Add(), Subtract(), Multiply(), Divide(), Minimum(), Maximum()
 	//! [Default value] 0
	bool set_op(int val) { return setValue("op", val); }
	//! Operation: Add(), Subtract(), Multiply(), Divide(), Minimum(), Maximum()
 	//! [Default value] 0
	int get_op() const { return getInt("op"); }

	//! The first scalar input
 	bool set_input1(const Plugin& texturefloat) { return setValue("input1", texturefloat); }
	//! The first scalar input
 	bool set_input1(float texturefloat) { return setValue("input1", texturefloat); }
	//! The first scalar input
 	Value get_input1() const { return getValue("input1"); }

	//! The second scalar input
 	bool set_input2(const Plugin& texturefloat) { return setValue("input2", texturefloat); }
	//! The second scalar input
 	bool set_input2(float texturefloat) { return setValue("input2", texturefloat); }
	//! The second scalar input
 	Value get_input2() const { return getValue("input2"); }

	//! Specifies the maximum displacement value.  If the displacement value is higher than the Max Displacement value, displacement will be clipped
 	//! [Default value] -1
	bool set_max_displacement(float val) { return setValue("max_displacement", val); }
	//! Specifies the maximum displacement value.  If the displacement value is higher than the Max Displacement value, displacement will be clipped
 	//! [Default value] -1
	float get_max_displacement() const { return getFloat("max_displacement"); }
};

class TexSetRange : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexSetRange"; }

	//! (description missing)
	bool set_value(const Plugin& texture) { return setValue("value", texture); }
	//! (description missing)
	bool set_value(const AColor& texture) { return setValue("value", texture); }
	//! (description missing)
	Value get_value() const { return getValue("value"); }

	//! (description missing)
	bool set_oldMin(const Plugin& texture) { return setValue("oldMin", texture); }
	//! (description missing)
	bool set_oldMin(const AColor& texture) { return setValue("oldMin", texture); }
	//! (description missing)
	Value get_oldMin() const { return getValue("oldMin"); }

	//! (description missing)
	bool set_oldMax(const Plugin& texture) { return setValue("oldMax", texture); }
	//! (description missing)
	bool set_oldMax(const AColor& texture) { return setValue("oldMax", texture); }
	//! (description missing)
	Value get_oldMax() const { return getValue("oldMax"); }

	//! (description missing)
	bool set_newMin(const Plugin& texture) { return setValue("newMin", texture); }
	//! (description missing)
	bool set_newMin(const AColor& texture) { return setValue("newMin", texture); }
	//! (description missing)
	Value get_newMin() const { return getValue("newMin"); }

	//! (description missing)
	bool set_newMax(const Plugin& texture) { return setValue("newMax", texture); }
	//! (description missing)
	bool set_newMax(const AColor& texture) { return setValue("newMax", texture); }
	//! (description missing)
	Value get_newMax() const { return getValue("newMax"); }
};

class TexSimplexNoise : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexSimplexNoise"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	bool set_placement_type(int val) { return setValue("placement_type", val); }
	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	int get_placement_type() const { return getInt("placement_type"); }

	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_u(float val) { return setValue("u", val); }
	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_u() const { return getFloat("u"); }

	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_v(float val) { return setValue("v", val); }
	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_v() const { return getFloat("v"); }

	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_w(float val) { return setValue("w", val); }
	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_w() const { return getFloat("w"); }

	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_h(float val) { return setValue("h", val); }
	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_h() const { return getFloat("h"); }

	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	bool set_jitter(float val) { return setValue("jitter", val); }
	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	float get_jitter() const { return getFloat("jitter"); }

	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_u(bool val) { return setValue("tile_u", val); }
	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_u() const { return getBool("tile_u"); }

	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_v(bool val) { return setValue("tile_v", val); }
	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_v() const { return getBool("tile_v"); }

	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool set_uv_noise_on(bool val) { return setValue("uv_noise_on", val); }
	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool get_uv_noise_on() const { return getBool("uv_noise_on"); }

	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool set_uv_noise_animate(bool val) { return setValue("uv_noise_animate", val); }
	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool get_uv_noise_animate() const { return getBool("uv_noise_animate"); }

	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	bool set_uv_noise_amount(float val) { return setValue("uv_noise_amount", val); }
	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	float get_uv_noise_amount() const { return getFloat("uv_noise_amount"); }

	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	bool set_uv_noise_levels(float val) { return setValue("uv_noise_levels", val); }
	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	float get_uv_noise_levels() const { return getFloat("uv_noise_levels"); }

	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	bool set_uv_noise_size(float val) { return setValue("uv_noise_size", val); }
	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	float get_uv_noise_size() const { return getFloat("uv_noise_size"); }

	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	bool set_un_noise_phase(float val) { return setValue("un_noise_phase", val); }
	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	float get_un_noise_phase() const { return getFloat("un_noise_phase"); }

	//! (description missing)
	bool set_amplitude(const Plugin& texturefloat) { return setValue("amplitude", texturefloat); }
	//! (description missing)
	bool set_amplitude(float texturefloat) { return setValue("amplitude", texturefloat); }
	//! (description missing)
	Value get_amplitude() const { return getValue("amplitude"); }

	//! (description missing)
	//! [Default value] 0
	bool set_distortion_ratio(float val) { return setValue("distortion_ratio", val); }
	//! (description missing)
	//! [Default value] 0
	float get_distortion_ratio() const { return getFloat("distortion_ratio"); }

	//! (description missing)
	//! [Default value] 0
	bool set_distortion_u(float val) { return setValue("distortion_u", val); }
	//! (description missing)
	//! [Default value] 0
	float get_distortion_u() const { return getFloat("distortion_u"); }

	//! (description missing)
	//! [Default value] 0
	bool set_distortion_v(float val) { return setValue("distortion_v", val); }
	//! (description missing)
	//! [Default value] 0
	float get_distortion_v() const { return getFloat("distortion_v"); }

	//! (description missing)
	bool set_frequency(const Plugin& texturefloat) { return setValue("frequency", texturefloat); }
	//! (description missing)
	bool set_frequency(float texturefloat) { return setValue("frequency", texturefloat); }
	//! (description missing)
	Value get_frequency() const { return getValue("frequency"); }

	//! (description missing)
	bool set_frequency_ratio(const Plugin& texturefloat) { return setValue("frequency_ratio", texturefloat); }
	//! (description missing)
	bool set_frequency_ratio(float texturefloat) { return setValue("frequency_ratio", texturefloat); }
	//! (description missing)
	Value get_frequency_ratio() const { return getValue("frequency_ratio"); }

	//! (description missing)
	//! [Default value] 1
	bool set_gamma(float val) { return setValue("gamma", val); }
	//! (description missing)
	//! [Default value] 1
	float get_gamma() const { return getFloat("gamma"); }

	//! (description missing)
	//! [Default value] 0
	bool set_noise_type(int val) { return setValue("noise_type", val); }
	//! (description missing)
	//! [Default value] 0
	int get_noise_type() const { return getInt("noise_type"); }

	//! (description missing)
	//! [Default value] 3
	bool set_octaves(int val) { return setValue("octaves", val); }
	//! (description missing)
	//! [Default value] 3
	int get_octaves() const { return getInt("octaves"); }

	//! (description missing)
	bool set_ratio(const Plugin& texturefloat) { return setValue("ratio", texturefloat); }
	//! (description missing)
	bool set_ratio(float texturefloat) { return setValue("ratio", texturefloat); }
	//! (description missing)
	Value get_ratio() const { return getValue("ratio"); }

	//! (description missing)
	bool set_scale(const Plugin& texturefloat) { return setValue("scale", texturefloat); }
	//! (description missing)
	bool set_scale(float texturefloat) { return setValue("scale", texturefloat); }
	//! (description missing)
	Value get_scale() const { return getValue("scale"); }

	//! (description missing)
	bool set_threshold(const Plugin& texturefloat) { return setValue("threshold", texturefloat); }
	//! (description missing)
	bool set_threshold(float texturefloat) { return setValue("threshold", texturefloat); }
	//! (description missing)
	Value get_threshold() const { return getValue("threshold"); }
};

class TexSky : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexSky"; }

	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	bool set_transform(const Transform& transform) { return setValue("transform", transform); }
	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	Transform get_transform() const { return getTransform("transform"); }

	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	bool set_target_transform(const Transform& transform) { return setValue("target_transform", transform); }
	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	Transform get_target_transform() const { return getTransform("target_transform"); }

	//! Determines the amount of dust in the air and affects the color of the sun and sky. Smaller values produce a clear/blue sky, larger values yellow and orange
 	//! [UI Guides] minValue=2, maxValue=20
 	//! [Default value] 3
	bool set_turbidity(float val) { return setValue("turbidity", val); }
	//! Determines the amount of dust in the air and affects the color of the sun and sky. Smaller values produce a clear/blue sky, larger values yellow and orange
 	//! [UI Guides] minValue=2, maxValue=20
 	//! [Default value] 3
	float get_turbidity() const { return getFloat("turbidity"); }

	//! Affects the color of the sun light (between 0.0 and 1.0). Smaller values make the sunlight more yellow, larger values make it blue
 	//! [UI Guides] minValue=0, maxValue=1
 	//! [Default value] 0.35
	bool set_ozone(float val) { return setValue("ozone", val); }
	//! Affects the color of the sun light (between 0.0 and 1.0). Smaller values make the sunlight more yellow, larger values make it blue
 	//! [UI Guides] minValue=0, maxValue=1
 	//! [Default value] 0.35
	float get_ozone() const { return getFloat("ozone"); }

	//! (description missing)
	//! [Default value] 2
	bool set_water_vapour(float val) { return setValue("water_vapour", val); }
	//! (description missing)
	//! [Default value] 2
	float get_water_vapour() const { return getFloat("water_vapour"); }

	//! [UI Guides] minValue=0
 	//! [Default value] 1
	bool set_intensity_multiplier(float val) { return setValue("intensity_multiplier", val); }
	//! [UI Guides] minValue=0
 	//! [Default value] 1
	float get_intensity_multiplier() const { return getFloat("intensity_multiplier"); }

	//! Controls the visible size of the sun. Affects the appearance of the sun disc as seen by the camera and reflections, as well as the blurriness of the sun shadows
 	//! [UI Guides] minValue=0
 	//! [Default value] 1
	bool set_size_multiplier(float val) { return setValue("size_multiplier", val); }
	//! Controls the visible size of the sun. Affects the appearance of the sun disc as seen by the camera and reflections, as well as the blurriness of the sun shadows
 	//! [UI Guides] minValue=0
 	//! [Default value] 1
	float get_size_multiplier() const { return getFloat("size_multiplier"); }

	//! Sunlight color. Used to add user control to light color definition
 	//! [Default value] Color(1, 1, 1)
	bool set_filter_color(const Color& color) { return setValue("filter_color", color); }
	//! Sunlight color. Used to add user control to light color definition
 	//! [Default value] Color(1, 1, 1)
	Color get_filter_color() const { return getColor("filter_color"); }

	//! Reflective property of the "ground". Affects sky-dome brightness and color
 	//! [Default value] Color(0.2, 0.2, 0.2)
	bool set_ground_albedo(const Color& color) { return setValue("ground_albedo", color); }
	//! Reflective property of the "ground". Affects sky-dome brightness and color
 	//! [Default value] Color(0.2, 0.2, 0.2)
	Color get_ground_albedo() const { return getColor("ground_albedo"); }

	//! The angle (in degrees) (up from the horizon) where the sky starts to blend with the ground albedo. Values close to 0.0 produce a sharper horizon line, while larger values produce a softer horizon line.
 	//! [UI Guides] minValue=0.0, maxValue=90.0, quantityType=angle, units=degrees
 	//! [Default value] 5.73917
	bool set_blend_angle(float val) { return setValue("blend_angle", val); }
	//! The angle (in degrees) (up from the horizon) where the sky starts to blend with the ground albedo. Values close to 0.0 produce a sharper horizon line, while larger values produce a softer horizon line.
 	//! [UI Guides] minValue=0.0, maxValue=90.0, quantityType=angle, units=degrees
 	//! [Default value] 5.73917
	float get_blend_angle() const { return getFloat("blend_angle"); }

	//! Horizon offset under the sky-dome. Allows the user to manually lower the horizon line.
 	//! [UI Guides] minValue=0.0, maxValue=90.0, quantityType=angle, units=degrees
 	//! [Default value] 0
	bool set_horizon_offset(float val) { return setValue("horizon_offset", val); }
	//! Horizon offset under the sky-dome. Allows the user to manually lower the horizon line.
 	//! [UI Guides] minValue=0.0, maxValue=90.0, quantityType=angle, units=degrees
 	//! [Default value] 0
	float get_horizon_offset() const { return getFloat("horizon_offset"); }

	//! This option affects the way the color in the Filter color parameter affects the color of the sun
 	//! [Default value] 0
	bool set_color_mode(int val) { return setValue("color_mode", val); }
	//! This option affects the way the color in the Filter color parameter affects the color of the sun
 	//! [Default value] 0
	int get_color_mode() const { return getInt("color_mode"); }

	//! (description missing)
	//! [Default value] Vector(0, 0, 1)
	bool set_up_vector(const Vector& vector) { return setValue("up_vector", vector); }
	//! (description missing)
	//! [Default value] Vector(0, 0, 1)
	Vector get_up_vector() const { return getVector("up_vector"); }

	//! When on, this option makes the sun invisible, both to the camera and to reflections
 	//! [Default value] false
	bool set_invisible(bool val) { return setValue("invisible", val); }
	//! When on, this option makes the sun invisible, both to the camera and to reflections
 	//! [Default value] false
	bool get_invisible() const { return getBool("invisible"); }

	//! Specifies the intensity (in lx) of the illumination on horizontal surfaces coming from the sky
 	//! [UI Guides] enableIf: ?sky_model==1;?sky_model==2, minValue=0
 	//! [Default value] 25000
	bool set_horiz_illum(float val) { return setValue("horiz_illum", val); }
	//! Specifies the intensity (in lx) of the illumination on horizontal surfaces coming from the sky
 	//! [UI Guides] enableIf: ?sky_model==1;?sky_model==2, minValue=0
 	//! [Default value] 25000
	float get_horiz_illum() const { return getFloat("horiz_illum"); }

	//! Selects the procedural model used to simulate the TexSky texture
 	//! [UI Guides] enum=0:Preetham et al;1:CIE Clear;2:CIE Overcast;3:Hosek et al
 	//! [Default value] 0
	bool set_sky_model(int val) { return setValue("sky_model", val); }
	//! Selects the procedural model used to simulate the TexSky texture
 	//! [UI Guides] enum=0:Preetham et al;1:CIE Clear;2:CIE Overcast;3:Hosek et al
 	//! [Default value] 0
	int get_sky_model() const { return getInt("sky_model"); }

	//! If specified, all parameters are taken from the sun; otherwise, the sky parameters are used
 	bool set_sun(const Plugin& plugin) { return setValue("sun", plugin); }
	//! If specified, all parameters are taken from the sun; otherwise, the sky parameters are used
 	Plugin get_sun() const { return getPlugin("sun"); }

	//! Use only the direction of the specified sun (don't inherit all other parameters)
 	//! [Default value] 0
	bool set_sun_dir_only(int val) { return setValue("sun_dir_only", val); }
	//! Use only the direction of the specified sun (don't inherit all other parameters)
 	//! [Default value] 0
	int get_sun_dir_only() const { return getInt("sun_dir_only"); }
};

class TexSmoke : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexSmoke"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! (description missing)
	//! [Default value] false
	bool set_use_3d_mapping(bool val) { return setValue("use_3d_mapping", val); }
	//! (description missing)
	//! [Default value] false
	bool get_use_3d_mapping() const { return getBool("use_3d_mapping"); }

	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	bool set_placement_type(int val) { return setValue("placement_type", val); }
	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	int get_placement_type() const { return getInt("placement_type"); }

	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_u(float val) { return setValue("u", val); }
	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_u() const { return getFloat("u"); }

	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_v(float val) { return setValue("v", val); }
	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_v() const { return getFloat("v"); }

	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_w(float val) { return setValue("w", val); }
	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_w() const { return getFloat("w"); }

	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_h(float val) { return setValue("h", val); }
	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_h() const { return getFloat("h"); }

	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	bool set_jitter(float val) { return setValue("jitter", val); }
	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	float get_jitter() const { return getFloat("jitter"); }

	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_u(bool val) { return setValue("tile_u", val); }
	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_u() const { return getBool("tile_u"); }

	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_v(bool val) { return setValue("tile_v", val); }
	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_v() const { return getBool("tile_v"); }

	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool set_uv_noise_on(bool val) { return setValue("uv_noise_on", val); }
	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool get_uv_noise_on() const { return getBool("uv_noise_on"); }

	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool set_uv_noise_animate(bool val) { return setValue("uv_noise_animate", val); }
	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool get_uv_noise_animate() const { return getBool("uv_noise_animate"); }

	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	bool set_uv_noise_amount(float val) { return setValue("uv_noise_amount", val); }
	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	float get_uv_noise_amount() const { return getFloat("uv_noise_amount"); }

	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	bool set_uv_noise_levels(float val) { return setValue("uv_noise_levels", val); }
	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	float get_uv_noise_levels() const { return getFloat("uv_noise_levels"); }

	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	bool set_uv_noise_size(float val) { return setValue("uv_noise_size", val); }
	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	float get_uv_noise_size() const { return getFloat("uv_noise_size"); }

	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	bool set_un_noise_phase(float val) { return setValue("un_noise_phase", val); }
	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	float get_un_noise_phase() const { return getFloat("un_noise_phase"); }

	//! First color
 	bool set_color1(const Plugin& texture) { return setValue("color1", texture); }
	//! First color
 	bool set_color1(const AColor& texture) { return setValue("color1", texture); }
	//! First color
 	Value get_color1() const { return getValue("color1"); }

	//! Second color
 	bool set_color2(const Plugin& texture) { return setValue("color2", texture); }
	//! Second color
 	bool set_color2(const AColor& texture) { return setValue("color2", texture); }
	//! Second color
 	Value get_color2() const { return getValue("color2"); }

	//! Size
 	//! [Default value] 1
	bool set_size(float val) { return setValue("size", val); }
	//! Size
 	//! [Default value] 1
	float get_size() const { return getFloat("size"); }

	//! Iterations
 	//! [Default value] 5
	bool set_iterations(int val) { return setValue("iterations", val); }
	//! Iterations
 	//! [Default value] 5
	int get_iterations() const { return getInt("iterations"); }

	//! Phase
 	//! [Default value] 0
	bool set_phase(float val) { return setValue("phase", val); }
	//! Phase
 	//! [Default value] 0
	float get_phase() const { return getFloat("phase"); }

	//! Exponent
 	//! [Default value] 1.5
	bool set_exponent(float val) { return setValue("exponent", val); }
	//! Exponent
 	//! [Default value] 1.5
	float get_exponent() const { return getFloat("exponent"); }
};

class TexSnow : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexSnow"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! (description missing)
	//! [Default value] false
	bool set_use_3d_mapping(bool val) { return setValue("use_3d_mapping", val); }
	//! (description missing)
	//! [Default value] false
	bool get_use_3d_mapping() const { return getBool("use_3d_mapping"); }

	//! (description missing)
	//! [Default value] true
	bool set_wrap(bool val) { return setValue("wrap", val); }
	//! (description missing)
	//! [Default value] true
	bool get_wrap() const { return getBool("wrap"); }

	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	bool set_placement_type(int val) { return setValue("placement_type", val); }
	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	int get_placement_type() const { return getInt("placement_type"); }

	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_u(float val) { return setValue("u", val); }
	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_u() const { return getFloat("u"); }

	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_v(float val) { return setValue("v", val); }
	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_v() const { return getFloat("v"); }

	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_w(float val) { return setValue("w", val); }
	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_w() const { return getFloat("w"); }

	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_h(float val) { return setValue("h", val); }
	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_h() const { return getFloat("h"); }

	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	bool set_jitter(float val) { return setValue("jitter", val); }
	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	float get_jitter() const { return getFloat("jitter"); }

	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_u(bool val) { return setValue("tile_u", val); }
	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_u() const { return getBool("tile_u"); }

	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_v(bool val) { return setValue("tile_v", val); }
	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_v() const { return getBool("tile_v"); }

	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool set_uv_noise_on(bool val) { return setValue("uv_noise_on", val); }
	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool get_uv_noise_on() const { return getBool("uv_noise_on"); }

	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool set_uv_noise_animate(bool val) { return setValue("uv_noise_animate", val); }
	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool get_uv_noise_animate() const { return getBool("uv_noise_animate"); }

	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	bool set_uv_noise_amount(float val) { return setValue("uv_noise_amount", val); }
	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	float get_uv_noise_amount() const { return getFloat("uv_noise_amount"); }

	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	bool set_uv_noise_levels(float val) { return setValue("uv_noise_levels", val); }
	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	float get_uv_noise_levels() const { return getFloat("uv_noise_levels"); }

	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	bool set_uv_noise_size(float val) { return setValue("uv_noise_size", val); }
	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	float get_uv_noise_size() const { return getFloat("uv_noise_size"); }

	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	bool set_un_noise_phase(float val) { return setValue("un_noise_phase", val); }
	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	float get_un_noise_phase() const { return getFloat("un_noise_phase"); }

	//! [UI Guides] displayName=Snow Color
 	bool set_snow_tex(const Plugin& texture) { return setValue("snow_tex", texture); }
	//! [UI Guides] displayName=Snow Color
 	bool set_snow_tex(const AColor& texture) { return setValue("snow_tex", texture); }
	//! [UI Guides] displayName=Snow Color
 	Value get_snow_tex() const { return getValue("snow_tex"); }

	//! [UI Guides] displayName=Surface Color
 	bool set_surface_tex(const Plugin& texture) { return setValue("surface_tex", texture); }
	//! [UI Guides] displayName=Surface Color
 	bool set_surface_tex(const AColor& texture) { return setValue("surface_tex", texture); }
	//! [UI Guides] displayName=Surface Color
 	Value get_surface_tex() const { return getValue("surface_tex"); }

	//! [UI Guides] minValue=0, maxValue=1
 	bool set_threshold(const Plugin& texturefloat) { return setValue("threshold", texturefloat); }
	//! [UI Guides] minValue=0, maxValue=1
 	bool set_threshold(float texturefloat) { return setValue("threshold", texturefloat); }
	//! [UI Guides] minValue=0, maxValue=1
 	Value get_threshold() const { return getValue("threshold"); }

	//! [UI Guides] minValue=0
 	bool set_depth_decay(const Plugin& texturefloat) { return setValue("depth_decay", texturefloat); }
	//! [UI Guides] minValue=0
 	bool set_depth_decay(float texturefloat) { return setValue("depth_decay", texturefloat); }
	//! [UI Guides] minValue=0
 	Value get_depth_decay() const { return getValue("depth_decay"); }

	//! [UI Guides] minValue=0, maxValue=1
 	bool set_thickness(const Plugin& texturefloat) { return setValue("thickness", texturefloat); }
	//! [UI Guides] minValue=0, maxValue=1
 	bool set_thickness(float texturefloat) { return setValue("thickness", texturefloat); }
	//! [UI Guides] minValue=0, maxValue=1
 	Value get_thickness() const { return getValue("thickness"); }
};

class TexSoftbox : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexSoftbox"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	bool set_placement_type(int val) { return setValue("placement_type", val); }
	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	int get_placement_type() const { return getInt("placement_type"); }

	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_u(float val) { return setValue("u", val); }
	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_u() const { return getFloat("u"); }

	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_v(float val) { return setValue("v", val); }
	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_v() const { return getFloat("v"); }

	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_w(float val) { return setValue("w", val); }
	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_w() const { return getFloat("w"); }

	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_h(float val) { return setValue("h", val); }
	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_h() const { return getFloat("h"); }

	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	bool set_jitter(float val) { return setValue("jitter", val); }
	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	float get_jitter() const { return getFloat("jitter"); }

	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_u(bool val) { return setValue("tile_u", val); }
	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_u() const { return getBool("tile_u"); }

	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_v(bool val) { return setValue("tile_v", val); }
	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_v() const { return getBool("tile_v"); }

	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool set_uv_noise_on(bool val) { return setValue("uv_noise_on", val); }
	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool get_uv_noise_on() const { return getBool("uv_noise_on"); }

	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool set_uv_noise_animate(bool val) { return setValue("uv_noise_animate", val); }
	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool get_uv_noise_animate() const { return getBool("uv_noise_animate"); }

	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	bool set_uv_noise_amount(float val) { return setValue("uv_noise_amount", val); }
	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	float get_uv_noise_amount() const { return getFloat("uv_noise_amount"); }

	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	bool set_uv_noise_levels(float val) { return setValue("uv_noise_levels", val); }
	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	float get_uv_noise_levels() const { return getFloat("uv_noise_levels"); }

	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	bool set_uv_noise_size(float val) { return setValue("uv_noise_size", val); }
	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	float get_uv_noise_size() const { return getFloat("uv_noise_size"); }

	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	bool set_un_noise_phase(float val) { return setValue("un_noise_phase", val); }
	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	float get_un_noise_phase() const { return getFloat("un_noise_phase"); }

	//! Base color
 	//! [UI Guides] displayName=Base Color
 	//! [Default value] Color(1, 1, 1)
	bool set_base_color(const Color& color) { return setValue("base_color", color); }
	//! Base color
 	//! [UI Guides] displayName=Base Color
 	//! [Default value] Color(1, 1, 1)
	Color get_base_color() const { return getColor("base_color"); }

	//! Turn on base texture
 	//! [UI Guides] displayName=Use Base Texture
 	//! [Default value] false
	bool set_base_tex_on(bool val) { return setValue("base_tex_on", val); }
	//! Turn on base texture
 	//! [UI Guides] displayName=Use Base Texture
 	//! [Default value] false
	bool get_base_tex_on() const { return getBool("base_tex_on"); }

	//! Base texture
 	//! [UI Guides] displayName=Base Texture, enableIf: ?base_tex_on=1
 	bool set_base_tex(const Plugin& texture) { return setValue("base_tex", texture); }
	//! Base texture
 	//! [UI Guides] displayName=Base Texture, enableIf: ?base_tex_on=1
 	bool set_base_tex(const AColor& texture) { return setValue("base_tex", texture); }
	//! Base texture
 	//! [UI Guides] displayName=Base Texture, enableIf: ?base_tex_on=1
 	Value get_base_tex() const { return getValue("base_tex"); }

	//! Turn on base tint
 	//! [UI Guides] startRollout=, displayName=Base Tint On
 	//! [Default value] false
	bool set_base_tint_on(bool val) { return setValue("base_tint_on", val); }
	//! Turn on base tint
 	//! [UI Guides] startRollout=, displayName=Base Tint On
 	//! [Default value] false
	bool get_base_tint_on() const { return getBool("base_tint_on"); }

	//! Base tint color
 	//! [UI Guides] displayName=Base Tint Color, enableIf: ?base_tint_on=1
 	//! [Default value] Color(1, 1, 1)
	bool set_base_tint(const Color& color) { return setValue("base_tint", color); }
	//! Base tint color
 	//! [UI Guides] displayName=Base Tint Color, enableIf: ?base_tint_on=1
 	//! [Default value] Color(1, 1, 1)
	Color get_base_tint() const { return getColor("base_tint"); }

	//! Base tint strength
 	//! [UI Guides] displayName=Base Tint Strength, enableIf: ?base_tint_on=1, minValue=0.0, maxValue=1.0
 	//! [Default value] 0.5
	bool set_base_tint_strength(float val) { return setValue("base_tint_strength", val); }
	//! Base tint strength
 	//! [UI Guides] displayName=Base Tint Strength, enableIf: ?base_tint_on=1, minValue=0.0, maxValue=1.0
 	//! [Default value] 0.5
	float get_base_tint_strength() const { return getFloat("base_tint_strength"); }

	//! Base multiplier
 	//! [UI Guides] startRollout=, displayName=Base Multiplier
 	//! [Default value] 1
	bool set_base_mult(float val) { return setValue("base_mult", val); }
	//! Base multiplier
 	//! [UI Guides] startRollout=, displayName=Base Multiplier
 	//! [Default value] 1
	float get_base_mult() const { return getFloat("base_mult"); }

	//! Base gamma
 	//! [UI Guides] displayName=Base Gamma, minValue=0.0, maxValue=100.0
 	//! [Default value] 1
	bool set_base_gamma(float val) { return setValue("base_gamma", val); }
	//! Base gamma
 	//! [UI Guides] displayName=Base Gamma, minValue=0.0, maxValue=100.0
 	//! [Default value] 1
	float get_base_gamma() const { return getFloat("base_gamma"); }

	//! Turn on hot/dark spots
 	//! [UI Guides] startRollout=Hot Spot / Dark Spot, displayName=Spots On
 	//! [Default value] false
	bool set_spots_on(bool val) { return setValue("spots_on", val); }
	//! Turn on hot/dark spots
 	//! [UI Guides] startRollout=Hot Spot / Dark Spot, displayName=Spots On
 	//! [Default value] false
	bool get_spots_on() const { return getBool("spots_on"); }

	//! Spots multiplier
 	//! [UI Guides] displayName=Spots Multiplier, enableIf: ?spots_on=1, minValue=0.0
 	//! [Default value] 1
	bool set_spots_mult(float val) { return setValue("spots_mult", val); }
	//! Spots multiplier
 	//! [UI Guides] displayName=Spots Multiplier, enableIf: ?spots_on=1, minValue=0.0
 	//! [Default value] 1
	float get_spots_mult() const { return getFloat("spots_mult"); }

	//! Spots mode
 	//! [UI Guides] enum=0:Hot Spot Add;1:Dark Spot Subtract, displayName=Spots Mode, enableIf: ?spots_on=1
 	//! [Default value] 0
	bool set_spots_mode(int val) { return setValue("spots_mode", val); }
	//! Spots mode
 	//! [UI Guides] enum=0:Hot Spot Add;1:Dark Spot Subtract, displayName=Spots Mode, enableIf: ?spots_on=1
 	//! [Default value] 0
	int get_spots_mode() const { return getInt("spots_mode"); }

	//! Turn on spots tint
 	//! [UI Guides] displayName=Spots Tint On, enableIf: ?spots_on=1
 	//! [Default value] false
	bool set_spots_tint_on(bool val) { return setValue("spots_tint_on", val); }
	//! Turn on spots tint
 	//! [UI Guides] displayName=Spots Tint On, enableIf: ?spots_on=1
 	//! [Default value] false
	bool get_spots_tint_on() const { return getBool("spots_tint_on"); }

	//! Spots tint color
 	//! [UI Guides] displayName=Spots Tint Color, enableIf: ?spots_on=1, ?spots_tint_on=1
 	//! [Default value] Color(1, 1, 1)
	bool set_spots_tint(const Color& color) { return setValue("spots_tint", color); }
	//! Spots tint color
 	//! [UI Guides] displayName=Spots Tint Color, enableIf: ?spots_on=1, ?spots_tint_on=1
 	//! [Default value] Color(1, 1, 1)
	Color get_spots_tint() const { return getColor("spots_tint"); }

	//! Spots tint strength
 	//! [UI Guides] displayName=Spots Tint Strength, enableIf: ?spots_on=1, ?spots_tint_on=1, minValue=0.0, maxValue=1.0
 	//! [Default value] 0.5
	bool set_spots_tint_strength(float val) { return setValue("spots_tint_strength", val); }
	//! Spots tint strength
 	//! [UI Guides] displayName=Spots Tint Strength, enableIf: ?spots_on=1, ?spots_tint_on=1, minValue=0.0, maxValue=1.0
 	//! [Default value] 0.5
	float get_spots_tint_strength() const { return getFloat("spots_tint_strength"); }

	//! Spots u offset
 	//! [UI Guides] startRollout=, enableIf: ?spots_on=1, minValue=-100.0, maxValue=100.0
 	//! [Default value] 0
	bool set_u_offset(float val) { return setValue("u_offset", val); }
	//! Spots u offset
 	//! [UI Guides] startRollout=, enableIf: ?spots_on=1, minValue=-100.0, maxValue=100.0
 	//! [Default value] 0
	float get_u_offset() const { return getFloat("u_offset"); }

	//! Spots u tiling
 	//! [UI Guides] enableIf: ?spots_on=1
 	//! [Default value] 1
	bool set_u_tiling(float val) { return setValue("u_tiling", val); }
	//! Spots u tiling
 	//! [UI Guides] enableIf: ?spots_on=1
 	//! [Default value] 1
	float get_u_tiling() const { return getFloat("u_tiling"); }

	//! Turn on spots u tiling
 	//! [UI Guides] enableIf: ?spots_on=1
 	//! [Default value] false
	bool set_u_tiling_on(bool val) { return setValue("u_tiling_on", val); }
	//! Turn on spots u tiling
 	//! [UI Guides] enableIf: ?spots_on=1
 	//! [Default value] false
	bool get_u_tiling_on() const { return getBool("u_tiling_on"); }

	//! Spots v offset
 	//! [UI Guides] enableIf: ?spots_on=1, minValue=-100.0, maxValue=100.0
 	//! [Default value] 0
	bool set_v_offset(float val) { return setValue("v_offset", val); }
	//! Spots v offset
 	//! [UI Guides] enableIf: ?spots_on=1, minValue=-100.0, maxValue=100.0
 	//! [Default value] 0
	float get_v_offset() const { return getFloat("v_offset"); }

	//! Spots v tiling
 	//! [UI Guides] enableIf: ?spots_on=1
 	//! [Default value] 1
	bool set_v_tiling(float val) { return setValue("v_tiling", val); }
	//! Spots v tiling
 	//! [UI Guides] enableIf: ?spots_on=1
 	//! [Default value] 1
	float get_v_tiling() const { return getFloat("v_tiling"); }

	//! Turn on v tiling
 	//! [UI Guides] enableIf: ?spots_on=1
 	//! [Default value] false
	bool set_v_tiling_on(bool val) { return setValue("v_tiling_on", val); }
	//! Turn on v tiling
 	//! [UI Guides] enableIf: ?spots_on=1
 	//! [Default value] false
	bool get_v_tiling_on() const { return getBool("v_tiling_on"); }

	//! Fading outer radius
 	//! [UI Guides] startRollout=, displayName=Outer Radius, enableIf: ?spots_on=1, minValue=0.0, maxValue=1.0
 	//! [Default value] 0.5
	bool set_spots_oradius(float val) { return setValue("spots_oradius", val); }
	//! Fading outer radius
 	//! [UI Guides] startRollout=, displayName=Outer Radius, enableIf: ?spots_on=1, minValue=0.0, maxValue=1.0
 	//! [Default value] 0.5
	float get_spots_oradius() const { return getFloat("spots_oradius"); }

	//! Fading inner radius
 	//! [UI Guides] displayName=Inner Radius, enableIf: ?spots_on=1, minValue=0.0, maxValue=1.0
 	//! [Default value] 0.4
	bool set_spots_iradius(float val) { return setValue("spots_iradius", val); }
	//! Fading inner radius
 	//! [UI Guides] displayName=Inner Radius, enableIf: ?spots_on=1, minValue=0.0, maxValue=1.0
 	//! [Default value] 0.4
	float get_spots_iradius() const { return getFloat("spots_iradius"); }

	//! Fading softness
 	//! [UI Guides] displayName=Softness, enableIf: ?spots_on=1, minValue=0.0, maxValue=20.0
 	//! [Default value] 1
	bool set_spots_exp(float val) { return setValue("spots_exp", val); }
	//! Fading softness
 	//! [UI Guides] displayName=Softness, enableIf: ?spots_on=1, minValue=0.0, maxValue=20.0
 	//! [Default value] 1
	float get_spots_exp() const { return getFloat("spots_exp"); }

	//! Turn on vertical gradient
 	//! [UI Guides] startRollout=Gradients, displayName=V Vignette On
 	//! [Default value] false
	bool set_grad_vert_on(bool val) { return setValue("grad_vert_on", val); }
	//! Turn on vertical gradient
 	//! [UI Guides] startRollout=Gradients, displayName=V Vignette On
 	//! [Default value] false
	bool get_grad_vert_on() const { return getBool("grad_vert_on"); }

	//! Flip vertical gradient
 	//! [UI Guides] displayName=V Vignette Flip, enableIf: ?grad_vert_on=1
 	//! [Default value] false
	bool set_grad_vert_flip(bool val) { return setValue("grad_vert_flip", val); }
	//! Flip vertical gradient
 	//! [UI Guides] displayName=V Vignette Flip, enableIf: ?grad_vert_on=1
 	//! [Default value] false
	bool get_grad_vert_flip() const { return getBool("grad_vert_flip"); }

	//! Vertical gradient positions
 	bool set_grad_vert_pos(const ValueList& list) { return setValue("grad_vert_pos", list); }
	//! Vertical gradient positions
 	ValueList get_grad_vert_pos() const { return getValueList("grad_vert_pos"); }

	//! Vertical gradient colors
 	bool set_grad_vert_col(const ValueList& textureList) { return setValue("grad_vert_col", textureList); }
	//! Vertical gradient colors
 	ValueList get_grad_vert_col() const { return getValueList("grad_vert_col"); }

	//! The V Vignette gradient.
 	//! [UI Guides] displayName=V Vignette Gradient, enableIf: ?grad_vert_on=1
 	bool set_grad_vert(const Plugin& plugin) { return setValue("grad_vert", plugin); }
	//! The V Vignette gradient.
 	//! [UI Guides] displayName=V Vignette Gradient, enableIf: ?grad_vert_on=1
 	Plugin get_grad_vert() const { return getPlugin("grad_vert"); }

	//! Turn on horizontal gradient
 	//! [UI Guides] startRollout=, displayName=U Vignette On
 	//! [Default value] false
	bool set_grad_horiz_on(bool val) { return setValue("grad_horiz_on", val); }
	//! Turn on horizontal gradient
 	//! [UI Guides] startRollout=, displayName=U Vignette On
 	//! [Default value] false
	bool get_grad_horiz_on() const { return getBool("grad_horiz_on"); }

	//! Flip horizontal gradient
 	//! [UI Guides] displayName=U Vignette Flip, enableIf: ?grad_horiz_on=1
 	//! [Default value] false
	bool set_grad_horiz_flip(bool val) { return setValue("grad_horiz_flip", val); }
	//! Flip horizontal gradient
 	//! [UI Guides] displayName=U Vignette Flip, enableIf: ?grad_horiz_on=1
 	//! [Default value] false
	bool get_grad_horiz_flip() const { return getBool("grad_horiz_flip"); }

	//! Horizontal gradient positions
 	bool set_grad_horiz_pos(const ValueList& list) { return setValue("grad_horiz_pos", list); }
	//! Horizontal gradient positions
 	ValueList get_grad_horiz_pos() const { return getValueList("grad_horiz_pos"); }

	//! Horizontal gradient colors
 	bool set_grad_horiz_col(const ValueList& textureList) { return setValue("grad_horiz_col", textureList); }
	//! Horizontal gradient colors
 	ValueList get_grad_horiz_col() const { return getValueList("grad_horiz_col"); }

	//! The U Vignette gradient.
 	//! [UI Guides] displayName=U Vignette Gradient, enableIf: ?grad_horiz_on=1
 	bool set_grad_horiz(const Plugin& plugin) { return setValue("grad_horiz", plugin); }
	//! The U Vignette gradient.
 	//! [UI Guides] displayName=U Vignette Gradient, enableIf: ?grad_horiz_on=1
 	Plugin get_grad_horiz() const { return getPlugin("grad_horiz"); }

	//! Turn on radial gradient
 	//! [UI Guides] startRollout=, displayName=Radial Vignette On
 	//! [Default value] false
	bool set_grad_rad_on(bool val) { return setValue("grad_rad_on", val); }
	//! Turn on radial gradient
 	//! [UI Guides] startRollout=, displayName=Radial Vignette On
 	//! [Default value] false
	bool get_grad_rad_on() const { return getBool("grad_rad_on"); }

	//! Flip radial gradient
 	//! [UI Guides] displayName=Radial Vignette Flip, enableIf: ?grad_rad_on=1
 	//! [Default value] false
	bool set_grad_rad_flip(bool val) { return setValue("grad_rad_flip", val); }
	//! Flip radial gradient
 	//! [UI Guides] displayName=Radial Vignette Flip, enableIf: ?grad_rad_on=1
 	//! [Default value] false
	bool get_grad_rad_flip() const { return getBool("grad_rad_flip"); }

	//! Radial gradient positions
 	bool set_grad_rad_pos(const ValueList& list) { return setValue("grad_rad_pos", list); }
	//! Radial gradient positions
 	ValueList get_grad_rad_pos() const { return getValueList("grad_rad_pos"); }

	//! Radial gradient colors
 	bool set_grad_rad_col(const ValueList& textureList) { return setValue("grad_rad_col", textureList); }
	//! Radial gradient colors
 	ValueList get_grad_rad_col() const { return getValueList("grad_rad_col"); }

	//! The Radial Vignette gradient.
 	//! [UI Guides] displayName=Radial Vignette Gradient, enableIf: ?grad_rad_on=1
 	bool set_grad_rad(const Plugin& plugin) { return setValue("grad_rad", plugin); }
	//! The Radial Vignette gradient.
 	//! [UI Guides] displayName=Radial Vignette Gradient, enableIf: ?grad_rad_on=1
 	Plugin get_grad_rad() const { return getPlugin("grad_rad"); }

	//! Turn on frame
 	//! [UI Guides] startRollout=, displayName=Frame Vignette On
 	//! [Default value] false
	bool set_frame_on(bool val) { return setValue("frame_on", val); }
	//! Turn on frame
 	//! [UI Guides] startRollout=, displayName=Frame Vignette On
 	//! [Default value] false
	bool get_frame_on() const { return getBool("frame_on"); }

	//! Flip frame
 	//! [UI Guides] displayName=Frame Vignette Flip, enableIf: ?frame_on=1
 	//! [Default value] false
	bool set_frame_flip(bool val) { return setValue("frame_flip", val); }
	//! Flip frame
 	//! [UI Guides] displayName=Frame Vignette Flip, enableIf: ?frame_on=1
 	//! [Default value] false
	bool get_frame_flip() const { return getBool("frame_flip"); }

	//! Frame positions
 	bool set_frame_pos(const ValueList& list) { return setValue("frame_pos", list); }
	//! Frame positions
 	ValueList get_frame_pos() const { return getValueList("frame_pos"); }

	//! Frame colors
 	bool set_frame_col(const ValueList& textureList) { return setValue("frame_col", textureList); }
	//! Frame colors
 	ValueList get_frame_col() const { return getValueList("frame_col"); }

	//! The Frame Vignette gradient.
 	//! [UI Guides] displayName=Frame Vignette Gradient, enableIf: ?frame_on=1
 	bool set_grad_frame(const Plugin& plugin) { return setValue("grad_frame", plugin); }
	//! The Frame Vignette gradient.
 	//! [UI Guides] displayName=Frame Vignette Gradient, enableIf: ?frame_on=1
 	Plugin get_grad_frame() const { return getPlugin("grad_frame"); }

	//! Turn on frame tint
 	//! [UI Guides] displayName=Frame Tint On, enableIf: ?frame_on=1
 	//! [Default value] false
	bool set_frame_tint_on(bool val) { return setValue("frame_tint_on", val); }
	//! Turn on frame tint
 	//! [UI Guides] displayName=Frame Tint On, enableIf: ?frame_on=1
 	//! [Default value] false
	bool get_frame_tint_on() const { return getBool("frame_tint_on"); }

	//! Frame tint color
 	//! [UI Guides] displayName=Frame Tint On, enableIf: ?frame_on=1, ?frame_tint_on=1
 	//! [Default value] Color(1, 1, 1)
	bool set_frame_tint(const Color& color) { return setValue("frame_tint", color); }
	//! Frame tint color
 	//! [UI Guides] displayName=Frame Tint On, enableIf: ?frame_on=1, ?frame_tint_on=1
 	//! [Default value] Color(1, 1, 1)
	Color get_frame_tint() const { return getColor("frame_tint"); }

	//! Frame tint strength
 	//! [UI Guides] displayName=Frame Tint Strength, enableIf: ?frame_on=1, ?frame_tint_on=1, minValue=0.0, maxValue=1.0
 	//! [Default value] 0.5
	bool set_frame_tint_strength(float val) { return setValue("frame_tint_strength", val); }
	//! Frame tint strength
 	//! [UI Guides] displayName=Frame Tint Strength, enableIf: ?frame_on=1, ?frame_tint_on=1, minValue=0.0, maxValue=1.0
 	//! [Default value] 0.5
	float get_frame_tint_strength() const { return getFloat("frame_tint_strength"); }

	//! Frame noise amount
 	//! [UI Guides] startRollout=, displayName=Frame Noise Amount, enableIf: ?frame_on=1, minValue=0.0, maxValue=1.0
 	//! [Default value] 0
	bool set_noise_amount(float val) { return setValue("noise_amount", val); }
	//! Frame noise amount
 	//! [UI Guides] startRollout=, displayName=Frame Noise Amount, enableIf: ?frame_on=1, minValue=0.0, maxValue=1.0
 	//! [Default value] 0
	float get_noise_amount() const { return getFloat("noise_amount"); }

	//! Frame noise size
 	//! [UI Guides] displayName=Frame Noise Size, enableIf: ?frame_on=1, minValue=0.0001
 	//! [Default value] 1
	bool set_noise_size(float val) { return setValue("noise_size", val); }
	//! Frame noise size
 	//! [UI Guides] displayName=Frame Noise Size, enableIf: ?frame_on=1, minValue=0.0001
 	//! [Default value] 1
	float get_noise_size() const { return getFloat("noise_size"); }

	//! Frame noise phase
 	//! [UI Guides] displayName=Frame Noise Phase, enableIf: ?frame_on=1, minValue=-1000.0, maxValue=1000.0
 	//! [Default value] 0
	bool set_noise_phase(float val) { return setValue("noise_phase", val); }
	//! Frame noise phase
 	//! [UI Guides] displayName=Frame Noise Phase, enableIf: ?frame_on=1, minValue=-1000.0, maxValue=1000.0
 	//! [Default value] 0
	float get_noise_phase() const { return getFloat("noise_phase"); }

	//! Turn on frame fractal noise
 	//! [UI Guides] displayName=Fractal Noise, enableIf: ?frame_on=1
 	//! [Default value] false
	bool set_noise_fractal(bool val) { return setValue("noise_fractal", val); }
	//! Turn on frame fractal noise
 	//! [UI Guides] displayName=Fractal Noise, enableIf: ?frame_on=1
 	//! [Default value] false
	bool get_noise_fractal() const { return getBool("noise_fractal"); }

	//! Frame noise levels
 	//! [UI Guides] displayName=Fractal Levels, enableIf: ?frame_on=1, ?noise_fractal=1, minValue=1, maxValue=10
 	//! [Default value] 3
	bool set_noise_levels(int val) { return setValue("noise_levels", val); }
	//! Frame noise levels
 	//! [UI Guides] displayName=Fractal Levels, enableIf: ?frame_on=1, ?noise_fractal=1, minValue=1, maxValue=10
 	//! [Default value] 3
	int get_noise_levels() const { return getInt("noise_levels"); }
};

class TexSpeckle : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexSpeckle"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! (description missing)
	//! [Default value] false
	bool set_use_3d_mapping(bool val) { return setValue("use_3d_mapping", val); }
	//! (description missing)
	//! [Default value] false
	bool get_use_3d_mapping() const { return getBool("use_3d_mapping"); }

	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	bool set_placement_type(int val) { return setValue("placement_type", val); }
	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	int get_placement_type() const { return getInt("placement_type"); }

	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_u(float val) { return setValue("u", val); }
	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_u() const { return getFloat("u"); }

	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_v(float val) { return setValue("v", val); }
	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_v() const { return getFloat("v"); }

	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_w(float val) { return setValue("w", val); }
	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_w() const { return getFloat("w"); }

	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_h(float val) { return setValue("h", val); }
	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_h() const { return getFloat("h"); }

	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	bool set_jitter(float val) { return setValue("jitter", val); }
	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	float get_jitter() const { return getFloat("jitter"); }

	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_u(bool val) { return setValue("tile_u", val); }
	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_u() const { return getBool("tile_u"); }

	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_v(bool val) { return setValue("tile_v", val); }
	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_v() const { return getBool("tile_v"); }

	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool set_uv_noise_on(bool val) { return setValue("uv_noise_on", val); }
	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool get_uv_noise_on() const { return getBool("uv_noise_on"); }

	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool set_uv_noise_animate(bool val) { return setValue("uv_noise_animate", val); }
	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool get_uv_noise_animate() const { return getBool("uv_noise_animate"); }

	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	bool set_uv_noise_amount(float val) { return setValue("uv_noise_amount", val); }
	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	float get_uv_noise_amount() const { return getFloat("uv_noise_amount"); }

	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	bool set_uv_noise_levels(float val) { return setValue("uv_noise_levels", val); }
	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	float get_uv_noise_levels() const { return getFloat("uv_noise_levels"); }

	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	bool set_uv_noise_size(float val) { return setValue("uv_noise_size", val); }
	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	float get_uv_noise_size() const { return getFloat("uv_noise_size"); }

	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	bool set_un_noise_phase(float val) { return setValue("un_noise_phase", val); }
	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	float get_un_noise_phase() const { return getFloat("un_noise_phase"); }

	//! First color
 	bool set_color1(const Plugin& texture) { return setValue("color1", texture); }
	//! First color
 	bool set_color1(const AColor& texture) { return setValue("color1", texture); }
	//! First color
 	Value get_color1() const { return getValue("color1"); }

	//! Second color
 	bool set_color2(const Plugin& texture) { return setValue("color2", texture); }
	//! Second color
 	bool set_color2(const AColor& texture) { return setValue("color2", texture); }
	//! Second color
 	Value get_color2() const { return getValue("color2"); }

	//! Size
 	//! [Default value] 1
	bool set_size(float val) { return setValue("size", val); }
	//! Size
 	//! [Default value] 1
	float get_size() const { return getFloat("size"); }
};

class TexSplat : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexSplat"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! (description missing)
	//! [Default value] false
	bool set_use_3d_mapping(bool val) { return setValue("use_3d_mapping", val); }
	//! (description missing)
	//! [Default value] false
	bool get_use_3d_mapping() const { return getBool("use_3d_mapping"); }

	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	bool set_placement_type(int val) { return setValue("placement_type", val); }
	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	int get_placement_type() const { return getInt("placement_type"); }

	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_u(float val) { return setValue("u", val); }
	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_u() const { return getFloat("u"); }

	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_v(float val) { return setValue("v", val); }
	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_v() const { return getFloat("v"); }

	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_w(float val) { return setValue("w", val); }
	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_w() const { return getFloat("w"); }

	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_h(float val) { return setValue("h", val); }
	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_h() const { return getFloat("h"); }

	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	bool set_jitter(float val) { return setValue("jitter", val); }
	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	float get_jitter() const { return getFloat("jitter"); }

	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_u(bool val) { return setValue("tile_u", val); }
	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_u() const { return getBool("tile_u"); }

	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_v(bool val) { return setValue("tile_v", val); }
	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_v() const { return getBool("tile_v"); }

	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool set_uv_noise_on(bool val) { return setValue("uv_noise_on", val); }
	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool get_uv_noise_on() const { return getBool("uv_noise_on"); }

	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool set_uv_noise_animate(bool val) { return setValue("uv_noise_animate", val); }
	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool get_uv_noise_animate() const { return getBool("uv_noise_animate"); }

	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	bool set_uv_noise_amount(float val) { return setValue("uv_noise_amount", val); }
	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	float get_uv_noise_amount() const { return getFloat("uv_noise_amount"); }

	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	bool set_uv_noise_levels(float val) { return setValue("uv_noise_levels", val); }
	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	float get_uv_noise_levels() const { return getFloat("uv_noise_levels"); }

	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	bool set_uv_noise_size(float val) { return setValue("uv_noise_size", val); }
	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	float get_uv_noise_size() const { return getFloat("uv_noise_size"); }

	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	bool set_un_noise_phase(float val) { return setValue("un_noise_phase", val); }
	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	float get_un_noise_phase() const { return getFloat("un_noise_phase"); }

	//! First color
 	bool set_color1(const Plugin& texture) { return setValue("color1", texture); }
	//! First color
 	bool set_color1(const AColor& texture) { return setValue("color1", texture); }
	//! First color
 	Value get_color1() const { return getValue("color1"); }

	//! Second color
 	bool set_color2(const Plugin& texture) { return setValue("color2", texture); }
	//! Second color
 	bool set_color2(const AColor& texture) { return setValue("color2", texture); }
	//! Second color
 	Value get_color2() const { return getValue("color2"); }

	//! Size
 	//! [Default value] 1
	bool set_size(float val) { return setValue("size", val); }
	//! Size
 	//! [Default value] 1
	float get_size() const { return getFloat("size"); }

	//! Number of iterations for the fractal generator
 	//! [Default value] 4
	bool set_iterations(int val) { return setValue("iterations", val); }
	//! Number of iterations for the fractal generator
 	//! [Default value] 4
	int get_iterations() const { return getInt("iterations"); }

	//! Threshold
 	//! [Default value] 0.2
	bool set_threshold(float val) { return setValue("threshold", val); }
	//! Threshold
 	//! [Default value] 0.2
	float get_threshold() const { return getFloat("threshold"); }

	//! Transition smoothing
 	//! [Default value] 0.02
	bool set_smoothing(float val) { return setValue("smoothing", val); }
	//! Transition smoothing
 	//! [Default value] 0.02
	float get_smoothing() const { return getFloat("smoothing"); }
};

class TexStencil : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexStencil"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! The texture that is used as a stencil
 	bool set_image(const Plugin& texture) { return setValue("image", texture); }
	//! The texture that is used as a stencil
 	bool set_image(const AColor& texture) { return setValue("image", texture); }
	//! The texture that is used as a stencil
 	Value get_image() const { return getValue("image"); }

	//! Represents the Stencil's transparency
 	bool set_mask(const Plugin& texturefloat) { return setValue("mask", texturefloat); }
	//! Represents the Stencil's transparency
 	bool set_mask(float texturefloat) { return setValue("mask", texturefloat); }
	//! Represents the Stencil's transparency
 	Value get_mask() const { return getValue("mask"); }

	//! If true, selects the areas in the texture similar to or equal to the Color Key and masks them out
 	//! [Default value] false
	bool set_key_masking(bool val) { return setValue("key_masking", val); }
	//! If true, selects the areas in the texture similar to or equal to the Color Key and masks them out
 	//! [Default value] false
	bool get_key_masking() const { return getBool("key_masking"); }

	//! If true, inverts the Chroma Key mask(only the colors specified in the Color Key and HSV Range are displayed)
 	//! [Default value] false
	bool set_positive_key(bool val) { return setValue("positive_key", val); }
	//! If true, inverts the Chroma Key mask(only the colors specified in the Color Key and HSV Range are displayed)
 	//! [Default value] false
	bool get_positive_key() const { return getBool("positive_key"); }

	//! The color to be masked in the texture
 	bool set_color_key(const Plugin& texture) { return setValue("color_key", texture); }
	//! The color to be masked in the texture
 	bool set_color_key(const AColor& texture) { return setValue("color_key", texture); }
	//! The color to be masked in the texture
 	Value get_color_key() const { return getValue("color_key"); }

	//! The range of hues centered on the Color Key color which are also masked
 	bool set_hue_range(const Plugin& texturefloat) { return setValue("hue_range", texturefloat); }
	//! The range of hues centered on the Color Key color which are also masked
 	bool set_hue_range(float texturefloat) { return setValue("hue_range", texturefloat); }
	//! The range of hues centered on the Color Key color which are also masked
 	Value get_hue_range() const { return getValue("hue_range"); }

	//! The range of saturations centered on the Color Key color which are also masked
 	bool set_sat_range(const Plugin& texturefloat) { return setValue("sat_range", texturefloat); }
	//! The range of saturations centered on the Color Key color which are also masked
 	bool set_sat_range(float texturefloat) { return setValue("sat_range", texturefloat); }
	//! The range of saturations centered on the Color Key color which are also masked
 	Value get_sat_range() const { return getValue("sat_range"); }

	//! The range of values centered on the Color Key color which are also masked
 	bool set_val_range(const Plugin& texturefloat) { return setValue("val_range", texturefloat); }
	//! The range of values centered on the Color Key color which are also masked
 	bool set_val_range(float texturefloat) { return setValue("val_range", texturefloat); }
	//! The range of values centered on the Color Key color which are also masked
 	Value get_val_range() const { return getValue("val_range"); }

	//! Represents the texture that is underneath
 	bool set_default_color(const Plugin& texture) { return setValue("default_color", texture); }
	//! Represents the texture that is underneath
 	bool set_default_color(const AColor& texture) { return setValue("default_color", texture); }
	//! Represents the texture that is underneath
 	Value get_default_color() const { return getValue("default_color"); }

	//! Controls the sharpness of the texture edges.
 	//! [Default value] 0
	bool set_edge_blend(float val) { return setValue("edge_blend", val); }
	//! Controls the sharpness of the texture edges.
 	//! [Default value] 0
	float get_edge_blend() const { return getFloat("edge_blend"); }

	//! UVWGen from which the uvw coordinates will be taken
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! UVWGen from which the uvw coordinates will be taken
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }
};

class TexStucco : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexStucco"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! (description missing)
	//! [Default value] false
	bool set_use_3d_mapping(bool val) { return setValue("use_3d_mapping", val); }
	//! (description missing)
	//! [Default value] false
	bool get_use_3d_mapping() const { return getBool("use_3d_mapping"); }

	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	bool set_placement_type(int val) { return setValue("placement_type", val); }
	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	int get_placement_type() const { return getInt("placement_type"); }

	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_u(float val) { return setValue("u", val); }
	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_u() const { return getFloat("u"); }

	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_v(float val) { return setValue("v", val); }
	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_v() const { return getFloat("v"); }

	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_w(float val) { return setValue("w", val); }
	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_w() const { return getFloat("w"); }

	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_h(float val) { return setValue("h", val); }
	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_h() const { return getFloat("h"); }

	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	bool set_jitter(float val) { return setValue("jitter", val); }
	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	float get_jitter() const { return getFloat("jitter"); }

	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_u(bool val) { return setValue("tile_u", val); }
	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_u() const { return getBool("tile_u"); }

	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_v(bool val) { return setValue("tile_v", val); }
	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_v() const { return getBool("tile_v"); }

	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool set_uv_noise_on(bool val) { return setValue("uv_noise_on", val); }
	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool get_uv_noise_on() const { return getBool("uv_noise_on"); }

	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool set_uv_noise_animate(bool val) { return setValue("uv_noise_animate", val); }
	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool get_uv_noise_animate() const { return getBool("uv_noise_animate"); }

	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	bool set_uv_noise_amount(float val) { return setValue("uv_noise_amount", val); }
	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	float get_uv_noise_amount() const { return getFloat("uv_noise_amount"); }

	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	bool set_uv_noise_levels(float val) { return setValue("uv_noise_levels", val); }
	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	float get_uv_noise_levels() const { return getFloat("uv_noise_levels"); }

	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	bool set_uv_noise_size(float val) { return setValue("uv_noise_size", val); }
	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	float get_uv_noise_size() const { return getFloat("uv_noise_size"); }

	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	bool set_un_noise_phase(float val) { return setValue("un_noise_phase", val); }
	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	float get_un_noise_phase() const { return getFloat("un_noise_phase"); }

	//! First color
 	bool set_color1(const Plugin& texture) { return setValue("color1", texture); }
	//! First color
 	bool set_color1(const AColor& texture) { return setValue("color1", texture); }
	//! First color
 	Value get_color1() const { return getValue("color1"); }

	//! Second color
 	bool set_color2(const Plugin& texture) { return setValue("color2", texture); }
	//! Second color
 	bool set_color2(const AColor& texture) { return setValue("color2", texture); }
	//! Second color
 	Value get_color2() const { return getValue("color2"); }

	//! Size
 	//! [Default value] 1
	bool set_size(float val) { return setValue("size", val); }
	//! Size
 	//! [Default value] 1
	float get_size() const { return getFloat("size"); }

	//! Thickness
 	//! [Default value] 4
	bool set_thickness(float val) { return setValue("thickness", val); }
	//! Thickness
 	//! [Default value] 4
	float get_thickness() const { return getFloat("thickness"); }

	//! Threshold
 	//! [Default value] 0.2
	bool set_threshold(float val) { return setValue("threshold", val); }
	//! Threshold
 	//! [Default value] 0.2
	float get_threshold() const { return getFloat("threshold"); }
};

class TexSurfIncidence : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexSurfIncidence"; }

	//! Incidence mode
 	//! [Default value] 0
	bool set_inc_mode(int val) { return setValue("inc_mode", val); }
	//! Incidence mode
 	//! [Default value] 0
	int get_inc_mode() const { return getInt("inc_mode"); }

	//! Controls the contrast between dark and light areas of shading
 	//! [Default value] 100
	bool set_bias(float val) { return setValue("bias", val); }
	//! Controls the contrast between dark and light areas of shading
 	//! [Default value] 100
	float get_bias() const { return getFloat("bias"); }

	//! Controls the brightness of the effect
 	//! [Default value] 100
	bool set_gain(float val) { return setValue("gain", val); }
	//! Controls the brightness of the effect
 	//! [Default value] 100
	float get_gain() const { return getFloat("gain"); }

	//! custom vector
 	//! [Default value] Vector(0, 0, 0)
	bool set_custom_vector(const Vector& vector) { return setValue("custom_vector", vector); }
	//! custom vector
 	//! [Default value] Vector(0, 0, 0)
	Vector get_custom_vector() const { return getVector("custom_vector"); }

	//! Invert if enabled
 	//! [Default value] 0
	bool set_invert(int val) { return setValue("invert", val); }
	//! Invert if enabled
 	//! [Default value] 0
	int get_invert() const { return getInt("invert"); }

	//! Range (0 - 0 to 90 degrees, 1 - 0 to 180 degrees)
 	//! [UI Guides] enum=0:0 to 90 degrees; 1:0 to 180 degrees
 	//! [Default value] 0
	bool set_range(int val) { return setValue("range", val); }
	//! Range (0 - 0 to 90 degrees, 1 - 0 to 180 degrees)
 	//! [UI Guides] enum=0:0 to 90 degrees; 1:0 to 180 degrees
 	//! [Default value] 0
	int get_range() const { return getInt("range"); }
};

class TexSurfaceLuminance : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexSurfaceLuminance"; }

	//! 0: no luminance, 1: direct light, 2: diffuse light, 3: direct+diffuse light
 	//! [UI Guides] enum=0:No luminance; 1:Direct light; 2:Diffuse light; 3:Direct+diffuse light
 	//! [Default value] 1
	bool set_luminance_mode(int val) { return setValue("luminance_mode", val); }
	//! 0: no luminance, 1: direct light, 2: diffuse light, 3: direct+diffuse light
 	//! [UI Guides] enum=0:No luminance; 1:Direct light; 2:Diffuse light; 3:Direct+diffuse light
 	//! [Default value] 1
	int get_luminance_mode() const { return getInt("luminance_mode"); }

	//! Samples for diffuse lighting
 	//! [Default value] 0
	bool set_samples(int val) { return setValue("samples", val); }
	//! Samples for diffuse lighting
 	//! [Default value] 0
	int get_samples() const { return getInt("samples"); }

	//! If true, the direct light will contribute to the GI calculations. This have visual effect only if the texture is used for diffuse calculation.
 	//! [Default value] false
	bool set_contribute_to_gi(bool val) { return setValue("contribute_to_gi", val); }
	//! If true, the direct light will contribute to the GI calculations. This have visual effect only if the texture is used for diffuse calculation.
 	//! [Default value] false
	bool get_contribute_to_gi() const { return getBool("contribute_to_gi"); }
};

class TexSwirl : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexSwirl"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	bool set_placement_type(int val) { return setValue("placement_type", val); }
	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	int get_placement_type() const { return getInt("placement_type"); }

	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_u(float val) { return setValue("u", val); }
	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_u() const { return getFloat("u"); }

	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_v(float val) { return setValue("v", val); }
	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_v() const { return getFloat("v"); }

	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_w(float val) { return setValue("w", val); }
	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_w() const { return getFloat("w"); }

	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_h(float val) { return setValue("h", val); }
	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_h() const { return getFloat("h"); }

	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	bool set_jitter(float val) { return setValue("jitter", val); }
	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	float get_jitter() const { return getFloat("jitter"); }

	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_u(bool val) { return setValue("tile_u", val); }
	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_u() const { return getBool("tile_u"); }

	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_v(bool val) { return setValue("tile_v", val); }
	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_v() const { return getBool("tile_v"); }

	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool set_uv_noise_on(bool val) { return setValue("uv_noise_on", val); }
	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool get_uv_noise_on() const { return getBool("uv_noise_on"); }

	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool set_uv_noise_animate(bool val) { return setValue("uv_noise_animate", val); }
	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool get_uv_noise_animate() const { return getBool("uv_noise_animate"); }

	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	bool set_uv_noise_amount(float val) { return setValue("uv_noise_amount", val); }
	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	float get_uv_noise_amount() const { return getFloat("uv_noise_amount"); }

	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	bool set_uv_noise_levels(float val) { return setValue("uv_noise_levels", val); }
	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	float get_uv_noise_levels() const { return getFloat("uv_noise_levels"); }

	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	bool set_uv_noise_size(float val) { return setValue("uv_noise_size", val); }
	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	float get_uv_noise_size() const { return getFloat("uv_noise_size"); }

	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	bool set_un_noise_phase(float val) { return setValue("un_noise_phase", val); }
	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	float get_un_noise_phase() const { return getFloat("un_noise_phase"); }

	//! First color
 	bool set_color1(const Plugin& texture) { return setValue("color1", texture); }
	//! First color
 	bool set_color1(const AColor& texture) { return setValue("color1", texture); }
	//! First color
 	Value get_color1() const { return getValue("color1"); }

	//! Second color
 	bool set_color2(const Plugin& texture) { return setValue("color2", texture); }
	//! Second color
 	bool set_color2(const AColor& texture) { return setValue("color2", texture); }
	//! Second color
 	Value get_color2() const { return getValue("color2"); }

	//! Swirl Intensity
 	//! [Default value] 2
	bool set_swirl_intensity(float val) { return setValue("swirl_intensity", val); }
	//! Swirl Intensity
 	//! [Default value] 2
	float get_swirl_intensity() const { return getFloat("swirl_intensity"); }

	//! Color Contrast
 	//! [Default value] 0.4
	bool set_color_contrast(float val) { return setValue("color_contrast", val); }
	//! Color Contrast
 	//! [Default value] 0.4
	float get_color_contrast() const { return getFloat("color_contrast"); }

	//! Swirl Amount
 	//! [Default value] 1
	bool set_swirl_amount(float val) { return setValue("swirl_amount", val); }
	//! Swirl Amount
 	//! [Default value] 1
	float get_swirl_amount() const { return getFloat("swirl_amount"); }

	//! Constant Detail
 	//! [Default value] 4
	bool set_constant_detail(int val) { return setValue("constant_detail", val); }
	//! Constant Detail
 	//! [Default value] 4
	int get_constant_detail() const { return getInt("constant_detail"); }

	//! Center Position X
 	//! [Default value] -0.5
	bool set_center_x(float val) { return setValue("center_x", val); }
	//! Center Position X
 	//! [Default value] -0.5
	float get_center_x() const { return getFloat("center_x"); }

	//! Center Position Y
 	//! [Default value] -0.5
	bool set_center_y(float val) { return setValue("center_y", val); }
	//! Center Position Y
 	//! [Default value] -0.5
	float get_center_y() const { return getFloat("center_y"); }

	//! Random Seed
 	//! [Default value] 0
	bool set_random_seed(float val) { return setValue("random_seed", val); }
	//! Random Seed
 	//! [Default value] 0
	float get_random_seed() const { return getFloat("random_seed"); }

	//! Twist
 	//! [Default value] 1
	bool set_twist(float val) { return setValue("twist", val); }
	//! Twist
 	//! [Default value] 1
	float get_twist() const { return getFloat("twist"); }
};

class TexSwitch : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexSwitch"; }

	//! (description missing)
	bool set_nodes(const ValueList& pluginList) { return setValue("nodes", pluginList); }
	//! (description missing)
	ValueList get_nodes() const { return getValueList("nodes"); }

	//! (description missing)
	bool set_textures(const ValueList& pluginList) { return setValue("textures", pluginList); }
	//! (description missing)
	ValueList get_textures() const { return getValueList("textures"); }

	//! (description missing)
	bool set_default_texture(const Plugin& texture) { return setValue("default_texture", texture); }
	//! (description missing)
	bool set_default_texture(const AColor& texture) { return setValue("default_texture", texture); }
	//! (description missing)
	Value get_default_texture() const { return getValue("default_texture"); }
};

class TexSwitchFloat : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexSwitchFloat"; }

	//! (description missing)
	bool set_nodes(const ValueList& pluginList) { return setValue("nodes", pluginList); }
	//! (description missing)
	ValueList get_nodes() const { return getValueList("nodes"); }

	//! (description missing)
	bool set_textures(const ValueList& pluginList) { return setValue("textures", pluginList); }
	//! (description missing)
	ValueList get_textures() const { return getValueList("textures"); }

	//! (description missing)
	bool set_default_texture(const Plugin& texturefloat) { return setValue("default_texture", texturefloat); }
	//! (description missing)
	bool set_default_texture(float texturefloat) { return setValue("default_texture", texturefloat); }
	//! (description missing)
	Value get_default_texture() const { return getValue("default_texture"); }
};

class TexSwitchInt : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexSwitchInt"; }

	//! (description missing)
	bool set_nodes(const ValueList& pluginList) { return setValue("nodes", pluginList); }
	//! (description missing)
	ValueList get_nodes() const { return getValueList("nodes"); }

	//! (description missing)
	//! [Default value] 0
	bool set_values(const IntList& intList) { return setValue("values", intList); }
	//! (description missing)
	//! [Default value] 0
	bool set_values(const int* ints, size_t count) { return setArray("values", ints, count); }
	//! (description missing)
	//! [Default value] 0
	template<size_t count> bool set_values(const int (&ints)[count]) { return setArray("values", ints, count); }
	//! (description missing)
	//! [Default value] 0
	IntList get_values() const { return getIntList("values"); }

	//! (description missing)
	//! [Default value] 0
	bool set_default(int val) { return setValue("default", val); }
	//! (description missing)
	//! [Default value] 0
	int get_default() const { return getInt("default"); }
};

class TexSwitchMatrix : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexSwitchMatrix"; }

	//! (description missing)
	bool set_nodes(const ValueList& pluginList) { return setValue("nodes", pluginList); }
	//! (description missing)
	ValueList get_nodes() const { return getValueList("nodes"); }

	//! (description missing)
	bool set_textures(const ValueList& pluginList) { return setValue("textures", pluginList); }
	//! (description missing)
	ValueList get_textures() const { return getValueList("textures"); }

	//! (description missing)
	bool set_default_texture(const Plugin& texturematrix) { return setValue("default_texture", texturematrix); }
	//! (description missing)
	bool set_default_texture(const Matrix& texturematrix) { return setValue("default_texture", texturematrix); }
	//! (description missing)
	Value get_default_texture() const { return getValue("default_texture"); }
};

class TexSwitchTransform : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexSwitchTransform"; }

	//! (description missing)
	bool set_nodes(const ValueList& pluginList) { return setValue("nodes", pluginList); }
	//! (description missing)
	ValueList get_nodes() const { return getValueList("nodes"); }

	//! (description missing)
	bool set_textures(const ValueList& pluginList) { return setValue("textures", pluginList); }
	//! (description missing)
	ValueList get_textures() const { return getValueList("textures"); }

	//! (description missing)
	bool set_default_texture(const Plugin& texturetransform) { return setValue("default_texture", texturetransform); }
	//! (description missing)
	bool set_default_texture(const Transform& texturetransform) { return setValue("default_texture", texturetransform); }
	//! (description missing)
	Value get_default_texture() const { return getValue("default_texture"); }
};

class TexTemperature : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexTemperature"; }

	//! Output mode: 0 - from color; 1 - from temperature mode.
 	//! [Default value] 0
	bool set_color_mode(int val) { return setValue("color_mode", val); }
	//! Output mode: 0 - from color; 1 - from temperature mode.
 	//! [Default value] 0
	int get_color_mode() const { return getInt("color_mode"); }

	//! Temperature in Kelvins.
 	bool set_temperature(const Plugin& texturefloat) { return setValue("temperature", texturefloat); }
	//! Temperature in Kelvins.
 	bool set_temperature(float texturefloat) { return setValue("temperature", texturefloat); }
	//! Temperature in Kelvins.
 	Value get_temperature() const { return getValue("temperature"); }

	//! Color.
 	//! [Default value] Color(0.5, 0.5, 0.5)
	bool set_color(const Color& color) { return setValue("color", color); }
	//! Color.
 	//! [Default value] Color(0.5, 0.5, 0.5)
	Color get_color() const { return getColor("color"); }

	//! Color multiplier.
 	//! [Default value] 1
	bool set_rgb_multiplier(float val) { return setValue("rgb_multiplier", val); }
	//! Color multiplier.
 	//! [Default value] 1
	float get_rgb_multiplier() const { return getFloat("rgb_multiplier"); }

	//! Alpha color channel.
 	//! [Default value] 1
	bool set_alpha(float val) { return setValue("alpha", val); }
	//! Alpha color channel.
 	//! [Default value] 1
	float get_alpha() const { return getFloat("alpha"); }

	//! Gamma correction value.
 	//! [Default value] 1
	bool set_gamma_correction(float val) { return setValue("gamma_correction", val); }
	//! Gamma correction value.
 	//! [Default value] 1
	float get_gamma_correction() const { return getFloat("gamma_correction"); }
};

class TexTemperatureToColor : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexTemperatureToColor"; }

	//! (description missing)
	bool set_input(const Plugin& texture) { return setValue("input", texture); }
	//! (description missing)
	bool set_input(const AColor& texture) { return setValue("input", texture); }
	//! (description missing)
	Value get_input() const { return getValue("input"); }

	//! (description missing)
	//! [Default value] 1
	bool set_temperature(float val) { return setValue("temperature", val); }
	//! (description missing)
	//! [Default value] 1
	float get_temperature() const { return getFloat("temperature"); }
};

class TexThickness : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexThickness"; }

	//! The object thickness is multiplied by this value to get the texture color.
 	//! [Default value] 1
	bool set_thickness_mult(float val) { return setValue("thickness_mult", val); }
	//! The object thickness is multiplied by this value to get the texture color.
 	//! [Default value] 1
	float get_thickness_mult() const { return getFloat("thickness_mult"); }
};

class TexTiles : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexTiles"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	bool set_placement_type(int val) { return setValue("placement_type", val); }
	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	int get_placement_type() const { return getInt("placement_type"); }

	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_u(float val) { return setValue("u", val); }
	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_u() const { return getFloat("u"); }

	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_v(float val) { return setValue("v", val); }
	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_v() const { return getFloat("v"); }

	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_w(float val) { return setValue("w", val); }
	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_w() const { return getFloat("w"); }

	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_h(float val) { return setValue("h", val); }
	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_h() const { return getFloat("h"); }

	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	bool set_jitter(float val) { return setValue("jitter", val); }
	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	float get_jitter() const { return getFloat("jitter"); }

	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_u(bool val) { return setValue("tile_u", val); }
	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_u() const { return getBool("tile_u"); }

	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_v(bool val) { return setValue("tile_v", val); }
	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_v() const { return getBool("tile_v"); }

	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool set_uv_noise_on(bool val) { return setValue("uv_noise_on", val); }
	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool get_uv_noise_on() const { return getBool("uv_noise_on"); }

	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool set_uv_noise_animate(bool val) { return setValue("uv_noise_animate", val); }
	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool get_uv_noise_animate() const { return getBool("uv_noise_animate"); }

	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	bool set_uv_noise_amount(float val) { return setValue("uv_noise_amount", val); }
	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	float get_uv_noise_amount() const { return getFloat("uv_noise_amount"); }

	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	bool set_uv_noise_levels(float val) { return setValue("uv_noise_levels", val); }
	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	float get_uv_noise_levels() const { return getFloat("uv_noise_levels"); }

	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	bool set_uv_noise_size(float val) { return setValue("uv_noise_size", val); }
	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	float get_uv_noise_size() const { return getFloat("uv_noise_size"); }

	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	bool set_un_noise_phase(float val) { return setValue("un_noise_phase", val); }
	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	float get_un_noise_phase() const { return getFloat("un_noise_phase"); }

	//! Tiles pattern: 0-Custom Tiles, 1-Running Bond, 2-Common Flemish Bond, 3-English Bond, 4-1/2 Running Bond, 5-Stack Bond, 6-Fine Running Bond, 7-Fine Stack Bond
 	//! [UI Guides] enum=0:Custom Tiles; 1:Running Bond; 2:Common Flemish Bond; 3:English Bond; 4:1/2 Running Bond; 5:Stack Bond; 6:Fine Running Bond; 7:Fine Stack Bond
 	//! [Default value] 0
	bool set_pattern_type(int val) { return setValue("pattern_type", val); }
	//! Tiles pattern: 0-Custom Tiles, 1-Running Bond, 2-Common Flemish Bond, 3-English Bond, 4-1/2 Running Bond, 5-Stack Bond, 6-Fine Running Bond, 7-Fine Stack Bond
 	//! [UI Guides] enum=0:Custom Tiles; 1:Running Bond; 2:Common Flemish Bond; 3:English Bond; 4:1/2 Running Bond; 5:Stack Bond; 6:Fine Running Bond; 7:Fine Stack Bond
 	//! [Default value] 0
	int get_pattern_type() const { return getInt("pattern_type"); }

	//! Mortar color
 	bool set_color_mortar(const Plugin& texture) { return setValue("color_mortar", texture); }
	//! Mortar color
 	bool set_color_mortar(const AColor& texture) { return setValue("color_mortar", texture); }
	//! Mortar color
 	Value get_color_mortar() const { return getValue("color_mortar"); }

	//! Tiles color
 	bool set_color_tiles(const Plugin& texture) { return setValue("color_tiles", texture); }
	//! Tiles color
 	bool set_color_tiles(const AColor& texture) { return setValue("color_tiles", texture); }
	//! Tiles color
 	Value get_color_tiles() const { return getValue("color_tiles"); }

	//! Tiles horizontal count
 	//! [UI Guides] minValue=0
 	//! [Default value] 1
	bool set_horizontal_count(float val) { return setValue("horizontal_count", val); }
	//! Tiles horizontal count
 	//! [UI Guides] minValue=0
 	//! [Default value] 1
	float get_horizontal_count() const { return getFloat("horizontal_count"); }

	//! Tiles vertical count
 	//! [UI Guides] minValue=0
 	//! [Default value] 1
	bool set_vertical_count(float val) { return setValue("vertical_count", val); }
	//! Tiles vertical count
 	//! [UI Guides] minValue=0
 	//! [Default value] 1
	float get_vertical_count() const { return getFloat("vertical_count"); }

	//! Color variance
 	//! [UI Guides] minValue=0
 	//! [Default value] 0
	bool set_color_variance(float val) { return setValue("color_variance", val); }
	//! Color variance
 	//! [UI Guides] minValue=0
 	//! [Default value] 0
	float get_color_variance() const { return getFloat("color_variance"); }

	//! Fade variance
 	//! [UI Guides] minValue=0
 	//! [Default value] 0
	bool set_fade_variance(float val) { return setValue("fade_variance", val); }
	//! Fade variance
 	//! [UI Guides] minValue=0
 	//! [Default value] 0
	float get_fade_variance() const { return getFloat("fade_variance"); }

	//! Horizontal gap between tiles
 	//! [UI Guides] minValue=0
 	//! [Default value] 0
	bool set_horizontal_gap(float val) { return setValue("horizontal_gap", val); }
	//! Horizontal gap between tiles
 	//! [UI Guides] minValue=0
 	//! [Default value] 0
	float get_horizontal_gap() const { return getFloat("horizontal_gap"); }

	//! Vertical gap between tiles
 	//! [UI Guides] minValue=0
 	//! [Default value] 0
	bool set_vertical_gap(float val) { return setValue("vertical_gap", val); }
	//! Vertical gap between tiles
 	//! [UI Guides] minValue=0
 	//! [Default value] 0
	float get_vertical_gap() const { return getFloat("vertical_gap"); }

	//! Holes
 	//! [UI Guides] displayName=Holes %, minValue=0, maxValue=100
 	//! [Default value] 0
	bool set_holes(int val) { return setValue("holes", val); }
	//! Holes
 	//! [UI Guides] displayName=Holes %, minValue=0, maxValue=100
 	//! [Default value] 0
	int get_holes() const { return getInt("holes"); }

	//! Edge roughness
 	//! [UI Guides] minValue=0
 	//! [Default value] 0
	bool set_edge_roughness(float val) { return setValue("edge_roughness", val); }
	//! Edge roughness
 	//! [UI Guides] minValue=0
 	//! [Default value] 0
	float get_edge_roughness() const { return getFloat("edge_roughness"); }

	//! Random seed
 	//! [UI Guides] minValue=0
 	//! [Default value] 0
	bool set_random_seed(int val) { return setValue("random_seed", val); }
	//! Random seed
 	//! [UI Guides] minValue=0
 	//! [Default value] 0
	int get_random_seed() const { return getInt("random_seed"); }

	//! Line shift
 	//! [UI Guides] minValue=0, enableIf: ?pattern_type=0
 	//! [Default value] 0.5
	bool set_line_shift(float val) { return setValue("line_shift", val); }
	//! Line shift
 	//! [UI Guides] minValue=0, enableIf: ?pattern_type=0
 	//! [Default value] 0.5
	float get_line_shift() const { return getFloat("line_shift"); }

	//! Random shift
 	//! [UI Guides] minValue=0, enableIf: ?pattern_type=0
 	//! [Default value] 0
	bool set_random_shift(float val) { return setValue("random_shift", val); }
	//! Random shift
 	//! [UI Guides] minValue=0, enableIf: ?pattern_type=0
 	//! [Default value] 0
	float get_random_shift() const { return getFloat("random_shift"); }

	//! if true - custom row parameters
 	//! [UI Guides] enableIf: ?pattern_type=0
 	//! [Default value] false
	bool set_row_modify(bool val) { return setValue("row_modify", val); }
	//! if true - custom row parameters
 	//! [UI Guides] enableIf: ?pattern_type=0
 	//! [Default value] false
	bool get_row_modify() const { return getBool("row_modify"); }

	//! every per_row row is modified by corresponding change value
 	//! [UI Guides] minValue=0, enableIf: ?pattern_type=0, ?row_modify=1
 	//! [Default value] 1
	bool set_per_row(int val) { return setValue("per_row", val); }
	//! every per_row row is modified by corresponding change value
 	//! [UI Guides] minValue=0, enableIf: ?pattern_type=0, ?row_modify=1
 	//! [Default value] 1
	int get_per_row() const { return getInt("per_row"); }

	//! row change value modifying the number of tiles in affected rows
 	//! [UI Guides] minValue=0, enableIf: ?pattern_type=0, ?row_modify=1
 	//! [Default value] 1
	bool set_row_change(float val) { return setValue("row_change", val); }
	//! row change value modifying the number of tiles in affected rows
 	//! [UI Guides] minValue=0, enableIf: ?pattern_type=0, ?row_modify=1
 	//! [Default value] 1
	float get_row_change() const { return getFloat("row_change"); }

	//! if true - custom column parameters
 	//! [UI Guides] enableIf: ?pattern_type=0
 	//! [Default value] false
	bool set_column_modify(bool val) { return setValue("column_modify", val); }
	//! if true - custom column parameters
 	//! [UI Guides] enableIf: ?pattern_type=0
 	//! [Default value] false
	bool get_column_modify() const { return getBool("column_modify"); }

	//! every per_column column is modified by corresponding change value
 	//! [UI Guides] minValue=0, enableIf: ?pattern_type=0, ?column_modify=1
 	//! [Default value] 1
	bool set_per_column(int val) { return setValue("per_column", val); }
	//! every per_column column is modified by corresponding change value
 	//! [UI Guides] minValue=0, enableIf: ?pattern_type=0, ?column_modify=1
 	//! [Default value] 1
	int get_per_column() const { return getInt("per_column"); }

	//! column change value modifying the number of tiles in affected columns
 	//! [UI Guides] minValue=0, enableIf: ?pattern_type=0, ?column_modify=1
 	//! [Default value] 1
	bool set_column_change(float val) { return setValue("column_change", val); }
	//! column change value modifying the number of tiles in affected columns
 	//! [UI Guides] minValue=0, enableIf: ?pattern_type=0, ?column_modify=1
 	//! [Default value] 1
	float get_column_change() const { return getFloat("column_change"); }
};

class TexTriPlanar : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexTriPlanar"; }

	//! Specifies whether to use the same texture on all axes, or separate textures for each axis.
 	//! [UI Guides] enum=0:Same texture on all axes;1:Different texture on each axis;
 	//! [Default value] 0
	bool set_texture_mode(int val) { return setValue("texture_mode", val); }
	//! Specifies whether to use the same texture on all axes, or separate textures for each axis.
 	//! [UI Guides] enum=0:Same texture on all axes;1:Different texture on each axis;
 	//! [Default value] 0
	int get_texture_mode() const { return getInt("texture_mode"); }

	//! The base texture, or the texture for the X axis if texture mode is set to different textures.
 	bool set_texture_x(const Plugin& texture) { return setValue("texture_x", texture); }
	//! The base texture, or the texture for the X axis if texture mode is set to different textures.
 	bool set_texture_x(const AColor& texture) { return setValue("texture_x", texture); }
	//! The base texture, or the texture for the X axis if texture mode is set to different textures.
 	Value get_texture_x() const { return getValue("texture_x"); }

	//! The texture for the Y axis.
 	//! [UI Guides] enableIf: ?texture_mode=1, attributes=textureSlot
 	bool set_texture_y(const Plugin& texture) { return setValue("texture_y", texture); }
	//! The texture for the Y axis.
 	//! [UI Guides] enableIf: ?texture_mode=1, attributes=textureSlot
 	bool set_texture_y(const AColor& texture) { return setValue("texture_y", texture); }
	//! The texture for the Y axis.
 	//! [UI Guides] enableIf: ?texture_mode=1, attributes=textureSlot
 	Value get_texture_y() const { return getValue("texture_y"); }

	//! The texture for the Z axis.
 	//! [UI Guides] enableIf: ?texture_mode=1, attributes=textureSlot
 	bool set_texture_z(const Plugin& texture) { return setValue("texture_z", texture); }
	//! The texture for the Z axis.
 	//! [UI Guides] enableIf: ?texture_mode=1, attributes=textureSlot
 	bool set_texture_z(const AColor& texture) { return setValue("texture_z", texture); }
	//! The texture for the Z axis.
 	//! [UI Guides] enableIf: ?texture_mode=1, attributes=textureSlot
 	Value get_texture_z() const { return getValue("texture_z"); }

	//! Scale of the texture; larger values increase the number of texture repeats, lower values make the texture larger.
 	//! [UI Guides] minValue=0.0, startRollout=
 	//! [Default value] 1
	bool set_scale(float val) { return setValue("scale", val); }
	//! Scale of the texture; larger values increase the number of texture repeats, lower values make the texture larger.
 	//! [UI Guides] minValue=0.0, startRollout=
 	//! [Default value] 1
	float get_scale() const { return getFloat("scale"); }

	//! Amount of blending at the plane seams.
 	//! [UI Guides] minValue=0.0, maxValue=1.0
 	//! [Default value] 1
	bool set_blend(float val) { return setValue("blend", val); }
	//! Amount of blending at the plane seams.
 	//! [UI Guides] minValue=0.0, maxValue=1.0
 	//! [Default value] 1
	float get_blend() const { return getFloat("blend"); }

	//! Offset from the reference frame center (object or reference node).
 	//! [UI Guides] quantityType=distance, startRollout=
 	//! [Default value] Vector(0, 0, 0)
	bool set_frame_offset(const Vector& vector) { return setValue("frame_offset", vector); }
	//! Offset from the reference frame center (object or reference node).
 	//! [UI Guides] quantityType=distance, startRollout=
 	//! [Default value] Vector(0, 0, 0)
	Vector get_frame_offset() const { return getVector("frame_offset"); }

	//! Texture rotations for the three axes, in degrees, in texture space.
 	//! [UI Guides] minValue=0.0, maxValue=360.0, quantityType=angle, units=degrees
 	//! [Default value] Vector(0, 0, 0)
	bool set_texture_rotation(const Vector& vector) { return setValue("texture_rotation", vector); }
	//! Texture rotations for the three axes, in degrees, in texture space.
 	//! [UI Guides] minValue=0.0, maxValue=360.0, quantityType=angle, units=degrees
 	//! [Default value] Vector(0, 0, 0)
	Vector get_texture_rotation() const { return getVector("texture_rotation"); }

	//! Randomize the texture offset in texture space.
 	//! [Default value] false
	bool set_random_texture_offset(bool val) { return setValue("random_texture_offset", val); }
	//! Randomize the texture offset in texture space.
 	//! [Default value] false
	bool get_random_texture_offset() const { return getBool("random_texture_offset"); }

	//! Randomize the texture rotation from one object to another, in texture space. The "texture rotation" parameter, if non-zero, is used as increments for the rotation.
 	//! [Default value] false
	bool set_random_texture_rotation(bool val) { return setValue("random_texture_rotation", val); }
	//! Randomize the texture rotation from one object to another, in texture space. The "texture rotation" parameter, if non-zero, is used as increments for the rotation.
 	//! [Default value] false
	bool get_random_texture_rotation() const { return getBool("random_texture_rotation"); }

	//! Randomly permute the axes.
 	//! [Default value] false
	bool set_random_axis(bool val) { return setValue("random_axis", val); }
	//! Randomly permute the axes.
 	//! [Default value] false
	bool get_random_axis() const { return getBool("random_axis"); }

	//! Random frame rotation (in object or reference space).
 	//! [Default value] false
	bool set_random_frame_rotation(bool val) { return setValue("random_frame_rotation", val); }
	//! Random frame rotation (in object or reference space).
 	//! [Default value] false
	bool get_random_frame_rotation() const { return getBool("random_frame_rotation"); }

	//! Specifies what to use to randomize the offset/rotation.
 	//! [UI Guides] enum=0:By face material ID;1:By object render ID;, enableIf: ?random_texture_offset=1;?random_texture_rotation=1;?random_axis=1;?random_frame_rotation=1
 	//! [Default value] 0
	bool set_random_mode(int val) { return setValue("random_mode", val); }
	//! Specifies what to use to randomize the offset/rotation.
 	//! [UI Guides] enum=0:By face material ID;1:By object render ID;, enableIf: ?random_texture_offset=1;?random_texture_rotation=1;?random_axis=1;?random_frame_rotation=1
 	//! [Default value] 0
	int get_random_mode() const { return getInt("random_mode"); }

	//! The space that the projection takes place in, either local object space, or some other object in the scene. If the space is set to reference object(Node), but no object is specified, world space is used.
 	//! [UI Guides] displayName=Reference space, enum=0:Local object;1:Reference to another object;, startRollout=
 	//! [Default value] 0
	bool set_ref_space(int val) { return setValue("ref_space", val); }
	//! The space that the projection takes place in, either local object space, or some other object in the scene. If the space is set to reference object(Node), but no object is specified, world space is used.
 	//! [UI Guides] displayName=Reference space, enum=0:Local object;1:Reference to another object;, startRollout=
 	//! [Default value] 0
	int get_ref_space() const { return getInt("ref_space"); }

	//! The reference object's world transform, when the reference space is set to reference object(Node). If this parameter is missing, world space is used.
 	//! [UI Guides] enableIf: ?ref_space=1
 	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	bool set_node_ref_transform(const Transform& transform) { return setValue("node_ref_transform", transform); }
	//! The reference object's world transform, when the reference space is set to reference object(Node). If this parameter is missing, world space is used.
 	//! [UI Guides] enableIf: ?ref_space=1
 	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	Transform get_node_ref_transform() const { return getTransform("node_ref_transform"); }
};

class TexUVW : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexUVW"; }

	//! The uvw space that will be displayed as RGB
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw space that will be displayed as RGB
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! Specifies which component to show (0 - all, 1 - u, 2 - v, 3 - w)
 	//! [UI Guides] enum=0:All; 1:U; 2:V; 3:W
 	//! [Default value] 0
	bool set_component(int val) { return setValue("component", val); }
	//! Specifies which component to show (0 - all, 1 - u, 2 - v, 3 - w)
 	//! [UI Guides] enum=0:All; 1:U; 2:V; 3:W
 	//! [Default value] 0
	int get_component() const { return getInt("component"); }
};

class TexUVWGenToTexture : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexUVWGenToTexture"; }

	//! (description missing)
	bool set_input(const Plugin& plugin) { return setValue("input", plugin); }
	//! (description missing)
	Plugin get_input() const { return getPlugin("input"); }
};

class TexUserColor : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexUserColor"; }

	//! Default color when the attribute is not found
 	bool set_default_color(const Plugin& texture) { return setValue("default_color", texture); }
	//! Default color when the attribute is not found
 	bool set_default_color(const AColor& texture) { return setValue("default_color", texture); }
	//! Default color when the attribute is not found
 	Value get_default_color() const { return getValue("default_color"); }

	//! user attribute name of type color or float
 	bool set_user_attribute(const char* str) { return setValue("user_attribute", str); }
	//! user attribute name of type color or float
 	bool set_user_attribute(const std::string& str) { return setValue("user_attribute", str); }
	//! user attribute name of type color or float
 	std::string get_user_attribute() const { return getString("user_attribute"); }
};

class TexUserInteger : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexUserInteger"; }

	//! Default value if the attribute is not found
 	bool set_default_value(const Plugin& textureint) { return setValue("default_value", textureint); }
	//! Default value if the attribute is not found
 	bool set_default_value(int textureint) { return setValue("default_value", textureint); }
	//! Default value if the attribute is not found
 	Value get_default_value() const { return getValue("default_value"); }

	//! user attribute name of type float or color
 	bool set_user_attribute(const char* str) { return setValue("user_attribute", str); }
	//! user attribute name of type float or color
 	bool set_user_attribute(const std::string& str) { return setValue("user_attribute", str); }
	//! user attribute name of type float or color
 	std::string get_user_attribute() const { return getString("user_attribute"); }
};

class TexUserScalar : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexUserScalar"; }

	//! Default value if the attribute is not found
 	bool set_default_value(const Plugin& texturefloat) { return setValue("default_value", texturefloat); }
	//! Default value if the attribute is not found
 	bool set_default_value(float texturefloat) { return setValue("default_value", texturefloat); }
	//! Default value if the attribute is not found
 	Value get_default_value() const { return getValue("default_value"); }

	//! user attribute name of type float or color
 	bool set_user_attribute(const char* str) { return setValue("user_attribute", str); }
	//! user attribute name of type float or color
 	bool set_user_attribute(const std::string& str) { return setValue("user_attribute", str); }
	//! user attribute name of type float or color
 	std::string get_user_attribute() const { return getString("user_attribute"); }
};

class TexVRayFurSampler : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexVRayFurSampler"; }
};

class TexVectorOp : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexVectorOp"; }

	//! The first vector
 	bool set_vector_a(const Plugin& texturevector) { return setValue("vector_a", texturevector); }
	//! The first vector
 	bool set_vector_a(const Vector& texturevector) { return setValue("vector_a", texturevector); }
	//! The first vector
 	Value get_vector_a() const { return getValue("vector_a"); }

	//! The second vector
 	bool set_vector_b(const Plugin& texturevector) { return setValue("vector_b", texturevector); }
	//! The second vector
 	bool set_vector_b(const Vector& texturevector) { return setValue("vector_b", texturevector); }
	//! The second vector
 	Value get_vector_b() const { return getValue("vector_b"); }

	//! Multiplier for the first vector
 	bool set_mult_a(const Plugin& texturefloat) { return setValue("mult_a", texturefloat); }
	//! Multiplier for the first vector
 	bool set_mult_a(float texturefloat) { return setValue("mult_a", texturefloat); }
	//! Multiplier for the first vector
 	Value get_mult_a() const { return getValue("mult_a"); }

	//! Multiplier for the second vector
 	bool set_mult_b(const Plugin& texturefloat) { return setValue("mult_b", texturefloat); }
	//! Multiplier for the second vector
 	bool set_mult_b(float texturefloat) { return setValue("mult_b", texturefloat); }
	//! Multiplier for the second vector
 	Value get_mult_b() const { return getValue("mult_b"); }
};

class TexVectorProduct : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexVectorProduct"; }

	//! Operation (0 - No operation, 1 - Dot Product, 2 - Cross Product, 3 - Vector Matrix Product, 4 - Point Matrix Product)
 	//! [UI Guides] enum=0:No operation; 1:Dot Product; 2:Cross Product; 3:Vector Matrix Product; 4:Point Matrix Product
 	//! [Default value] 1
	bool set_operation(int val) { return setValue("operation", val); }
	//! Operation (0 - No operation, 1 - Dot Product, 2 - Cross Product, 3 - Vector Matrix Product, 4 - Point Matrix Product)
 	//! [UI Guides] enum=0:No operation; 1:Dot Product; 2:Cross Product; 3:Vector Matrix Product; 4:Point Matrix Product
 	//! [Default value] 1
	int get_operation() const { return getInt("operation"); }

	//! (description missing)
	bool set_input1(const Plugin& texture) { return setValue("input1", texture); }
	//! (description missing)
	bool set_input1(const AColor& texture) { return setValue("input1", texture); }
	//! (description missing)
	Value get_input1() const { return getValue("input1"); }

	//! (description missing)
	bool set_input2(const Plugin& texture) { return setValue("input2", texture); }
	//! (description missing)
	bool set_input2(const AColor& texture) { return setValue("input2", texture); }
	//! (description missing)
	Value get_input2() const { return getValue("input2"); }

	//! (description missing)
	bool set_transform(const Plugin& texturetransform) { return setValue("transform", texturetransform); }
	//! (description missing)
	bool set_transform(const Transform& texturetransform) { return setValue("transform", texturetransform); }
	//! (description missing)
	Value get_transform() const { return getValue("transform"); }

	//! When this is true the output vector will be normalized (in case of dot product, the input vectors are normalized before the operation)
 	//! [Default value] false
	bool set_normalize(bool val) { return setValue("normalize", val); }
	//! When this is true the output vector will be normalized (in case of dot product, the input vectors are normalized before the operation)
 	//! [Default value] false
	bool get_normalize() const { return getBool("normalize"); }
};

class TexVectorToColor : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexVectorToColor"; }

	//! (description missing)
	bool set_input(const Plugin& texturevector) { return setValue("input", texturevector); }
	//! (description missing)
	bool set_input(const Vector& texturevector) { return setValue("input", texturevector); }
	//! (description missing)
	Value get_input() const { return getValue("input"); }
};

class TexVertexColorDirect : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexVertexColorDirect"; }

	//! (description missing)
	bool set_color_set_name(const char* str) { return setValue("color_set_name", str); }
	//! (description missing)
	bool set_color_set_name(const std::string& str) { return setValue("color_set_name", str); }
	//! (description missing)
	std::string get_color_set_name() const { return getString("color_set_name"); }

	//! (description missing)
	bool set_default_color(const Plugin& texture) { return setValue("default_color", texture); }
	//! (description missing)
	bool set_default_color(const AColor& texture) { return setValue("default_color", texture); }
	//! (description missing)
	Value get_default_color() const { return getValue("default_color"); }
};

class TexVoxelData : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexVoxelData"; }

	//! Interpolation type: 0 - Linear, 1 - Quadratic
 	//! [Default value] 0
	bool set_interpolation(int val) { return setValue("interpolation", val); }
	//! Interpolation type: 0 - Linear, 1 - Quadratic
 	//! [Default value] 0
	int get_interpolation() const { return getInt("interpolation"); }

	//! Resolution
 	//! [Default value] Vector(0, 0, 0)
	bool set_resolution(const Vector& vector) { return setValue("resolution", vector); }
	//! Resolution
 	//! [Default value] Vector(0, 0, 0)
	Vector get_resolution() const { return getVector("resolution"); }

	//! Fluid density
 	//! [Default value] 0
	bool set_density(const FloatList& floatList) { return setValue("density", floatList); }
	//! Fluid density
 	//! [Default value] 0
	bool set_density(const float* floats, size_t count) { return setArray("density", floats, count); }
	//! Fluid density
 	//! [Default value] 0
	template<size_t count> bool set_density(const float (&floats)[count]) { return setArray("density", floats, count); }
	//! Fluid density
 	//! [Default value] 0
	FloatList get_density() const { return getFloatList("density"); }

	//! Fluid flame
 	//! [Default value] 0
	bool set_flame(const FloatList& floatList) { return setValue("flame", floatList); }
	//! Fluid flame
 	//! [Default value] 0
	bool set_flame(const float* floats, size_t count) { return setArray("flame", floats, count); }
	//! Fluid flame
 	//! [Default value] 0
	template<size_t count> bool set_flame(const float (&floats)[count]) { return setArray("flame", floats, count); }
	//! Fluid flame
 	//! [Default value] 0
	FloatList get_flame() const { return getFloatList("flame"); }

	//! Fluid fuel
 	//! [Default value] 0
	bool set_fuel(const FloatList& floatList) { return setValue("fuel", floatList); }
	//! Fluid fuel
 	//! [Default value] 0
	bool set_fuel(const float* floats, size_t count) { return setArray("fuel", floats, count); }
	//! Fluid fuel
 	//! [Default value] 0
	template<size_t count> bool set_fuel(const float (&floats)[count]) { return setArray("fuel", floats, count); }
	//! Fluid fuel
 	//! [Default value] 0
	FloatList get_fuel() const { return getFloatList("fuel"); }

	//! The UVW generator for the texture
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The UVW generator for the texture
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }
};

class TexWater : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexWater"; }

	//! (description missing)
	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! (description missing)
	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! multiplier for the height of the water
 	//! [UI Guides] minValue=0.0
 	//! [Default value] 1
	bool set_height_mult(float val) { return setValue("height_mult", val); }
	//! multiplier for the height of the water
 	//! [UI Guides] minValue=0.0
 	//! [Default value] 1
	float get_height_mult() const { return getFloat("height_mult"); }

	//! (description missing)
	//! [Default value] true
	bool set_use_3d_mapping(bool val) { return setValue("use_3d_mapping", val); }
	//! (description missing)
	//! [Default value] true
	bool get_use_3d_mapping() const { return getBool("use_3d_mapping"); }

	//! direction of the wind
 	//! [Default value] 0
	bool set_wind_direction(float val) { return setValue("wind_direction", val); }
	//! direction of the wind
 	//! [Default value] 0
	float get_wind_direction() const { return getFloat("wind_direction"); }

	//! magnitude of the wind
 	//! [UI Guides] minValue=0.0
 	//! [Default value] 0
	bool set_wind_magnitude(float val) { return setValue("wind_magnitude", val); }
	//! magnitude of the wind
 	//! [UI Guides] minValue=0.0
 	//! [Default value] 0
	float get_wind_magnitude() const { return getFloat("wind_magnitude"); }

	//! [UI Guides] minValue=0.0, maxValue=1.0
 	//! [Default value] 0
	bool set_wind_direction_mult(float val) { return setValue("wind_direction_mult", val); }
	//! [UI Guides] minValue=0.0, maxValue=1.0
 	//! [Default value] 0
	float get_wind_direction_mult() const { return getFloat("wind_direction_mult"); }

	//! (description missing)
	//! [Default value] 0
	bool set_choppy_mult(float val) { return setValue("choppy_mult", val); }
	//! (description missing)
	//! [Default value] 0
	float get_choppy_mult() const { return getFloat("choppy_mult"); }

	//! [UI Guides] minValue=0.0
 	//! [Default value] 1
	bool set_movement_rate(float val) { return setValue("movement_rate", val); }
	//! [UI Guides] minValue=0.0
 	//! [Default value] 1
	float get_movement_rate() const { return getFloat("movement_rate"); }

	//! Used to produce different waters
 	//! [Default value] 1
	bool set_seed(int val) { return setValue("seed", val); }
	//! Used to produce different waters
 	//! [Default value] 1
	int get_seed() const { return getInt("seed"); }

	//! Resolution -> real resolution is 2^res
 	//! [UI Guides] enum=0:32; 1:64; 2:128; 3:256; 4:512; 5:1024; 6:2048
 	//! [Default value] 4
	bool set_resolution(int val) { return setValue("resolution", val); }
	//! Resolution -> real resolution is 2^res
 	//! [UI Guides] enum=0:32; 1:64; 2:128; 3:256; 4:512; 5:1024; 6:2048
 	//! [Default value] 4
	int get_resolution() const { return getInt("resolution"); }

	//! Size of the patch -> real resolution is 2^res
 	//! [UI Guides] minValue=0.0
 	//! [Default value] 128
	bool set_patch_size(float val) { return setValue("patch_size", val); }
	//! Size of the patch -> real resolution is 2^res
 	//! [UI Guides] minValue=0.0
 	//! [Default value] 128
	float get_patch_size() const { return getFloat("patch_size"); }
};

class TexWood : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexWood"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! (description missing)
	//! [Default value] false
	bool set_use_3d_mapping(bool val) { return setValue("use_3d_mapping", val); }
	//! (description missing)
	//! [Default value] false
	bool get_use_3d_mapping() const { return getBool("use_3d_mapping"); }

	//! (description missing)
	//! [Default value] true
	bool set_wrap(bool val) { return setValue("wrap", val); }
	//! (description missing)
	//! [Default value] true
	bool get_wrap() const { return getBool("wrap"); }

	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	bool set_placement_type(int val) { return setValue("placement_type", val); }
	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	int get_placement_type() const { return getInt("placement_type"); }

	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_u(float val) { return setValue("u", val); }
	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_u() const { return getFloat("u"); }

	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_v(float val) { return setValue("v", val); }
	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_v() const { return getFloat("v"); }

	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_w(float val) { return setValue("w", val); }
	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_w() const { return getFloat("w"); }

	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_h(float val) { return setValue("h", val); }
	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_h() const { return getFloat("h"); }

	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	bool set_jitter(float val) { return setValue("jitter", val); }
	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	float get_jitter() const { return getFloat("jitter"); }

	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_u(bool val) { return setValue("tile_u", val); }
	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_u() const { return getBool("tile_u"); }

	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_v(bool val) { return setValue("tile_v", val); }
	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_v() const { return getBool("tile_v"); }

	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool set_uv_noise_on(bool val) { return setValue("uv_noise_on", val); }
	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool get_uv_noise_on() const { return getBool("uv_noise_on"); }

	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool set_uv_noise_animate(bool val) { return setValue("uv_noise_animate", val); }
	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool get_uv_noise_animate() const { return getBool("uv_noise_animate"); }

	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	bool set_uv_noise_amount(float val) { return setValue("uv_noise_amount", val); }
	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	float get_uv_noise_amount() const { return getFloat("uv_noise_amount"); }

	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	bool set_uv_noise_levels(float val) { return setValue("uv_noise_levels", val); }
	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	float get_uv_noise_levels() const { return getFloat("uv_noise_levels"); }

	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	bool set_uv_noise_size(float val) { return setValue("uv_noise_size", val); }
	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	float get_uv_noise_size() const { return getFloat("uv_noise_size"); }

	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	bool set_un_noise_phase(float val) { return setValue("un_noise_phase", val); }
	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	float get_un_noise_phase() const { return getFloat("un_noise_phase"); }

	//! (description missing)
	bool set_filler_color_tex(const Plugin& texture) { return setValue("filler_color_tex", texture); }
	//! (description missing)
	bool set_filler_color_tex(const AColor& texture) { return setValue("filler_color_tex", texture); }
	//! (description missing)
	Value get_filler_color_tex() const { return getValue("filler_color_tex"); }

	//! (description missing)
	bool set_vein_color_tex(const Plugin& texture) { return setValue("vein_color_tex", texture); }
	//! (description missing)
	bool set_vein_color_tex(const AColor& texture) { return setValue("vein_color_tex", texture); }
	//! (description missing)
	Value get_vein_color_tex() const { return getValue("vein_color_tex"); }

	//! (description missing)
	//! [Default value] 0.25
	bool set_vein_spread(float val) { return setValue("vein_spread", val); }
	//! (description missing)
	//! [Default value] 0.25
	float get_vein_spread() const { return getFloat("vein_spread"); }

	//! (description missing)
	//! [Default value] 0.05
	bool set_layer_size(float val) { return setValue("layer_size", val); }
	//! (description missing)
	//! [Default value] 0.05
	float get_layer_size() const { return getFloat("layer_size"); }

	//! (description missing)
	//! [Default value] 0.5
	bool set_randomness(float val) { return setValue("randomness", val); }
	//! (description missing)
	//! [Default value] 0.5
	float get_randomness() const { return getFloat("randomness"); }

	//! (description missing)
	//! [Default value] 20
	bool set_age(float val) { return setValue("age", val); }
	//! (description missing)
	//! [Default value] 20
	float get_age() const { return getFloat("age"); }

	//! (description missing)
	bool set_grain_color_tex(const Plugin& texture) { return setValue("grain_color_tex", texture); }
	//! (description missing)
	bool set_grain_color_tex(const AColor& texture) { return setValue("grain_color_tex", texture); }
	//! (description missing)
	Value get_grain_color_tex() const { return getValue("grain_color_tex"); }

	//! (description missing)
	//! [Default value] 0.5
	bool set_grain_contr(float val) { return setValue("grain_contr", val); }
	//! (description missing)
	//! [Default value] 0.5
	float get_grain_contr() const { return getFloat("grain_contr"); }

	//! (description missing)
	//! [Default value] 0.01
	bool set_grain_spacing(float val) { return setValue("grain_spacing", val); }
	//! (description missing)
	//! [Default value] 0.01
	float get_grain_spacing() const { return getFloat("grain_spacing"); }

	//! (description missing)
	//! [Default value] 0.5
	bool set_center_u(float val) { return setValue("center_u", val); }
	//! (description missing)
	//! [Default value] 0.5
	float get_center_u() const { return getFloat("center_u"); }

	//! (description missing)
	//! [Default value] -0.5
	bool set_center_v(float val) { return setValue("center_v", val); }
	//! (description missing)
	//! [Default value] -0.5
	float get_center_v() const { return getFloat("center_v"); }

	//! (description missing)
	//! [Default value] 0
	bool set_amplitude_x(float val) { return setValue("amplitude_x", val); }
	//! (description missing)
	//! [Default value] 0
	float get_amplitude_x() const { return getFloat("amplitude_x"); }

	//! (description missing)
	//! [Default value] 0
	bool set_amplitude_y(float val) { return setValue("amplitude_y", val); }
	//! (description missing)
	//! [Default value] 0
	float get_amplitude_y() const { return getFloat("amplitude_y"); }

	//! (description missing)
	//! [Default value] 0.35
	bool set_ratio(float val) { return setValue("ratio", val); }
	//! (description missing)
	//! [Default value] 0.35
	float get_ratio() const { return getFloat("ratio"); }

	//! (description missing)
	//! [Default value] 1
	bool set_ripples_x(float val) { return setValue("ripples_x", val); }
	//! (description missing)
	//! [Default value] 1
	float get_ripples_x() const { return getFloat("ripples_x"); }

	//! (description missing)
	//! [Default value] 1
	bool set_ripples_y(float val) { return setValue("ripples_y", val); }
	//! (description missing)
	//! [Default value] 1
	float get_ripples_y() const { return getFloat("ripples_y"); }

	//! (description missing)
	//! [Default value] 1
	bool set_ripples_z(float val) { return setValue("ripples_z", val); }
	//! (description missing)
	//! [Default value] 1
	float get_ripples_z() const { return getFloat("ripples_z"); }

	//! (description missing)
	//! [Default value] 0
	bool set_depth_min(float val) { return setValue("depth_min", val); }
	//! (description missing)
	//! [Default value] 0
	float get_depth_min() const { return getFloat("depth_min"); }

	//! (description missing)
	//! [Default value] 8
	bool set_depth_max(float val) { return setValue("depth_max", val); }
	//! (description missing)
	//! [Default value] 8
	float get_depth_max() const { return getFloat("depth_max"); }
};

class TexXSIBitmap : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexXSIBitmap"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! 0: not tiling; 1: tile in UV; 2: tile in U; 3: tile in V; 4: tile in UV, but not filter tiling;
 	//! [UI Guides] enum=0:No tiling;1:Tile in UV;2:Tile in U;3:Tile in V;4:Tile in UV, but no filter tiling
 	//! [Default value] 1
	bool set_tile(int val) { return setValue("tile", val); }
	//! 0: not tiling; 1: tile in UV; 2: tile in U; 3: tile in V; 4: tile in UV, but not filter tiling;
 	//! [UI Guides] enum=0:No tiling;1:Tile in UV;2:Tile in U;3:Tile in V;4:Tile in UV, but no filter tiling
 	//! [Default value] 1
	int get_tile() const { return getInt("tile"); }

	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	bool set_placement_type(int val) { return setValue("placement_type", val); }
	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	int get_placement_type() const { return getInt("placement_type"); }

	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_u(float val) { return setValue("u", val); }
	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_u() const { return getFloat("u"); }

	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_v(float val) { return setValue("v", val); }
	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_v() const { return getFloat("v"); }

	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_w(float val) { return setValue("w", val); }
	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_w() const { return getFloat("w"); }

	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_h(float val) { return setValue("h", val); }
	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_h() const { return getFloat("h"); }

	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	bool set_jitter(float val) { return setValue("jitter", val); }
	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	float get_jitter() const { return getFloat("jitter"); }

	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_u(bool val) { return setValue("tile_u", val); }
	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_u() const { return getBool("tile_u"); }

	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_v(bool val) { return setValue("tile_v", val); }
	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_v() const { return getBool("tile_v"); }

	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool set_uv_noise_on(bool val) { return setValue("uv_noise_on", val); }
	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool get_uv_noise_on() const { return getBool("uv_noise_on"); }

	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool set_uv_noise_animate(bool val) { return setValue("uv_noise_animate", val); }
	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool get_uv_noise_animate() const { return getBool("uv_noise_animate"); }

	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	bool set_uv_noise_amount(float val) { return setValue("uv_noise_amount", val); }
	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	float get_uv_noise_amount() const { return getFloat("uv_noise_amount"); }

	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	bool set_uv_noise_levels(float val) { return setValue("uv_noise_levels", val); }
	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	float get_uv_noise_levels() const { return getFloat("uv_noise_levels"); }

	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	bool set_uv_noise_size(float val) { return setValue("uv_noise_size", val); }
	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	float get_uv_noise_size() const { return getFloat("uv_noise_size"); }

	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	bool set_un_noise_phase(float val) { return setValue("un_noise_phase", val); }
	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	float get_un_noise_phase() const { return getFloat("un_noise_phase"); }

	//! (description missing)
	bool set_bitmap(const Plugin& plugin) { return setValue("bitmap", plugin); }
	//! (description missing)
	Plugin get_bitmap() const { return getPlugin("bitmap"); }

	//! Controls a 360 degrees hue shift through HLS color space spectrum without modifying the intensity or saturation of the color.
 	//! [Default value] 0
	bool set_hue(float val) { return setValue("hue", val); }
	//! Controls a 360 degrees hue shift through HLS color space spectrum without modifying the intensity or saturation of the color.
 	//! [Default value] 0
	float get_hue() const { return getFloat("hue"); }

	//! Adjusts the saturation or amount of "pigment" in a color.
 	//! [Default value] 100
	bool set_saturation(float val) { return setValue("saturation", val); }
	//! Adjusts the saturation or amount of "pigment" in a color.
 	//! [Default value] 100
	float get_saturation() const { return getFloat("saturation"); }

	//! Increases and decreases the contrast levels between light and dark colors. 0.5 = no change in contrast.
 	//! [Default value] 100
	bool set_gain(float val) { return setValue("gain", val); }
	//! Increases and decreases the contrast levels between light and dark colors. 0.5 = no change in contrast.
 	//! [Default value] 100
	float get_gain() const { return getFloat("gain"); }

	//! Controls the brightness of the image clip. A negative value darkens the image and a positive value brightens it.
 	//! [Default value] 0
	bool set_brightness(float val) { return setValue("brightness", val); }
	//! Controls the brightness of the image clip. A negative value darkens the image and a positive value brightens it.
 	//! [Default value] 0
	float get_brightness() const { return getFloat("brightness"); }

	//! If true, converts the image to a gray scale (black and white) image.
 	//! [Default value] false
	bool set_rgba_to_grayscl(bool val) { return setValue("rgba_to_grayscl", val); }
	//! If true, converts the image to a gray scale (black and white) image.
 	//! [Default value] false
	bool get_rgba_to_grayscl() const { return getBool("rgba_to_grayscl"); }

	//! Flip horizontal
 	//! [Default value] false
	bool set_flip_u(bool val) { return setValue("flip_u", val); }
	//! Flip horizontal
 	//! [Default value] false
	bool get_flip_u() const { return getBool("flip_u"); }

	//! Flip vertical
 	//! [Default value] false
	bool set_flip_v(bool val) { return setValue("flip_v", val); }
	//! Flip vertical
 	//! [Default value] false
	bool get_flip_v() const { return getBool("flip_v"); }

	//! Enable effects
 	//! [Default value] false
	bool set_enable_effects(bool val) { return setValue("enable_effects", val); }
	//! Enable effects
 	//! [Default value] false
	bool get_enable_effects() const { return getBool("enable_effects"); }

	//! HDR exposure
 	//! [Default value] 0
	bool set_exposure(float val) { return setValue("exposure", val); }
	//! HDR exposure
 	//! [Default value] 0
	float get_exposure() const { return getFloat("exposure"); }
};

class TexXSICell : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexXSICell"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	bool set_placement_type(int val) { return setValue("placement_type", val); }
	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	int get_placement_type() const { return getInt("placement_type"); }

	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_u(float val) { return setValue("u", val); }
	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_u() const { return getFloat("u"); }

	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_v(float val) { return setValue("v", val); }
	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_v() const { return getFloat("v"); }

	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_w(float val) { return setValue("w", val); }
	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_w() const { return getFloat("w"); }

	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_h(float val) { return setValue("h", val); }
	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_h() const { return getFloat("h"); }

	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	bool set_jitter(float val) { return setValue("jitter", val); }
	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	float get_jitter() const { return getFloat("jitter"); }

	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_u(bool val) { return setValue("tile_u", val); }
	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_u() const { return getBool("tile_u"); }

	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_v(bool val) { return setValue("tile_v", val); }
	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_v() const { return getBool("tile_v"); }

	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool set_uv_noise_on(bool val) { return setValue("uv_noise_on", val); }
	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool get_uv_noise_on() const { return getBool("uv_noise_on"); }

	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool set_uv_noise_animate(bool val) { return setValue("uv_noise_animate", val); }
	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool get_uv_noise_animate() const { return getBool("uv_noise_animate"); }

	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	bool set_uv_noise_amount(float val) { return setValue("uv_noise_amount", val); }
	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	float get_uv_noise_amount() const { return getFloat("uv_noise_amount"); }

	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	bool set_uv_noise_levels(float val) { return setValue("uv_noise_levels", val); }
	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	float get_uv_noise_levels() const { return getFloat("uv_noise_levels"); }

	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	bool set_uv_noise_size(float val) { return setValue("uv_noise_size", val); }
	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	float get_uv_noise_size() const { return getFloat("uv_noise_size"); }

	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	bool set_un_noise_phase(float val) { return setValue("un_noise_phase", val); }
	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	float get_un_noise_phase() const { return getFloat("un_noise_phase"); }

	//! (description missing)
	bool set_cells_color_tex(const Plugin& texture) { return setValue("cells_color_tex", texture); }
	//! (description missing)
	bool set_cells_color_tex(const AColor& texture) { return setValue("cells_color_tex", texture); }
	//! (description missing)
	Value get_cells_color_tex() const { return getValue("cells_color_tex"); }

	//! (description missing)
	bool set_background_color_tex(const Plugin& texture) { return setValue("background_color_tex", texture); }
	//! (description missing)
	bool set_background_color_tex(const AColor& texture) { return setValue("background_color_tex", texture); }
	//! (description missing)
	Value get_background_color_tex() const { return getValue("background_color_tex"); }

	//! UVW coordinates scale
 	//! [Default value] Color(1, 1, 1)
	bool set_scale(const Color& color) { return setValue("scale", color); }
	//! UVW coordinates scale
 	//! [Default value] Color(1, 1, 1)
	Color get_scale() const { return getColor("scale"); }
};

class TexXSIColorBalance : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexXSIColorBalance"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! Input texture
 	bool set_xsi_color(const Plugin& texture) { return setValue("xsi_color", texture); }
	//! Input texture
 	bool set_xsi_color(const AColor& texture) { return setValue("xsi_color", texture); }
	//! Input texture
 	Value get_xsi_color() const { return getValue("xsi_color"); }

	//! (description missing)
	//! [Default value] 0
	bool set_shadows_red(float val) { return setValue("shadows_red", val); }
	//! (description missing)
	//! [Default value] 0
	float get_shadows_red() const { return getFloat("shadows_red"); }

	//! (description missing)
	//! [Default value] 0
	bool set_shadows_green(float val) { return setValue("shadows_green", val); }
	//! (description missing)
	//! [Default value] 0
	float get_shadows_green() const { return getFloat("shadows_green"); }

	//! (description missing)
	//! [Default value] 0
	bool set_shadows_blue(float val) { return setValue("shadows_blue", val); }
	//! (description missing)
	//! [Default value] 0
	float get_shadows_blue() const { return getFloat("shadows_blue"); }

	//! (description missing)
	//! [Default value] 0
	bool set_midtones_red(float val) { return setValue("midtones_red", val); }
	//! (description missing)
	//! [Default value] 0
	float get_midtones_red() const { return getFloat("midtones_red"); }

	//! (description missing)
	//! [Default value] 0
	bool set_midtones_green(float val) { return setValue("midtones_green", val); }
	//! (description missing)
	//! [Default value] 0
	float get_midtones_green() const { return getFloat("midtones_green"); }

	//! (description missing)
	//! [Default value] 0
	bool set_midtones_blue(float val) { return setValue("midtones_blue", val); }
	//! (description missing)
	//! [Default value] 0
	float get_midtones_blue() const { return getFloat("midtones_blue"); }

	//! (description missing)
	//! [Default value] 0
	bool set_highlights_red(float val) { return setValue("highlights_red", val); }
	//! (description missing)
	//! [Default value] 0
	float get_highlights_red() const { return getFloat("highlights_red"); }

	//! (description missing)
	//! [Default value] 0
	bool set_highlights_green(float val) { return setValue("highlights_green", val); }
	//! (description missing)
	//! [Default value] 0
	float get_highlights_green() const { return getFloat("highlights_green"); }

	//! (description missing)
	//! [Default value] 0
	bool set_highlights_blue(float val) { return setValue("highlights_blue", val); }
	//! (description missing)
	//! [Default value] 0
	float get_highlights_blue() const { return getFloat("highlights_blue"); }

	//! (description missing)
	//! [Default value] 0
	bool set_preserve_value(int val) { return setValue("preserve_value", val); }
	//! (description missing)
	//! [Default value] 0
	int get_preserve_value() const { return getInt("preserve_value"); }
};

class TexXSIColorCorrection : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexXSIColorCorrection"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! Input texture
 	bool set_xsi_color(const Plugin& texture) { return setValue("xsi_color", texture); }
	//! Input texture
 	bool set_xsi_color(const AColor& texture) { return setValue("xsi_color", texture); }
	//! Input texture
 	Value get_xsi_color() const { return getValue("xsi_color"); }

	//! Used to compensate for non-linearity in displays. Often used as a general brightness control.
 	//! [Default value] 1
	bool set_gamma(float val) { return setValue("gamma", val); }
	//! Used to compensate for non-linearity in displays. Often used as a general brightness control.
 	//! [Default value] 1
	float get_gamma() const { return getFloat("gamma"); }

	//! Increases and decreases the contrast levels between light and dark colors. 0.5 = no change in contrast
 	//! [Default value] 0.5
	bool set_contrast(float val) { return setValue("contrast", val); }
	//! Increases and decreases the contrast levels between light and dark colors. 0.5 = no change in contrast
 	//! [Default value] 0.5
	float get_contrast() const { return getFloat("contrast"); }

	//! Controls a 360 degrees hue shift through the HLS color space spectrum without modifying the intensity or saturation of the color
 	//! [Default value] 0
	bool set_hue(float val) { return setValue("hue", val); }
	//! Controls a 360 degrees hue shift through the HLS color space spectrum without modifying the intensity or saturation of the color
 	//! [Default value] 0
	float get_hue() const { return getFloat("hue"); }

	//! Adjusts the saturation, or amount of <pigment> in a color. A value of 1 results in no white and all color; a value of 0 results in no color, just white light
 	//! [Default value] 0
	bool set_saturation(float val) { return setValue("saturation", val); }
	//! Adjusts the saturation, or amount of <pigment> in a color. A value of 1 results in no white and all color; a value of 0 results in no color, just white light
 	//! [Default value] 0
	float get_saturation() const { return getFloat("saturation"); }

	//! Adjusts the level or luminance of a color. Similar to intensity or brightness
 	//! [Default value] 0
	bool set_level(float val) { return setValue("level", val); }
	//! Adjusts the level or luminance of a color. Similar to intensity or brightness
 	//! [Default value] 0
	float get_level() const { return getFloat("level"); }
};

class TexXSIColorMix : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexXSIColorMix"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! Color or Texture
 	bool set_xsi_color(const Plugin& texture) { return setValue("xsi_color", texture); }
	//! Color or Texture
 	bool set_xsi_color(const AColor& texture) { return setValue("xsi_color", texture); }
	//! Color or Texture
 	Value get_xsi_color() const { return getValue("xsi_color"); }

	//! Scale color parameter
 	//! [Default value] 1
	bool set_xsi_scale(float val) { return setValue("xsi_scale", val); }
	//! Scale color parameter
 	//! [Default value] 1
	float get_xsi_scale() const { return getFloat("xsi_scale"); }

	//! Use alpha of the texture as return greyscale value
 	//! [Default value] false
	bool set_use_alpha(bool val) { return setValue("use_alpha", val); }
	//! Use alpha of the texture as return greyscale value
 	//! [Default value] false
	bool get_use_alpha() const { return getBool("use_alpha"); }

	//! Invert
 	//! [Default value] false
	bool set_xsi_invert(bool val) { return setValue("xsi_invert", val); }
	//! Invert
 	//! [Default value] false
	bool get_xsi_invert() const { return getBool("xsi_invert"); }

	//! Make result alpha 1
 	//! [Default value] false
	bool set_fix_alpha_to_1(bool val) { return setValue("fix_alpha_to_1", val); }
	//! Make result alpha 1
 	//! [Default value] false
	bool get_fix_alpha_to_1() const { return getBool("fix_alpha_to_1"); }
};

class TexXSIFabric : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexXSIFabric"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! (description missing)
	//! [Default value] false
	bool set_use_3d_mapping(bool val) { return setValue("use_3d_mapping", val); }
	//! (description missing)
	//! [Default value] false
	bool get_use_3d_mapping() const { return getBool("use_3d_mapping"); }

	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	bool set_placement_type(int val) { return setValue("placement_type", val); }
	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	int get_placement_type() const { return getInt("placement_type"); }

	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_u(float val) { return setValue("u", val); }
	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_u() const { return getFloat("u"); }

	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_v(float val) { return setValue("v", val); }
	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_v() const { return getFloat("v"); }

	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_w(float val) { return setValue("w", val); }
	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_w() const { return getFloat("w"); }

	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_h(float val) { return setValue("h", val); }
	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_h() const { return getFloat("h"); }

	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	bool set_jitter(float val) { return setValue("jitter", val); }
	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	float get_jitter() const { return getFloat("jitter"); }

	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_u(bool val) { return setValue("tile_u", val); }
	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_u() const { return getBool("tile_u"); }

	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_v(bool val) { return setValue("tile_v", val); }
	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_v() const { return getBool("tile_v"); }

	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool set_uv_noise_on(bool val) { return setValue("uv_noise_on", val); }
	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool get_uv_noise_on() const { return getBool("uv_noise_on"); }

	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool set_uv_noise_animate(bool val) { return setValue("uv_noise_animate", val); }
	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool get_uv_noise_animate() const { return getBool("uv_noise_animate"); }

	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	bool set_uv_noise_amount(float val) { return setValue("uv_noise_amount", val); }
	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	float get_uv_noise_amount() const { return getFloat("uv_noise_amount"); }

	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	bool set_uv_noise_levels(float val) { return setValue("uv_noise_levels", val); }
	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	float get_uv_noise_levels() const { return getFloat("uv_noise_levels"); }

	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	bool set_uv_noise_size(float val) { return setValue("uv_noise_size", val); }
	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	float get_uv_noise_size() const { return getFloat("uv_noise_size"); }

	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	bool set_un_noise_phase(float val) { return setValue("un_noise_phase", val); }
	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	float get_un_noise_phase() const { return getFloat("un_noise_phase"); }

	//! (description missing)
	bool set_uthread_color(const Plugin& texture) { return setValue("uthread_color", texture); }
	//! (description missing)
	bool set_uthread_color(const AColor& texture) { return setValue("uthread_color", texture); }
	//! (description missing)
	Value get_uthread_color() const { return getValue("uthread_color"); }

	//! (description missing)
	bool set_vthread_color(const Plugin& texture) { return setValue("vthread_color", texture); }
	//! (description missing)
	bool set_vthread_color(const AColor& texture) { return setValue("vthread_color", texture); }
	//! (description missing)
	Value get_vthread_color() const { return getValue("vthread_color"); }

	//! (description missing)
	bool set_gap_color(const Plugin& texture) { return setValue("gap_color", texture); }
	//! (description missing)
	bool set_gap_color(const AColor& texture) { return setValue("gap_color", texture); }
	//! (description missing)
	Value get_gap_color() const { return getValue("gap_color"); }

	//! (description missing)
	bool set_uthread_width(const Plugin& texturefloat) { return setValue("uthread_width", texturefloat); }
	//! (description missing)
	bool set_uthread_width(float texturefloat) { return setValue("uthread_width", texturefloat); }
	//! (description missing)
	Value get_uthread_width() const { return getValue("uthread_width"); }

	//! (description missing)
	bool set_vthread_width(const Plugin& texturefloat) { return setValue("vthread_width", texturefloat); }
	//! (description missing)
	bool set_vthread_width(float texturefloat) { return setValue("vthread_width", texturefloat); }
	//! (description missing)
	Value get_vthread_width() const { return getValue("vthread_width"); }

	//! (description missing)
	bool set_u_wave(const Plugin& texturefloat) { return setValue("u_wave", texturefloat); }
	//! (description missing)
	bool set_u_wave(float texturefloat) { return setValue("u_wave", texturefloat); }
	//! (description missing)
	Value get_u_wave() const { return getValue("u_wave"); }

	//! (description missing)
	bool set_v_wave(const Plugin& texturefloat) { return setValue("v_wave", texturefloat); }
	//! (description missing)
	bool set_v_wave(float texturefloat) { return setValue("v_wave", texturefloat); }
	//! (description missing)
	Value get_v_wave() const { return getValue("v_wave"); }

	//! (description missing)
	bool set_randomness(const Plugin& texturefloat) { return setValue("randomness", texturefloat); }
	//! (description missing)
	bool set_randomness(float texturefloat) { return setValue("randomness", texturefloat); }
	//! (description missing)
	Value get_randomness() const { return getValue("randomness"); }

	//! (description missing)
	bool set_width_variation(const Plugin& texturefloat) { return setValue("width_variation", texturefloat); }
	//! (description missing)
	bool set_width_variation(float texturefloat) { return setValue("width_variation", texturefloat); }
	//! (description missing)
	Value get_width_variation() const { return getValue("width_variation"); }

	//! (description missing)
	bool set_bright_variation(const Plugin& texturefloat) { return setValue("bright_variation", texturefloat); }
	//! (description missing)
	bool set_bright_variation(float texturefloat) { return setValue("bright_variation", texturefloat); }
	//! (description missing)
	Value get_bright_variation() const { return getValue("bright_variation"); }

	//! UVW coordinates scale
 	//! [Default value] Color(1, 1, 1)
	bool set_scale(const Color& color) { return setValue("scale", color); }
	//! UVW coordinates scale
 	//! [Default value] Color(1, 1, 1)
	Color get_scale() const { return getColor("scale"); }
};

class TexXSIFalloff : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexXSIFalloff"; }

	//! Curve falloff
 	//! [Default value] 1
	bool set_curve_falloff(float val) { return setValue("curve_falloff", val); }
	//! Curve falloff
 	//! [Default value] 1
	float get_curve_falloff() const { return getFloat("curve_falloff"); }

	//! Facing reflectivity
 	//! [Default value] 1
	bool set_facing_refl(float val) { return setValue("facing_refl", val); }
	//! Facing reflectivity
 	//! [Default value] 1
	float get_facing_refl() const { return getFloat("facing_refl"); }

	//! Perpendicular reflectivity
 	//! [Default value] 1
	bool set_perp_refl(float val) { return setValue("perp_refl", val); }
	//! Perpendicular reflectivity
 	//! [Default value] 1
	float get_perp_refl() const { return getFloat("perp_refl"); }

	//! Refraction (front) color
 	bool set_white_color(const Plugin& texture) { return setValue("white_color", texture); }
	//! Refraction (front) color
 	bool set_white_color(const AColor& texture) { return setValue("white_color", texture); }
	//! Refraction (front) color
 	Value get_white_color() const { return getValue("white_color"); }

	//! Reflection (side) color
 	bool set_black_color(const Plugin& texture) { return setValue("black_color", texture); }
	//! Reflection (side) color
 	bool set_black_color(const AColor& texture) { return setValue("black_color", texture); }
	//! Reflection (side) color
 	Value get_black_color() const { return getValue("black_color"); }
};

class TexXSIFlagstone : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexXSIFlagstone"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	bool set_placement_type(int val) { return setValue("placement_type", val); }
	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	int get_placement_type() const { return getInt("placement_type"); }

	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_u(float val) { return setValue("u", val); }
	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_u() const { return getFloat("u"); }

	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_v(float val) { return setValue("v", val); }
	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_v() const { return getFloat("v"); }

	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_w(float val) { return setValue("w", val); }
	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_w() const { return getFloat("w"); }

	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_h(float val) { return setValue("h", val); }
	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_h() const { return getFloat("h"); }

	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	bool set_jitter(float val) { return setValue("jitter", val); }
	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	float get_jitter() const { return getFloat("jitter"); }

	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_u(bool val) { return setValue("tile_u", val); }
	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_u() const { return getBool("tile_u"); }

	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_v(bool val) { return setValue("tile_v", val); }
	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_v() const { return getBool("tile_v"); }

	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool set_uv_noise_on(bool val) { return setValue("uv_noise_on", val); }
	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool get_uv_noise_on() const { return getBool("uv_noise_on"); }

	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool set_uv_noise_animate(bool val) { return setValue("uv_noise_animate", val); }
	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool get_uv_noise_animate() const { return getBool("uv_noise_animate"); }

	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	bool set_uv_noise_amount(float val) { return setValue("uv_noise_amount", val); }
	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	float get_uv_noise_amount() const { return getFloat("uv_noise_amount"); }

	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	bool set_uv_noise_levels(float val) { return setValue("uv_noise_levels", val); }
	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	float get_uv_noise_levels() const { return getFloat("uv_noise_levels"); }

	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	bool set_uv_noise_size(float val) { return setValue("uv_noise_size", val); }
	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	float get_uv_noise_size() const { return getFloat("uv_noise_size"); }

	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	bool set_un_noise_phase(float val) { return setValue("un_noise_phase", val); }
	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	float get_un_noise_phase() const { return getFloat("un_noise_phase"); }

	//! (description missing)
	bool set_color2(const Plugin& texture) { return setValue("color2", texture); }
	//! (description missing)
	bool set_color2(const AColor& texture) { return setValue("color2", texture); }
	//! (description missing)
	Value get_color2() const { return getValue("color2"); }

	//! (description missing)
	bool set_color1(const Plugin& texture) { return setValue("color1", texture); }
	//! (description missing)
	bool set_color1(const AColor& texture) { return setValue("color1", texture); }
	//! (description missing)
	Value get_color1() const { return getValue("color1"); }

	//! (description missing)
	bool set_mortar_width(const Plugin& texturefloat) { return setValue("mortar_width", texturefloat); }
	//! (description missing)
	bool set_mortar_width(float texturefloat) { return setValue("mortar_width", texturefloat); }
	//! (description missing)
	Value get_mortar_width() const { return getValue("mortar_width"); }

	//! UVW coordinates scale
 	//! [Default value] Color(1, 1, 1)
	bool set_scale(const Color& color) { return setValue("scale", color); }
	//! UVW coordinates scale
 	//! [Default value] Color(1, 1, 1)
	Color get_scale() const { return getColor("scale"); }
};

class TexXSIGradient : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexXSIGradient"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	bool set_placement_type(int val) { return setValue("placement_type", val); }
	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	int get_placement_type() const { return getInt("placement_type"); }

	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_u(float val) { return setValue("u", val); }
	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_u() const { return getFloat("u"); }

	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_v(float val) { return setValue("v", val); }
	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_v() const { return getFloat("v"); }

	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_w(float val) { return setValue("w", val); }
	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_w() const { return getFloat("w"); }

	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_h(float val) { return setValue("h", val); }
	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_h() const { return getFloat("h"); }

	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	bool set_jitter(float val) { return setValue("jitter", val); }
	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	float get_jitter() const { return getFloat("jitter"); }

	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_u(bool val) { return setValue("tile_u", val); }
	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_u() const { return getBool("tile_u"); }

	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_v(bool val) { return setValue("tile_v", val); }
	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_v() const { return getBool("tile_v"); }

	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool set_uv_noise_on(bool val) { return setValue("uv_noise_on", val); }
	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool get_uv_noise_on() const { return getBool("uv_noise_on"); }

	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool set_uv_noise_animate(bool val) { return setValue("uv_noise_animate", val); }
	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool get_uv_noise_animate() const { return getBool("uv_noise_animate"); }

	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	bool set_uv_noise_amount(float val) { return setValue("uv_noise_amount", val); }
	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	float get_uv_noise_amount() const { return getFloat("uv_noise_amount"); }

	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	bool set_uv_noise_levels(float val) { return setValue("uv_noise_levels", val); }
	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	float get_uv_noise_levels() const { return getFloat("uv_noise_levels"); }

	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	bool set_uv_noise_size(float val) { return setValue("uv_noise_size", val); }
	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	float get_uv_noise_size() const { return getFloat("uv_noise_size"); }

	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	bool set_un_noise_phase(float val) { return setValue("un_noise_phase", val); }
	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	float get_un_noise_phase() const { return getFloat("un_noise_phase"); }

	//! (description missing)
	bool set_color1(const Plugin& texture) { return setValue("color1", texture); }
	//! (description missing)
	bool set_color1(const AColor& texture) { return setValue("color1", texture); }
	//! (description missing)
	Value get_color1() const { return getValue("color1"); }

	//! (description missing)
	bool set_color2(const Plugin& texture) { return setValue("color2", texture); }
	//! (description missing)
	bool set_color2(const AColor& texture) { return setValue("color2", texture); }
	//! (description missing)
	Value get_color2() const { return getValue("color2"); }

	//! (description missing)
	bool set_color3(const Plugin& texture) { return setValue("color3", texture); }
	//! (description missing)
	bool set_color3(const AColor& texture) { return setValue("color3", texture); }
	//! (description missing)
	Value get_color3() const { return getValue("color3"); }

	//! (description missing)
	bool set_color4(const Plugin& texture) { return setValue("color4", texture); }
	//! (description missing)
	bool set_color4(const AColor& texture) { return setValue("color4", texture); }
	//! (description missing)
	Value get_color4() const { return getValue("color4"); }

	//! (description missing)
	bool set_color5(const Plugin& texture) { return setValue("color5", texture); }
	//! (description missing)
	bool set_color5(const AColor& texture) { return setValue("color5", texture); }
	//! (description missing)
	Value get_color5() const { return getValue("color5"); }

	//! (description missing)
	bool set_color6(const Plugin& texture) { return setValue("color6", texture); }
	//! (description missing)
	bool set_color6(const AColor& texture) { return setValue("color6", texture); }
	//! (description missing)
	Value get_color6() const { return getValue("color6"); }

	//! (description missing)
	bool set_color7(const Plugin& texture) { return setValue("color7", texture); }
	//! (description missing)
	bool set_color7(const AColor& texture) { return setValue("color7", texture); }
	//! (description missing)
	Value get_color7() const { return getValue("color7"); }

	//! (description missing)
	bool set_color8(const Plugin& texture) { return setValue("color8", texture); }
	//! (description missing)
	bool set_color8(const AColor& texture) { return setValue("color8", texture); }
	//! (description missing)
	Value get_color8() const { return getValue("color8"); }

	//! (description missing)
	//! [Default value] 0
	bool set_pos_color1(float val) { return setValue("pos_color1", val); }
	//! (description missing)
	//! [Default value] 0
	float get_pos_color1() const { return getFloat("pos_color1"); }

	//! (description missing)
	//! [Default value] 1
	bool set_pos_color2(float val) { return setValue("pos_color2", val); }
	//! (description missing)
	//! [Default value] 1
	float get_pos_color2() const { return getFloat("pos_color2"); }

	//! (description missing)
	//! [Default value] -1
	bool set_pos_color3(float val) { return setValue("pos_color3", val); }
	//! (description missing)
	//! [Default value] -1
	float get_pos_color3() const { return getFloat("pos_color3"); }

	//! (description missing)
	//! [Default value] -1
	bool set_pos_color4(float val) { return setValue("pos_color4", val); }
	//! (description missing)
	//! [Default value] -1
	float get_pos_color4() const { return getFloat("pos_color4"); }

	//! (description missing)
	//! [Default value] -1
	bool set_pos_color5(float val) { return setValue("pos_color5", val); }
	//! (description missing)
	//! [Default value] -1
	float get_pos_color5() const { return getFloat("pos_color5"); }

	//! (description missing)
	//! [Default value] -1
	bool set_pos_color6(float val) { return setValue("pos_color6", val); }
	//! (description missing)
	//! [Default value] -1
	float get_pos_color6() const { return getFloat("pos_color6"); }

	//! (description missing)
	//! [Default value] -1
	bool set_pos_color7(float val) { return setValue("pos_color7", val); }
	//! (description missing)
	//! [Default value] -1
	float get_pos_color7() const { return getFloat("pos_color7"); }

	//! (description missing)
	//! [Default value] -1
	bool set_pos_color8(float val) { return setValue("pos_color8", val); }
	//! (description missing)
	//! [Default value] -1
	float get_pos_color8() const { return getFloat("pos_color8"); }

	//! Gradient type: 0 (Vertical), 1(Horizontal), 2(Radial Wave), 3(RadialRainbow), 4(DiagonalDown), 5(DiagonalUp)
 	//! [UI Guides] enum=0:Vertical; 1:Horizontal; 2:Radial Wave; 3:RadialRainbow; 4:DiagonalDown; 5:DiagonalUp
 	//! [Default value] 0
	bool set_gradient_type(int val) { return setValue("gradient_type", val); }
	//! Gradient type: 0 (Vertical), 1(Horizontal), 2(Radial Wave), 3(RadialRainbow), 4(DiagonalDown), 5(DiagonalUp)
 	//! [UI Guides] enum=0:Vertical; 1:Horizontal; 2:Radial Wave; 3:RadialRainbow; 4:DiagonalDown; 5:DiagonalUp
 	//! [Default value] 0
	int get_gradient_type() const { return getInt("gradient_type"); }

	//! Inverts gradient directions if true
 	//! [Default value] false
	bool set_invert_direction(bool val) { return setValue("invert_direction", val); }
	//! Inverts gradient directions if true
 	//! [Default value] false
	bool get_invert_direction() const { return getBool("invert_direction"); }

	//! If true, the gradient ends at the edge of the outermost color. Otherwise the outermost color bleeds over the untextured portion of the object
 	//! [Default value] false
	bool set_clip(bool val) { return setValue("clip", val); }
	//! If true, the gradient ends at the edge of the outermost color. Otherwise the outermost color bleeds over the untextured portion of the object
 	//! [Default value] false
	bool get_clip() const { return getBool("clip"); }

	//! If true, copies the gradient's alpha channel into the RGB channels, creating a grayscale image.
 	//! [Default value] false
	bool set_alpha_output(bool val) { return setValue("alpha_output", val); }
	//! If true, copies the gradient's alpha channel into the RGB channels, creating a grayscale image.
 	//! [Default value] false
	bool get_alpha_output() const { return getBool("alpha_output"); }

	//! Determines the factor by which the Alpha is multiplied when it is copied into the RGB channels
 	bool set_alpha_factor(const Plugin& texturefloat) { return setValue("alpha_factor", texturefloat); }
	//! Determines the factor by which the Alpha is multiplied when it is copied into the RGB channels
 	bool set_alpha_factor(float texturefloat) { return setValue("alpha_factor", texturefloat); }
	//! Determines the factor by which the Alpha is multiplied when it is copied into the RGB channels
 	Value get_alpha_factor() const { return getValue("alpha_factor"); }

	//! Especially for XSI Gradient Mixer, when input type is scalar
 	//! [Default value] -1
	bool set_input(float val) { return setValue("input", val); }
	//! Especially for XSI Gradient Mixer, when input type is scalar
 	//! [Default value] -1
	float get_input() const { return getFloat("input"); }
};

class TexXSIHLSAdjust : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexXSIHLSAdjust"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! Input texture
 	bool set_xsi_color(const Plugin& texture) { return setValue("xsi_color", texture); }
	//! Input texture
 	bool set_xsi_color(const AColor& texture) { return setValue("xsi_color", texture); }
	//! Input texture
 	Value get_xsi_color() const { return getValue("xsi_color"); }

	//! master hue
 	//! [Default value] 0
	bool set_master_h(float val) { return setValue("master_h", val); }
	//! master hue
 	//! [Default value] 0
	float get_master_h() const { return getFloat("master_h"); }

	//! master lightness
 	//! [Default value] 0
	bool set_master_l(float val) { return setValue("master_l", val); }
	//! master lightness
 	//! [Default value] 0
	float get_master_l() const { return getFloat("master_l"); }

	//! master saturation
 	//! [Default value] 0
	bool set_master_s(float val) { return setValue("master_s", val); }
	//! master saturation
 	//! [Default value] 0
	float get_master_s() const { return getFloat("master_s"); }

	//! red hue
 	//! [Default value] 0
	bool set_red_h(float val) { return setValue("red_h", val); }
	//! red hue
 	//! [Default value] 0
	float get_red_h() const { return getFloat("red_h"); }

	//! red lightness
 	//! [Default value] 0
	bool set_red_l(float val) { return setValue("red_l", val); }
	//! red lightness
 	//! [Default value] 0
	float get_red_l() const { return getFloat("red_l"); }

	//! red saturation
 	//! [Default value] 0
	bool set_red_s(float val) { return setValue("red_s", val); }
	//! red saturation
 	//! [Default value] 0
	float get_red_s() const { return getFloat("red_s"); }

	//! green hue
 	//! [Default value] 0
	bool set_green_h(float val) { return setValue("green_h", val); }
	//! green hue
 	//! [Default value] 0
	float get_green_h() const { return getFloat("green_h"); }

	//! green lightness
 	//! [Default value] 0
	bool set_green_l(float val) { return setValue("green_l", val); }
	//! green lightness
 	//! [Default value] 0
	float get_green_l() const { return getFloat("green_l"); }

	//! green saturation
 	//! [Default value] 0
	bool set_green_s(float val) { return setValue("green_s", val); }
	//! green saturation
 	//! [Default value] 0
	float get_green_s() const { return getFloat("green_s"); }

	//! blue hue
 	//! [Default value] 0
	bool set_blue_h(float val) { return setValue("blue_h", val); }
	//! blue hue
 	//! [Default value] 0
	float get_blue_h() const { return getFloat("blue_h"); }

	//! blue lightness
 	//! [Default value] 0
	bool set_blue_l(float val) { return setValue("blue_l", val); }
	//! blue lightness
 	//! [Default value] 0
	float get_blue_l() const { return getFloat("blue_l"); }

	//! blue saturation
 	//! [Default value] 0
	bool set_blue_s(float val) { return setValue("blue_s", val); }
	//! blue saturation
 	//! [Default value] 0
	float get_blue_s() const { return getFloat("blue_s"); }

	//! cyan hue
 	//! [Default value] 0
	bool set_cyan_h(float val) { return setValue("cyan_h", val); }
	//! cyan hue
 	//! [Default value] 0
	float get_cyan_h() const { return getFloat("cyan_h"); }

	//! cyan lightness
 	//! [Default value] 0
	bool set_cyan_l(float val) { return setValue("cyan_l", val); }
	//! cyan lightness
 	//! [Default value] 0
	float get_cyan_l() const { return getFloat("cyan_l"); }

	//! cyan saturation
 	//! [Default value] 0
	bool set_cyan_s(float val) { return setValue("cyan_s", val); }
	//! cyan saturation
 	//! [Default value] 0
	float get_cyan_s() const { return getFloat("cyan_s"); }

	//! yellow hue
 	//! [Default value] 0
	bool set_yellow_h(float val) { return setValue("yellow_h", val); }
	//! yellow hue
 	//! [Default value] 0
	float get_yellow_h() const { return getFloat("yellow_h"); }

	//! yellow lightness
 	//! [Default value] 0
	bool set_yellow_l(float val) { return setValue("yellow_l", val); }
	//! yellow lightness
 	//! [Default value] 0
	float get_yellow_l() const { return getFloat("yellow_l"); }

	//! yellow saturation
 	//! [Default value] 0
	bool set_yellow_s(float val) { return setValue("yellow_s", val); }
	//! yellow saturation
 	//! [Default value] 0
	float get_yellow_s() const { return getFloat("yellow_s"); }

	//! yellow hue
 	//! [Default value] 0
	bool set_magenta_h(float val) { return setValue("magenta_h", val); }
	//! yellow hue
 	//! [Default value] 0
	float get_magenta_h() const { return getFloat("magenta_h"); }

	//! yellow lightness
 	//! [Default value] 0
	bool set_magenta_l(float val) { return setValue("magenta_l", val); }
	//! yellow lightness
 	//! [Default value] 0
	float get_magenta_l() const { return getFloat("magenta_l"); }

	//! yellow saturation
 	//! [Default value] 0
	bool set_magenta_s(float val) { return setValue("magenta_s", val); }
	//! yellow saturation
 	//! [Default value] 0
	float get_magenta_s() const { return getFloat("magenta_s"); }
};

class TexXSIIntensity : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexXSIIntensity"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! Color or Texture
 	bool set_xsi_color(const Plugin& texture) { return setValue("xsi_color", texture); }
	//! Color or Texture
 	bool set_xsi_color(const AColor& texture) { return setValue("xsi_color", texture); }
	//! Color or Texture
 	Value get_xsi_color() const { return getValue("xsi_color"); }

	//! multiply factor
 	//! [Default value] 1
	bool set_factor(float val) { return setValue("factor", val); }
	//! multiply factor
 	//! [Default value] 1
	float get_factor() const { return getFloat("factor"); }
};

class TexXSILayered : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexXSILayered"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! (description missing)
	bool set_textures(const ValueList& pluginList) { return setValue("textures", pluginList); }
	//! (description missing)
	ValueList get_textures() const { return getValueList("textures"); }

	//! (description missing)
	bool set_mask_textures(const ValueList& pluginList) { return setValue("mask_textures", pluginList); }
	//! (description missing)
	ValueList get_mask_textures() const { return getValueList("mask_textures"); }

	//! Combination of following 0:NoMask, 1:InvertMask, 2:MaskConnectionPoint,										  4:InputAlphaMask, 8:IntensityMask, 16:ThresholdMask
 	//! [UI Guides] enum=0:NoMask; 1:InvertMask; 2:MaskConnectionPoint;4:InputAlphaMask; 8:IntensityMask; 16:ThresholdMask
 	//! [Default value] 1
	bool set_mask_modes(const IntList& intList) { return setValue("mask_modes", intList); }
	//! Combination of following 0:NoMask, 1:InvertMask, 2:MaskConnectionPoint,										  4:InputAlphaMask, 8:IntensityMask, 16:ThresholdMask
 	//! [UI Guides] enum=0:NoMask; 1:InvertMask; 2:MaskConnectionPoint;4:InputAlphaMask; 8:IntensityMask; 16:ThresholdMask
 	//! [Default value] 1
	bool set_mask_modes(const int* ints, size_t count) { return setArray("mask_modes", ints, count); }
	//! Combination of following 0:NoMask, 1:InvertMask, 2:MaskConnectionPoint,										  4:InputAlphaMask, 8:IntensityMask, 16:ThresholdMask
 	//! [UI Guides] enum=0:NoMask; 1:InvertMask; 2:MaskConnectionPoint;4:InputAlphaMask; 8:IntensityMask; 16:ThresholdMask
 	//! [Default value] 1
	template<size_t count> bool set_mask_modes(const int (&ints)[count]) { return setArray("mask_modes", ints, count); }
	//! Combination of following 0:NoMask, 1:InvertMask, 2:MaskConnectionPoint,										  4:InputAlphaMask, 8:IntensityMask, 16:ThresholdMask
 	//! [UI Guides] enum=0:NoMask; 1:InvertMask; 2:MaskConnectionPoint;4:InputAlphaMask; 8:IntensityMask; 16:ThresholdMask
 	//! [Default value] 1
	IntList get_mask_modes() const { return getIntList("mask_modes"); }

	//! 0:Over, 1:In, 2:Out, 3:Plus, 4:BoundedPlus, 5:Hide-Reveal(Multiply),										  6:Hide-Reveal Bonded, 7:Difference, 8:Darken, 9:Lighten, 10:Hard Light,										  11:Soft Light, 12:Screen, 13:Overlay, 14:Blend
 	//! [UI Guides] enum=0:Over; 1:In; 2:Out; 3:Plus; 4:BoundedPlus; 5:Hide-RevealMultiply;6:Hide-Reveal Bonded; 7:Difference; 8:Darken; 9:Lighten; 10:Hard Light; 11:Soft Light; 12:Screen; 13:Overlay; 14:Blend
 	//! [Default value] 1
	bool set_blend_modes(const IntList& intList) { return setValue("blend_modes", intList); }
	//! 0:Over, 1:In, 2:Out, 3:Plus, 4:BoundedPlus, 5:Hide-Reveal(Multiply),										  6:Hide-Reveal Bonded, 7:Difference, 8:Darken, 9:Lighten, 10:Hard Light,										  11:Soft Light, 12:Screen, 13:Overlay, 14:Blend
 	//! [UI Guides] enum=0:Over; 1:In; 2:Out; 3:Plus; 4:BoundedPlus; 5:Hide-RevealMultiply;6:Hide-Reveal Bonded; 7:Difference; 8:Darken; 9:Lighten; 10:Hard Light; 11:Soft Light; 12:Screen; 13:Overlay; 14:Blend
 	//! [Default value] 1
	bool set_blend_modes(const int* ints, size_t count) { return setArray("blend_modes", ints, count); }
	//! 0:Over, 1:In, 2:Out, 3:Plus, 4:BoundedPlus, 5:Hide-Reveal(Multiply),										  6:Hide-Reveal Bonded, 7:Difference, 8:Darken, 9:Lighten, 10:Hard Light,										  11:Soft Light, 12:Screen, 13:Overlay, 14:Blend
 	//! [UI Guides] enum=0:Over; 1:In; 2:Out; 3:Plus; 4:BoundedPlus; 5:Hide-RevealMultiply;6:Hide-Reveal Bonded; 7:Difference; 8:Darken; 9:Lighten; 10:Hard Light; 11:Soft Light; 12:Screen; 13:Overlay; 14:Blend
 	//! [Default value] 1
	template<size_t count> bool set_blend_modes(const int (&ints)[count]) { return setArray("blend_modes", ints, count); }
	//! 0:Over, 1:In, 2:Out, 3:Plus, 4:BoundedPlus, 5:Hide-Reveal(Multiply),										  6:Hide-Reveal Bonded, 7:Difference, 8:Darken, 9:Lighten, 10:Hard Light,										  11:Soft Light, 12:Screen, 13:Overlay, 14:Blend
 	//! [UI Guides] enum=0:Over; 1:In; 2:Out; 3:Plus; 4:BoundedPlus; 5:Hide-RevealMultiply;6:Hide-Reveal Bonded; 7:Difference; 8:Darken; 9:Lighten; 10:Hard Light; 11:Soft Light; 12:Screen; 13:Overlay; 14:Blend
 	//! [Default value] 1
	IntList get_blend_modes() const { return getIntList("blend_modes"); }

	//! (description missing)
	bool set_alpha(const Plugin& texturefloat) { return setValue("alpha", texturefloat); }
	//! (description missing)
	bool set_alpha(float texturefloat) { return setValue("alpha", texturefloat); }
	//! (description missing)
	Value get_alpha() const { return getValue("alpha"); }

	//! Weight list
 	//! [Default value] 1
	bool set_weights(const FloatList& floatList) { return setValue("weights", floatList); }
	//! Weight list
 	//! [Default value] 1
	bool set_weights(const float* floats, size_t count) { return setArray("weights", floats, count); }
	//! Weight list
 	//! [Default value] 1
	template<size_t count> bool set_weights(const float (&floats)[count]) { return setArray("weights", floats, count); }
	//! Weight list
 	//! [Default value] 1
	FloatList get_weights() const { return getFloatList("weights"); }

	//! Layer threshold list
 	//! [Default value] 1
	bool set_maskthresholds(const FloatList& floatList) { return setValue("maskthresholds", floatList); }
	//! Layer threshold list
 	//! [Default value] 1
	bool set_maskthresholds(const float* floats, size_t count) { return setArray("maskthresholds", floats, count); }
	//! Layer threshold list
 	//! [Default value] 1
	template<size_t count> bool set_maskthresholds(const float (&floats)[count]) { return setArray("maskthresholds", floats, count); }
	//! Layer threshold list
 	//! [Default value] 1
	FloatList get_maskthresholds() const { return getFloatList("maskthresholds"); }
};

class TexXSIMulti : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexXSIMulti"; }

	//! A list of float textures
 	bool set_textures(const ValueList& pluginList) { return setValue("textures", pluginList); }
	//! A list of float textures
 	ValueList get_textures() const { return getValueList("textures"); }

	//! A list of material IDs
 	//! [Default value] 1
	bool set_ids_list(const IntList& intList) { return setValue("ids_list", intList); }
	//! A list of material IDs
 	//! [Default value] 1
	bool set_ids_list(const int* ints, size_t count) { return setArray("ids_list", ints, count); }
	//! A list of material IDs
 	//! [Default value] 1
	template<size_t count> bool set_ids_list(const int (&ints)[count]) { return setArray("ids_list", ints, count); }
	//! A list of material IDs
 	//! [Default value] 1
	IntList get_ids_list() const { return getIntList("ids_list"); }
};

class TexXSINormalMap : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexXSINormalMap"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	bool set_placement_type(int val) { return setValue("placement_type", val); }
	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	int get_placement_type() const { return getInt("placement_type"); }

	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_u(float val) { return setValue("u", val); }
	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_u() const { return getFloat("u"); }

	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_v(float val) { return setValue("v", val); }
	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_v() const { return getFloat("v"); }

	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_w(float val) { return setValue("w", val); }
	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_w() const { return getFloat("w"); }

	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_h(float val) { return setValue("h", val); }
	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_h() const { return getFloat("h"); }

	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	bool set_jitter(float val) { return setValue("jitter", val); }
	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	float get_jitter() const { return getFloat("jitter"); }

	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_u(bool val) { return setValue("tile_u", val); }
	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_u() const { return getBool("tile_u"); }

	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_v(bool val) { return setValue("tile_v", val); }
	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_v() const { return getBool("tile_v"); }

	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool set_uv_noise_on(bool val) { return setValue("uv_noise_on", val); }
	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool get_uv_noise_on() const { return getBool("uv_noise_on"); }

	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool set_uv_noise_animate(bool val) { return setValue("uv_noise_animate", val); }
	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool get_uv_noise_animate() const { return getBool("uv_noise_animate"); }

	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	bool set_uv_noise_amount(float val) { return setValue("uv_noise_amount", val); }
	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	float get_uv_noise_amount() const { return getFloat("uv_noise_amount"); }

	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	bool set_uv_noise_levels(float val) { return setValue("uv_noise_levels", val); }
	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	float get_uv_noise_levels() const { return getFloat("uv_noise_levels"); }

	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	bool set_uv_noise_size(float val) { return setValue("uv_noise_size", val); }
	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	float get_uv_noise_size() const { return getFloat("uv_noise_size"); }

	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	bool set_un_noise_phase(float val) { return setValue("un_noise_phase", val); }
	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	float get_un_noise_phase() const { return getFloat("un_noise_phase"); }

	//! Color or Texture
 	bool set_xsi_color(const Plugin& texture) { return setValue("xsi_color", texture); }
	//! Color or Texture
 	bool set_xsi_color(const AColor& texture) { return setValue("xsi_color", texture); }
	//! Color or Texture
 	Value get_xsi_color() const { return getValue("xsi_color"); }

	//! Vertex color map
 	bool set_tangents(const Plugin& texture) { return setValue("tangents", texture); }
	//! Vertex color map
 	bool set_tangents(const AColor& texture) { return setValue("tangents", texture); }
	//! Vertex color map
 	Value get_tangents() const { return getValue("tangents"); }

	//! Direction texture of type (r, 0, 0)
 	bool set_dir_tex(const Plugin& texture) { return setValue("dir_tex", texture); }
	//! Direction texture of type (r, 0, 0)
 	bool set_dir_tex(const AColor& texture) { return setValue("dir_tex", texture); }
	//! Direction texture of type (r, 0, 0)
 	Value get_dir_tex() const { return getValue("dir_tex"); }

	//! Unbiased Tangents
 	//! [Default value] 0
	bool set_TangentsAreUnbiased(int val) { return setValue("TangentsAreUnbiased", val); }
	//! Unbiased Tangents
 	//! [Default value] 0
	int get_TangentsAreUnbiased() const { return getInt("TangentsAreUnbiased"); }
};

class TexXSIRGBAKeyer : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexXSIRGBAKeyer"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! Input texture
 	bool set_xsi_color(const Plugin& texture) { return setValue("xsi_color", texture); }
	//! Input texture
 	bool set_xsi_color(const AColor& texture) { return setValue("xsi_color", texture); }
	//! Input texture
 	Value get_xsi_color() const { return getValue("xsi_color"); }

	//! Minimum threshold
 	bool set_min_thresh(const Plugin& texture) { return setValue("min_thresh", texture); }
	//! Minimum threshold
 	bool set_min_thresh(const AColor& texture) { return setValue("min_thresh", texture); }
	//! Minimum threshold
 	Value get_min_thresh() const { return getValue("min_thresh"); }

	//! Maximum threshold
 	bool set_max_thresh(const Plugin& texture) { return setValue("max_thresh", texture); }
	//! Maximum threshold
 	bool set_max_thresh(const AColor& texture) { return setValue("max_thresh", texture); }
	//! Maximum threshold
 	Value get_max_thresh() const { return getValue("max_thresh"); }

	//! Color if in range
 	bool set_inrange(const Plugin& texture) { return setValue("inrange", texture); }
	//! Color if in range
 	bool set_inrange(const AColor& texture) { return setValue("inrange", texture); }
	//! Color if in range
 	Value get_inrange() const { return getValue("inrange"); }

	//! Color if outside range
 	bool set_outrange(const Plugin& texture) { return setValue("outrange", texture); }
	//! Color if outside range
 	bool set_outrange(const AColor& texture) { return setValue("outrange", texture); }
	//! Color if outside range
 	Value get_outrange() const { return getValue("outrange"); }

	//! Include alpha
 	//! [Default value] 0
	bool set_alpha(int val) { return setValue("alpha", val); }
	//! Include alpha
 	//! [Default value] 0
	int get_alpha() const { return getInt("alpha"); }
};

class TexXSIRipple : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexXSIRipple"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! (description missing)
	//! [Default value] false
	bool set_use_3d_mapping(bool val) { return setValue("use_3d_mapping", val); }
	//! (description missing)
	//! [Default value] false
	bool get_use_3d_mapping() const { return getBool("use_3d_mapping"); }

	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	bool set_placement_type(int val) { return setValue("placement_type", val); }
	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	int get_placement_type() const { return getInt("placement_type"); }

	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_u(float val) { return setValue("u", val); }
	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_u() const { return getFloat("u"); }

	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_v(float val) { return setValue("v", val); }
	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_v() const { return getFloat("v"); }

	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_w(float val) { return setValue("w", val); }
	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_w() const { return getFloat("w"); }

	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_h(float val) { return setValue("h", val); }
	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_h() const { return getFloat("h"); }

	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	bool set_jitter(float val) { return setValue("jitter", val); }
	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	float get_jitter() const { return getFloat("jitter"); }

	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_u(bool val) { return setValue("tile_u", val); }
	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_u() const { return getBool("tile_u"); }

	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_v(bool val) { return setValue("tile_v", val); }
	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_v() const { return getBool("tile_v"); }

	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool set_uv_noise_on(bool val) { return setValue("uv_noise_on", val); }
	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool get_uv_noise_on() const { return getBool("uv_noise_on"); }

	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool set_uv_noise_animate(bool val) { return setValue("uv_noise_animate", val); }
	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool get_uv_noise_animate() const { return getBool("uv_noise_animate"); }

	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	bool set_uv_noise_amount(float val) { return setValue("uv_noise_amount", val); }
	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	float get_uv_noise_amount() const { return getFloat("uv_noise_amount"); }

	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	bool set_uv_noise_levels(float val) { return setValue("uv_noise_levels", val); }
	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	float get_uv_noise_levels() const { return getFloat("uv_noise_levels"); }

	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	bool set_uv_noise_size(float val) { return setValue("uv_noise_size", val); }
	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	float get_uv_noise_size() const { return getFloat("uv_noise_size"); }

	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	bool set_un_noise_phase(float val) { return setValue("un_noise_phase", val); }
	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	float get_un_noise_phase() const { return getFloat("un_noise_phase"); }

	//! (description missing)
	bool set_color1(const Plugin& texture) { return setValue("color1", texture); }
	//! (description missing)
	bool set_color1(const AColor& texture) { return setValue("color1", texture); }
	//! (description missing)
	Value get_color1() const { return getValue("color1"); }

	//! (description missing)
	bool set_color2(const Plugin& texture) { return setValue("color2", texture); }
	//! (description missing)
	bool set_color2(const AColor& texture) { return setValue("color2", texture); }
	//! (description missing)
	Value get_color2() const { return getValue("color2"); }

	//! (description missing)
	bool set_Amplitude(const Plugin& texturefloat) { return setValue("Amplitude", texturefloat); }
	//! (description missing)
	bool set_Amplitude(float texturefloat) { return setValue("Amplitude", texturefloat); }
	//! (description missing)
	Value get_Amplitude() const { return getValue("Amplitude"); }

	//! (description missing)
	//! [Default value] Vector(-1, -1, 0)
	bool set_Origin(const Vector& vector) { return setValue("Origin", vector); }
	//! (description missing)
	//! [Default value] Vector(-1, -1, 0)
	Vector get_Origin() const { return getVector("Origin"); }

	//! (description missing)
	bool set_Time(const Plugin& texturefloat) { return setValue("Time", texturefloat); }
	//! (description missing)
	bool set_Time(float texturefloat) { return setValue("Time", texturefloat); }
	//! (description missing)
	Value get_Time() const { return getValue("Time"); }

	//! (description missing)
	bool set_Frequency(const Plugin& texturefloat) { return setValue("Frequency", texturefloat); }
	//! (description missing)
	bool set_Frequency(float texturefloat) { return setValue("Frequency", texturefloat); }
	//! (description missing)
	Value get_Frequency() const { return getValue("Frequency"); }

	//! (description missing)
	bool set_Decay(const Plugin& texturefloat) { return setValue("Decay", texturefloat); }
	//! (description missing)
	bool set_Decay(float texturefloat) { return setValue("Decay", texturefloat); }
	//! (description missing)
	Value get_Decay() const { return getValue("Decay"); }

	//! (description missing)
	bool set_Group_Velocity(const Plugin& texturefloat) { return setValue("Group_Velocity", texturefloat); }
	//! (description missing)
	bool set_Group_Velocity(float texturefloat) { return setValue("Group_Velocity", texturefloat); }
	//! (description missing)
	Value get_Group_Velocity() const { return getValue("Group_Velocity"); }

	//! (description missing)
	bool set_Phase_Velocity(const Plugin& texturefloat) { return setValue("Phase_Velocity", texturefloat); }
	//! (description missing)
	bool set_Phase_Velocity(float texturefloat) { return setValue("Phase_Velocity", texturefloat); }
	//! (description missing)
	Value get_Phase_Velocity() const { return getValue("Phase_Velocity"); }

	//! (description missing)
	bool set_Spread_Start(const Plugin& texturefloat) { return setValue("Spread_Start", texturefloat); }
	//! (description missing)
	bool set_Spread_Start(float texturefloat) { return setValue("Spread_Start", texturefloat); }
	//! (description missing)
	Value get_Spread_Start() const { return getValue("Spread_Start"); }

	//! (description missing)
	bool set_Spread_Rate(const Plugin& texturefloat) { return setValue("Spread_Rate", texturefloat); }
	//! (description missing)
	bool set_Spread_Rate(float texturefloat) { return setValue("Spread_Rate", texturefloat); }
	//! (description missing)
	Value get_Spread_Rate() const { return getValue("Spread_Rate"); }
};

class TexXSIRock : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexXSIRock"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! (description missing)
	//! [Default value] false
	bool set_use_3d_mapping(bool val) { return setValue("use_3d_mapping", val); }
	//! (description missing)
	//! [Default value] false
	bool get_use_3d_mapping() const { return getBool("use_3d_mapping"); }

	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	bool set_placement_type(int val) { return setValue("placement_type", val); }
	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	int get_placement_type() const { return getInt("placement_type"); }

	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_u(float val) { return setValue("u", val); }
	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_u() const { return getFloat("u"); }

	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_v(float val) { return setValue("v", val); }
	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_v() const { return getFloat("v"); }

	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_w(float val) { return setValue("w", val); }
	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_w() const { return getFloat("w"); }

	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_h(float val) { return setValue("h", val); }
	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_h() const { return getFloat("h"); }

	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	bool set_jitter(float val) { return setValue("jitter", val); }
	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	float get_jitter() const { return getFloat("jitter"); }

	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_u(bool val) { return setValue("tile_u", val); }
	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_u() const { return getBool("tile_u"); }

	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_v(bool val) { return setValue("tile_v", val); }
	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_v() const { return getBool("tile_v"); }

	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool set_uv_noise_on(bool val) { return setValue("uv_noise_on", val); }
	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool get_uv_noise_on() const { return getBool("uv_noise_on"); }

	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool set_uv_noise_animate(bool val) { return setValue("uv_noise_animate", val); }
	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool get_uv_noise_animate() const { return getBool("uv_noise_animate"); }

	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	bool set_uv_noise_amount(float val) { return setValue("uv_noise_amount", val); }
	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	float get_uv_noise_amount() const { return getFloat("uv_noise_amount"); }

	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	bool set_uv_noise_levels(float val) { return setValue("uv_noise_levels", val); }
	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	float get_uv_noise_levels() const { return getFloat("uv_noise_levels"); }

	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	bool set_uv_noise_size(float val) { return setValue("uv_noise_size", val); }
	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	float get_uv_noise_size() const { return getFloat("uv_noise_size"); }

	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	bool set_un_noise_phase(float val) { return setValue("un_noise_phase", val); }
	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	float get_un_noise_phase() const { return getFloat("un_noise_phase"); }

	//! (description missing)
	bool set_color1_tex(const Plugin& texture) { return setValue("color1_tex", texture); }
	//! (description missing)
	bool set_color1_tex(const AColor& texture) { return setValue("color1_tex", texture); }
	//! (description missing)
	Value get_color1_tex() const { return getValue("color1_tex"); }

	//! (description missing)
	bool set_color2_tex(const Plugin& texture) { return setValue("color2_tex", texture); }
	//! (description missing)
	bool set_color2_tex(const AColor& texture) { return setValue("color2_tex", texture); }
	//! (description missing)
	Value get_color2_tex() const { return getValue("color2_tex"); }

	//! (description missing)
	bool set_grain_size(const Plugin& texturefloat) { return setValue("grain_size", texturefloat); }
	//! (description missing)
	bool set_grain_size(float texturefloat) { return setValue("grain_size", texturefloat); }
	//! (description missing)
	Value get_grain_size() const { return getValue("grain_size"); }

	//! (description missing)
	bool set_diffusion(const Plugin& texturefloat) { return setValue("diffusion", texturefloat); }
	//! (description missing)
	bool set_diffusion(float texturefloat) { return setValue("diffusion", texturefloat); }
	//! (description missing)
	Value get_diffusion() const { return getValue("diffusion"); }

	//! (description missing)
	bool set_mix_ratio(const Plugin& texturefloat) { return setValue("mix_ratio", texturefloat); }
	//! (description missing)
	bool set_mix_ratio(float texturefloat) { return setValue("mix_ratio", texturefloat); }
	//! (description missing)
	Value get_mix_ratio() const { return getValue("mix_ratio"); }
};

class TexXSIScalar2Color : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexXSIScalar2Color"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! Scalar2Color will be calculated on the base of a color or float texture
 	bool set_clr_txt(const Plugin& texture) { return setValue("clr_txt", texture); }
	//! Scalar2Color will be calculated on the base of a color or float texture
 	bool set_clr_txt(const AColor& texture) { return setValue("clr_txt", texture); }
	//! Scalar2Color will be calculated on the base of a color or float texture
 	Value get_clr_txt() const { return getValue("clr_txt"); }

	//! Specifies the input scalar value (value between 0 and 1) to be copied to RGB channels
 	bool set_float_txt(const Plugin& texturefloat) { return setValue("float_txt", texturefloat); }
	//! Specifies the input scalar value (value between 0 and 1) to be copied to RGB channels
 	bool set_float_txt(float texturefloat) { return setValue("float_txt", texturefloat); }
	//! Specifies the input scalar value (value between 0 and 1) to be copied to RGB channels
 	Value get_float_txt() const { return getValue("float_txt"); }

	//! Specifies the input scalar value to be copied to the alpha channel of the output
 	//! [Default value] 1
	bool set_alpha(float val) { return setValue("alpha", val); }
	//! Specifies the input scalar value to be copied to the alpha channel of the output
 	//! [Default value] 1
	float get_alpha() const { return getFloat("alpha"); }
};

class TexXSIScalarInvert : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexXSIScalarInvert"; }

	//! Specifies the input value to be inverted
 	bool set_input(const Plugin& texturefloat) { return setValue("input", texturefloat); }
	//! Specifies the input value to be inverted
 	bool set_input(float texturefloat) { return setValue("input", texturefloat); }
	//! Specifies the input value to be inverted
 	Value get_input() const { return getValue("input"); }
};

class TexXSISnow : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexXSISnow"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	bool set_placement_type(int val) { return setValue("placement_type", val); }
	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	int get_placement_type() const { return getInt("placement_type"); }

	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_u(float val) { return setValue("u", val); }
	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_u() const { return getFloat("u"); }

	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_v(float val) { return setValue("v", val); }
	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_v() const { return getFloat("v"); }

	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_w(float val) { return setValue("w", val); }
	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_w() const { return getFloat("w"); }

	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_h(float val) { return setValue("h", val); }
	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_h() const { return getFloat("h"); }

	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	bool set_jitter(float val) { return setValue("jitter", val); }
	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	float get_jitter() const { return getFloat("jitter"); }

	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_u(bool val) { return setValue("tile_u", val); }
	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_u() const { return getBool("tile_u"); }

	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_v(bool val) { return setValue("tile_v", val); }
	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_v() const { return getBool("tile_v"); }

	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool set_uv_noise_on(bool val) { return setValue("uv_noise_on", val); }
	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool get_uv_noise_on() const { return getBool("uv_noise_on"); }

	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool set_uv_noise_animate(bool val) { return setValue("uv_noise_animate", val); }
	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool get_uv_noise_animate() const { return getBool("uv_noise_animate"); }

	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	bool set_uv_noise_amount(float val) { return setValue("uv_noise_amount", val); }
	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	float get_uv_noise_amount() const { return getFloat("uv_noise_amount"); }

	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	bool set_uv_noise_levels(float val) { return setValue("uv_noise_levels", val); }
	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	float get_uv_noise_levels() const { return getFloat("uv_noise_levels"); }

	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	bool set_uv_noise_size(float val) { return setValue("uv_noise_size", val); }
	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	float get_uv_noise_size() const { return getFloat("uv_noise_size"); }

	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	bool set_un_noise_phase(float val) { return setValue("un_noise_phase", val); }
	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	float get_un_noise_phase() const { return getFloat("un_noise_phase"); }

	//! (description missing)
	bool set_snow_col(const Plugin& texture) { return setValue("snow_col", texture); }
	//! (description missing)
	bool set_snow_col(const AColor& texture) { return setValue("snow_col", texture); }
	//! (description missing)
	Value get_snow_col() const { return getValue("snow_col"); }

	//! (description missing)
	bool set_surface_col(const Plugin& texture) { return setValue("surface_col", texture); }
	//! (description missing)
	bool set_surface_col(const AColor& texture) { return setValue("surface_col", texture); }
	//! (description missing)
	Value get_surface_col() const { return getValue("surface_col"); }

	//! (description missing)
	bool set_threshold(const Plugin& texturefloat) { return setValue("threshold", texturefloat); }
	//! (description missing)
	bool set_threshold(float texturefloat) { return setValue("threshold", texturefloat); }
	//! (description missing)
	Value get_threshold() const { return getValue("threshold"); }

	//! (description missing)
	bool set_depth_decay(const Plugin& texturefloat) { return setValue("depth_decay", texturefloat); }
	//! (description missing)
	bool set_depth_decay(float texturefloat) { return setValue("depth_decay", texturefloat); }
	//! (description missing)
	Value get_depth_decay() const { return getValue("depth_decay"); }

	//! (description missing)
	bool set_thickness(const Plugin& texturefloat) { return setValue("thickness", texturefloat); }
	//! (description missing)
	bool set_thickness(float texturefloat) { return setValue("thickness", texturefloat); }
	//! (description missing)
	Value get_thickness() const { return getValue("thickness"); }

	//! (description missing)
	bool set_randomness(const Plugin& texturefloat) { return setValue("randomness", texturefloat); }
	//! (description missing)
	bool set_randomness(float texturefloat) { return setValue("randomness", texturefloat); }
	//! (description missing)
	Value get_randomness() const { return getValue("randomness"); }

	//! (description missing)
	bool set_rand_freq(const Plugin& texturefloat) { return setValue("rand_freq", texturefloat); }
	//! (description missing)
	bool set_rand_freq(float texturefloat) { return setValue("rand_freq", texturefloat); }
	//! (description missing)
	Value get_rand_freq() const { return getValue("rand_freq"); }
};

class TexXSIVein : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexXSIVein"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! (description missing)
	//! [Default value] false
	bool set_use_3d_mapping(bool val) { return setValue("use_3d_mapping", val); }
	//! (description missing)
	//! [Default value] false
	bool get_use_3d_mapping() const { return getBool("use_3d_mapping"); }

	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	bool set_placement_type(int val) { return setValue("placement_type", val); }
	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	int get_placement_type() const { return getInt("placement_type"); }

	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_u(float val) { return setValue("u", val); }
	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_u() const { return getFloat("u"); }

	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_v(float val) { return setValue("v", val); }
	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_v() const { return getFloat("v"); }

	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_w(float val) { return setValue("w", val); }
	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_w() const { return getFloat("w"); }

	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_h(float val) { return setValue("h", val); }
	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_h() const { return getFloat("h"); }

	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	bool set_jitter(float val) { return setValue("jitter", val); }
	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	float get_jitter() const { return getFloat("jitter"); }

	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_u(bool val) { return setValue("tile_u", val); }
	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_u() const { return getBool("tile_u"); }

	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_v(bool val) { return setValue("tile_v", val); }
	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_v() const { return getBool("tile_v"); }

	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool set_uv_noise_on(bool val) { return setValue("uv_noise_on", val); }
	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool get_uv_noise_on() const { return getBool("uv_noise_on"); }

	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool set_uv_noise_animate(bool val) { return setValue("uv_noise_animate", val); }
	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool get_uv_noise_animate() const { return getBool("uv_noise_animate"); }

	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	bool set_uv_noise_amount(float val) { return setValue("uv_noise_amount", val); }
	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	float get_uv_noise_amount() const { return getFloat("uv_noise_amount"); }

	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	bool set_uv_noise_levels(float val) { return setValue("uv_noise_levels", val); }
	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	float get_uv_noise_levels() const { return getFloat("uv_noise_levels"); }

	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	bool set_uv_noise_size(float val) { return setValue("uv_noise_size", val); }
	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	float get_uv_noise_size() const { return getFloat("uv_noise_size"); }

	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	bool set_un_noise_phase(float val) { return setValue("un_noise_phase", val); }
	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	float get_un_noise_phase() const { return getFloat("un_noise_phase"); }

	//! (description missing)
	bool set_color1(const Plugin& texture) { return setValue("color1", texture); }
	//! (description missing)
	bool set_color1(const AColor& texture) { return setValue("color1", texture); }
	//! (description missing)
	Value get_color1() const { return getValue("color1"); }

	//! (description missing)
	bool set_color2(const Plugin& texture) { return setValue("color2", texture); }
	//! (description missing)
	bool set_color2(const AColor& texture) { return setValue("color2", texture); }
	//! (description missing)
	Value get_color2() const { return getValue("color2"); }

	//! (description missing)
	bool set_complexity(const Plugin& texturefloat) { return setValue("complexity", texturefloat); }
	//! (description missing)
	bool set_complexity(float texturefloat) { return setValue("complexity", texturefloat); }
	//! (description missing)
	Value get_complexity() const { return getValue("complexity"); }

	//! (description missing)
	bool set_thickness(const Plugin& texturefloat) { return setValue("thickness", texturefloat); }
	//! (description missing)
	bool set_thickness(float texturefloat) { return setValue("thickness", texturefloat); }
	//! (description missing)
	Value get_thickness() const { return getValue("thickness"); }

	//! (description missing)
	bool set_falloff(const Plugin& texturefloat) { return setValue("falloff", texturefloat); }
	//! (description missing)
	bool set_falloff(float texturefloat) { return setValue("falloff", texturefloat); }
	//! (description missing)
	Value get_falloff() const { return getValue("falloff"); }

	//! (description missing)
	bool set_sharpness(const Plugin& texturefloat) { return setValue("sharpness", texturefloat); }
	//! (description missing)
	bool set_sharpness(float texturefloat) { return setValue("sharpness", texturefloat); }
	//! (description missing)
	Value get_sharpness() const { return getValue("sharpness"); }

	//! (description missing)
	bool set_intensity(const Plugin& texturefloat) { return setValue("intensity", texturefloat); }
	//! (description missing)
	bool set_intensity(float texturefloat) { return setValue("intensity", texturefloat); }
	//! (description missing)
	Value get_intensity() const { return getValue("intensity"); }

	//! (description missing)
	bool set_time(const Plugin& texturefloat) { return setValue("time", texturefloat); }
	//! (description missing)
	bool set_time(float texturefloat) { return setValue("time", texturefloat); }
	//! (description missing)
	Value get_time() const { return getValue("time"); }

	//! UVW coordinates scale
 	//! [Default value] Color(1, 1, 1)
	bool set_scale(const Color& color) { return setValue("scale", color); }
	//! UVW coordinates scale
 	//! [Default value] Color(1, 1, 1)
	Color get_scale() const { return getColor("scale"); }
};

class TexXSIVertexColorLookup : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexXSIVertexColorLookup"; }

	//! The channel number * 3 + a number indicating which of the x,y or z values are used.
 	//! [Default value] 0
	bool set_channel(int val) { return setValue("channel", val); }
	//! The channel number * 3 + a number indicating which of the x,y or z values are used.
 	//! [Default value] 0
	int get_channel() const { return getInt("channel"); }

	//! Weight multiplication factor
 	//! [Default value] 1
	bool set_factor(float val) { return setValue("factor", val); }
	//! Weight multiplication factor
 	//! [Default value] 1
	float get_factor() const { return getFloat("factor"); }

	//! Minimum weight (w/o factor)
 	//! [Default value] 0
	bool set_weight_min(float val) { return setValue("weight_min", val); }
	//! Minimum weight (w/o factor)
 	//! [Default value] 0
	float get_weight_min() const { return getFloat("weight_min"); }

	//! Minimum weight (w/o factor)
 	//! [Default value] 1
	bool set_weight_max(float val) { return setValue("weight_max", val); }
	//! Minimum weight (w/o factor)
 	//! [Default value] 1
	float get_weight_max() const { return getFloat("weight_max"); }
};

class TexXSIWeightmapColorLookup : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexXSIWeightmapColorLookup"; }

	//! The channel number * 3 + a number indicating which of the x,y or z values are used.
 	//! [Default value] 0
	bool set_channel(int val) { return setValue("channel", val); }
	//! The channel number * 3 + a number indicating which of the x,y or z values are used.
 	//! [Default value] 0
	int get_channel() const { return getInt("channel"); }

	//! Weight multiplication factor
 	//! [Default value] 1
	bool set_factor(float val) { return setValue("factor", val); }
	//! Weight multiplication factor
 	//! [Default value] 1
	float get_factor() const { return getFloat("factor"); }

	//! Minimum weight (w/o factor)
 	//! [Default value] 0
	bool set_weight_min(float val) { return setValue("weight_min", val); }
	//! Minimum weight (w/o factor)
 	//! [Default value] 0
	float get_weight_min() const { return getFloat("weight_min"); }

	//! Minimum weight (w/o factor)
 	//! [Default value] 1
	bool set_weight_max(float val) { return setValue("weight_max", val); }
	//! Minimum weight (w/o factor)
 	//! [Default value] 1
	float get_weight_max() const { return getFloat("weight_max"); }
};

class TexXSIWeightmapLookup : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexXSIWeightmapLookup"; }

	//! The channel number * 3 + a number indicating which of the x,y or z values are used.
 	//! [Default value] 0
	bool set_channel(int val) { return setValue("channel", val); }
	//! The channel number * 3 + a number indicating which of the x,y or z values are used.
 	//! [Default value] 0
	int get_channel() const { return getInt("channel"); }

	//! Weight multiplication factor
 	//! [Default value] 1
	bool set_factor(float val) { return setValue("factor", val); }
	//! Weight multiplication factor
 	//! [Default value] 1
	float get_factor() const { return getFloat("factor"); }

	//! Minimum weight (w/o factor)
 	//! [Default value] 0
	bool set_weight_min(float val) { return setValue("weight_min", val); }
	//! Minimum weight (w/o factor)
 	//! [Default value] 0
	float get_weight_min() const { return getFloat("weight_min"); }

	//! Minimum weight (w/o factor)
 	//! [Default value] 1
	bool set_weight_max(float val) { return setValue("weight_max", val); }
	//! Minimum weight (w/o factor)
 	//! [Default value] 1
	float get_weight_max() const { return getFloat("weight_max"); }
};

class TexXSIWood : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TexXSIWood"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	bool set_placement_type(int val) { return setValue("placement_type", val); }
	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	int get_placement_type() const { return getInt("placement_type"); }

	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_u(float val) { return setValue("u", val); }
	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_u() const { return getFloat("u"); }

	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_v(float val) { return setValue("v", val); }
	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_v() const { return getFloat("v"); }

	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_w(float val) { return setValue("w", val); }
	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_w() const { return getFloat("w"); }

	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_h(float val) { return setValue("h", val); }
	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_h() const { return getFloat("h"); }

	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	bool set_jitter(float val) { return setValue("jitter", val); }
	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	float get_jitter() const { return getFloat("jitter"); }

	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_u(bool val) { return setValue("tile_u", val); }
	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_u() const { return getBool("tile_u"); }

	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_v(bool val) { return setValue("tile_v", val); }
	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_v() const { return getBool("tile_v"); }

	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool set_uv_noise_on(bool val) { return setValue("uv_noise_on", val); }
	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool get_uv_noise_on() const { return getBool("uv_noise_on"); }

	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool set_uv_noise_animate(bool val) { return setValue("uv_noise_animate", val); }
	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool get_uv_noise_animate() const { return getBool("uv_noise_animate"); }

	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	bool set_uv_noise_amount(float val) { return setValue("uv_noise_amount", val); }
	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	float get_uv_noise_amount() const { return getFloat("uv_noise_amount"); }

	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	bool set_uv_noise_levels(float val) { return setValue("uv_noise_levels", val); }
	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	float get_uv_noise_levels() const { return getFloat("uv_noise_levels"); }

	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	bool set_uv_noise_size(float val) { return setValue("uv_noise_size", val); }
	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	float get_uv_noise_size() const { return getFloat("uv_noise_size"); }

	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	bool set_un_noise_phase(float val) { return setValue("un_noise_phase", val); }
	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	float get_un_noise_phase() const { return getFloat("un_noise_phase"); }

	//! (description missing)
	bool set_filler_color_tex(const Plugin& texture) { return setValue("filler_color_tex", texture); }
	//! (description missing)
	bool set_filler_color_tex(const AColor& texture) { return setValue("filler_color_tex", texture); }
	//! (description missing)
	Value get_filler_color_tex() const { return getValue("filler_color_tex"); }

	//! (description missing)
	bool set_vein_color_tex(const Plugin& texture) { return setValue("vein_color_tex", texture); }
	//! (description missing)
	bool set_vein_color_tex(const AColor& texture) { return setValue("vein_color_tex", texture); }
	//! (description missing)
	Value get_vein_color_tex() const { return getValue("vein_color_tex"); }

	//! (description missing)
	bool set_vein_spread(const Plugin& texturefloat) { return setValue("vein_spread", texturefloat); }
	//! (description missing)
	bool set_vein_spread(float texturefloat) { return setValue("vein_spread", texturefloat); }
	//! (description missing)
	Value get_vein_spread() const { return getValue("vein_spread"); }

	//! (description missing)
	bool set_grain_color_tex(const Plugin& texture) { return setValue("grain_color_tex", texture); }
	//! (description missing)
	bool set_grain_color_tex(const AColor& texture) { return setValue("grain_color_tex", texture); }
	//! (description missing)
	Value get_grain_color_tex() const { return getValue("grain_color_tex"); }

	//! (description missing)
	bool set_grain_bias(const Plugin& texturefloat) { return setValue("grain_bias", texturefloat); }
	//! (description missing)
	bool set_grain_bias(float texturefloat) { return setValue("grain_bias", texturefloat); }
	//! (description missing)
	Value get_grain_bias() const { return getValue("grain_bias"); }

	//! (description missing)
	bool set_grain_size(const Plugin& texturefloat) { return setValue("grain_size", texturefloat); }
	//! (description missing)
	bool set_grain_size(float texturefloat) { return setValue("grain_size", texturefloat); }
	//! (description missing)
	Value get_grain_size() const { return getValue("grain_size"); }

	//! (description missing)
	bool set_grain_density(const Plugin& texturefloat) { return setValue("grain_density", texturefloat); }
	//! (description missing)
	bool set_grain_density(float texturefloat) { return setValue("grain_density", texturefloat); }
	//! (description missing)
	Value get_grain_density() const { return getValue("grain_density"); }

	//! (description missing)
	//! [Default value] true
	bool set_wobbly_struct(bool val) { return setValue("wobbly_struct", val); }
	//! (description missing)
	//! [Default value] true
	bool get_wobbly_struct() const { return getBool("wobbly_struct"); }

	//! (description missing)
	bool set_age(const Plugin& texturefloat) { return setValue("age", texturefloat); }
	//! (description missing)
	bool set_age(float texturefloat) { return setValue("age", texturefloat); }
	//! (description missing)
	Value get_age() const { return getValue("age"); }

	//! (description missing)
	bool set_layer_size(const Plugin& texturefloat) { return setValue("layer_size", texturefloat); }
	//! (description missing)
	bool set_layer_size(float texturefloat) { return setValue("layer_size", texturefloat); }
	//! (description missing)
	Value get_layer_size() const { return getValue("layer_size"); }

	//! (description missing)
	bool set_randomness(const Plugin& texturefloat) { return setValue("randomness", texturefloat); }
	//! (description missing)
	bool set_randomness(float texturefloat) { return setValue("randomness", texturefloat); }
	//! (description missing)
	Value get_randomness() const { return getValue("randomness"); }

	//! (description missing)
	bool set_center_u(const Plugin& texturefloat) { return setValue("center_u", texturefloat); }
	//! (description missing)
	bool set_center_u(float texturefloat) { return setValue("center_u", texturefloat); }
	//! (description missing)
	Value get_center_u() const { return getValue("center_u"); }

	//! (description missing)
	bool set_center_v(const Plugin& texturefloat) { return setValue("center_v", texturefloat); }
	//! (description missing)
	bool set_center_v(float texturefloat) { return setValue("center_v", texturefloat); }
	//! (description missing)
	Value get_center_v() const { return getValue("center_v"); }

	//! (description missing)
	bool set_ratio(const Plugin& texturefloat) { return setValue("ratio", texturefloat); }
	//! (description missing)
	bool set_ratio(float texturefloat) { return setValue("ratio", texturefloat); }
	//! (description missing)
	Value get_ratio() const { return getValue("ratio"); }

	//! (description missing)
	bool set_complexity(const Plugin& texturefloat) { return setValue("complexity", texturefloat); }
	//! (description missing)
	bool set_complexity(float texturefloat) { return setValue("complexity", texturefloat); }
	//! (description missing)
	Value get_complexity() const { return getValue("complexity"); }

	//! (description missing)
	bool set_u_amp(const Plugin& texturefloat) { return setValue("u_amp", texturefloat); }
	//! (description missing)
	bool set_u_amp(float texturefloat) { return setValue("u_amp", texturefloat); }
	//! (description missing)
	Value get_u_amp() const { return getValue("u_amp"); }

	//! (description missing)
	bool set_v_amp(const Plugin& texturefloat) { return setValue("v_amp", texturefloat); }
	//! (description missing)
	bool set_v_amp(float texturefloat) { return setValue("v_amp", texturefloat); }
	//! (description missing)
	Value get_v_amp() const { return getValue("v_amp"); }

	//! (description missing)
	//! [Default value] Vector(1, 1, 1)
	bool set_frequency(const Vector& vector) { return setValue("frequency", vector); }
	//! (description missing)
	//! [Default value] Vector(1, 1, 1)
	Vector get_frequency() const { return getVector("frequency"); }

	//! (description missing)
	//! [Default value] false
	bool set_absolute(bool val) { return setValue("absolute", val); }
	//! (description missing)
	//! [Default value] false
	bool get_absolute() const { return getBool("absolute"); }
};

class TransformToTex : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TransformToTex"; }

	//! (description missing)
	bool set_input(const Plugin& texturetransform) { return setValue("input", texturetransform); }
	//! (description missing)
	bool set_input(const Transform& texturetransform) { return setValue("input", texturetransform); }
	//! (description missing)
	Value get_input() const { return getValue("input"); }
};

class TrimmingRegion : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TrimmingRegion"; }

	//! List of NURBSCurve objects - the inner curves for the trimming region
 	bool set_innerCurves(const ValueList& pluginList) { return setValue("innerCurves", pluginList); }
	//! List of NURBSCurve objects - the inner curves for the trimming region
 	ValueList get_innerCurves() const { return getValueList("innerCurves"); }

	//! A NURBSCurve object - the outer curve for the trimming region
 	bool set_outerCurve(const Plugin& plugin) { return setValue("outerCurve", plugin); }
	//! A NURBSCurve object - the outer curve for the trimming region
 	Plugin get_outerCurve() const { return getPlugin("outerCurve"); }
};

class TrimmingRegionsComplex : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "TrimmingRegionsComplex"; }

	//! List containing information about the number of regions, number of boundaries within them, number of curves for a boundary, the curves' number of cvs, knots and degree
 	//! [Default value] 0
	bool set_count(const IntList& intList) { return setValue("count", intList); }
	//! List containing information about the number of regions, number of boundaries within them, number of curves for a boundary, the curves' number of cvs, knots and degree
 	//! [Default value] 0
	bool set_count(const int* ints, size_t count) { return setArray("count", ints, count); }
	//! List containing information about the number of regions, number of boundaries within them, number of curves for a boundary, the curves' number of cvs, knots and degree
 	//! [Default value] 0
	template<size_t count> bool set_count(const int (&ints)[count]) { return setArray("count", ints, count); }
	//! List containing information about the number of regions, number of boundaries within them, number of curves for a boundary, the curves' number of cvs, knots and degree
 	//! [Default value] 0
	IntList get_count() const { return getIntList("count"); }

	//! List containg pairs of (u, v) coordinates of control vertices for all the curves
 	//! [Default value] 0
	bool set_cvs(const FloatList& floatList) { return setValue("cvs", floatList); }
	//! List containg pairs of (u, v) coordinates of control vertices for all the curves
 	//! [Default value] 0
	bool set_cvs(const float* floats, size_t count) { return setArray("cvs", floats, count); }
	//! List containg pairs of (u, v) coordinates of control vertices for all the curves
 	//! [Default value] 0
	template<size_t count> bool set_cvs(const float (&floats)[count]) { return setArray("cvs", floats, count); }
	//! List containg pairs of (u, v) coordinates of control vertices for all the curves
 	//! [Default value] 0
	FloatList get_cvs() const { return getFloatList("cvs"); }

	//! List containing the knot values for all the curves
 	//! [Default value] 0
	bool set_knots(const FloatList& floatList) { return setValue("knots", floatList); }
	//! List containing the knot values for all the curves
 	//! [Default value] 0
	bool set_knots(const float* floats, size_t count) { return setArray("knots", floats, count); }
	//! List containing the knot values for all the curves
 	//! [Default value] 0
	template<size_t count> bool set_knots(const float (&floats)[count]) { return setArray("knots", floats, count); }
	//! List containing the knot values for all the curves
 	//! [Default value] 0
	FloatList get_knots() const { return getFloatList("knots"); }
};

class UVWGenBercon : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "UVWGenBercon"; }

	//! the X offset
 	//! [Default value] 0
	bool set_offset_x(float val) { return setValue("offset_x", val); }
	//! the X offset
 	//! [Default value] 0
	float get_offset_x() const { return getFloat("offset_x"); }

	//! the Y offset
 	//! [Default value] 0
	bool set_offset_y(float val) { return setValue("offset_y", val); }
	//! the Y offset
 	//! [Default value] 0
	float get_offset_y() const { return getFloat("offset_y"); }

	//! the Z offset
 	//! [Default value] 0
	bool set_offset_z(float val) { return setValue("offset_z", val); }
	//! the Z offset
 	//! [Default value] 0
	float get_offset_z() const { return getFloat("offset_z"); }

	//! X size
 	//! [Default value] 1
	bool set_size_x(float val) { return setValue("size_x", val); }
	//! X size
 	//! [Default value] 1
	float get_size_x() const { return getFloat("size_x"); }

	//! Y size
 	//! [Default value] 1
	bool set_size_y(float val) { return setValue("size_y", val); }
	//! Y size
 	//! [Default value] 1
	float get_size_y() const { return getFloat("size_y"); }

	//! Z size
 	//! [Default value] 1
	bool set_size_z(float val) { return setValue("size_z", val); }
	//! Z size
 	//! [Default value] 1
	float get_size_z() const { return getFloat("size_z"); }

	//! X angle
 	//! [Default value] 0
	bool set_angle_x(float val) { return setValue("angle_x", val); }
	//! X angle
 	//! [Default value] 0
	float get_angle_x() const { return getFloat("angle_x"); }

	//! Y angle
 	//! [Default value] 0
	bool set_angle_y(float val) { return setValue("angle_y", val); }
	//! Y angle
 	//! [Default value] 0
	float get_angle_y() const { return getFloat("angle_y"); }

	//! Z angle
 	//! [Default value] 0
	bool set_angle_z(float val) { return setValue("angle_z", val); }
	//! Z angle
 	//! [Default value] 0
	float get_angle_z() const { return getFloat("angle_z"); }

	//! X tiles
 	//! [Default value] 1
	bool set_tile_x(int val) { return setValue("tile_x", val); }
	//! X tiles
 	//! [Default value] 1
	int get_tile_x() const { return getInt("tile_x"); }

	//! Y tiles
 	//! [Default value] 1
	bool set_tile_y(int val) { return setValue("tile_y", val); }
	//! Y tiles
 	//! [Default value] 1
	int get_tile_y() const { return getInt("tile_y"); }

	//! Z tiles
 	//! [Default value] 1
	bool set_tile_z(int val) { return setValue("tile_z", val); }
	//! Z tiles
 	//! [Default value] 1
	int get_tile_z() const { return getInt("tile_z"); }

	//! second X offset
 	//! [Default value] 0
	bool set_offset_x2(float val) { return setValue("offset_x2", val); }
	//! second X offset
 	//! [Default value] 0
	float get_offset_x2() const { return getFloat("offset_x2"); }

	//! second Y offset
 	//! [Default value] 0
	bool set_offset_y2(float val) { return setValue("offset_y2", val); }
	//! second Y offset
 	//! [Default value] 0
	float get_offset_y2() const { return getFloat("offset_y2"); }

	//! second Z offset
 	//! [Default value] 0
	bool set_offset_z2(float val) { return setValue("offset_z2", val); }
	//! second Z offset
 	//! [Default value] 0
	float get_offset_z2() const { return getFloat("offset_z2"); }

	//! second X size
 	//! [Default value] 0
	bool set_size_x2(float val) { return setValue("size_x2", val); }
	//! second X size
 	//! [Default value] 0
	float get_size_x2() const { return getFloat("size_x2"); }

	//! second Y size
 	//! [Default value] 0
	bool set_size_y2(float val) { return setValue("size_y2", val); }
	//! second Y size
 	//! [Default value] 0
	float get_size_y2() const { return getFloat("size_y2"); }

	//! second Z size
 	//! [Default value] 0
	bool set_size_z2(float val) { return setValue("size_z2", val); }
	//! second Z size
 	//! [Default value] 0
	float get_size_z2() const { return getFloat("size_z2"); }

	//! second X angle
 	//! [Default value] 0
	bool set_angle_x2(float val) { return setValue("angle_x2", val); }
	//! second X angle
 	//! [Default value] 0
	float get_angle_x2() const { return getFloat("angle_x2"); }

	//! second Y angle
 	//! [Default value] 0
	bool set_angle_y2(float val) { return setValue("angle_y2", val); }
	//! second Y angle
 	//! [Default value] 0
	float get_angle_y2() const { return getFloat("angle_y2"); }

	//! second Z angle
 	//! [Default value] 0
	bool set_angle_z2(float val) { return setValue("angle_z2", val); }
	//! second Z angle
 	//! [Default value] 0
	float get_angle_z2() const { return getFloat("angle_z2"); }

	//! XYZ Lock
 	//! [Default value] 0
	bool set_xyz_lock(int val) { return setValue("xyz_lock", val); }
	//! XYZ Lock
 	//! [Default value] 0
	int get_xyz_lock() const { return getInt("xyz_lock"); }

	//! Seed
 	//! [Default value] 1
	bool set_seed(int val) { return setValue("seed", val); }
	//! Seed
 	//! [Default value] 1
	int get_seed() const { return getInt("seed"); }

	//! Random by material
 	//! [Default value] 0
	bool set_rand_mat(int val) { return setValue("rand_mat", val); }
	//! Random by material
 	//! [Default value] 0
	int get_rand_mat() const { return getInt("rand_mat"); }

	//! Random by object
 	//! [Default value] 0
	bool set_rand_obj(int val) { return setValue("rand_obj", val); }
	//! Random by object
 	//! [Default value] 0
	int get_rand_obj() const { return getInt("rand_obj"); }

	//! Random by particle
 	//! [Default value] 0
	bool set_rand_par(int val) { return setValue("rand_par", val); }
	//! Random by particle
 	//! [Default value] 0
	int get_rand_par() const { return getInt("rand_par"); }

	//! Mapping type
 	//! [Default value] 0
	bool set_map(int val) { return setValue("map", val); }
	//! Mapping type
 	//! [Default value] 0
	int get_map() const { return getInt("map"); }

	//! Mapping channel
 	//! [Default value] 0
	bool set_channel(int val) { return setValue("channel", val); }
	//! Mapping channel
 	//! [Default value] 0
	int get_channel() const { return getInt("channel"); }

	//! filtering
 	//! [Default value] 1
	bool set_filtering(float val) { return setValue("filtering", val); }
	//! filtering
 	//! [Default value] 1
	float get_filtering() const { return getFloat("filtering"); }
};

class UVWGenChannel : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "UVWGenChannel"; }

	//! Initial transformation on the uvw coordinates, before mirror, crop etc
 	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	bool set_uvw_transform(const Transform& transform) { return setValue("uvw_transform", transform); }
	//! Initial transformation on the uvw coordinates, before mirror, crop etc
 	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	Transform get_uvw_transform() const { return getTransform("uvw_transform"); }

	//! (description missing)
	bool set_uvw_transform_tex(const Plugin& texturetransform) { return setValue("uvw_transform_tex", texturetransform); }
	//! (description missing)
	bool set_uvw_transform_tex(const Transform& texturetransform) { return setValue("uvw_transform_tex", texturetransform); }
	//! (description missing)
	Value get_uvw_transform_tex() const { return getValue("uvw_transform_tex"); }

	//! Final transformation on the resulting uvw coordinates, after mirror, crop etc
 	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	bool set_tex_transform(const Transform& transform) { return setValue("tex_transform", transform); }
	//! Final transformation on the resulting uvw coordinates, after mirror, crop etc
 	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	Transform get_tex_transform() const { return getTransform("tex_transform"); }

	//! Number of uvw transform samples
 	//! [Default value] 0
	bool set_nsamples(int val) { return setValue("nsamples", val); }
	//! Number of uvw transform samples
 	//! [Default value] 0
	int get_nsamples() const { return getInt("nsamples"); }

	//! 0 - no wrapping, 1 - wrap, 2 - mirror tile
 	//! [Default value] 0
	bool set_wrap_u(int val) { return setValue("wrap_u", val); }
	//! 0 - no wrapping, 1 - wrap, 2 - mirror tile
 	//! [Default value] 0
	int get_wrap_u() const { return getInt("wrap_u"); }

	//! 0 - no wrapping, 1 - wrap, 2 - mirror tile
 	//! [Default value] 0
	bool set_wrap_v(int val) { return setValue("wrap_v", val); }
	//! 0 - no wrapping, 1 - wrap, 2 - mirror tile
 	//! [Default value] 0
	int get_wrap_v() const { return getInt("wrap_v"); }

	//! 0 - no wrapping, 1 - wrap, 2 - mirror tile
 	//! [Default value] 0
	bool set_wrap_w(int val) { return setValue("wrap_w", val); }
	//! 0 - no wrapping, 1 - wrap, 2 - mirror tile
 	//! [Default value] 0
	int get_wrap_w() const { return getInt("wrap_w"); }

	//! 1 to crop in the u-direction
 	//! [Default value] 0
	bool set_crop_u(int val) { return setValue("crop_u", val); }
	//! 1 to crop in the u-direction
 	//! [Default value] 0
	int get_crop_u() const { return getInt("crop_u"); }

	//! 1 to crop in the v-direction
 	//! [Default value] 0
	bool set_crop_v(int val) { return setValue("crop_v", val); }
	//! 1 to crop in the v-direction
 	//! [Default value] 0
	int get_crop_v() const { return getInt("crop_v"); }

	//! 1 to crop in the w-direction
 	//! [Default value] 0
	bool set_crop_w(int val) { return setValue("crop_w", val); }
	//! 1 to crop in the w-direction
 	//! [Default value] 0
	int get_crop_w() const { return getInt("crop_w"); }

	//! Coverage
 	//! [Default value] Vector(1, 1, 1)
	bool set_coverage(const Vector& vector) { return setValue("coverage", vector); }
	//! Coverage
 	//! [Default value] Vector(1, 1, 1)
	Vector get_coverage() const { return getVector("coverage"); }

	//! Wrap mode (0 - wrap on 0.5 boundary; 1 - wrap on integer boundary
 	//! [UI Guides] enum=0:On 0.5 boundary; 1:On integer boundary
 	//! [Default value] 0
	bool set_wrap_mode(int val) { return setValue("wrap_mode", val); }
	//! Wrap mode (0 - wrap on 0.5 boundary; 1 - wrap on integer boundary
 	//! [UI Guides] enum=0:On 0.5 boundary; 1:On integer boundary
 	//! [Default value] 0
	int get_wrap_mode() const { return getInt("wrap_mode"); }

	//! Additional scale factor for the texture derivatives
 	//! [Default value] 1
	bool set_duvw_scale(float val) { return setValue("duvw_scale", val); }
	//! Additional scale factor for the texture derivatives
 	//! [Default value] 1
	float get_duvw_scale() const { return getFloat("duvw_scale"); }

	//! (description missing)
	//! [Default value] 1
	bool set_uvw_channel(int val) { return setValue("uvw_channel", val); }
	//! (description missing)
	//! [Default value] 1
	int get_uvw_channel() const { return getInt("uvw_channel"); }

	//! Optional UVWGen from which the initial uvw coordinates will be taken, instead of the surface point
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! Optional UVWGen from which the initial uvw coordinates will be taken, instead of the surface point
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! If this is true then we will use uvw_channel for front-side and uvw_channel + 1 for back-side contexts. This is primarily for V-Ray for SketchUp.
 	//! [Default value] false
	bool set_use_double_sided_mode(bool val) { return setValue("use_double_sided_mode", val); }
	//! If this is true then we will use uvw_channel for front-side and uvw_channel + 1 for back-side contexts. This is primarily for V-Ray for SketchUp.
 	//! [Default value] false
	bool get_use_double_sided_mode() const { return getBool("use_double_sided_mode"); }
};

class UVWGenEnvironment : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "UVWGenEnvironment"; }

	//! Transformation of the input directions
 	//! [Default value] Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1))
	bool set_uvw_matrix(const Matrix& matrix) { return setValue("uvw_matrix", matrix); }
	//! Transformation of the input directions
 	//! [Default value] Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1))
	Matrix get_uvw_matrix() const { return getMatrix("uvw_matrix"); }

	//! Transformation of the resulting UVW coordinates
 	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	bool set_uvw_transform(const Transform& transform) { return setValue("uvw_transform", transform); }
	//! Transformation of the resulting UVW coordinates
 	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	Transform get_uvw_transform() const { return getTransform("uvw_transform"); }

	//! One of "angular", "cubic", "spherical", "mirror_ball", "screen", "max_spherical", "spherical_vray", "max_cylindrical" or "max_shrink_wrap"
 	//! [UI Guides] string_enum=angular;cubic;spherical;mirror_ball;screen;max_spherical;spherical_vray;max_cylindrical;max_shrink_wrap
 	//! [Default value] spherical
	bool set_mapping_type(const char* str) { return setValue("mapping_type", str); }
	//! One of "angular", "cubic", "spherical", "mirror_ball", "screen", "max_spherical", "spherical_vray", "max_cylindrical" or "max_shrink_wrap"
 	//! [UI Guides] string_enum=angular;cubic;spherical;mirror_ball;screen;max_spherical;spherical_vray;max_cylindrical;max_shrink_wrap
 	//! [Default value] spherical
	bool set_mapping_type(const std::string& str) { return setValue("mapping_type", str); }
	//! One of "angular", "cubic", "spherical", "mirror_ball", "screen", "max_spherical", "spherical_vray", "max_cylindrical" or "max_shrink_wrap"
 	//! [UI Guides] string_enum=angular;cubic;spherical;mirror_ball;screen;max_spherical;spherical_vray;max_cylindrical;max_shrink_wrap
 	//! [Default value] spherical
	std::string get_mapping_type() const { return getString("mapping_type"); }

	//! 0 - no wrapping, 1 - wrap, 2 - mirror tile
 	//! [UI Guides] enum=0:No wrapping; 1:Wrap; 2:Mirror tile
 	//! [Default value] 0
	bool set_wrap_u(int val) { return setValue("wrap_u", val); }
	//! 0 - no wrapping, 1 - wrap, 2 - mirror tile
 	//! [UI Guides] enum=0:No wrapping; 1:Wrap; 2:Mirror tile
 	//! [Default value] 0
	int get_wrap_u() const { return getInt("wrap_u"); }

	//! 0 - no wrapping, 1 - wrap, 2 - mirror tile
 	//! [UI Guides] enum=0:No wrapping; 1:Wrap; 2:Mirror tile
 	//! [Default value] 0
	bool set_wrap_v(int val) { return setValue("wrap_v", val); }
	//! 0 - no wrapping, 1 - wrap, 2 - mirror tile
 	//! [UI Guides] enum=0:No wrapping; 1:Wrap; 2:Mirror tile
 	//! [Default value] 0
	int get_wrap_v() const { return getInt("wrap_v"); }

	//! 0 - no wrapping, 1 - wrap, 2 - mirror tile
 	//! [UI Guides] enum=0:No wrapping; 1:Wrap; 2:Mirror tile
 	//! [Default value] 0
	bool set_wrap_w(int val) { return setValue("wrap_w", val); }
	//! 0 - no wrapping, 1 - wrap, 2 - mirror tile
 	//! [UI Guides] enum=0:No wrapping; 1:Wrap; 2:Mirror tile
 	//! [Default value] 0
	int get_wrap_w() const { return getInt("wrap_w"); }

	//! 1 to crop in the u-direction
 	//! [UI Guides] enum=0:No; 1:Yes
 	//! [Default value] 0
	bool set_crop_u(int val) { return setValue("crop_u", val); }
	//! 1 to crop in the u-direction
 	//! [UI Guides] enum=0:No; 1:Yes
 	//! [Default value] 0
	int get_crop_u() const { return getInt("crop_u"); }

	//! 1 to crop in the v-direction
 	//! [UI Guides] enum=0:No; 1:Yes
 	//! [Default value] 0
	bool set_crop_v(int val) { return setValue("crop_v", val); }
	//! 1 to crop in the v-direction
 	//! [UI Guides] enum=0:No; 1:Yes
 	//! [Default value] 0
	int get_crop_v() const { return getInt("crop_v"); }

	//! 1 to crop in the w-direction
 	//! [UI Guides] enum=0:No; 1:Yes
 	//! [Default value] 0
	bool set_crop_w(int val) { return setValue("crop_w", val); }
	//! 1 to crop in the w-direction
 	//! [UI Guides] enum=0:No; 1:Yes
 	//! [Default value] 0
	int get_crop_w() const { return getInt("crop_w"); }

	//! Additional scale factor for the texture derivatives
 	//! [Default value] 1
	bool set_duvw_scale(float val) { return setValue("duvw_scale", val); }
	//! Additional scale factor for the texture derivatives
 	//! [Default value] 1
	float get_duvw_scale() const { return getFloat("duvw_scale"); }

	//! (description missing)
	//! [Default value] 0
	bool set_ground_on(int val) { return setValue("ground_on", val); }
	//! (description missing)
	//! [Default value] 0
	int get_ground_on() const { return getInt("ground_on"); }

	//! (description missing)
	//! [Default value] Vector(0, 0, 0)
	bool set_ground_position(const Vector& vector) { return setValue("ground_position", vector); }
	//! (description missing)
	//! [Default value] Vector(0, 0, 0)
	Vector get_ground_position() const { return getVector("ground_position"); }

	//! (description missing)
	//! [Default value] 1000
	bool set_ground_radius(float val) { return setValue("ground_radius", val); }
	//! (description missing)
	//! [Default value] 1000
	float get_ground_radius() const { return getFloat("ground_radius"); }
};

class UVWGenExplicit : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "UVWGenExplicit"; }

	//! the U input
 	bool set_u(const Plugin& texturefloat) { return setValue("u", texturefloat); }
	//! the U input
 	bool set_u(float texturefloat) { return setValue("u", texturefloat); }
	//! the U input
 	Value get_u() const { return getValue("u"); }

	//! the V input
 	bool set_v(const Plugin& texturefloat) { return setValue("v", texturefloat); }
	//! the V input
 	bool set_v(float texturefloat) { return setValue("v", texturefloat); }
	//! the V input
 	Value get_v() const { return getValue("v"); }

	//! the W input
 	bool set_w(const Plugin& texturefloat) { return setValue("w", texturefloat); }
	//! the W input
 	bool set_w(float texturefloat) { return setValue("w", texturefloat); }
	//! the W input
 	Value get_w() const { return getValue("w"); }

	//! (description missing)
	bool set_uvw(const Plugin& texture) { return setValue("uvw", texture); }
	//! (description missing)
	bool set_uvw(const AColor& texture) { return setValue("uvw", texture); }
	//! (description missing)
	Value get_uvw() const { return getValue("uvw"); }
};

class UVWGenMayaPlace2dTexture : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "UVWGenMayaPlace2dTexture"; }

	//! (description missing)
	//! [Default value] 1
	bool set_uvw_channel(int val) { return setValue("uvw_channel", val); }
	//! (description missing)
	//! [Default value] 1
	int get_uvw_channel() const { return getInt("uvw_channel"); }

	//! Used when more than one mesh has UV linking specified for this 2d placement. If present will override uvw_channel.
 	bool set_uvw_channel_tex(const Plugin& textureint) { return setValue("uvw_channel_tex", textureint); }
	//! Used when more than one mesh has UV linking specified for this 2d placement. If present will override uvw_channel.
 	bool set_uvw_channel_tex(int textureint) { return setValue("uvw_channel_tex", textureint); }
	//! Used when more than one mesh has UV linking specified for this 2d placement. If present will override uvw_channel.
 	Value get_uvw_channel_tex() const { return getValue("uvw_channel_tex"); }

	//! Optional UVWGen from which the initial uvw coordinates will be taken, instead of the surface point
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! Optional UVWGen from which the initial uvw coordinates will be taken, instead of the surface point
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! (description missing)
	//! [Default value] 1
	bool set_coverage_u(float val) { return setValue("coverage_u", val); }
	//! (description missing)
	//! [Default value] 1
	float get_coverage_u() const { return getFloat("coverage_u"); }

	//! (description missing)
	bool set_coverage_u_tex(const Plugin& texturefloat) { return setValue("coverage_u_tex", texturefloat); }
	//! (description missing)
	bool set_coverage_u_tex(float texturefloat) { return setValue("coverage_u_tex", texturefloat); }
	//! (description missing)
	Value get_coverage_u_tex() const { return getValue("coverage_u_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_coverage_v(float val) { return setValue("coverage_v", val); }
	//! (description missing)
	//! [Default value] 1
	float get_coverage_v() const { return getFloat("coverage_v"); }

	//! (description missing)
	bool set_coverage_v_tex(const Plugin& texturefloat) { return setValue("coverage_v_tex", texturefloat); }
	//! (description missing)
	bool set_coverage_v_tex(float texturefloat) { return setValue("coverage_v_tex", texturefloat); }
	//! (description missing)
	Value get_coverage_v_tex() const { return getValue("coverage_v_tex"); }

	//! (description missing)
	//! [Default value] 0
	bool set_translate_frame_u(float val) { return setValue("translate_frame_u", val); }
	//! (description missing)
	//! [Default value] 0
	float get_translate_frame_u() const { return getFloat("translate_frame_u"); }

	//! (description missing)
	bool set_translate_frame_u_tex(const Plugin& texturefloat) { return setValue("translate_frame_u_tex", texturefloat); }
	//! (description missing)
	bool set_translate_frame_u_tex(float texturefloat) { return setValue("translate_frame_u_tex", texturefloat); }
	//! (description missing)
	Value get_translate_frame_u_tex() const { return getValue("translate_frame_u_tex"); }

	//! (description missing)
	//! [Default value] 0
	bool set_translate_frame_v(float val) { return setValue("translate_frame_v", val); }
	//! (description missing)
	//! [Default value] 0
	float get_translate_frame_v() const { return getFloat("translate_frame_v"); }

	//! (description missing)
	bool set_translate_frame_v_tex(const Plugin& texturefloat) { return setValue("translate_frame_v_tex", texturefloat); }
	//! (description missing)
	bool set_translate_frame_v_tex(float texturefloat) { return setValue("translate_frame_v_tex", texturefloat); }
	//! (description missing)
	Value get_translate_frame_v_tex() const { return getValue("translate_frame_v_tex"); }

	//! [UI Guides] units=radians
 	//! [Default value] 0
	bool set_rotate_frame(float val) { return setValue("rotate_frame", val); }
	//! [UI Guides] units=radians
 	//! [Default value] 0
	float get_rotate_frame() const { return getFloat("rotate_frame"); }

	//! (description missing)
	bool set_rotate_frame_tex(const Plugin& texturefloat) { return setValue("rotate_frame_tex", texturefloat); }
	//! (description missing)
	bool set_rotate_frame_tex(float texturefloat) { return setValue("rotate_frame_tex", texturefloat); }
	//! (description missing)
	Value get_rotate_frame_tex() const { return getValue("rotate_frame_tex"); }

	//! (description missing)
	//! [Default value] false
	bool set_mirror_u(bool val) { return setValue("mirror_u", val); }
	//! (description missing)
	//! [Default value] false
	bool get_mirror_u() const { return getBool("mirror_u"); }

	//! (description missing)
	//! [Default value] false
	bool set_mirror_v(bool val) { return setValue("mirror_v", val); }
	//! (description missing)
	//! [Default value] false
	bool get_mirror_v() const { return getBool("mirror_v"); }

	//! (description missing)
	//! [Default value] true
	bool set_wrap_u(bool val) { return setValue("wrap_u", val); }
	//! (description missing)
	//! [Default value] true
	bool get_wrap_u() const { return getBool("wrap_u"); }

	//! (description missing)
	//! [Default value] true
	bool set_wrap_v(bool val) { return setValue("wrap_v", val); }
	//! (description missing)
	//! [Default value] true
	bool get_wrap_v() const { return getBool("wrap_v"); }

	//! (description missing)
	//! [Default value] false
	bool set_stagger(bool val) { return setValue("stagger", val); }
	//! (description missing)
	//! [Default value] false
	bool get_stagger() const { return getBool("stagger"); }

	//! Clamp the 'U' coordinate when accessing texture coordinate outside the [0,1] range
 	//! [Default value] false
	bool set_clamp_u(bool val) { return setValue("clamp_u", val); }
	//! Clamp the 'U' coordinate when accessing texture coordinate outside the [0,1] range
 	//! [Default value] false
	bool get_clamp_u() const { return getBool("clamp_u"); }

	//! Clamp the 'V' coordinate when accessing texture coordinate outside the [0,1] range
 	//! [Default value] false
	bool set_clamp_v(bool val) { return setValue("clamp_v", val); }
	//! Clamp the 'V' coordinate when accessing texture coordinate outside the [0,1] range
 	//! [Default value] false
	bool get_clamp_v() const { return getBool("clamp_v"); }

	//! (description missing)
	//! [Default value] 1
	bool set_repeat_u(float val) { return setValue("repeat_u", val); }
	//! (description missing)
	//! [Default value] 1
	float get_repeat_u() const { return getFloat("repeat_u"); }

	//! (description missing)
	bool set_repeat_u_tex(const Plugin& texturefloat) { return setValue("repeat_u_tex", texturefloat); }
	//! (description missing)
	bool set_repeat_u_tex(float texturefloat) { return setValue("repeat_u_tex", texturefloat); }
	//! (description missing)
	Value get_repeat_u_tex() const { return getValue("repeat_u_tex"); }

	//! (description missing)
	//! [Default value] 1
	bool set_repeat_v(float val) { return setValue("repeat_v", val); }
	//! (description missing)
	//! [Default value] 1
	float get_repeat_v() const { return getFloat("repeat_v"); }

	//! (description missing)
	bool set_repeat_v_tex(const Plugin& texturefloat) { return setValue("repeat_v_tex", texturefloat); }
	//! (description missing)
	bool set_repeat_v_tex(float texturefloat) { return setValue("repeat_v_tex", texturefloat); }
	//! (description missing)
	Value get_repeat_v_tex() const { return getValue("repeat_v_tex"); }

	//! (description missing)
	//! [Default value] 0
	bool set_offset_u(float val) { return setValue("offset_u", val); }
	//! (description missing)
	//! [Default value] 0
	float get_offset_u() const { return getFloat("offset_u"); }

	//! (description missing)
	bool set_offset_u_tex(const Plugin& texturefloat) { return setValue("offset_u_tex", texturefloat); }
	//! (description missing)
	bool set_offset_u_tex(float texturefloat) { return setValue("offset_u_tex", texturefloat); }
	//! (description missing)
	Value get_offset_u_tex() const { return getValue("offset_u_tex"); }

	//! (description missing)
	//! [Default value] 0
	bool set_offset_v(float val) { return setValue("offset_v", val); }
	//! (description missing)
	//! [Default value] 0
	float get_offset_v() const { return getFloat("offset_v"); }

	//! (description missing)
	bool set_offset_v_tex(const Plugin& texturefloat) { return setValue("offset_v_tex", texturefloat); }
	//! (description missing)
	bool set_offset_v_tex(float texturefloat) { return setValue("offset_v_tex", texturefloat); }
	//! (description missing)
	Value get_offset_v_tex() const { return getValue("offset_v_tex"); }

	//! [UI Guides] units=radians
 	//! [Default value] 0
	bool set_rotate_uv(float val) { return setValue("rotate_uv", val); }
	//! [UI Guides] units=radians
 	//! [Default value] 0
	float get_rotate_uv() const { return getFloat("rotate_uv"); }

	//! (description missing)
	bool set_rotate_uv_tex(const Plugin& texturefloat) { return setValue("rotate_uv_tex", texturefloat); }
	//! (description missing)
	bool set_rotate_uv_tex(float texturefloat) { return setValue("rotate_uv_tex", texturefloat); }
	//! (description missing)
	Value get_rotate_uv_tex() const { return getValue("rotate_uv_tex"); }

	//! (description missing)
	//! [Default value] 0
	bool set_noise_u(float val) { return setValue("noise_u", val); }
	//! (description missing)
	//! [Default value] 0
	float get_noise_u() const { return getFloat("noise_u"); }

	//! (description missing)
	bool set_noise_u_tex(const Plugin& texturefloat) { return setValue("noise_u_tex", texturefloat); }
	//! (description missing)
	bool set_noise_u_tex(float texturefloat) { return setValue("noise_u_tex", texturefloat); }
	//! (description missing)
	Value get_noise_u_tex() const { return getValue("noise_u_tex"); }

	//! (description missing)
	//! [Default value] 0
	bool set_noise_v(float val) { return setValue("noise_v", val); }
	//! (description missing)
	//! [Default value] 0
	float get_noise_v() const { return getFloat("noise_v"); }

	//! (description missing)
	bool set_noise_v_tex(const Plugin& texturefloat) { return setValue("noise_v_tex", texturefloat); }
	//! (description missing)
	bool set_noise_v_tex(float texturefloat) { return setValue("noise_v_tex", texturefloat); }
	//! (description missing)
	Value get_noise_v_tex() const { return getValue("noise_v_tex"); }

	//! The number of parameter samples to take for motion blur. 0 means the global value. 1 means motion blur should be disabled for this plugin.
 	//! [Default value] 1
	bool set_nsamples(int val) { return setValue("nsamples", val); }
	//! The number of parameter samples to take for motion blur. 0 means the global value. 1 means motion blur should be disabled for this plugin.
 	//! [Default value] 1
	int get_nsamples() const { return getInt("nsamples"); }

	//! The name of the uv channel that should be used.
 	bool set_uv_set_name(const char* str) { return setValue("uv_set_name", str); }
	//! The name of the uv channel that should be used.
 	bool set_uv_set_name(const std::string& str) { return setValue("uv_set_name", str); }
	//! The name of the uv channel that should be used.
 	std::string get_uv_set_name() const { return getString("uv_set_name"); }
};

class UVWGenModo : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "UVWGenModo"; }

	//! The name of the uv channel that should be used.
 	bool set_uv_set_name(const char* str) { return setValue("uv_set_name", str); }
	//! The name of the uv channel that should be used.
 	bool set_uv_set_name(const std::string& str) { return setValue("uv_set_name", str); }
	//! The name of the uv channel that should be used.
 	std::string get_uv_set_name() const { return getString("uv_set_name"); }

	//! Used only as a fallback when UV maps identified with a string are not supported by a sub-system ( for example RT GPU, or texture baking ).
 	//! [Default value] 0
	bool set_uv_set_index(int val) { return setValue("uv_set_index", val); }
	//! Used only as a fallback when UV maps identified with a string are not supported by a sub-system ( for example RT GPU, or texture baking ).
 	//! [Default value] 0
	int get_uv_set_index() const { return getInt("uv_set_index"); }

	//! Optional UVWGen from which the initial uvw coordinates will be taken, instead of using 'uv_set_name'.
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! Optional UVWGen from which the initial uvw coordinates will be taken, instead of using 'uv_set_name'.
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! When set to false uvwgen->getLocalUVWTransform must not be used, instead uvwgen->getUVW must be used.
 	//! [Default value] true
	bool set_uvwgen_has_local_tm(bool val) { return setValue("uvwgen_has_local_tm", val); }
	//! When set to false uvwgen->getLocalUVWTransform must not be used, instead uvwgen->getUVW must be used.
 	//! [Default value] true
	bool get_uvwgen_has_local_tm() const { return getBool("uvwgen_has_local_tm"); }

	//! Horizontal tiling mode.
 	//! [UI Guides] enum=0:Reset;1:Repeat;2:Mirror;3:Edge
 	//! [Default value] 1
	bool set_tile_mode_u(int val) { return setValue("tile_mode_u", val); }
	//! Horizontal tiling mode.
 	//! [UI Guides] enum=0:Reset;1:Repeat;2:Mirror;3:Edge
 	//! [Default value] 1
	int get_tile_mode_u() const { return getInt("tile_mode_u"); }

	//! Vertical tiling mode.
 	//! [UI Guides] enum=0:Reset;1:Repeat;2:Mirror;3:Edge
 	//! [Default value] 1
	bool set_tile_mode_v(int val) { return setValue("tile_mode_v", val); }
	//! Vertical tiling mode.
 	//! [UI Guides] enum=0:Reset;1:Repeat;2:Mirror;3:Edge
 	//! [Default value] 1
	int get_tile_mode_v() const { return getInt("tile_mode_v"); }

	//! How many times to repeat the UV space horizontally.
 	//! [Default value] 1
	bool set_repeat_u(float val) { return setValue("repeat_u", val); }
	//! How many times to repeat the UV space horizontally.
 	//! [Default value] 1
	float get_repeat_u() const { return getFloat("repeat_u"); }

	//! How many times to repeat the UV space vertically.
 	//! [Default value] 1
	bool set_repeat_v(float val) { return setValue("repeat_v", val); }
	//! How many times to repeat the UV space vertically.
 	//! [Default value] 1
	float get_repeat_v() const { return getFloat("repeat_v"); }

	//! Rotation of the UV space in radians.
 	//! [Default value] 0
	bool set_rotation(float val) { return setValue("rotation", val); }
	//! Rotation of the UV space in radians.
 	//! [Default value] 0
	float get_rotation() const { return getFloat("rotation"); }

	//! The color value of this texture is added to the generated UVW coordinates.
 	bool set_texture_offset_tex(const Plugin& texture) { return setValue("texture_offset_tex", texture); }
	//! The color value of this texture is added to the generated UVW coordinates.
 	bool set_texture_offset_tex(const AColor& texture) { return setValue("texture_offset_tex", texture); }
	//! The color value of this texture is added to the generated UVW coordinates.
 	Value get_texture_offset_tex() const { return getValue("texture_offset_tex"); }

	//! Similar to texture_offset_tex, but used for implementing random texture offsets from MODO. The value of this scalar texture is used as an offset for the U coordinate, the V offset is derived from it by a random number generator.
 	bool set_texture_offset_random(const Plugin& texturefloat) { return setValue("texture_offset_random", texturefloat); }
	//! Similar to texture_offset_tex, but used for implementing random texture offsets from MODO. The value of this scalar texture is used as an offset for the U coordinate, the V offset is derived from it by a random number generator.
 	bool set_texture_offset_random(float texturefloat) { return setValue("texture_offset_random", texturefloat); }
	//! Similar to texture_offset_tex, but used for implementing random texture offsets from MODO. The value of this scalar texture is used as an offset for the U coordinate, the V offset is derived from it by a random number generator.
 	Value get_texture_offset_random() const { return getValue("texture_offset_random"); }

	//! Multiplier for the values in the 'texture_offset' texture.
 	//! [Default value] 1
	bool set_texture_offset_amplitude(float val) { return setValue("texture_offset_amplitude", val); }
	//! Multiplier for the values in the 'texture_offset' texture.
 	//! [Default value] 1
	float get_texture_offset_amplitude() const { return getFloat("texture_offset_amplitude"); }

	//! These are the m00...m22 channels from MODO. The matrix is in row-major order.
 	//! [Default value] Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1))
	bool set_uv_matrix(const Matrix& matrix) { return setValue("uv_matrix", matrix); }
	//! These are the m00...m22 channels from MODO. The matrix is in row-major order.
 	//! [Default value] Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1))
	Matrix get_uv_matrix() const { return getMatrix("uv_matrix"); }

	//! The cylindrical projection applies the repeat_u/repeat_v options a little differently.
 	//! [Default value] false
	bool set_cylindrical_base_uvwgen(bool val) { return setValue("cylindrical_base_uvwgen", val); }
	//! The cylindrical projection applies the repeat_u/repeat_v options a little differently.
 	//! [Default value] false
	bool get_cylindrical_base_uvwgen() const { return getBool("cylindrical_base_uvwgen"); }

	//! Changes the pivot used to apply the repeat_u/repeat_v and uv_matrix transformations. Only used when uvwgen is NULL  i.e. the UV coordinates come from an UV map and not from a projection.
 	//! [Default value] false
	bool set_legacy_uv_rotation(bool val) { return setValue("legacy_uv_rotation", val); }
	//! Changes the pivot used to apply the repeat_u/repeat_v and uv_matrix transformations. Only used when uvwgen is NULL  i.e. the UV coordinates come from an UV map and not from a projection.
 	//! [Default value] false
	bool get_legacy_uv_rotation() const { return getBool("legacy_uv_rotation"); }
};

class UVWGenObject : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "UVWGenObject"; }

	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	bool set_uvw_transform(const Transform& transform) { return setValue("uvw_transform", transform); }
	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	Transform get_uvw_transform() const { return getTransform("uvw_transform"); }

	//! Additional scale factor for the texture derivatives
 	//! [Default value] 1
	bool set_duvw_scale(float val) { return setValue("duvw_scale", val); }
	//! Additional scale factor for the texture derivatives
 	//! [Default value] 1
	float get_duvw_scale() const { return getFloat("duvw_scale"); }
};

class UVWGenObjectBBox : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "UVWGenObjectBBox"; }

	//! Initial transformation on the uvw coordinates, before mirror, crop etc
 	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	bool set_uvw_transform(const Transform& transform) { return setValue("uvw_transform", transform); }
	//! Initial transformation on the uvw coordinates, before mirror, crop etc
 	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	Transform get_uvw_transform() const { return getTransform("uvw_transform"); }

	//! (description missing)
	bool set_uvw_transform_tex(const Plugin& texturetransform) { return setValue("uvw_transform_tex", texturetransform); }
	//! (description missing)
	bool set_uvw_transform_tex(const Transform& texturetransform) { return setValue("uvw_transform_tex", texturetransform); }
	//! (description missing)
	Value get_uvw_transform_tex() const { return getValue("uvw_transform_tex"); }

	//! Final transformation on the resulting uvw coordinates, after mirror, crop etc
 	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	bool set_tex_transform(const Transform& transform) { return setValue("tex_transform", transform); }
	//! Final transformation on the resulting uvw coordinates, after mirror, crop etc
 	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	Transform get_tex_transform() const { return getTransform("tex_transform"); }

	//! Number of uvw transform samples
 	//! [Default value] 0
	bool set_nsamples(int val) { return setValue("nsamples", val); }
	//! Number of uvw transform samples
 	//! [Default value] 0
	int get_nsamples() const { return getInt("nsamples"); }

	//! 0 - no wrapping, 1 - wrap, 2 - mirror tile
 	//! [Default value] 0
	bool set_wrap_u(int val) { return setValue("wrap_u", val); }
	//! 0 - no wrapping, 1 - wrap, 2 - mirror tile
 	//! [Default value] 0
	int get_wrap_u() const { return getInt("wrap_u"); }

	//! 0 - no wrapping, 1 - wrap, 2 - mirror tile
 	//! [Default value] 0
	bool set_wrap_v(int val) { return setValue("wrap_v", val); }
	//! 0 - no wrapping, 1 - wrap, 2 - mirror tile
 	//! [Default value] 0
	int get_wrap_v() const { return getInt("wrap_v"); }

	//! 0 - no wrapping, 1 - wrap, 2 - mirror tile
 	//! [Default value] 0
	bool set_wrap_w(int val) { return setValue("wrap_w", val); }
	//! 0 - no wrapping, 1 - wrap, 2 - mirror tile
 	//! [Default value] 0
	int get_wrap_w() const { return getInt("wrap_w"); }

	//! 1 to crop in the u-direction
 	//! [Default value] 0
	bool set_crop_u(int val) { return setValue("crop_u", val); }
	//! 1 to crop in the u-direction
 	//! [Default value] 0
	int get_crop_u() const { return getInt("crop_u"); }

	//! 1 to crop in the v-direction
 	//! [Default value] 0
	bool set_crop_v(int val) { return setValue("crop_v", val); }
	//! 1 to crop in the v-direction
 	//! [Default value] 0
	int get_crop_v() const { return getInt("crop_v"); }

	//! 1 to crop in the w-direction
 	//! [Default value] 0
	bool set_crop_w(int val) { return setValue("crop_w", val); }
	//! 1 to crop in the w-direction
 	//! [Default value] 0
	int get_crop_w() const { return getInt("crop_w"); }

	//! Coverage
 	//! [Default value] Vector(1, 1, 1)
	bool set_coverage(const Vector& vector) { return setValue("coverage", vector); }
	//! Coverage
 	//! [Default value] Vector(1, 1, 1)
	Vector get_coverage() const { return getVector("coverage"); }

	//! Wrap mode (0 - wrap on 0.5 boundary; 1 - wrap on integer boundary
 	//! [UI Guides] enum=0:On 0.5 boundary; 1:On integer boundary
 	//! [Default value] 0
	bool set_wrap_mode(int val) { return setValue("wrap_mode", val); }
	//! Wrap mode (0 - wrap on 0.5 boundary; 1 - wrap on integer boundary
 	//! [UI Guides] enum=0:On 0.5 boundary; 1:On integer boundary
 	//! [Default value] 0
	int get_wrap_mode() const { return getInt("wrap_mode"); }

	//! Additional scale factor for the texture derivatives
 	//! [Default value] 1
	bool set_duvw_scale(float val) { return setValue("duvw_scale", val); }
	//! Additional scale factor for the texture derivatives
 	//! [Default value] 1
	float get_duvw_scale() const { return getFloat("duvw_scale"); }
};

class UVWGenPlanarWorld : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "UVWGenPlanarWorld"; }

	//! Initial transformation on the uvw coordinates, before mirror, crop etc
 	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	bool set_uvw_transform(const Transform& transform) { return setValue("uvw_transform", transform); }
	//! Initial transformation on the uvw coordinates, before mirror, crop etc
 	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	Transform get_uvw_transform() const { return getTransform("uvw_transform"); }

	//! (description missing)
	bool set_uvw_transform_tex(const Plugin& texturetransform) { return setValue("uvw_transform_tex", texturetransform); }
	//! (description missing)
	bool set_uvw_transform_tex(const Transform& texturetransform) { return setValue("uvw_transform_tex", texturetransform); }
	//! (description missing)
	Value get_uvw_transform_tex() const { return getValue("uvw_transform_tex"); }

	//! Final transformation on the resulting uvw coordinates, after mirror, crop etc
 	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	bool set_tex_transform(const Transform& transform) { return setValue("tex_transform", transform); }
	//! Final transformation on the resulting uvw coordinates, after mirror, crop etc
 	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	Transform get_tex_transform() const { return getTransform("tex_transform"); }

	//! Number of uvw transform samples
 	//! [Default value] 0
	bool set_nsamples(int val) { return setValue("nsamples", val); }
	//! Number of uvw transform samples
 	//! [Default value] 0
	int get_nsamples() const { return getInt("nsamples"); }

	//! 0 - no wrapping, 1 - wrap, 2 - mirror tile
 	//! [Default value] 0
	bool set_wrap_u(int val) { return setValue("wrap_u", val); }
	//! 0 - no wrapping, 1 - wrap, 2 - mirror tile
 	//! [Default value] 0
	int get_wrap_u() const { return getInt("wrap_u"); }

	//! 0 - no wrapping, 1 - wrap, 2 - mirror tile
 	//! [Default value] 0
	bool set_wrap_v(int val) { return setValue("wrap_v", val); }
	//! 0 - no wrapping, 1 - wrap, 2 - mirror tile
 	//! [Default value] 0
	int get_wrap_v() const { return getInt("wrap_v"); }

	//! 0 - no wrapping, 1 - wrap, 2 - mirror tile
 	//! [Default value] 0
	bool set_wrap_w(int val) { return setValue("wrap_w", val); }
	//! 0 - no wrapping, 1 - wrap, 2 - mirror tile
 	//! [Default value] 0
	int get_wrap_w() const { return getInt("wrap_w"); }

	//! 1 to crop in the u-direction
 	//! [Default value] 0
	bool set_crop_u(int val) { return setValue("crop_u", val); }
	//! 1 to crop in the u-direction
 	//! [Default value] 0
	int get_crop_u() const { return getInt("crop_u"); }

	//! 1 to crop in the v-direction
 	//! [Default value] 0
	bool set_crop_v(int val) { return setValue("crop_v", val); }
	//! 1 to crop in the v-direction
 	//! [Default value] 0
	int get_crop_v() const { return getInt("crop_v"); }

	//! 1 to crop in the w-direction
 	//! [Default value] 0
	bool set_crop_w(int val) { return setValue("crop_w", val); }
	//! 1 to crop in the w-direction
 	//! [Default value] 0
	int get_crop_w() const { return getInt("crop_w"); }

	//! Coverage
 	//! [Default value] Vector(1, 1, 1)
	bool set_coverage(const Vector& vector) { return setValue("coverage", vector); }
	//! Coverage
 	//! [Default value] Vector(1, 1, 1)
	Vector get_coverage() const { return getVector("coverage"); }

	//! Wrap mode (0 - wrap on 0.5 boundary; 1 - wrap on integer boundary
 	//! [UI Guides] enum=0:On 0.5 boundary; 1:On integer boundary
 	//! [Default value] 0
	bool set_wrap_mode(int val) { return setValue("wrap_mode", val); }
	//! Wrap mode (0 - wrap on 0.5 boundary; 1 - wrap on integer boundary
 	//! [UI Guides] enum=0:On 0.5 boundary; 1:On integer boundary
 	//! [Default value] 0
	int get_wrap_mode() const { return getInt("wrap_mode"); }

	//! Additional scale factor for the texture derivatives
 	//! [Default value] 1
	bool set_duvw_scale(float val) { return setValue("duvw_scale", val); }
	//! Additional scale factor for the texture derivatives
 	//! [Default value] 1
	float get_duvw_scale() const { return getFloat("duvw_scale"); }
};

class UVWGenProjection : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "UVWGenProjection"; }

	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	bool set_uvw_transform(const Transform& transform) { return setValue("uvw_transform", transform); }
	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	Transform get_uvw_transform() const { return getTransform("uvw_transform"); }

	//! (description missing)
	bool set_uvw_transform_tex(const Plugin& texturetransform) { return setValue("uvw_transform_tex", texturetransform); }
	//! (description missing)
	bool set_uvw_transform_tex(const Transform& texturetransform) { return setValue("uvw_transform_tex", texturetransform); }
	//! (description missing)
	Value get_uvw_transform_tex() const { return getValue("uvw_transform_tex"); }

	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	bool set_tex_transform(const Transform& transform) { return setValue("tex_transform", transform); }
	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	Transform get_tex_transform() const { return getTransform("tex_transform"); }

	//! Mapping type (0 - none; 1 - planar; 2 - spherical; 3 - cylindrical; 4 - ball; 5 - cubic; 6 - triplanar; 8 - perspective; 9 - modo cubic; 10 - modo box
 	//! [UI Guides] enum=0:Node;1:Planar;2:Spherical;3:Cylindrical;4:Ball;5:Cubic;6:Triplanar;8:Perspective; 9:Modo cubic; 10:Modo box;
 	//! [Default value] 1
	bool set_type(int val) { return setValue("type", val); }
	//! Mapping type (0 - none; 1 - planar; 2 - spherical; 3 - cylindrical; 4 - ball; 5 - cubic; 6 - triplanar; 8 - perspective; 9 - modo cubic; 10 - modo box
 	//! [UI Guides] enum=0:Node;1:Planar;2:Spherical;3:Cylindrical;4:Ball;5:Cubic;6:Triplanar;8:Perspective; 9:Modo cubic; 10:Modo box;
 	//! [Default value] 1
	int get_type() const { return getInt("type"); }

	//! (description missing)
	//! [Default value] 3.14159
	bool set_u_angle(float val) { return setValue("u_angle", val); }
	//! (description missing)
	//! [Default value] 3.14159
	float get_u_angle() const { return getFloat("u_angle"); }

	//! (description missing)
	//! [Default value] 1.5708
	bool set_v_angle(float val) { return setValue("v_angle", val); }
	//! (description missing)
	//! [Default value] 1.5708
	float get_v_angle() const { return getFloat("v_angle"); }

	//! (description missing)
	bool set_camera_settings(const Plugin& plugin) { return setValue("camera_settings", plugin); }
	//! (description missing)
	Plugin get_camera_settings() const { return getPlugin("camera_settings"); }

	//! (description missing)
	bool set_camera_view(const Plugin& plugin) { return setValue("camera_view", plugin); }
	//! (description missing)
	Plugin get_camera_view() const { return getPlugin("camera_view"); }

	//! 0 - Fit fill; 1 - Horizontal; 2 - Vertical;
 	//! [UI Guides] enum=0:Fit fill;1:Horizontal;2:Vertical;
 	//! [Default value] 0
	bool set_fitfill(int val) { return setValue("fitfill", val); }
	//! 0 - Fit fill; 1 - Horizontal; 2 - Vertical;
 	//! [UI Guides] enum=0:Fit fill;1:Horizontal;2:Vertical;
 	//! [Default value] 0
	int get_fitfill() const { return getInt("fitfill"); }

	//! 0 - None; 1 - Match camera film gate; 2 - Match camera resolution;
 	//! [UI Guides] enum=0:None;1:Match camera file gate;2:Match camera resolution;
 	//! [Default value] 0
	bool set_fittype(int val) { return setValue("fittype", val); }
	//! 0 - None; 1 - Match camera film gate; 2 - Match camera resolution;
 	//! [UI Guides] enum=0:None;1:Match camera file gate;2:Match camera resolution;
 	//! [Default value] 0
	int get_fittype() const { return getInt("fittype"); }

	//! If we are projecting a bitmap, this is the bitmap's buffer, we need it to implement vertical/horizontal fit
 	bool set_bitmap(const Plugin& plugin) { return setValue("bitmap", plugin); }
	//! If we are projecting a bitmap, this is the bitmap's buffer, we need it to implement vertical/horizontal fit
 	Plugin get_bitmap() const { return getPlugin("bitmap"); }

	//! (description missing)
	//! [Default value] 1
	bool set_film_gate_w(float val) { return setValue("film_gate_w", val); }
	//! (description missing)
	//! [Default value] 1
	float get_film_gate_w() const { return getFloat("film_gate_w"); }

	//! (description missing)
	//! [Default value] 1
	bool set_film_gate_h(float val) { return setValue("film_gate_h", val); }
	//! (description missing)
	//! [Default value] 1
	float get_film_gate_h() const { return getFloat("film_gate_h"); }

	//! Determine whether to project on back faces of polygons when in perspective mode
 	//! [Default value] false
	bool set_hide_backface(bool val) { return setValue("hide_backface", val); }
	//! Determine whether to project on back faces of polygons when in perspective mode
 	//! [Default value] false
	bool get_hide_backface() const { return getBool("hide_backface"); }

	//! Determine whether to project on occluded points when in perspective mode
 	//! [Default value] false
	bool set_hide_occluded(bool val) { return setValue("hide_occluded", val); }
	//! Determine whether to project on occluded points when in perspective mode
 	//! [Default value] false
	bool get_hide_occluded() const { return getBool("hide_occluded"); }

	//! If true the projection will be applied in the object space of the currently shaded geometry.
 	//! [Default value] false
	bool set_object_space(bool val) { return setValue("object_space", val); }
	//! If true the projection will be applied in the object space of the currently shaded geometry.
 	//! [Default value] false
	bool get_object_space() const { return getBool("object_space"); }
};

class UVWGenSwitch : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "UVWGenSwitch"; }

	//! (description missing)
	bool set_nodes(const ValueList& pluginList) { return setValue("nodes", pluginList); }
	//! (description missing)
	ValueList get_nodes() const { return getValueList("nodes"); }

	//! (description missing)
	bool set_uvwgens(const ValueList& pluginList) { return setValue("uvwgens", pluginList); }
	//! (description missing)
	ValueList get_uvwgens() const { return getValueList("uvwgens"); }

	//! (description missing)
	bool set_default(const Plugin& plugin) { return setValue("default", plugin); }
	//! (description missing)
	Plugin get_default() const { return getPlugin("default"); }
};

class VRayClipper : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "VRayClipper"; }

	//! (description missing)
	//! [Default value] true
	bool set_enabled(bool val) { return setValue("enabled", val); }
	//! (description missing)
	//! [Default value] true
	bool get_enabled() const { return getBool("enabled"); }

	//! If enabled, the clipper will affect area light sources as well.
 	//! [Default value] true
	bool set_affect_light(bool val) { return setValue("affect_light", val); }
	//! If enabled, the clipper will affect area light sources as well.
 	//! [Default value] true
	bool get_affect_light() const { return getBool("affect_light"); }

	//! If enabled, the clipper will affect objects as they are directly seen by the camera, but they will appear unchanged to reflection/refraction/GI rays.
 	//! [Default value] false
	bool set_only_camera_rays(bool val) { return setValue("only_camera_rays", val); }
	//! If enabled, the clipper will affect objects as they are directly seen by the camera, but they will appear unchanged to reflection/refraction/GI rays.
 	//! [Default value] false
	bool get_only_camera_rays() const { return getBool("only_camera_rays"); }

	//! Enables or disables the clipping of lights geometry (for example a mesh light).
 	//! [UI Guides] displayName=Clip Lights Geometry
 	//! [Default value] true
	bool set_clip_lights(bool val) { return setValue("clip_lights", val); }
	//! Enables or disables the clipping of lights geometry (for example a mesh light).
 	//! [UI Guides] displayName=Clip Lights Geometry
 	//! [Default value] true
	bool get_clip_lights() const { return getBool("clip_lights"); }

	//! When ON holes in geometry inside other geometries will be filled
 	//! [UI Guides] displayName=Fill inner cavities
 	//! [Default value] false
	bool set_fill_cavities(bool val) { return setValue("fill_cavities", val); }
	//! When ON holes in geometry inside other geometries will be filled
 	//! [UI Guides] displayName=Fill inner cavities
 	//! [Default value] false
	bool get_fill_cavities() const { return getBool("fill_cavities"); }

	//! When enabled, the clipper will use the material of each clipped object to fill in the resulting holes. When this is off, the material applied to the clipper object itself will be used.
 	//! [UI Guides] displayName=Use Object Material
 	//! [Default value] false
	bool set_use_obj_mtl(bool val) { return setValue("use_obj_mtl", val); }
	//! When enabled, the clipper will use the material of each clipped object to fill in the resulting holes. When this is off, the material applied to the clipper object itself will be used.
 	//! [UI Guides] displayName=Use Object Material
 	//! [Default value] false
	bool get_use_obj_mtl() const { return getBool("use_obj_mtl"); }

	//! (description missing)
	//! [Default value] false
	bool set_set_material_id(bool val) { return setValue("set_material_id", val); }
	//! (description missing)
	//! [Default value] false
	bool get_set_material_id() const { return getBool("set_material_id"); }

	//! (description missing)
	//! [Default value] 1
	bool set_material_id(int val) { return setValue("material_id", val); }
	//! (description missing)
	//! [Default value] 1
	int get_material_id() const { return getInt("material_id"); }

	//! List of node plugins to consider for inclusion/exclusion
 	//! [UI Guides] displayName=Exclude, startRollout=, attributes=objectSet
 	bool set_exclusion_nodes(const ValueList& pluginList) { return setValue("exclusion_nodes", pluginList); }
	//! List of node plugins to consider for inclusion/exclusion
 	//! [UI Guides] displayName=Exclude, startRollout=, attributes=objectSet
 	ValueList get_exclusion_nodes() const { return getValueList("exclusion_nodes"); }

	//! false to include the nodes listed, true to exclude the nodes listed.
 	//! [UI Guides] displayName=As Exclusive list
 	//! [Default value] true
	bool set_exclusion_mode(bool val) { return setValue("exclusion_mode", val); }
	//! false to include the nodes listed, true to exclude the nodes listed.
 	//! [UI Guides] displayName=As Exclusive list
 	//! [Default value] true
	bool get_exclusion_mode() const { return getBool("exclusion_mode"); }

	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	bool set_transform(const Transform& transform) { return setValue("transform", transform); }
	//! (description missing)
	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	Transform get_transform() const { return getTransform("transform"); }

	//! (description missing)
	bool set_material(const Plugin& plugin) { return setValue("material", plugin); }
	//! (description missing)
	Plugin get_material() const { return getPlugin("material"); }

	//! The object ID assigned to geometry that is clipped by the clipper. This is used only when there is no clip mesh specified.
 	//! [UI Guides] displayName=Object ID, minValue=0
 	//! [Default value] 0
	bool set_object_id(int val) { return setValue("object_id", val); }
	//! The object ID assigned to geometry that is clipped by the clipper. This is used only when there is no clip mesh specified.
 	//! [UI Guides] displayName=Object ID, minValue=0
 	//! [Default value] 0
	int get_object_id() const { return getInt("object_id"); }

	//! Mesh plugin to use as a clipping mesh instead of a simple plane.
 	bool set_clip_mesh(const Plugin& plugin) { return setValue("clip_mesh", plugin); }
	//! Mesh plugin to use as a clipping mesh instead of a simple plane.
 	Plugin get_clip_mesh() const { return getPlugin("clip_mesh"); }

	//! Specifies the boolean operation to perform: 0 - intersection, 1 - substraction(scene - clip_mesh).
 	//! [UI Guides] displayName=Mesh Operation, enum=0:Intersection;1:Substraction scene-mesh
 	//! [Default value] 1
	bool set_invert_inside(int val) { return setValue("invert_inside", val); }
	//! Specifies the boolean operation to perform: 0 - intersection, 1 - substraction(scene - clip_mesh).
 	//! [UI Guides] displayName=Mesh Operation, enum=0:Intersection;1:Substraction scene-mesh
 	//! [Default value] 1
	int get_invert_inside() const { return getInt("invert_inside"); }
};

class VRayScene : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "VRayScene"; }

	//! Path to a *.vrscene file
 	//! [UI Guides] fileAsset=vrscene, fileAssetNames=V-Ray Scene, fileAssetOp=load, displayName=File Path
 	bool set_filepath(const char* str) { return setValue("filepath", str); }
	//! Path to a *.vrscene file
 	//! [UI Guides] fileAsset=vrscene, fileAssetNames=V-Ray Scene, fileAssetOp=load, displayName=File Path
 	bool set_filepath(const std::string& str) { return setValue("filepath", str); }
	//! Path to a *.vrscene file
 	//! [UI Guides] fileAsset=vrscene, fileAssetNames=V-Ray Scene, fileAssetOp=load, displayName=File Path
 	std::string get_filepath() const { return getString("filepath"); }

	//! Additional transform
 	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	bool set_transform(const Transform& transform) { return setValue("transform", transform); }
	//! Additional transform
 	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	Transform get_transform() const { return getTransform("transform"); }

	//! Use additional transform
 	//! [Default value] true
	bool set_use_transform(bool val) { return setValue("use_transform", val); }
	//! Use additional transform
 	//! [Default value] true
	bool get_use_transform() const { return getBool("use_transform"); }

	//! Add nodes from the included files
 	//! [UI Guides] displayName=Include geometry, startRollout=Scene elements
 	//! [Default value] true
	bool set_add_nodes(bool val) { return setValue("add_nodes", val); }
	//! Add nodes from the included files
 	//! [UI Guides] displayName=Include geometry, startRollout=Scene elements
 	//! [Default value] true
	bool get_add_nodes() const { return getBool("add_nodes"); }

	//! Add lights from the included files
 	//! [UI Guides] displayName=Include lights
 	//! [Default value] true
	bool set_add_lights(bool val) { return setValue("add_lights", val); }
	//! Add lights from the included files
 	//! [UI Guides] displayName=Include lights
 	//! [Default value] true
	bool get_add_lights() const { return getBool("add_lights"); }

	//! Override animation settings
 	//! [UI Guides] displayName=Enable animation override, startRollout=Animation override
 	//! [Default value] false
	bool set_anim_override(bool val) { return setValue("anim_override", val); }
	//! Override animation settings
 	//! [UI Guides] displayName=Enable animation override, startRollout=Animation override
 	//! [Default value] false
	bool get_anim_override() const { return getBool("anim_override"); }

	//! Animation playback speed
 	//! [UI Guides] displayName=Speed, minValue=0.0, enableIf: ?anim_override=1
 	//! [Default value] 1
	bool set_anim_speed(float val) { return setValue("anim_speed", val); }
	//! Animation playback speed
 	//! [UI Guides] displayName=Speed, minValue=0.0, enableIf: ?anim_override=1
 	//! [Default value] 1
	float get_anim_speed() const { return getFloat("anim_speed"); }

	//! Animation playback type (0 - Loop; 1 - Once; 2 - Ping-Pong; 3 - Still)
 	//! [UI Guides] enum=0:Loop;1:Once;2:Ping-Pong;3:Still, displayName=Playback Type, enableIf: ?anim_override=1
 	//! [Default value] 0
	bool set_anim_type(int val) { return setValue("anim_type", val); }
	//! Animation playback type (0 - Loop; 1 - Once; 2 - Ping-Pong; 3 - Still)
 	//! [UI Guides] enum=0:Loop;1:Once;2:Ping-Pong;3:Still, displayName=Playback Type, enableIf: ?anim_override=1
 	//! [Default value] 0
	int get_anim_type() const { return getInt("anim_type"); }

	//! Animation initial frame offset
 	//! [UI Guides] displayName=Offset, minValue=0.0, enableIf: ?anim_override=1
 	//! [Default value] 0
	bool set_anim_offset(float val) { return setValue("anim_offset", val); }
	//! Animation initial frame offset
 	//! [UI Guides] displayName=Offset, minValue=0.0, enableIf: ?anim_override=1
 	//! [Default value] 0
	float get_anim_offset() const { return getFloat("anim_offset"); }

	//! Specifies the first frame of the animation sequence
 	//! [UI Guides] displayName=Start, minValue=0, enableIf: ?anim_override=1
 	//! [Default value] 0
	bool set_anim_start(int val) { return setValue("anim_start", val); }
	//! Specifies the first frame of the animation sequence
 	//! [UI Guides] displayName=Start, minValue=0, enableIf: ?anim_override=1
 	//! [Default value] 0
	int get_anim_start() const { return getInt("anim_start"); }

	//! Specifies the length of the animation sequence
 	//! [UI Guides] displayName=Length, minValue=1, enableIf: ?anim_override=1
 	//! [Default value] 0
	bool set_anim_length(int val) { return setValue("anim_length", val); }
	//! Specifies the length of the animation sequence
 	//! [UI Guides] displayName=Length, minValue=1, enableIf: ?anim_override=1
 	//! [Default value] 0
	int get_anim_length() const { return getInt("anim_length"); }

	//! Override material
 	bool set_material_override(const Plugin& plugin) { return setValue("material_override", plugin); }
	//! Override material
 	Plugin get_material_override() const { return getPlugin("material_override"); }

	//! Plugin names list to hide
 	bool set_hidden_objects(const ValueList& stringList) { return setValue("hidden_objects", stringList); }
	//! Plugin names list to hide
 	ValueList get_hidden_objects() const { return getValueList("hidden_objects"); }

	//! Disable loader
 	//! [Default value] false
	bool set_disable(bool val) { return setValue("disable", val); }
	//! Disable loader
 	//! [Default value] false
	bool get_disable() const { return getBool("disable"); }

	//! Object ID override
 	//! [Default value] -1
	bool set_objectID(int val) { return setValue("objectID", val); }
	//! Object ID override
 	//! [Default value] -1
	int get_objectID() const { return getInt("objectID"); }

	//! Use MtlWrapper
 	//! [Default value] false
	bool set_mw_use(bool val) { return setValue("mw_use", val); }
	//! Use MtlWrapper
 	//! [Default value] false
	bool get_mw_use() const { return getBool("mw_use"); }

	//! Allow enable/disable of irradiance map per surface.
 	//! [UI Guides] displayName=Use irradiance map, startRollout=Additional surface properties
 	//! [Default value] true
	bool set_mw_use_irrad_map(bool val) { return setValue("mw_use_irrad_map", val); }
	//! Allow enable/disable of irradiance map per surface.
 	//! [UI Guides] displayName=Use irradiance map, startRollout=Additional surface properties
 	//! [Default value] true
	bool get_mw_use_irrad_map() const { return getBool("mw_use_irrad_map"); }

	//! Controls the GI generated by the material.
 	//! [UI Guides] displayName=Generated GI mult., minValue=0.0
 	//! [Default value] 1
	bool set_mw_generate_gi(float val) { return setValue("mw_generate_gi", val); }
	//! Controls the GI generated by the material.
 	//! [UI Guides] displayName=Generated GI mult., minValue=0.0
 	//! [Default value] 1
	float get_mw_generate_gi() const { return getFloat("mw_generate_gi"); }

	//! Controls the GI received by the material.
 	//! [UI Guides] displayName=Received GI mult., minValue=0.0
 	//! [Default value] 1
	bool set_mw_receive_gi(float val) { return setValue("mw_receive_gi", val); }
	//! Controls the GI received by the material.
 	//! [UI Guides] displayName=Received GI mult., minValue=0.0
 	//! [Default value] 1
	float get_mw_receive_gi() const { return getFloat("mw_receive_gi"); }

	//! Controls the caustics generated by the material.
 	//! [UI Guides] displayName=Generated caustics mult., minValue=0.0
 	//! [Default value] 1
	bool set_mw_generate_caustics(float val) { return setValue("mw_generate_caustics", val); }
	//! Controls the caustics generated by the material.
 	//! [UI Guides] displayName=Generated caustics mult., minValue=0.0
 	//! [Default value] 1
	float get_mw_generate_caustics() const { return getFloat("mw_generate_caustics"); }

	//! Controls the caustics received by the material.
 	//! [UI Guides] displayName=Received caustics mult., minValue=0.0
 	//! [Default value] 1
	bool set_mw_receive_caustics(float val) { return setValue("mw_receive_caustics", val); }
	//! Controls the caustics received by the material.
 	//! [UI Guides] displayName=Received caustics mult., minValue=0.0
 	//! [Default value] 1
	float get_mw_receive_caustics() const { return getFloat("mw_receive_caustics"); }

	//! The contribution of the resulting color to the alpha channel.
 	//! [UI Guides] startRollout=Matte properties, minValue=-1, maxValue=1
 	//! [Default value] 1
	bool set_mw_alpha_contribution(float val) { return setValue("mw_alpha_contribution", val); }
	//! The contribution of the resulting color to the alpha channel.
 	//! [UI Guides] startRollout=Matte properties, minValue=-1, maxValue=1
 	//! [Default value] 1
	float get_mw_alpha_contribution() const { return getFloat("mw_alpha_contribution"); }

	//! Makes the material appear as a matte material, which shows the background, instead of the base material, when viewed directly.
 	//! [Default value] false
	bool set_mw_matte_surface(bool val) { return setValue("mw_matte_surface", val); }
	//! Makes the material appear as a matte material, which shows the background, instead of the base material, when viewed directly.
 	//! [Default value] false
	bool get_mw_matte_surface() const { return getBool("mw_matte_surface"); }

	//! Turn this on to make shadows visible on the matte surface.
 	//! [UI Guides] enableIf: ?matte_surface=1
 	//! [Default value] false
	bool set_mw_shadows(bool val) { return setValue("mw_shadows", val); }
	//! Turn this on to make shadows visible on the matte surface.
 	//! [UI Guides] enableIf: ?matte_surface=1
 	//! [Default value] false
	bool get_mw_shadows() const { return getBool("mw_shadows"); }

	//! Turn this on to make shadows affect the alpha contribution of the matte surface.
 	//! [UI Guides] enableIf: ?matte_surface=1
 	//! [Default value] false
	bool set_mw_affect_alpha(bool val) { return setValue("mw_affect_alpha", val); }
	//! Turn this on to make shadows affect the alpha contribution of the matte surface.
 	//! [UI Guides] enableIf: ?matte_surface=1
 	//! [Default value] false
	bool get_mw_affect_alpha() const { return getBool("mw_affect_alpha"); }

	//! Tint for the shadows on the matte surface.
 	//! [UI Guides] enableIf: ?matte_surface=1
 	//! [Default value] Color(0, 0, 0)
	bool set_mw_shadow_tint_color(const Color& color) { return setValue("mw_shadow_tint_color", color); }
	//! Tint for the shadows on the matte surface.
 	//! [UI Guides] enableIf: ?matte_surface=1
 	//! [Default value] Color(0, 0, 0)
	Color get_mw_shadow_tint_color() const { return getColor("mw_shadow_tint_color"); }

	//! An optional brightness parameter for the shadows on the matte surface.A value of 0.0 will make the shadows completely invisible, while a value of 1.0 will show the full shadows.
 	//! [UI Guides] enableIf: ?matte_surface=1, minValue=0, maxValue=1
 	//! [Default value] 1
	bool set_mw_shadow_brightness(float val) { return setValue("mw_shadow_brightness", val); }
	//! An optional brightness parameter for the shadows on the matte surface.A value of 0.0 will make the shadows completely invisible, while a value of 1.0 will show the full shadows.
 	//! [UI Guides] enableIf: ?matte_surface=1, minValue=0, maxValue=1
 	//! [Default value] 1
	float get_mw_shadow_brightness() const { return getFloat("mw_shadow_brightness"); }

	//! Shows the reflections of the base material.
 	//! [UI Guides] enableIf: ?matte_surface=1, minValue=0, maxValue=1
 	//! [Default value] 1
	bool set_mw_reflection_amount(float val) { return setValue("mw_reflection_amount", val); }
	//! Shows the reflections of the base material.
 	//! [UI Guides] enableIf: ?matte_surface=1, minValue=0, maxValue=1
 	//! [Default value] 1
	float get_mw_reflection_amount() const { return getFloat("mw_reflection_amount"); }

	//! Shows the refractions of the base material.
 	//! [UI Guides] enableIf: ?matte_surface=1, minValue=0, maxValue=1
 	//! [Default value] 1
	bool set_mw_refraction_amount(float val) { return setValue("mw_refraction_amount", val); }
	//! Shows the refractions of the base material.
 	//! [UI Guides] enableIf: ?matte_surface=1, minValue=0, maxValue=1
 	//! [Default value] 1
	float get_mw_refraction_amount() const { return getFloat("mw_refraction_amount"); }

	//! Determines the amount of gi shadows.
 	//! [UI Guides] displayName=GI amount, enableIf: ?matte_surface=1, minValue=0, maxValue=1
 	//! [Default value] 1
	bool set_mw_gi_amount(float val) { return setValue("mw_gi_amount", val); }
	//! Determines the amount of gi shadows.
 	//! [UI Guides] displayName=GI amount, enableIf: ?matte_surface=1, minValue=0, maxValue=1
 	//! [Default value] 1
	float get_mw_gi_amount() const { return getFloat("mw_gi_amount"); }

	//! This will cause the material to appear as a matte object in reflections, refractions, GI etc for other matte objects.
 	//! [UI Guides] displayName=No GI on other mattes, enableIf: ?matte_surface=1
 	//! [Default value] true
	bool set_mw_no_gi_on_other_mattes(bool val) { return setValue("mw_no_gi_on_other_mattes", val); }
	//! This will cause the material to appear as a matte object in reflections, refractions, GI etc for other matte objects.
 	//! [UI Guides] displayName=No GI on other mattes, enableIf: ?matte_surface=1
 	//! [Default value] true
	bool get_mw_no_gi_on_other_mattes() const { return getBool("mw_no_gi_on_other_mattes"); }

	//! Set this to 1 to make the material act as matte for all secondary rays (reflections and refractions); if set to 2, the material will perform automatic projection mapping of the environment map on the matte geometry
 	//! [UI Guides] displayName=Matte for sec. rays, enum=0:Disable;1:Without Projection Mapping;2:With Projection Mapping, enableIf: ?matte_surface=1
 	//! [Default value] 0
	bool set_mw_matte_for_secondary_rays(int val) { return setValue("mw_matte_for_secondary_rays", val); }
	//! Set this to 1 to make the material act as matte for all secondary rays (reflections and refractions); if set to 2, the material will perform automatic projection mapping of the environment map on the matte geometry
 	//! [UI Guides] displayName=Matte for sec. rays, enum=0:Disable;1:Without Projection Mapping;2:With Projection Mapping, enableIf: ?matte_surface=1
 	//! [Default value] 0
	int get_mw_matte_for_secondary_rays() const { return getInt("mw_matte_for_secondary_rays"); }

	//! If two objects have different GI surface ids, the light cache samples of the two objects will not be blended
 	//! [UI Guides] displayName=GI surface ID, minValue0, startRollout=Miscellaneous
 	//! [Default value] 0
	bool set_mw_gi_surface_id(int val) { return setValue("mw_gi_surface_id", val); }
	//! If two objects have different GI surface ids, the light cache samples of the two objects will not be blended
 	//! [UI Guides] displayName=GI surface ID, minValue0, startRollout=Miscellaneous
 	//! [Default value] 0
	int get_mw_gi_surface_id() const { return getInt("mw_gi_surface_id"); }

	//! A multiplier for GI quality
 	//! [UI Guides] displayName=GI quality mult., minValue0.01
 	//! [Default value] 1
	bool set_mw_gi_quality_multiplier(float val) { return setValue("mw_gi_quality_multiplier", val); }
	//! A multiplier for GI quality
 	//! [UI Guides] displayName=GI quality mult., minValue0.01
 	//! [Default value] 1
	float get_mw_gi_quality_multiplier() const { return getFloat("mw_gi_quality_multiplier"); }

	//! Setting this to true will make the matte alpha opaque so that the alpha of objects behind the matte won't be seen.
 	//! [Default value] false
	bool set_mw_maya_background_shader_compatibility(bool val) { return setValue("mw_maya_background_shader_compatibility", val); }
	//! Setting this to true will make the matte alpha opaque so that the alpha of objects behind the matte won't be seen.
 	//! [Default value] false
	bool get_mw_maya_background_shader_compatibility() const { return getBool("mw_maya_background_shader_compatibility"); }

	//! The maximum reflection depth (-1 is controlled by the global options)
 	//! [Default value] -1
	bool set_mw_trace_depth(int val) { return setValue("mw_trace_depth", val); }
	//! The maximum reflection depth (-1 is controlled by the global options)
 	//! [Default value] -1
	int get_mw_trace_depth() const { return getInt("mw_trace_depth"); }

	//! Render channels the result of this BRDF will be written to
 	bool set_mw_channels(const ValueList& pluginList) { return setValue("mw_channels", pluginList); }
	//! Render channels the result of this BRDF will be written to
 	ValueList get_mw_channels() const { return getValueList("mw_channels"); }

	//! Setting this to false makes objects to not affect the render elements.
 	//! [Default value] true
	bool set_mw_generate_render_elements(bool val) { return setValue("mw_generate_render_elements", val); }
	//! Setting this to false makes objects to not affect the render elements.
 	//! [Default value] true
	bool get_mw_generate_render_elements() const { return getBool("mw_generate_render_elements"); }

	//! A list of plugins that will be excluded from reflections.
 	//! [UI Guides] attributes=objectSet, startRollout=
 	bool set_mw_reflection_exclude(const ValueList& pluginList) { return setValue("mw_reflection_exclude", pluginList); }
	//! A list of plugins that will be excluded from reflections.
 	//! [UI Guides] attributes=objectSet, startRollout=
 	ValueList get_mw_reflection_exclude() const { return getValueList("mw_reflection_exclude"); }

	//! Setting this to true will turn the reflection exclude list into inclusive (inverted).
 	//! [Default value] false
	bool set_mw_reflection_list_is_inclusive(bool val) { return setValue("mw_reflection_list_is_inclusive", val); }
	//! Setting this to true will turn the reflection exclude list into inclusive (inverted).
 	//! [Default value] false
	bool get_mw_reflection_list_is_inclusive() const { return getBool("mw_reflection_list_is_inclusive"); }

	//! A list of plugins that will be excluded from refractions.
 	//! [UI Guides] attributes=objectSet, startRollout=
 	bool set_mw_refraction_exclude(const ValueList& pluginList) { return setValue("mw_refraction_exclude", pluginList); }
	//! A list of plugins that will be excluded from refractions.
 	//! [UI Guides] attributes=objectSet, startRollout=
 	ValueList get_mw_refraction_exclude() const { return getValueList("mw_refraction_exclude"); }

	//! Setting this to true will turn the refraction exclude list into inclusive (inverted).
 	//! [Default value] false
	bool set_mw_refraction_list_is_inclusive(bool val) { return setValue("mw_refraction_list_is_inclusive", val); }
	//! Setting this to true will turn the refraction exclude list into inclusive (inverted).
 	//! [Default value] false
	bool get_mw_refraction_list_is_inclusive() const { return getBool("mw_refraction_list_is_inclusive"); }

	//! Use MtlRenderStats
 	//! [Default value] false
	bool set_mrs_use(bool val) { return setValue("mrs_use", val); }
	//! Use MtlRenderStats
 	//! [Default value] false
	bool get_mrs_use() const { return getBool("mrs_use"); }

	//! Whether the object is visible from the camera (camera rays)
 	//! [Default value] true
	bool set_mrs_camera_visibility(bool val) { return setValue("mrs_camera_visibility", val); }
	//! Whether the object is visible from the camera (camera rays)
 	//! [Default value] true
	bool get_mrs_camera_visibility() const { return getBool("mrs_camera_visibility"); }

	//! Whether the object is visible in reflections
 	//! [Default value] true
	bool set_mrs_reflections_visibility(bool val) { return setValue("mrs_reflections_visibility", val); }
	//! Whether the object is visible in reflections
 	//! [Default value] true
	bool get_mrs_reflections_visibility() const { return getBool("mrs_reflections_visibility"); }

	//! Whether the object is visible in refractions
 	//! [Default value] true
	bool set_mrs_refractions_visibility(bool val) { return setValue("mrs_refractions_visibility", val); }
	//! Whether the object is visible in refractions
 	//! [Default value] true
	bool get_mrs_refractions_visibility() const { return getBool("mrs_refractions_visibility"); }

	//! Whether the object is visible to GI (generating and receiving)
 	//! [Default value] true
	bool set_mrs_gi_visibility(bool val) { return setValue("mrs_gi_visibility", val); }
	//! Whether the object is visible to GI (generating and receiving)
 	//! [Default value] true
	bool get_mrs_gi_visibility() const { return getBool("mrs_gi_visibility"); }

	//! Whether the object casts shadows (visible to lights for shadow rays)
 	//! [Default value] true
	bool set_mrs_shadows_visibility(bool val) { return setValue("mrs_shadows_visibility", val); }
	//! Whether the object casts shadows (visible to lights for shadow rays)
 	//! [Default value] true
	bool get_mrs_shadows_visibility() const { return getBool("mrs_shadows_visibility"); }

	//! Whether the object receives shadows
 	//! [Default value] true
	bool set_mrs_shadows_receive(bool val) { return setValue("mrs_shadows_receive", val); }
	//! Whether the object receives shadows
 	//! [Default value] true
	bool get_mrs_shadows_receive() const { return getBool("mrs_shadows_receive"); }

	//! Overall visibility
 	//! [Default value] 1
	bool set_mrs_visibility(float val) { return setValue("mrs_visibility", val); }
	//! Overall visibility
 	//! [Default value] 1
	float get_mrs_visibility() const { return getFloat("mrs_visibility"); }

	//! Axis flipping: 0 - do not transform the coordinate system, 1 - detect up axis automatically, 2 - transform the axis from 3ds max to Maya
 	//! [UI Guides]  3 - transform the axis from Maya to 3ds max coordinate system,enum=0:As Is;1:Auto;2:Z-Up To Y-Up;3:Y-Up To Z-Up, displayName=Flip Axis Mode
 	//! [Default value] 0
	bool set_flip_axis(int val) { return setValue("flip_axis", val); }
	//! Axis flipping: 0 - do not transform the coordinate system, 1 - detect up axis automatically, 2 - transform the axis from 3ds max to Maya
 	//! [UI Guides]  3 - transform the axis from Maya to 3ds max coordinate system,enum=0:As Is;1:Auto;2:Z-Up To Y-Up;3:Y-Up To Z-Up, displayName=Flip Axis Mode
 	//! [Default value] 0
	int get_flip_axis() const { return getInt("flip_axis"); }

	//! Use runtime overrides
 	//! [Default value] false
	bool set_use_overrides(bool val) { return setValue("use_overrides", val); }
	//! Use runtime overrides
 	//! [Default value] false
	bool get_use_overrides() const { return getBool("use_overrides"); }

	//! Runtime plugin parameter overrides. A string in vrscene format.
 	bool set_override_snippet(const char* str) { return setValue("override_snippet", str); }
	//! Runtime plugin parameter overrides. A string in vrscene format.
 	bool set_override_snippet(const std::string& str) { return setValue("override_snippet", str); }
	//! Runtime plugin parameter overrides. A string in vrscene format.
 	std::string get_override_snippet() const { return getString("override_snippet"); }

	//! Runtime plugin parameter overrides. A path to an override file in vrscene format.
 	bool set_override_filepath(const char* str) { return setValue("override_filepath", str); }
	//! Runtime plugin parameter overrides. A path to an override file in vrscene format.
 	bool set_override_filepath(const std::string& str) { return setValue("override_filepath", str); }
	//! Runtime plugin parameter overrides. A path to an override file in vrscene format.
 	std::string get_override_filepath() const { return getString("override_filepath"); }
};

class VRayStereoscopicSettings : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "VRayStereoscopicSettings"; }

	//! The eye distance for which the stereoscopic image will be rendered.
 	//! [UI Guides] minValue=0.0, quantityType=distance
 	//! [Default value] 6.5
	bool set_eye_distance(float val) { return setValue("eye_distance", val); }
	//! The eye distance for which the stereoscopic image will be rendered.
 	//! [UI Guides] minValue=0.0, quantityType=distance
 	//! [Default value] 6.5
	float get_eye_distance() const { return getFloat("eye_distance"); }

	//! If on then the focus is determined by focus_method and focus_distance. Otherwise it is determined from the camera target distance.
 	//! [Default value] false
	bool set_specify_focus(bool val) { return setValue("specify_focus", val); }
	//! If on then the focus is determined by focus_method and focus_distance. Otherwise it is determined from the camera target distance.
 	//! [Default value] false
	bool get_specify_focus() const { return getBool("specify_focus"); }

	//! The focus distance when specify_focus is enabled.
 	//! [UI Guides] minValue=0.0, quantityType=distance, enableIf: ?specify_focus=1
 	//! [Default value] 200
	bool set_focus_distance(float val) { return setValue("focus_distance", val); }
	//! The focus distance when specify_focus is enabled.
 	//! [UI Guides] minValue=0.0, quantityType=distance, enableIf: ?specify_focus=1
 	//! [Default value] 200
	float get_focus_distance() const { return getFloat("focus_distance"); }

	//! Specifies the focus method for the two views (0 - none/parallel; 1 - rotation; 2 - shear).
 	//! [UI Guides] enum=0:None/parallel;1:Rotation;2:Shear
 	//! [Default value] 0
	bool set_focus_method(int val) { return setValue("focus_method", val); }
	//! Specifies the focus method for the two views (0 - none/parallel; 1 - rotation; 2 - shear).
 	//! [UI Guides] enum=0:None/parallel;1:Rotation;2:Shear
 	//! [Default value] 0
	int get_focus_method() const { return getInt("focus_method"); }

	//! Specifies how the two virtual cameras will be placed in relation to the real camera in the scene (0 - symmetric/shift both; 1 - shift left; 2 - shift right).
 	//! [UI Guides] enum=0:Symmetric/shift both;1:Shift left;2:Shift right
 	//! [Default value] 0
	bool set_interocular_method(int val) { return setValue("interocular_method", val); }
	//! Specifies how the two virtual cameras will be placed in relation to the real camera in the scene (0 - symmetric/shift both; 1 - shift left; 2 - shift right).
 	//! [UI Guides] enum=0:Symmetric/shift both;1:Shift left;2:Shift right
 	//! [Default value] 0
	int get_interocular_method() const { return getInt("interocular_method"); }

	//! Panoramic pole merging: from what angle near the top does the stereo effect start to fade when rendering with a spherical panorama camera.
 	//! [UI Guides] minValue=0.0, maxValue=1.5707963, units=radians
 	//! [Default value] 1.0472
	bool set_top_merge_angle(float val) { return setValue("top_merge_angle", val); }
	//! Panoramic pole merging: from what angle near the top does the stereo effect start to fade when rendering with a spherical panorama camera.
 	//! [UI Guides] minValue=0.0, maxValue=1.5707963, units=radians
 	//! [Default value] 1.0472
	float get_top_merge_angle() const { return getFloat("top_merge_angle"); }

	//! Panoramic pole merging: from what angle near the bottom does the stereo effect start to fade when rendering with a spherical panorama camera.
 	//! [UI Guides] minValue=0.0, maxValue=1.5707963, units=radians
 	//! [Default value] 1.0472
	bool set_bottom_merge_angle(float val) { return setValue("bottom_merge_angle", val); }
	//! Panoramic pole merging: from what angle near the bottom does the stereo effect start to fade when rendering with a spherical panorama camera.
 	//! [UI Guides] minValue=0.0, maxValue=1.5707963, units=radians
 	//! [Default value] 1.0472
	float get_bottom_merge_angle() const { return getFloat("bottom_merge_angle"); }

	//! Specifies which of the stereoscopic views will be rendered (0 - both; 1 - left; 2 - right; 3 - center).
 	//! [UI Guides] enum=0:Both;1:Left;2:Right;3:Center
 	//! [Default value] 0
	bool set_view(int val) { return setValue("view", val); }
	//! Specifies which of the stereoscopic views will be rendered (0 - both; 1 - left; 2 - right; 3 - center).
 	//! [UI Guides] enum=0:Both;1:Left;2:Right;3:Center
 	//! [Default value] 0
	int get_view() const { return getInt("view"); }

	//! Layout of the output image (0 - side-by-side; 1 - top-bottom).
 	//! [UI Guides] enum=0:Side-by-Side;1:Top-Bottom
 	//! [Default value] 0
	bool set_output_layout(int val) { return setValue("output_layout", val); }
	//! Layout of the output image (0 - side-by-side; 1 - top-bottom).
 	//! [UI Guides] enum=0:Side-by-Side;1:Top-Bottom
 	//! [Default value] 0
	int get_output_layout() const { return getInt("output_layout"); }

	//! When on this option will automatically adjust the resolution for the final image rendered.
 	//! [Default value] false
	bool set_adjust_resolution(bool val) { return setValue("adjust_resolution", val); }
	//! When on this option will automatically adjust the resolution for the final image rendered.
 	//! [Default value] false
	bool get_adjust_resolution() const { return getBool("adjust_resolution"); }

	//! Specifies the mode of operation for the shade map (0 - disabled; 1 - render shade map; 2 - use shade map).
 	//! [UI Guides] displayName=Shade Map Mode, enum=0:Disabled;1:Render shade map;2:Use shade map, startRollout=
 	//! [Default value] 0
	bool set_sm_mode(int val) { return setValue("sm_mode", val); }
	//! Specifies the mode of operation for the shade map (0 - disabled; 1 - render shade map; 2 - use shade map).
 	//! [UI Guides] displayName=Shade Map Mode, enum=0:Disabled;1:Render shade map;2:Use shade map, startRollout=
 	//! [Default value] 0
	int get_sm_mode() const { return getInt("sm_mode"); }

	//! Lower values will make V-Ray use less of the shade map and more real shading.
 	//! [UI Guides] minValue=0.0, maxValue=100.0, enableIf: ?sm_mode=2
 	//! [Default value] 1
	bool set_reuse_threshold(float val) { return setValue("reuse_threshold", val); }
	//! Lower values will make V-Ray use less of the shade map and more real shading.
 	//! [UI Guides] minValue=0.0, maxValue=100.0, enableIf: ?sm_mode=2
 	//! [Default value] 1
	float get_reuse_threshold() const { return getFloat("reuse_threshold"); }

	//! The name of the file in which the shade map information is stored.
 	//! [UI Guides] fileAsset=vrsm;vrst;exr fileAssetNames=V-Ray shade map file;V-Ray deep image file;OpenEXR deep image file, fileAssetOp=bothLoadAndSave, enableIf: ?sm_mode!=0
 	bool set_shademap_file(const char* str) { return setValue("shademap_file", str); }
	//! The name of the file in which the shade map information is stored.
 	//! [UI Guides] fileAsset=vrsm;vrst;exr fileAssetNames=V-Ray shade map file;V-Ray deep image file;OpenEXR deep image file, fileAssetOp=bothLoadAndSave, enableIf: ?sm_mode!=0
 	bool set_shademap_file(const std::string& str) { return setValue("shademap_file", str); }
	//! The name of the file in which the shade map information is stored.
 	//! [UI Guides] fileAsset=vrsm;vrst;exr fileAssetNames=V-Ray shade map file;V-Ray deep image file;OpenEXR deep image file, fileAssetOp=bothLoadAndSave, enableIf: ?sm_mode!=0
 	std::string get_shademap_file() const { return getString("shademap_file"); }

	//! Store 32 bit (single precision) color channels in the shade map. When off 16 bit (half precision) values are stored.
 	//! [UI Guides] displayName=32 Bit Colors, enableIf: ?sm_mode=1
 	//! [Default value] false
	bool set_float_colors_mode(bool val) { return setValue("float_colors_mode", val); }
	//! Store 32 bit (single precision) color channels in the shade map. When off 16 bit (half precision) values are stored.
 	//! [UI Guides] displayName=32 Bit Colors, enableIf: ?sm_mode=1
 	//! [Default value] false
	bool get_float_colors_mode() const { return getBool("float_colors_mode"); }

	//! Compression type for the .vrst files (0 - no compression, 1 - ZLIB compression).
 	//! [UI Guides] displayName=VRST Compression, enum=0:None;1:ZLIB, enableIf: ?sm_mode=1
 	//! [Default value] 1
	bool set_vrst_compression(int val) { return setValue("vrst_compression", val); }
	//! Compression type for the .vrst files (0 - no compression, 1 - ZLIB compression).
 	//! [UI Guides] displayName=VRST Compression, enum=0:None;1:ZLIB, enableIf: ?sm_mode=1
 	//! [Default value] 1
	int get_vrst_compression() const { return getInt("vrst_compression"); }

	//! Compression type for the .exr files (0 - no compression, 1 - RLE compression, 2 - ZIPS compression).
 	//! [UI Guides] displayName=EXR Compression, enum=0:None;1:RLE;2:ZIPS, enableIf: ?sm_mode=1
 	//! [Default value] 2
	bool set_exr_compression(int val) { return setValue("exr_compression", val); }
	//! Compression type for the .exr files (0 - no compression, 1 - RLE compression, 2 - ZIPS compression).
 	//! [UI Guides] displayName=EXR Compression, enum=0:None;1:RLE;2:ZIPS, enableIf: ?sm_mode=1
 	//! [Default value] 2
	int get_exr_compression() const { return getInt("exr_compression"); }

	//! A list of plugins for which the shade map won't be used.
 	//! [UI Guides] enableIf: ?sm_mode!=0, attributes=objectSet
 	bool set_exclude_list(const ValueList& pluginList) { return setValue("exclude_list", pluginList); }
	//! A list of plugins for which the shade map won't be used.
 	//! [UI Guides] enableIf: ?sm_mode!=0, attributes=objectSet
 	ValueList get_exclude_list() const { return getValueList("exclude_list"); }

	//! When on, the exclude_list is considered an 'Include list'.
 	//! [UI Guides] enableIf: ?sm_mode!=0
 	//! [Default value] false
	bool set_exclude_list_inclusive(bool val) { return setValue("exclude_list_inclusive", val); }
	//! When on, the exclude_list is considered an 'Include list'.
 	//! [UI Guides] enableIf: ?sm_mode!=0
 	//! [Default value] false
	bool get_exclude_list_inclusive() const { return getBool("exclude_list_inclusive"); }

	//! A camera plugin for the left eye; if not specified, the left camera is computed based on the scene camera.
 	bool set_left_camera(const Plugin& plugin) { return setValue("left_camera", plugin); }
	//! A camera plugin for the left eye; if not specified, the left camera is computed based on the scene camera.
 	Plugin get_left_camera() const { return getPlugin("left_camera"); }

	//! A camera plugin for the right eye; if not specified, the right camera is computed based on the scene camera.
 	bool set_right_camera(const Plugin& plugin) { return setValue("right_camera", plugin); }
	//! A camera plugin for the right eye; if not specified, the right camera is computed based on the scene camera.
 	Plugin get_right_camera() const { return getPlugin("right_camera"); }

	//! Horizontal film offset for the left camera
 	//! [Default value] 0
	bool set_film_offset_x_left(float val) { return setValue("film_offset_x_left", val); }
	//! Horizontal film offset for the left camera
 	//! [Default value] 0
	float get_film_offset_x_left() const { return getFloat("film_offset_x_left"); }

	//! Horizontal film offset for the right camera
 	//! [Default value] 0
	bool set_film_offset_x_right(float val) { return setValue("film_offset_x_right", val); }
	//! Horizontal film offset for the right camera
 	//! [Default value] 0
	float get_film_offset_x_right() const { return getFloat("film_offset_x_right"); }

	//! Vertical film offset for the left camera
 	//! [Default value] 0
	bool set_film_offset_y_left(float val) { return setValue("film_offset_y_left", val); }
	//! Vertical film offset for the left camera
 	//! [Default value] 0
	float get_film_offset_y_left() const { return getFloat("film_offset_y_left"); }

	//! Vertical film offset for the right camera
 	//! [Default value] 0
	bool set_film_offset_y_right(float val) { return setValue("film_offset_y_right", val); }
	//! Vertical film offset for the right camera
 	//! [Default value] 0
	float get_film_offset_y_right() const { return getFloat("film_offset_y_right"); }
};

class VolumeAerialPerspective : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "VolumeAerialPerspective"; }

	//! If specified, all parameters are taken from the specified sun. Otherwise, default values are used. Make sure to specify this.
 	//! [UI Guides] startTab=V-Ray Aerial Perspective, startRollout=V-Ray Aerial Perspective
 	bool set_sun(const Plugin& plugin) { return setValue("sun", plugin); }
	//! If specified, all parameters are taken from the specified sun. Otherwise, default values are used. Make sure to specify this.
 	//! [UI Guides] startTab=V-Ray Aerial Perspective, startRollout=V-Ray Aerial Perspective
 	Plugin get_sun() const { return getPlugin("sun"); }

	//! If 'false', disable the rendering of the aerial perspective effect.
 	//! [Default value] true
	bool set_enabled(bool val) { return setValue("enabled", val); }
	//! If 'false', disable the rendering of the aerial perspective effect.
 	//! [Default value] true
	bool get_enabled() const { return getBool("enabled"); }

	//! View distance inside the fog (until it becomes less than 10% see through).
 	//! [UI Guides] displayName=Visibility Range, quantityType=distance, units=meters, minValue=0
 	//! [Default value] 600000
	bool set_distance(float val) { return setValue("distance", val); }
	//! View distance inside the fog (until it becomes less than 10% see through).
 	//! [UI Guides] displayName=Visibility Range, quantityType=distance, units=meters, minValue=0
 	//! [Default value] 600000
	float get_distance() const { return getFloat("distance"); }

	//! Height of the atmospheric layer.
 	//! [UI Guides] displayName=Atmosphere Height, quantityType=distance, units=meters, minValue=0
 	//! [Default value] 600000
	bool set_atm_height(float val) { return setValue("atm_height", val); }
	//! Height of the atmospheric layer.
 	//! [UI Guides] displayName=Atmosphere Height, quantityType=distance, units=meters, minValue=0
 	//! [Default value] 600000
	float get_atm_height() const { return getFloat("atm_height"); }

	//! Multiplyer for the "inscattered light" component of the aerial persective.
 	//! [UI Guides] displayName=Inscattered Light Mult., minValue=0, maxValue=1000
 	//! [Default value] 1
	bool set_inscat_mult(float val) { return setValue("inscat_mult", val); }
	//! Multiplyer for the "inscattered light" component of the aerial persective.
 	//! [UI Guides] displayName=Inscattered Light Mult., minValue=0, maxValue=1000
 	//! [Default value] 1
	float get_inscat_mult() const { return getFloat("inscat_mult"); }

	//! Specify whether aerial perspective is applied to environment rays.
 	//! [UI Guides] displayName=Affect Environment
 	//! [Default value] false
	bool set_affect_env(bool val) { return setValue("affect_env", val); }
	//! Specify whether aerial perspective is applied to environment rays.
 	//! [UI Guides] displayName=Affect Environment
 	//! [Default value] false
	bool get_affect_env() const { return getBool("affect_env"); }

	//! Specify whether aerial perspective is applied to the background.
 	//! [UI Guides] displayName=Affect Background, enableIf: ?affect_env=1
 	//! [Default value] true
	bool set_affect_bg(bool val) { return setValue("affect_bg", val); }
	//! Specify whether aerial perspective is applied to the background.
 	//! [UI Guides] displayName=Affect Background, enableIf: ?affect_env=1
 	//! [Default value] true
	bool get_affect_bg() const { return getBool("affect_bg"); }

	//! Filter color for the fog. Note that fog color depends on the color of the sky.
 	//! [Default value] Color(1, 1, 1)
	bool set_filter_color(const Color& color) { return setValue("filter_color", color); }
	//! Filter color for the fog. Note that fog color depends on the color of the sky.
 	//! [Default value] Color(1, 1, 1)
	Color get_filter_color() const { return getColor("filter_color"); }
};

class VolumeChannels : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "VolumeChannels"; }

	//! (description missing)
	bool set_base_volume(const Plugin& plugin) { return setValue("base_volume", plugin); }
	//! (description missing)
	Plugin get_base_volume() const { return getPlugin("base_volume"); }

	//! Render channels the result of this volume will be written to
 	bool set_channels(const ValueList& pluginList) { return setValue("channels", pluginList); }
	//! Render channels the result of this volume will be written to
 	ValueList get_channels() const { return getValueList("channels"); }
};

class VolumeFog : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "VolumeFog"; }

	//! Fog emission color
 	//! [Default value] Color(0, 0, 0)
	bool set_emission(const Color& color) { return setValue("emission", color); }
	//! Fog emission color
 	//! [Default value] Color(0, 0, 0)
	Color get_emission() const { return getColor("emission"); }

	//! Fog color
 	//! [Default value] Color(0.5, 0.5, 0.5)
	bool set_color(const Color& color) { return setValue("color", color); }
	//! Fog color
 	//! [Default value] Color(0.5, 0.5, 0.5)
	Color get_color() const { return getColor("color"); }

	//! Fog color texture map
 	bool set_color_tex(const Plugin& texture) { return setValue("color_tex", texture); }
	//! Fog color texture map
 	bool set_color_tex(const AColor& texture) { return setValue("color_tex", texture); }
	//! Fog color texture map
 	Value get_color_tex() const { return getValue("color_tex"); }

	//! Fog color multiplier
 	//! [Default value] 0.1
	bool set_color_mult(float val) { return setValue("color_mult", val); }
	//! Fog color multiplier
 	//! [Default value] 0.1
	float get_color_mult() const { return getFloat("color_mult"); }

	//! The IOR for the volume
 	//! [Default value] 1
	bool set_ior(float val) { return setValue("ior", val); }
	//! The IOR for the volume
 	//! [Default value] 1
	float get_ior() const { return getFloat("ior"); }

	//! Bias for the fogging distance
 	//! [Default value] 0
	bool set_bias(float val) { return setValue("bias", val); }
	//! Bias for the fogging distance
 	//! [Default value] 0
	float get_bias() const { return getFloat("bias"); }

	//! If true, the fog will shade only closed volumes.
 	//! [Default value] false
	bool set_closed_volume(bool val) { return setValue("closed_volume", val); }
	//! If true, the fog will shade only closed volumes.
 	//! [Default value] false
	bool get_closed_volume() const { return getBool("closed_volume"); }
};

class VolumeMulti : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "VolumeMulti"; }

	//! (description missing)
	bool set_volumes(const ValueList& pluginList) { return setValue("volumes", pluginList); }
	//! (description missing)
	ValueList get_volumes() const { return getValueList("volumes"); }
};

class VolumeScatterFog : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "VolumeScatterFog"; }

	//! Fog emission color
 	//! [Default value] Color(0, 0, 0)
	bool set_emission(const Color& color) { return setValue("emission", color); }
	//! Fog emission color
 	//! [Default value] Color(0, 0, 0)
	Color get_emission() const { return getColor("emission"); }

	//! Fog color
 	//! [Default value] Color(0.5, 0.5, 0.5)
	bool set_color(const Color& color) { return setValue("color", color); }
	//! Fog color
 	//! [Default value] Color(0.5, 0.5, 0.5)
	Color get_color() const { return getColor("color"); }

	//! Fog color texture map
 	bool set_color_tex(const Plugin& texture) { return setValue("color_tex", texture); }
	//! Fog color texture map
 	bool set_color_tex(const AColor& texture) { return setValue("color_tex", texture); }
	//! Fog color texture map
 	Value get_color_tex() const { return getValue("color_tex"); }

	//! Fog color multiplier
 	//! [Default value] 0.1
	bool set_color_mult(float val) { return setValue("color_mult", val); }
	//! Fog color multiplier
 	//! [Default value] 0.1
	float get_color_mult() const { return getFloat("color_mult"); }

	//! The IOR for the volume
 	//! [Default value] 1
	bool set_ior(float val) { return setValue("ior", val); }
	//! The IOR for the volume
 	//! [Default value] 1
	float get_ior() const { return getFloat("ior"); }

	//! Bias for the fogging distance
 	//! [Default value] 0
	bool set_bias(float val) { return setValue("bias", val); }
	//! Bias for the fogging distance
 	//! [Default value] 0
	float get_bias() const { return getFloat("bias"); }

	//! If true, the fog will shade only closed volumes.
 	//! [Default value] false
	bool set_closed_volume(bool val) { return setValue("closed_volume", val); }
	//! If true, the fog will shade only closed volumes.
 	//! [Default value] false
	bool get_closed_volume() const { return getBool("closed_volume"); }

	//! Subdivs for the scattering samples
 	//! [UI Guides] quantityType=localSubdivs
 	//! [Default value] 8
	bool set_subdivs(int val) { return setValue("subdivs", val); }
	//! Subdivs for the scattering samples
 	//! [UI Guides] quantityType=localSubdivs
 	//! [Default value] 8
	int get_subdivs() const { return getInt("subdivs"); }

	//! Maximum distance to trace into the objects
 	//! [Default value] 1e+018
	bool set_thickness(float val) { return setValue("thickness", val); }
	//! Maximum distance to trace into the objects
 	//! [Default value] 1e+018
	float get_thickness() const { return getFloat("thickness"); }

	//! Multiplier for the sss effect
 	//! [Default value] 1
	bool set_light_mult(float val) { return setValue("light_mult", val); }
	//! Multiplier for the sss effect
 	//! [Default value] 1
	float get_light_mult() const { return getFloat("light_mult"); }

	//! Scatter coefficient (0.0 is full scattering; 1.0 is purely directional)
 	//! [Default value] 0
	bool set_scatter_coeff(float val) { return setValue("scatter_coeff", val); }
	//! Scatter coefficient (0.0 is full scattering; 1.0 is purely directional)
 	//! [Default value] 0
	float get_scatter_coeff() const { return getFloat("scatter_coeff"); }

	//! Scatter direction (0.0 is forward away from the viewer; 1.0 is backward towards the viewer)
 	//! [Default value] 1
	bool set_scatter_direction(float val) { return setValue("scatter_direction", val); }
	//! Scatter direction (0.0 is forward away from the viewer; 1.0 is backward towards the viewer)
 	//! [Default value] 1
	float get_scatter_direction() const { return getFloat("scatter_direction"); }

	//! Maximum number of scattering bounces
 	//! [Default value] 1
	bool set_scatter_levels(int val) { return setValue("scatter_levels", val); }
	//! Maximum number of scattering bounces
 	//! [Default value] 1
	int get_scatter_levels() const { return getInt("scatter_levels"); }

	//! true if this is environment fog and false if it is inside an object
 	//! [Default value] false
	bool set_environment_fog(bool val) { return setValue("environment_fog", val); }
	//! true if this is environment fog and false if it is inside an object
 	//! [Default value] false
	bool get_environment_fog() const { return getBool("environment_fog"); }
};

class VolumeVRayToon : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "VolumeVRayToon"; }

	//! The color of the cartoon line.
 	//! [UI Guides] displayName=Line Color, startTab=V-Ray Toon, startRollout=V-Ray Toon
 	//! [Default value] Color(0, 0, 0)
	bool set_lineColor(const Color& color) { return setValue("lineColor", color); }
	//! The color of the cartoon line.
 	//! [UI Guides] displayName=Line Color, startTab=V-Ray Toon, startRollout=V-Ray Toon
 	//! [Default value] Color(0, 0, 0)
	Color get_lineColor() const { return getColor("lineColor"); }

	//! The color texture of the cartoon line.
 	//! [UI Guides] displayName=Line Color map
 	bool set_lineColor_tex(const Plugin& texture) { return setValue("lineColor_tex", texture); }
	//! The color texture of the cartoon line.
 	//! [UI Guides] displayName=Line Color map
 	bool set_lineColor_tex(const AColor& texture) { return setValue("lineColor_tex", texture); }
	//! The color texture of the cartoon line.
 	//! [UI Guides] displayName=Line Color map
 	Value get_lineColor_tex() const { return getValue("lineColor_tex"); }

	//! 0:Pixels; 1:World
 	//! [UI Guides] enum=0:Pixels; 1:World, displayName=Width units
 	//! [Default value] 0
	bool set_widthType(int val) { return setValue("widthType", val); }
	//! 0:Pixels; 1:World
 	//! [UI Guides] enum=0:Pixels; 1:World, displayName=Width units
 	//! [Default value] 0
	int get_widthType() const { return getInt("widthType"); }

	//! Cartoon line width.
 	//! [UI Guides] displayName=Line Width, minValue=0
 	//! [Default value] 1.5
	bool set_lineWidth(float val) { return setValue("lineWidth", val); }
	//! Cartoon line width.
 	//! [UI Guides] displayName=Line Width, minValue=0
 	//! [Default value] 1.5
	float get_lineWidth() const { return getFloat("lineWidth"); }

	//! Cartoon line width texture.
 	//! [UI Guides] displayName=Line Width map, minValue=0, attributes=textureSlot
 	bool set_lineWidth_tex(const Plugin& texturefloat) { return setValue("lineWidth_tex", texturefloat); }
	//! Cartoon line width texture.
 	//! [UI Guides] displayName=Line Width map, minValue=0, attributes=textureSlot
 	bool set_lineWidth_tex(float texturefloat) { return setValue("lineWidth_tex", texturefloat); }
	//! Cartoon line width texture.
 	//! [UI Guides] displayName=Line Width map, minValue=0, attributes=textureSlot
 	Value get_lineWidth_tex() const { return getValue("lineWidth_tex"); }

	//! Opacity of the cartoon line.
 	//! [UI Guides] displayName=Opacity, minValue=0, maxValue=1, overridenBy=opacity_tex
 	//! [Default value] 1
	bool set_opacity(float val) { return setValue("opacity", val); }
	//! Opacity of the cartoon line.
 	//! [UI Guides] displayName=Opacity, minValue=0, maxValue=1, overridenBy=opacity_tex
 	//! [Default value] 1
	float get_opacity() const { return getFloat("opacity"); }

	//! Opacity texture of the cartoon line.
 	//! [UI Guides] displayName=Opacity map, minValue=0, maxValue=1, overrides=opacity
 	bool set_opacity_tex(const Plugin& texturefloat) { return setValue("opacity_tex", texturefloat); }
	//! Opacity texture of the cartoon line.
 	//! [UI Guides] displayName=Opacity map, minValue=0, maxValue=1, overrides=opacity
 	bool set_opacity_tex(float texturefloat) { return setValue("opacity_tex", texturefloat); }
	//! Opacity texture of the cartoon line.
 	//! [UI Guides] displayName=Opacity map, minValue=0, maxValue=1, overrides=opacity
 	Value get_opacity_tex() const { return getValue("opacity_tex"); }

	//! Compensate V-Ray physical camera exposure.
 	//! [UI Guides] startRollout=, displayName=Compensate Exposure
 	//! [Default value] false
	bool set_compensateExposure(bool val) { return setValue("compensateExposure", val); }
	//! Compensate V-Ray physical camera exposure.
 	//! [UI Guides] startRollout=, displayName=Compensate Exposure
 	//! [Default value] false
	bool get_compensateExposure() const { return getBool("compensateExposure"); }

	//! True : show outlines and not interior edges, false : show all edges.
 	//! [UI Guides] displayName=Hide Inner Edges
 	//! [Default value] false
	bool set_hideInnerEdges(bool val) { return setValue("hideInnerEdges", val); }
	//! True : show outlines and not interior edges, false : show all edges.
 	//! [UI Guides] displayName=Hide Inner Edges
 	//! [Default value] false
	bool get_hideInnerEdges() const { return getBool("hideInnerEdges"); }

	//! This determines when lines will be created for parts of the same object with varying surface normals (for example, at the inside edges of a box). A value of 0.0 means that only 90 degrees or larger angles will generate internal lines. Higher values mean that more smooth normals can also generate an edge. Don't set this value to pure 1.0 as this will fill curved objects completely.
 	//! [UI Guides] displayName=Normal Threshold, minValue=0, maxValue=1
 	//! [Default value] 0.7
	bool set_normalThreshold(float val) { return setValue("normalThreshold", val); }
	//! This determines when lines will be created for parts of the same object with varying surface normals (for example, at the inside edges of a box). A value of 0.0 means that only 90 degrees or larger angles will generate internal lines. Higher values mean that more smooth normals can also generate an edge. Don't set this value to pure 1.0 as this will fill curved objects completely.
 	//! [UI Guides] displayName=Normal Threshold, minValue=0, maxValue=1
 	//! [Default value] 0.7
	float get_normalThreshold() const { return getFloat("normalThreshold"); }

	//! This determines when outlines will be created for overlapping parts of one and the same object.
 	//! [UI Guides] displayName=Overlap Threshold, minValue=0, maxValue=1
 	//! [Default value] 0.95
	bool set_overlapThreshold(float val) { return setValue("overlapThreshold", val); }
	//! This determines when outlines will be created for overlapping parts of one and the same object.
 	//! [UI Guides] displayName=Overlap Threshold, minValue=0, maxValue=1
 	//! [Default value] 0.95
	float get_overlapThreshold() const { return getFloat("overlapThreshold"); }

	//! True : show toon lines in reflections/refractions. Note that this may increase render times.
 	//! [UI Guides] displayName=Visible in Reflection/Refraction
 	//! [Default value] false
	bool set_doSecondaryRays(bool val) { return setValue("doSecondaryRays", val); }
	//! True : show toon lines in reflections/refractions. Note that this may increase render times.
 	//! [UI Guides] displayName=Visible in Reflection/Refraction
 	//! [Default value] false
	bool get_doSecondaryRays() const { return getBool("doSecondaryRays"); }

	//! This parameter depends on the scale of your scene.
 	//! [UI Guides] displayName=Trace bias, minValue=0
 	//! [Default value] 0.2
	bool set_traceBias(float val) { return setValue("traceBias", val); }
	//! This parameter depends on the scale of your scene.
 	//! [UI Guides] displayName=Trace bias, minValue=0
 	//! [Default value] 0.2
	float get_traceBias() const { return getFloat("traceBias"); }

	//! This works like a bump map - a simple constant value won't do, you need to connect a texture.
 	//! [UI Guides] displayName=Distortion map, attributes=textureSlot
 	bool set_distortion_tex(const Plugin& texturefloat) { return setValue("distortion_tex", texturefloat); }
	//! This works like a bump map - a simple constant value won't do, you need to connect a texture.
 	//! [UI Guides] displayName=Distortion map, attributes=textureSlot
 	bool set_distortion_tex(float texturefloat) { return setValue("distortion_tex", texturefloat); }
	//! This works like a bump map - a simple constant value won't do, you need to connect a texture.
 	//! [UI Guides] displayName=Distortion map, attributes=textureSlot
 	Value get_distortion_tex() const { return getValue("distortion_tex"); }

	//! Specifies which objects will be affected by the VRayToon atmospheric.
 	//! [UI Guides] startRollout=, displayName=Exclude List, attributes=objectSet
 	bool set_excludeList(const ValueList& pluginList) { return setValue("excludeList", pluginList); }
	//! Specifies which objects will be affected by the VRayToon atmospheric.
 	//! [UI Guides] startRollout=, displayName=Exclude List, attributes=objectSet
 	ValueList get_excludeList() const { return getValueList("excludeList"); }

	//! True : apply toon effect only to objects in excludeList; false : apply toon effect to all objects out of excludeList.
 	//! [UI Guides] displayName=As Inclusive List
 	//! [Default value] false
	bool set_excludeType(bool val) { return setValue("excludeType", val); }
	//! True : apply toon effect only to objects in excludeList; false : apply toon effect to all objects out of excludeList.
 	//! [UI Guides] displayName=As Inclusive List
 	//! [Default value] false
	bool get_excludeType() const { return getBool("excludeType"); }
};

class texRenderHair : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "texRenderHair"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! The uvw generator for the texture
 	//! [UI Guides] startRollout=Mapped
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! (description missing)
	//! [Default value] false
	bool set_use_3d_mapping(bool val) { return setValue("use_3d_mapping", val); }
	//! (description missing)
	//! [Default value] false
	bool get_use_3d_mapping() const { return getBool("use_3d_mapping"); }

	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	bool set_placement_type(int val) { return setValue("placement_type", val); }
	//! The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
 	//! [UI Guides] enum=0:Whole texture is valid;1:Crop;2:Place
 	//! [Default value] 0
	int get_placement_type() const { return getInt("placement_type"); }

	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_u(float val) { return setValue("u", val); }
	//! U coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_u() const { return getFloat("u"); }

	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	bool set_v(float val) { return setValue("v", val); }
	//! V coordinate of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 0
	float get_v() const { return getFloat("v"); }

	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_w(float val) { return setValue("w", val); }
	//! Width of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_w() const { return getFloat("w"); }

	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	bool set_h(float val) { return setValue("h", val); }
	//! Height of the valid texture sector
 	//! [UI Guides] enableIf: ?placement_type=1; ?placement_type=2
 	//! [Default value] 1
	float get_h() const { return getFloat("h"); }

	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	bool set_jitter(float val) { return setValue("jitter", val); }
	//! Amount of random placement variation
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] 0
	float get_jitter() const { return getFloat("jitter"); }

	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_u(bool val) { return setValue("tile_u", val); }
	//! If true there is horizontal tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_u() const { return getBool("tile_u"); }

	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool set_tile_v(bool val) { return setValue("tile_v", val); }
	//! If true there is vertical tiling
 	//! [UI Guides] enableIf: ?placement_type=2
 	//! [Default value] false
	bool get_tile_v() const { return getBool("tile_v"); }

	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool set_uv_noise_on(bool val) { return setValue("uv_noise_on", val); }
	//! If true the noise is enabled.
 	//! [UI Guides] displayName=UV noise on
 	//! [Default value] false
	bool get_uv_noise_on() const { return getBool("uv_noise_on"); }

	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool set_uv_noise_animate(bool val) { return setValue("uv_noise_animate", val); }
	//! If true the noise is animated. Use "UV noise phase" to animate the noise.
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=Animate UV noise
 	//! [Default value] false
	bool get_uv_noise_animate() const { return getBool("uv_noise_animate"); }

	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	bool set_uv_noise_amount(float val) { return setValue("uv_noise_amount", val); }
	//! UV noise amount
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise amount
 	//! [Default value] 1
	float get_uv_noise_amount() const { return getFloat("uv_noise_amount"); }

	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	bool set_uv_noise_levels(float val) { return setValue("uv_noise_levels", val); }
	//! UV noise iterations
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise levels
 	//! [Default value] 1
	float get_uv_noise_levels() const { return getFloat("uv_noise_levels"); }

	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	bool set_uv_noise_size(float val) { return setValue("uv_noise_size", val); }
	//! UV noise size
 	//! [UI Guides] enableIf: ?uv_noise_on=1, displayName=UV noise size
 	//! [Default value] 1
	float get_uv_noise_size() const { return getFloat("uv_noise_size"); }

	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	bool set_un_noise_phase(float val) { return setValue("un_noise_phase", val); }
	//! UV noise phase
 	//! [UI Guides] enableIf: ?uv_noise_on=1, ?uv_noise_animate=1, displayName=UV noise phase; startRollout=<EndRollout>
 	//! [Default value] 0
	float get_un_noise_phase() const { return getFloat("un_noise_phase"); }

	//! Defines the main diffuse color of the hair strand's tips.
 	bool set_a_color_tex(const Plugin& texture) { return setValue("a_color_tex", texture); }
	//! Defines the main diffuse color of the hair strand's tips.
 	bool set_a_color_tex(const AColor& texture) { return setValue("a_color_tex", texture); }
	//! Defines the main diffuse color of the hair strand's tips.
 	Value get_a_color_tex() const { return getValue("a_color_tex"); }

	//! Defines a secondary diffuse color for the hair strand's tips. This provides an alternate color that gets added to random hair strands. 
 	bool set_b_color_tex(const Plugin& texture) { return setValue("b_color_tex", texture); }
	//! Defines a secondary diffuse color for the hair strand's tips. This provides an alternate color that gets added to random hair strands. 
 	bool set_b_color_tex(const AColor& texture) { return setValue("b_color_tex", texture); }
	//! Defines a secondary diffuse color for the hair strand's tips. This provides an alternate color that gets added to random hair strands. 
 	Value get_b_color_tex() const { return getValue("b_color_tex"); }

	//! Defines the diffuse color of the hair roots
 	bool set_root_color_tex(const Plugin& texture) { return setValue("root_color_tex", texture); }
	//! Defines the diffuse color of the hair roots
 	bool set_root_color_tex(const AColor& texture) { return setValue("root_color_tex", texture); }
	//! Defines the diffuse color of the hair roots
 	Value get_root_color_tex() const { return getValue("root_color_tex"); }

	//! A value of 0 is mostly Tip and 1 is mostly Root
 	bool set_root_crossover_tex(const Plugin& texturefloat) { return setValue("root_crossover_tex", texturefloat); }
	//! A value of 0 is mostly Tip and 1 is mostly Root
 	bool set_root_crossover_tex(float texturefloat) { return setValue("root_crossover_tex", texturefloat); }
	//! A value of 0 is mostly Tip and 1 is mostly Root
 	Value get_root_crossover_tex() const { return getValue("root_crossover_tex"); }

	//! Distance along the hair strand where the intersection occurred, in the [0,1] range.
 	bool set_distance_along_strand(const Plugin& texturefloat) { return setValue("distance_along_strand", texturefloat); }
	//! Distance along the hair strand where the intersection occurred, in the [0,1] range.
 	bool set_distance_along_strand(float texturefloat) { return setValue("distance_along_strand", texturefloat); }
	//! Distance along the hair strand where the intersection occurred, in the [0,1] range.
 	Value get_distance_along_strand() const { return getValue("distance_along_strand"); }

	//! Random by the hair strand where the intersection occurred, in the [0,1] range.
 	bool set_random_by_strand(const Plugin& texturefloat) { return setValue("random_by_strand", texturefloat); }
	//! Random by the hair strand where the intersection occurred, in the [0,1] range.
 	bool set_random_by_strand(float texturefloat) { return setValue("random_by_strand", texturefloat); }
	//! Random by the hair strand where the intersection occurred, in the [0,1] range.
 	Value get_random_by_strand() const { return getValue("random_by_strand"); }

	//! The probability ratio between a and b textures
 	bool set_a_b_balance(const Plugin& texturefloat) { return setValue("a_b_balance", texturefloat); }
	//! The probability ratio between a and b textures
 	bool set_a_b_balance(float texturefloat) { return setValue("a_b_balance", texturefloat); }
	//! The probability ratio between a and b textures
 	Value get_a_b_balance() const { return getValue("a_b_balance"); }
};

class texXSIColor2Alpha : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "texXSIColor2Alpha"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! Scalar2Alpha will be calculated on the base of a color texture
 	bool set_clr_txt(const Plugin& texture) { return setValue("clr_txt", texture); }
	//! Scalar2Alpha will be calculated on the base of a color texture
 	bool set_clr_txt(const AColor& texture) { return setValue("clr_txt", texture); }
	//! Scalar2Alpha will be calculated on the base of a color texture
 	Value get_clr_txt() const { return getValue("clr_txt"); }

	//! The intensity to output
 	bool set_intensity_txt(const Plugin& texturefloat) { return setValue("intensity_txt", texturefloat); }
	//! The intensity to output
 	bool set_intensity_txt(float texturefloat) { return setValue("intensity_txt", texturefloat); }
	//! The intensity to output
 	Value get_intensity_txt() const { return getValue("intensity_txt"); }
};

class texXSIColor2Vector : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "texXSIColor2Vector"; }

	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	bool set_compatibility_with(int val) { return setValue("compatibility_with", val); }
	//! This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
 	//! [UI Guides] enum=0:Max;1:Maya; startRollout=Common
 	//! [Default value] 0
	int get_compatibility_with() const { return getInt("compatibility_with"); }

	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	bool set_alpha_from_intensity(int val) { return setValue("alpha_from_intensity", val); }
	//! If 2 - the alpha is forced to 1.0f; 1 - the resulting alpha is the color intensity (if compatibility_with is 0) or the color luminance (if compatibility_with is 1); 0 - the alpha is taken from the bitmap alpha
 	//! [UI Guides] enum=0:Bitmap alpha;1:Color intensity/luminance;2:Force opaque
 	//! [Default value] 0
	int get_alpha_from_intensity() const { return getInt("alpha_from_intensity"); }

	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool set_invert(bool val) { return setValue("invert", val); }
	//! If true, the resulting texture color will be inverted
 	//! [Default value] false
	bool get_invert() const { return getBool("invert"); }

	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool set_invert_alpha(bool val) { return setValue("invert_alpha", val); }
	//! If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
 	//! [UI Guides] enableIf: ?invert=1
 	//! [Default value] true
	bool get_invert_alpha() const { return getBool("invert_alpha"); }

	//! A multiplier for the texture color
 	bool set_color_mult(const Plugin& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	bool set_color_mult(const AColor& texture) { return setValue("color_mult", texture); }
	//! A multiplier for the texture color
 	Value get_color_mult() const { return getValue("color_mult"); }

	//! An additional offset for the texture color
 	bool set_color_offset(const Plugin& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	bool set_color_offset(const AColor& texture) { return setValue("color_offset", texture); }
	//! An additional offset for the texture color
 	Value get_color_offset() const { return getValue("color_offset"); }

	//! A multiplier for the texture alpha
 	bool set_alpha_mult(const Plugin& texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	bool set_alpha_mult(float texturefloat) { return setValue("alpha_mult", texturefloat); }
	//! A multiplier for the texture alpha
 	Value get_alpha_mult() const { return getValue("alpha_mult"); }

	//! An additional offset for the texture alpha
 	bool set_alpha_offset(const Plugin& texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	bool set_alpha_offset(float texturefloat) { return setValue("alpha_offset", texturefloat); }
	//! An additional offset for the texture alpha
 	Value get_alpha_offset() const { return getValue("alpha_offset"); }

	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const Plugin& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	bool set_nouvw_color(const AColor& texture) { return setValue("nouvw_color", texture); }
	//! The color when there are no valid uvw coordinates
 	//! [UI Guides] displayName=No UVs Color
 	Value get_nouvw_color() const { return getValue("nouvw_color"); }

	//! Scalar2Vector will be calculated on the base of a color texture
 	bool set_clr_txt(const Plugin& texture) { return setValue("clr_txt", texture); }
	//! Scalar2Vector will be calculated on the base of a color texture
 	bool set_clr_txt(const AColor& texture) { return setValue("clr_txt", texture); }
	//! Scalar2Vector will be calculated on the base of a color texture
 	Value get_clr_txt() const { return getValue("clr_txt"); }

	//! The intensity to output
 	bool set_output_scale(const Plugin& texturefloat) { return setValue("output_scale", texturefloat); }
	//! The intensity to output
 	bool set_output_scale(float texturefloat) { return setValue("output_scale", texturefloat); }
	//! The intensity to output
 	Value get_output_scale() const { return getValue("output_scale"); }

	//! method: direct copy(0), normal map(1)
 	//! [Default value] 0
	bool set_method(int val) { return setValue("method", val); }
	//! method: direct copy(0), normal map(1)
 	//! [Default value] 0
	int get_method() const { return getInt("method"); }
};

class volumeXSIMulti : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "volumeXSIMulti"; }

	//! A list of volume plugins
 	bool set_volumes(const ValueList& pluginList) { return setValue("volumes", pluginList); }
	//! A list of volume plugins
 	ValueList get_volumes() const { return getValueList("volumes"); }

	//! A list of material IDs
 	//! [Default value] 1
	bool set_ids_list(const IntList& intList) { return setValue("ids_list", intList); }
	//! A list of material IDs
 	//! [Default value] 1
	bool set_ids_list(const int* ints, size_t count) { return setArray("ids_list", ints, count); }
	//! A list of material IDs
 	//! [Default value] 1
	template<size_t count> bool set_ids_list(const int (&ints)[count]) { return setArray("ids_list", ints, count); }
	//! A list of material IDs
 	//! [Default value] 1
	IntList get_ids_list() const { return getIntList("ids_list"); }
};

class xsiUVWGenChannel : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "xsiUVWGenChannel"; }

	//! Initial transformation on the uvw coordinates, before mirror, crop etc
 	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	bool set_uvw_transform(const Transform& transform) { return setValue("uvw_transform", transform); }
	//! Initial transformation on the uvw coordinates, before mirror, crop etc
 	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	Transform get_uvw_transform() const { return getTransform("uvw_transform"); }

	//! (description missing)
	bool set_uvw_transform_tex(const Plugin& texturetransform) { return setValue("uvw_transform_tex", texturetransform); }
	//! (description missing)
	bool set_uvw_transform_tex(const Transform& texturetransform) { return setValue("uvw_transform_tex", texturetransform); }
	//! (description missing)
	Value get_uvw_transform_tex() const { return getValue("uvw_transform_tex"); }

	//! Final transformation on the resulting uvw coordinates, after mirror, crop etc
 	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	bool set_tex_transform(const Transform& transform) { return setValue("tex_transform", transform); }
	//! Final transformation on the resulting uvw coordinates, after mirror, crop etc
 	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	Transform get_tex_transform() const { return getTransform("tex_transform"); }

	//! Number of uvw transform samples
 	//! [Default value] 0
	bool set_nsamples(int val) { return setValue("nsamples", val); }
	//! Number of uvw transform samples
 	//! [Default value] 0
	int get_nsamples() const { return getInt("nsamples"); }

	//! 0 - no wrapping, 1 - wrap, 2 - mirror tile
 	//! [Default value] 0
	bool set_wrap_u(int val) { return setValue("wrap_u", val); }
	//! 0 - no wrapping, 1 - wrap, 2 - mirror tile
 	//! [Default value] 0
	int get_wrap_u() const { return getInt("wrap_u"); }

	//! 0 - no wrapping, 1 - wrap, 2 - mirror tile
 	//! [Default value] 0
	bool set_wrap_v(int val) { return setValue("wrap_v", val); }
	//! 0 - no wrapping, 1 - wrap, 2 - mirror tile
 	//! [Default value] 0
	int get_wrap_v() const { return getInt("wrap_v"); }

	//! 0 - no wrapping, 1 - wrap, 2 - mirror tile
 	//! [Default value] 0
	bool set_wrap_w(int val) { return setValue("wrap_w", val); }
	//! 0 - no wrapping, 1 - wrap, 2 - mirror tile
 	//! [Default value] 0
	int get_wrap_w() const { return getInt("wrap_w"); }

	//! 1 to crop in the u-direction
 	//! [Default value] 0
	bool set_crop_u(int val) { return setValue("crop_u", val); }
	//! 1 to crop in the u-direction
 	//! [Default value] 0
	int get_crop_u() const { return getInt("crop_u"); }

	//! 1 to crop in the v-direction
 	//! [Default value] 0
	bool set_crop_v(int val) { return setValue("crop_v", val); }
	//! 1 to crop in the v-direction
 	//! [Default value] 0
	int get_crop_v() const { return getInt("crop_v"); }

	//! 1 to crop in the w-direction
 	//! [Default value] 0
	bool set_crop_w(int val) { return setValue("crop_w", val); }
	//! 1 to crop in the w-direction
 	//! [Default value] 0
	int get_crop_w() const { return getInt("crop_w"); }

	//! Coverage
 	//! [Default value] Vector(1, 1, 1)
	bool set_coverage(const Vector& vector) { return setValue("coverage", vector); }
	//! Coverage
 	//! [Default value] Vector(1, 1, 1)
	Vector get_coverage() const { return getVector("coverage"); }

	//! Wrap mode (0 - wrap on 0.5 boundary; 1 - wrap on integer boundary
 	//! [UI Guides] enum=0:On 0.5 boundary; 1:On integer boundary
 	//! [Default value] 0
	bool set_wrap_mode(int val) { return setValue("wrap_mode", val); }
	//! Wrap mode (0 - wrap on 0.5 boundary; 1 - wrap on integer boundary
 	//! [UI Guides] enum=0:On 0.5 boundary; 1:On integer boundary
 	//! [Default value] 0
	int get_wrap_mode() const { return getInt("wrap_mode"); }

	//! Additional scale factor for the texture derivatives
 	//! [Default value] 1
	bool set_duvw_scale(float val) { return setValue("duvw_scale", val); }
	//! Additional scale factor for the texture derivatives
 	//! [Default value] 1
	float get_duvw_scale() const { return getFloat("duvw_scale"); }

	//! (description missing)
	//! [Default value] 1
	bool set_uvw_channel(int val) { return setValue("uvw_channel", val); }
	//! (description missing)
	//! [Default value] 1
	int get_uvw_channel() const { return getInt("uvw_channel"); }

	//! Type of the channel used. 0 - uvw, 1 - vertex colors
 	//! [Default value] 0
	bool set_channel_type(int val) { return setValue("channel_type", val); }
	//! Type of the channel used. 0 - uvw, 1 - vertex colors
 	//! [Default value] 0
	int get_channel_type() const { return getInt("channel_type"); }

	//! Optional UVWGen from which the initial uvw coordinates will be taken, instead of the surface point
 	bool set_uvwgen(const Plugin& plugin) { return setValue("uvwgen", plugin); }
	//! Optional UVWGen from which the initial uvw coordinates will be taken, instead of the surface point
 	Plugin get_uvwgen() const { return getPlugin("uvwgen"); }

	//! alternate image in u direction
 	//! [Default value] 0
	bool set_u_alternate(int val) { return setValue("u_alternate", val); }
	//! alternate image in u direction
 	//! [Default value] 0
	int get_u_alternate() const { return getInt("u_alternate"); }

	//! alternate image in v direction
 	//! [Default value] 0
	bool set_v_alternate(int val) { return setValue("v_alternate", val); }
	//! alternate image in v direction
 	//! [Default value] 0
	int get_v_alternate() const { return getInt("v_alternate"); }

	//! min remap in x direction
 	//! [Default value] 0
	bool set_x_remapMin(float val) { return setValue("x_remapMin", val); }
	//! min remap in x direction
 	//! [Default value] 0
	float get_x_remapMin() const { return getFloat("x_remapMin"); }

	//! min remap in y direction
 	//! [Default value] 0
	bool set_y_remapMin(float val) { return setValue("y_remapMin", val); }
	//! min remap in y direction
 	//! [Default value] 0
	float get_y_remapMin() const { return getFloat("y_remapMin"); }

	//! min remap in z direction
 	//! [Default value] 0
	bool set_z_remapMin(float val) { return setValue("z_remapMin", val); }
	//! min remap in z direction
 	//! [Default value] 0
	float get_z_remapMin() const { return getFloat("z_remapMin"); }

	//! max remap in x direction
 	//! [Default value] 1
	bool set_x_remapMax(float val) { return setValue("x_remapMax", val); }
	//! max remap in x direction
 	//! [Default value] 1
	float get_x_remapMax() const { return getFloat("x_remapMax"); }

	//! max remap in y direction
 	//! [Default value] 1
	bool set_y_remapMax(float val) { return setValue("y_remapMax", val); }
	//! max remap in y direction
 	//! [Default value] 1
	float get_y_remapMax() const { return getFloat("y_remapMax"); }

	//! max remap in z direction
 	//! [Default value] 1
	bool set_z_remapMax(float val) { return setValue("z_remapMax", val); }
	//! max remap in z direction
 	//! [Default value] 1
	float get_z_remapMax() const { return getFloat("z_remapMax"); }
};

class xsiUVWGenEnvironment : public Plugin {
public:
	//! Return the name of the plugin type
	static const char* getType() { return "xsiUVWGenEnvironment"; }

	//! Transformation of the input directions
 	//! [Default value] Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1))
	bool set_uvw_matrix(const Matrix& matrix) { return setValue("uvw_matrix", matrix); }
	//! Transformation of the input directions
 	//! [Default value] Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1))
	Matrix get_uvw_matrix() const { return getMatrix("uvw_matrix"); }

	//! Transformation of the resulting UVW coordinates
 	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	bool set_uvw_transform(const Transform& transform) { return setValue("uvw_transform", transform); }
	//! Transformation of the resulting UVW coordinates
 	//! [Default value] Transform(Matrix(Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)), Vector(0, 0, 0))
	Transform get_uvw_transform() const { return getTransform("uvw_transform"); }

	//! spherical(0), cylindrical(1), cubic strip(2), cubic cross sideways(3), cubic cross(4)
 	//! [UI Guides] enum=0:Spherical; 1:Cylindrical; 2:Cubic strip; 3:Cubic cross sideways; 4:Cubic cross
 	//! [Default value] 1
	bool set_mapping_type(int val) { return setValue("mapping_type", val); }
	//! spherical(0), cylindrical(1), cubic strip(2), cubic cross sideways(3), cubic cross(4)
 	//! [UI Guides] enum=0:Spherical; 1:Cylindrical; 2:Cubic strip; 3:Cubic cross sideways; 4:Cubic cross
 	//! [Default value] 1
	int get_mapping_type() const { return getInt("mapping_type"); }
};

} // namespace Plugins
} // namespace VRay
#endif // _VRAY_PLUGINS_HPP_
